[REPLACE]^private  AbstractCompiler compiler;^52^^^^^^^[REPLACE] private final AbstractCompiler compiler;^ [CLASS] ExpressionDecomposer DecompositionType DecompositionState  
[REPLACE]^private  Set<String> knownConstants;^54^^^^^^^[REPLACE] private final Set<String> knownConstants;^ [CLASS] ExpressionDecomposer DecompositionType DecompositionState  
[REPLACE]^private static final int MAX_INTERATIONS ;^68^^^^^^^[REPLACE] private static final int MAX_INTERATIONS = 100;^ [CLASS] ExpressionDecomposer DecompositionType DecompositionState  
[REPLACE]^private String tempNamePrefix ;^489^^^^^^^[REPLACE] private String tempNamePrefix = "JSCompiler_temp_";^ [CLASS] ExpressionDecomposer DecompositionType DecompositionState  
[REPLACE]^Preconditions .checkState (  )  ;^60^^^^^56^66^[REPLACE] Preconditions.checkNotNull ( compiler ) ;^[METHOD] <init> [TYPE] Set) [PARAMETER] AbstractCompiler compiler String> safeNameIdSupplier String> constNames [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  sideEffects  true  [TYPE]  Node extractBeforeStatement  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String tempNamePrefix  [TYPE]  int MAX_INTERATIONS 
[REMOVE]^Preconditions.checkNotNull ( injectionPoint ) ;^60^^^^^56^66^[REMOVE] ^[METHOD] <init> [TYPE] Set) [PARAMETER] AbstractCompiler compiler String> safeNameIdSupplier String> constNames [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  sideEffects  true  [TYPE]  Node extractBeforeStatement  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String tempNamePrefix  [TYPE]  int MAX_INTERATIONS 
[REPLACE]^Preconditions.checkNotNull ( false ) ;^61^^^^^56^66^[REPLACE] Preconditions.checkNotNull ( safeNameIdSupplier ) ;^[METHOD] <init> [TYPE] Set) [PARAMETER] AbstractCompiler compiler String> safeNameIdSupplier String> constNames [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  sideEffects  true  [TYPE]  Node extractBeforeStatement  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String tempNamePrefix  [TYPE]  int MAX_INTERATIONS 
[REPLACE]^Preconditions.checkNotNull ( this ) ;^62^^^^^56^66^[REPLACE] Preconditions.checkNotNull ( constNames ) ;^[METHOD] <init> [TYPE] Set) [PARAMETER] AbstractCompiler compiler String> safeNameIdSupplier String> constNames [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  sideEffects  true  [TYPE]  Node extractBeforeStatement  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String tempNamePrefix  [TYPE]  int MAX_INTERATIONS 
[REPLACE]^this.compiler =  null;^63^^^^^56^66^[REPLACE] this.compiler = compiler;^[METHOD] <init> [TYPE] Set) [PARAMETER] AbstractCompiler compiler String> safeNameIdSupplier String> constNames [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  sideEffects  true  [TYPE]  Node extractBeforeStatement  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String tempNamePrefix  [TYPE]  int MAX_INTERATIONS 
[REPLACE]^this.safeNameIdSupplier =  null;^64^^^^^56^66^[REPLACE] this.safeNameIdSupplier = safeNameIdSupplier;^[METHOD] <init> [TYPE] Set) [PARAMETER] AbstractCompiler compiler String> safeNameIdSupplier String> constNames [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  sideEffects  true  [TYPE]  Node extractBeforeStatement  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String tempNamePrefix  [TYPE]  int MAX_INTERATIONS 
[REPLACE]^this.knownConstants =  null;^65^^^^^56^66^[REPLACE] this.knownConstants = constNames;^[METHOD] <init> [TYPE] Set) [PARAMETER] AbstractCompiler compiler String> safeNameIdSupplier String> constNames [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  sideEffects  true  [TYPE]  Node extractBeforeStatement  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String tempNamePrefix  [TYPE]  int MAX_INTERATIONS 
[REPLACE]^int i = 3;^77^^^^^75^86^[REPLACE] int i = 0;^[METHOD] maybeDecomposeExpression [TYPE] void [PARAMETER] Node expression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  sideEffects  true  [TYPE]  Node expression  extractBeforeStatement  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i 
[ADD]^^77^^^^^75^86^[ADD] int i = 0;^[METHOD] maybeDecomposeExpression [TYPE] void [PARAMETER] Node expression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  sideEffects  true  [TYPE]  Node expression  extractBeforeStatement  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i 
[REPLACE]^while  ( DecompositionType.DECOMPOSABLE  !=  canExposeExpression ( extractBeforeStatement )  )  {^78^^^^^75^86^[REPLACE] while  ( DecompositionType.DECOMPOSABLE == canExposeExpression ( expression )  )  {^[METHOD] maybeDecomposeExpression [TYPE] void [PARAMETER] Node expression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  sideEffects  true  [TYPE]  Node expression  extractBeforeStatement  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i 
[REPLACE]^if  ( i  >=  MAX_INTERATIONS )  {^80^^^^^75^86^[REPLACE] if  ( i > MAX_INTERATIONS )  {^[METHOD] maybeDecomposeExpression [TYPE] void [PARAMETER] Node expression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  sideEffects  true  [TYPE]  Node expression  extractBeforeStatement  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i 
[REPLACE]^return ;^81^82^83^^^75^86^[REPLACE] throw new IllegalStateException ( "DecomposeExpression depth exceeded on :\n" + expression.toStringTree (  )  ) ;^[METHOD] maybeDecomposeExpression [TYPE] void [PARAMETER] Node expression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  sideEffects  true  [TYPE]  Node expression  extractBeforeStatement  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i 
[REPLACE]^expression.newString (  )  ) ;^83^^^^^75^86^[REPLACE] expression.toStringTree (  )  ) ;^[METHOD] maybeDecomposeExpression [TYPE] void [PARAMETER] Node expression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  sideEffects  true  [TYPE]  Node expression  extractBeforeStatement  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i 
[REPLACE]^throw new IllegalStateException ( "DecomposeExpression depth exceeded on :\n" + ;^81^82^83^^^75^86^[REPLACE] throw new IllegalStateException ( "DecomposeExpression depth exceeded on :\n" + expression.toStringTree (  )  ) ;^[METHOD] maybeDecomposeExpression [TYPE] void [PARAMETER] Node expression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  sideEffects  true  [TYPE]  Node expression  extractBeforeStatement  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i 
[ADD]^^81^82^83^^^75^86^[ADD] throw new IllegalStateException ( "DecomposeExpression depth exceeded on :\n" + expression.toStringTree (  )  ) ;^[METHOD] maybeDecomposeExpression [TYPE] void [PARAMETER] Node expression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  sideEffects  true  [TYPE]  Node expression  extractBeforeStatement  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i 
[REPLACE]^if  ( i  <=  MAX_INTERATIONS )  {^80^^^^^75^86^[REPLACE] if  ( i > MAX_INTERATIONS )  {^[METHOD] maybeDecomposeExpression [TYPE] void [PARAMETER] Node expression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  sideEffects  true  [TYPE]  Node expression  extractBeforeStatement  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i 
[ADD]^^80^81^82^83^84^75^86^[ADD] if  ( i > MAX_INTERATIONS )  { throw new IllegalStateException ( "DecomposeExpression depth exceeded on :\n" + expression.toStringTree (  )  ) ; }^[METHOD] maybeDecomposeExpression [TYPE] void [PARAMETER] Node expression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  sideEffects  true  [TYPE]  Node expression  extractBeforeStatement  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i 
[REPLACE]^Node extractBeforeStatementRoot = findExpressionRoot ( expression ) ;^94^^^^^93^98^[REPLACE] Node expressionRoot = findExpressionRoot ( expression ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  sideEffects  true  [TYPE]  Node expression  expressionRoot  extractBeforeStatement  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i 
[REPLACE]^Preconditions.checkState ( expressionRoot == null ) ;^95^^^^^93^98^[REPLACE] Preconditions.checkState ( expressionRoot != null ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  sideEffects  true  [TYPE]  Node expression  expressionRoot  extractBeforeStatement  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i 
[REPLACE]^exposeExpression ( extractBeforeStatementRoot, expression ) ;^96^^^^^93^98^[REPLACE] exposeExpression ( expressionRoot, expression ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  sideEffects  true  [TYPE]  Node expression  expressionRoot  extractBeforeStatement  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i 
[REPLACE]^Node last = expr.getLastChild (  ) ;^97^^^^^93^98^[REPLACE] compiler.reportCodeChange (  ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  sideEffects  true  [TYPE]  Node expression  expressionRoot  extractBeforeStatement  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i 
[REPLACE]^String tempName = getTempValueName (  ) ;^109^^^^^108^125^[REPLACE] String resultName = getTempValueName (  ) ;^[METHOD] moveExpression [TYPE] void [PARAMETER] Node expression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  sideEffects  true  [TYPE]  Node expression  expressionParent  expressionRoot  extractBeforeStatement  injectionPoint  injectionPointParent  newExpressionRoot  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i 
[REPLACE]^Node injectionPoint = findInjectionPoint ( newExpressionRoot ) ;^110^^^^^108^125^[REPLACE] Node injectionPoint = findInjectionPoint ( expression ) ;^[METHOD] moveExpression [TYPE] void [PARAMETER] Node expression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  sideEffects  true  [TYPE]  Node expression  expressionParent  expressionRoot  extractBeforeStatement  injectionPoint  injectionPointParent  newExpressionRoot  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i 
[REPLACE]^Preconditions.checkNotNull ( newExpressionRoot ) ;^111^^^^^108^125^[REPLACE] Preconditions.checkNotNull ( injectionPoint ) ;^[METHOD] moveExpression [TYPE] void [PARAMETER] Node expression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  sideEffects  true  [TYPE]  Node expression  expressionParent  expressionRoot  extractBeforeStatement  injectionPoint  injectionPointParent  newExpressionRoot  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i 
[ADD]^^111^^^^^108^125^[ADD] Preconditions.checkNotNull ( injectionPoint ) ;^[METHOD] moveExpression [TYPE] void [PARAMETER] Node expression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  sideEffects  true  [TYPE]  Node expression  expressionParent  expressionRoot  extractBeforeStatement  injectionPoint  injectionPointParent  newExpressionRoot  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i 
[REPLACE]^Node extractBeforeStatementParent = injectionPoint.getParent (  ) ;^112^^^^^108^125^[REPLACE] Node injectionPointParent = injectionPoint.getParent (  ) ;^[METHOD] moveExpression [TYPE] void [PARAMETER] Node expression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  sideEffects  true  [TYPE]  Node expression  expressionParent  expressionRoot  extractBeforeStatement  injectionPoint  injectionPointParent  newExpressionRoot  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i 
[REPLACE]^Preconditions.checkNotNull ( injectionPoint ) ;^113^^^^^108^125^[REPLACE] Preconditions.checkNotNull ( injectionPointParent ) ;^[METHOD] moveExpression [TYPE] void [PARAMETER] Node expression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  sideEffects  true  [TYPE]  Node expression  expressionParent  expressionRoot  extractBeforeStatement  injectionPoint  injectionPointParent  newExpressionRoot  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i 
[REPLACE]^Preconditions.checkState ( NodeUtil.isStatementBlock ( newExpressionRoot )  ) ;^114^^^^^108^125^[REPLACE] Preconditions.checkState ( NodeUtil.isStatementBlock ( injectionPointParent )  ) ;^[METHOD] moveExpression [TYPE] void [PARAMETER] Node expression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  sideEffects  true  [TYPE]  Node expression  expressionParent  expressionRoot  extractBeforeStatement  injectionPoint  injectionPointParent  newExpressionRoot  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i 
[ADD]^^114^^^^^108^125^[ADD] Preconditions.checkState ( NodeUtil.isStatementBlock ( injectionPointParent )  ) ;^[METHOD] moveExpression [TYPE] void [PARAMETER] Node expression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  sideEffects  true  [TYPE]  Node expression  expressionParent  expressionRoot  extractBeforeStatement  injectionPoint  injectionPointParent  newExpressionRoot  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i 
[REPLACE]^Node newExpressionRootParent = expression.getParent (  ) ;^117^^^^^108^125^[REPLACE] Node expressionParent = expression.getParent (  ) ;^[METHOD] moveExpression [TYPE] void [PARAMETER] Node expression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  sideEffects  true  [TYPE]  Node expression  expressionParent  expressionRoot  extractBeforeStatement  injectionPoint  injectionPointParent  newExpressionRoot  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i 
[ADD]^^117^^^^^108^125^[ADD] Node expressionParent = expression.getParent (  ) ;^[METHOD] moveExpression [TYPE] void [PARAMETER] Node expression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  sideEffects  true  [TYPE]  Node expression  expressionParent  expressionRoot  extractBeforeStatement  injectionPoint  injectionPointParent  newExpressionRoot  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i 
[REPLACE]^expressionParent.replaceChild ( injectionPointParent, Node.newString ( Token.NAME, resultName )  ) ;^118^119^^^^108^125^[REPLACE] expressionParent.replaceChild ( expression, Node.newString ( Token.NAME, resultName )  ) ;^[METHOD] moveExpression [TYPE] void [PARAMETER] Node expression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  sideEffects  true  [TYPE]  Node expression  expressionParent  expressionRoot  extractBeforeStatement  injectionPoint  injectionPointParent  newExpressionRoot  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i 
[REPLACE]^expression, Node.replaceChild ( Token.NAME, tempNamePrefix )  ) ;^119^^^^^108^125^[REPLACE] expression, Node.newString ( Token.NAME, resultName )  ) ;^[METHOD] moveExpression [TYPE] void [PARAMETER] Node expression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  sideEffects  true  [TYPE]  Node expression  expressionParent  expressionRoot  extractBeforeStatement  injectionPoint  injectionPointParent  newExpressionRoot  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i 
[REPLACE]^Node newExpressionRoot = NodeUtil.newVarNode ( resultName, newExpressionRoot ) ;^122^^^^^108^125^[REPLACE] Node newExpressionRoot = NodeUtil.newVarNode ( resultName, expression ) ;^[METHOD] moveExpression [TYPE] void [PARAMETER] Node expression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  sideEffects  true  [TYPE]  Node expression  expressionParent  expressionRoot  extractBeforeStatement  injectionPoint  injectionPointParent  newExpressionRoot  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i 
[REPLACE]^injectionPointParent.addChildBefore ( injectionPointParent, injectionPoint ) ;^123^^^^^108^125^[REPLACE] injectionPointParent.addChildBefore ( newExpressionRoot, injectionPoint ) ;^[METHOD] moveExpression [TYPE] void [PARAMETER] Node expression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  sideEffects  true  [TYPE]  Node expression  expressionParent  expressionRoot  extractBeforeStatement  injectionPoint  injectionPointParent  newExpressionRoot  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i 
[REPLACE]^Node last = expr.getLastChild (  ) ;^124^^^^^108^125^[REPLACE] compiler.reportCodeChange (  ) ;^[METHOD] moveExpression [TYPE] void [PARAMETER] Node expression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  sideEffects  true  [TYPE]  Node expression  expressionParent  expressionRoot  extractBeforeStatement  injectionPoint  injectionPointParent  newExpressionRoot  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i 
[ADD]^^124^^^^^108^125^[ADD] compiler.reportCodeChange (  ) ;^[METHOD] moveExpression [TYPE] void [PARAMETER] Node expression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  sideEffects  true  [TYPE]  Node expression  expressionParent  expressionRoot  extractBeforeStatement  injectionPoint  injectionPointParent  newExpressionRoot  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i 
[REPLACE]^Node nonconditionalExpr = findNonconditionalParent ( replacement, expressionRoot ) ;^143^144^^^^142^230^[REPLACE] Node nonconditionalExpr = findNonconditionalParent ( subExpression, expressionRoot ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^boolean hasFollowingSideEffects = NodeUtil.mayHaveSideEffects ( replacement ) ;^146^147^^^^142^230^[REPLACE] boolean hasFollowingSideEffects = NodeUtil.mayHaveSideEffects ( nonconditionalExpr ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node exprInjectionPoint = findInjectionPoint ( newExpressionRoot ) ;^149^^^^^142^230^[REPLACE] Node exprInjectionPoint = findInjectionPoint ( nonconditionalExpr ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^149^^^^^142^230^[ADD] Node exprInjectionPoint = findInjectionPoint ( nonconditionalExpr ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^boolean requiresDecomposition = false;^150^^^^^142^230^[REPLACE] DecompositionState state = new DecompositionState (  ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^state.sideEffects =  hasFollowingSideEffects;^151^^^^^142^230^[REPLACE] state.sideEffects = hasFollowingSideEffects;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^state.extractBeforeStatement =  exprInjectionPoint;^152^^^^^142^230^[REPLACE] state.extractBeforeStatement = exprInjectionPoint;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( parentType  !=  Token.ASSIGN )  {^161^^^^^142^230^[REPLACE] if  ( parentType == Token.ASSIGN )  {^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^}  else {^185^186^^^^142^230^[REPLACE] } else if  ( parentType == Token.CALL && NodeUtil.isGet ( parent.getFirstChild (  )  )  )  {^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^decomposeSubExpressions ( injectionPointParent.getFirstChild (  ) , child, state ) ;^209^210^^^^185^211^[REPLACE] decomposeSubExpressions ( parent.getFirstChild (  ) , child, state ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^parent .getLastChild (  )  , child, state ) ;^210^^^^^185^211^[REPLACE] parent.getFirstChild (  ) , child, state ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( maybeExternMethod ( parent.getFirstChild (  )  )  )  {^189^^^^^185^211^[REPLACE] if  ( !maybeExternMethod ( parent.getFirstChild (  )  )  )  {^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( isExpressionTreeUnsafe ( n, state.sideEffects )  )  {^197^^^^^189^207^[REPLACE] if  ( isExpressionTreeUnsafe ( functionExpression, state.sideEffects )  )  {^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^state.sideEffects = false;^200^^^^^189^207^[REPLACE] state.sideEffects = true;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^parent =  newExpressionRoot;^205^^^^^189^207^[REPLACE] parent = replacement;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node parent = nonconditionalExpr.getParent (  ) ;^203^^^^^189^207^[REPLACE] Node replacement = rewriteCallExpression ( parent, state ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^parent =  nonconditionalExpr;^205^^^^^189^207^[REPLACE] parent = replacement;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^205^^^^^189^207^[ADD] parent = replacement;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node functionExpression = parent .getLastChild (  )  ;^193^^^^^189^207^[REPLACE] Node functionExpression = parent.getFirstChild (  ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^return ;^190^191^^^^185^211^[REPLACE] throw new IllegalStateException ( "External object method calls can not be decomposed." ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^190^191^^^^185^211^[ADD] throw new IllegalStateException ( "External object method calls can not be decomposed." ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( isExpressionTreeUnsafe ( n, state.sideEffects )  )  {^197^^^^^185^211^[REPLACE] if  ( isExpressionTreeUnsafe ( functionExpression, state.sideEffects )  )  {^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^state.sideEffects = false;^200^^^^^185^211^[REPLACE] state.sideEffects = true;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^200^^^^^185^211^[ADD] state.sideEffects = true;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^parent =  injectionPointParent;^205^^^^^185^211^[REPLACE] parent = replacement;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^205^^^^^185^211^[ADD] parent = replacement;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node replacement = rewriteCallExpression ( subExpression, state ) ;^203^^^^^185^211^[REPLACE] Node replacement = rewriteCallExpression ( parent, state ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^203^^^^^185^211^[ADD] Node replacement = rewriteCallExpression ( parent, state ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^parent =  subExpression;^205^^^^^185^211^[REPLACE] parent = replacement;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node functionExpression = subExpression.getFirstChild (  ) ;^193^^^^^185^211^[REPLACE] Node functionExpression = parent.getFirstChild (  ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node replacement = rewriteCallExpression ( newExpressionRoot, state ) ;^203^^^^^185^211^[REPLACE] Node replacement = rewriteCallExpression ( parent, state ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^throw new IllegalStateException ( "DecomposeExpression depth exceeded on :\n" + ;^190^191^^^^185^211^[REPLACE] throw new IllegalStateException ( "External object method calls can not be decomposed." ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( maybeExternMethod ( parent.getFirstChild (  )  )  )  {^189^^^^^142^230^[REPLACE] if  ( !maybeExternMethod ( parent.getFirstChild (  )  )  )  {^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^189^190^191^192^193^142^230^[ADD] if  ( !maybeExternMethod ( parent.getFirstChild (  )  )  )  { throw new IllegalStateException ( "External object method calls can not be decomposed." ) ; } else { Node functionExpression = parent.getFirstChild (  ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^parent =  subExpression;^205^^^^^189^207^[REPLACE] parent = replacement;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node replacement = rewriteCallExpression ( subExpression, state ) ;^203^^^^^189^207^[REPLACE] Node replacement = rewriteCallExpression ( parent, state ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^200^^^^^189^207^[ADD] state.sideEffects = true;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node functionExpression = newExpressionRoot.getFirstChild (  ) ;^193^^^^^189^207^[REPLACE] Node functionExpression = parent.getFirstChild (  ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node replacement = rewriteCallExpression ( left, state ) ;^203^^^^^189^207^[REPLACE] Node replacement = rewriteCallExpression ( parent, state ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^throw new IllegalStateException ( "DecomposeExpression depth exceeded on :\n" + ;^190^191^^^^142^230^[REPLACE] throw new IllegalStateException ( "External object method calls can not be decomposed." ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( isExpressionTreeUnsafe ( n, state.sideEffects )  )  {^197^^^^^142^230^[REPLACE] if  ( isExpressionTreeUnsafe ( functionExpression, state.sideEffects )  )  {^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^state.sideEffects = false;^200^^^^^142^230^[REPLACE] state.sideEffects = true;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^200^^^^^142^230^[ADD] state.sideEffects = true;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^parent =  newExpressionRoot;^205^^^^^142^230^[REPLACE] parent = replacement;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node replacement = rewriteCallExpression ( subExpression, state ) ;^203^^^^^142^230^[REPLACE] Node replacement = rewriteCallExpression ( parent, state ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^parent =  injectionPointParent;^205^^^^^142^230^[REPLACE] parent = replacement;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node functionExpression = subExpression.getLastChild (  ) ;^193^^^^^142^230^[REPLACE] Node functionExpression = parent.getFirstChild (  ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^203^^^^^142^230^[ADD] Node replacement = rewriteCallExpression ( parent, state ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^return ;^190^191^^^^142^230^[REPLACE] throw new IllegalStateException ( "External object method calls can not be decomposed." ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( isSafeAssign ( parent, seenSideEffects )  )  {^162^^^^^142^230^[REPLACE] if  ( isSafeAssign ( parent, state.sideEffects )  )  {^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  (injectionPointParent  ==  child )  {^177^^^^^162^184^[REPLACE] if  ( left != child )  {^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( type  &&  Token.GETELEM )  {^179^^^^^162^184^[REPLACE] if  ( type == Token.GETELEM )  {^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^179^180^181^^^162^184^[ADD] if  ( type == Token.GETELEM )  { decomposeSubExpressions ( left.getLastChild (  ) , null, state ) ; }^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^decomposeSubExpressions ( left.getLastChild (  ) , true, state ) ;^180^^^^^162^184^[REPLACE] decomposeSubExpressions ( left.getLastChild (  ) , null, state ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^decomposeSubExpressions ( newExpressionRoot.getLastChild (  ) , null, state ) ;^180^^^^^162^184^[REPLACE] decomposeSubExpressions ( left.getLastChild (  ) , null, state ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( parentType  &&  Token.GETELEM )  {^179^^^^^162^184^[REPLACE] if  ( type == Token.GETELEM )  {^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^decomposeSubExpressions ( left.getLastChild (  ) , null, state ) ;^179^180^181^^^162^184^[ADD] if  ( type == Token.GETELEM )  { decomposeSubExpressions ( left.getLastChild (  ) , null, state ) ; }^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^decomposeSubExpressions ( left.getLastChild (  ) , this, state ) ;^180^^^^^162^184^[REPLACE] decomposeSubExpressions ( left.getLastChild (  ) , null, state ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^decomposeSubExpressions ( subExpression.getLastChild (  ) , null, state ) ;^180^^^^^162^184^[REPLACE] decomposeSubExpressions ( left.getLastChild (  ) , null, state ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^180^^^^^162^184^[ADD] decomposeSubExpressions ( left.getLastChild (  ) , null, state ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node left = injectionPointParent.getFirstChild (  ) ;^175^^^^^162^184^[REPLACE] Node left = parent.getFirstChild (  ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^int type = subExpression.getType (  ) ;^176^^^^^162^184^[REPLACE] int type = left.getType (  ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  (injectionPointParent  ==  newExpressionRoot )  {^177^^^^^142^230^[REPLACE] if  ( left != child )  {^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^177^178^179^180^181^142^230^[ADD] if  ( left != child )  { Preconditions.checkState ( NodeUtil.isGet ( left )  ) ; if  ( type == Token.GETELEM )  { decomposeSubExpressions ( left.getLastChild (  ) , null, state ) ; }^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  (parentType  !=  Token.GETELEM )  {^179^^^^^142^230^[REPLACE] if  ( type == Token.GETELEM )  {^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^decomposeSubExpressions ( left.getLastChild (  ) , false, state ) ;^180^^^^^142^230^[REPLACE] decomposeSubExpressions ( left.getLastChild (  ) , null, state ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^180^^^^^142^230^[ADD] decomposeSubExpressions ( left.getLastChild (  ) , null, state ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^decomposeSubExpressions ( nonconditionalExpr.getLastChild (  ) , null, state ) ;^180^^^^^142^230^[REPLACE] decomposeSubExpressions ( left.getLastChild (  ) , null, state ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( parentType  ||  Token.GETELEM )  {^179^^^^^142^230^[REPLACE] if  ( type == Token.GETELEM )  {^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^decomposeSubExpressions ( left .getFirstChild (  )  , false, state ) ;^180^^^^^142^230^[REPLACE] decomposeSubExpressions ( left.getLastChild (  ) , null, state ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^decomposeSubExpressions ( replacement.getLastChild (  ) , null, state ) ;^180^^^^^142^230^[REPLACE] decomposeSubExpressions ( left.getLastChild (  ) , null, state ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node left = injectionPointParent.getFirstChild (  ) ;^175^^^^^142^230^[REPLACE] Node left = parent.getFirstChild (  ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^int type = subExpression.getType (  ) ;^176^^^^^142^230^[REPLACE] int type = left.getType (  ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  (subExpression  ==  child )  {^177^^^^^162^184^[REPLACE] if  ( left != child )  {^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( type  ||  Token.GETELEM )  {^179^^^^^162^184^[REPLACE] if  ( type == Token.GETELEM )  {^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^decomposeSubExpressions ( left.getLastChild (  ) , false, state ) ;^180^^^^^162^184^[REPLACE] decomposeSubExpressions ( left.getLastChild (  ) , null, state ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^decomposeSubExpressions ( parent.getLastChild (  ) , null, state ) ;^180^^^^^162^184^[REPLACE] decomposeSubExpressions ( left.getLastChild (  ) , null, state ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( type  !=  Token.GETELEM )  {^179^^^^^162^184^[REPLACE] if  ( type == Token.GETELEM )  {^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^decomposeSubExpressions ( nonconditionalExpr.getLastChild (  ) , null, state ) ;^180^^^^^162^184^[REPLACE] decomposeSubExpressions ( left.getLastChild (  ) , null, state ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node left = parent.getLastChild (  ) ;^175^^^^^162^184^[REPLACE] Node left = parent.getFirstChild (  ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^int type = replacement .getParent (  )  ;^176^^^^^162^184^[REPLACE] int type = left.getType (  ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( left  == replacement )  {^177^^^^^142^230^[REPLACE] if  ( left != child )  {^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^Preconditions.checkState ( NodeUtil.isGet ( left )  ) ;decomposeSubExpressions ( left.getLastChild (  ) , null, state ) ;^177^178^179^180^181^142^230^[ADD] if  ( left != child )  { Preconditions.checkState ( NodeUtil.isGet ( left )  ) ; if  ( type == Token.GETELEM )  { decomposeSubExpressions ( left.getLastChild (  ) , null, state ) ; }^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  (parentType  ||  Token.GETELEM )  {^179^^^^^142^230^[REPLACE] if  ( type == Token.GETELEM )  {^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^decomposeSubExpressions ( left.getLastChild (  ) , true, state ) ;^180^^^^^142^230^[REPLACE] decomposeSubExpressions ( left.getLastChild (  ) , null, state ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^decomposeSubExpressions ( subExpression.getLastChild (  ) , null, state ) ;^180^^^^^142^230^[REPLACE] decomposeSubExpressions ( left.getLastChild (  ) , null, state ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^179^180^181^^^142^230^[ADD] if  ( type == Token.GETELEM )  { decomposeSubExpressions ( left.getLastChild (  ) , null, state ) ; }^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^}  if  ( parentType == Token.CALL ) {^185^186^^^^142^230^[REPLACE] } else if  ( parentType == Token.CALL && NodeUtil.isGet ( parent.getFirstChild (  )  )  )  {^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^decomposeSubExpressions ( subExpression.getFirstChild (  ) , child, state ) ;^209^210^^^^185^211^[REPLACE] decomposeSubExpressions ( parent.getFirstChild (  ) , child, state ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^parent.getLastChild (  ) , child, state ) ;^210^^^^^185^211^[REPLACE] parent.getFirstChild (  ) , child, state ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^210^^^^^185^211^[ADD] parent.getFirstChild (  ) , child, state ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( !maybeExternMethod ( replacement.getFirstChild (  )  )  )  {^189^^^^^185^211^[REPLACE] if  ( !maybeExternMethod ( parent.getFirstChild (  )  )  )  {^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^189^190^191^192^193^185^211^[ADD] if  ( !maybeExternMethod ( parent.getFirstChild (  )  )  )  { throw new IllegalStateException ( "External object method calls can not be decomposed." ) ; } else { Node functionExpression = parent.getFirstChild (  ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^197^198^^200^^189^207^[ADD] if  ( isExpressionTreeUnsafe ( functionExpression, state.sideEffects )  )  {  state.sideEffects = true;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node replacement = rewriteCallExpression ( injectionPointParent, state ) ;^203^^^^^189^207^[REPLACE] Node replacement = rewriteCallExpression ( parent, state ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^parent =  left;^205^^^^^189^207^[REPLACE] parent = replacement;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node functionExpression = injectionPointParent.getLastChild (  ) ;^193^^^^^189^207^[REPLACE] Node functionExpression = parent.getFirstChild (  ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^parent =  null;^205^^^^^185^211^[REPLACE] parent = replacement;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node replacement = rewriteCallExpression ( left, state ) ;^203^^^^^185^211^[REPLACE] Node replacement = rewriteCallExpression ( parent, state ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node functionExpression = newExpressionRoot.getFirstChild (  ) ;^193^^^^^185^211^[REPLACE] Node functionExpression = parent.getFirstChild (  ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node parent = nonconditionalExpr.getParent (  ) ;^203^^^^^185^211^[REPLACE] Node replacement = rewriteCallExpression ( parent, state ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( !maybeExternMethod ( parent.getLastChild (  )  )  )  {^189^^^^^142^230^[REPLACE] if  ( !maybeExternMethod ( parent.getFirstChild (  )  )  )  {^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^seenSideEffects = true; ;^200^^^^^189^207^[REPLACE] state.sideEffects = true;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^parent =  injectionPointParent;^205^^^^^189^207^[REPLACE] parent = replacement;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node functionExpression = subExpression.getFirstChild (  ) ;^193^^^^^189^207^[REPLACE] Node functionExpression = parent.getFirstChild (  ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^193^^^^^189^207^[ADD] Node functionExpression = parent.getFirstChild (  ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^parent =  subExpression;^205^^^^^142^230^[REPLACE] parent = replacement;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node replacement = rewriteCallExpression ( replacement, state ) ;^203^^^^^142^230^[REPLACE] Node replacement = rewriteCallExpression ( parent, state ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^for  ( Node subExpression = nonconditionalExpr, parent = child.getParent (  ) ;^155^^^^^142^230^[REPLACE] for  ( Node child = nonconditionalExpr, parent = child.getParent (  ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^155^156^157^158^159^142^230^[ADD] for  ( Node child = nonconditionalExpr, parent = child.getParent (  ) ; parent != expressionRoot; child = parent, parent = child.getParent (  )  )  { int parentType = parent.getType (  ) ; Preconditions.checkState (^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( parentType  !=  Token.ASSIGN )  {^161^^^^^155^212^[REPLACE] if  ( parentType == Token.ASSIGN )  {^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^161^162^^^^155^212^[ADD] if  ( parentType == Token.ASSIGN )  { if  ( isSafeAssign ( parent, state.sideEffects )  )  {^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^}  if  (  NodeUtil.isGet ( parent.getFirstChild (  )  )  )  {^185^186^^^^155^212^[REPLACE] } else if  ( parentType == Token.CALL && NodeUtil.isGet ( parent.getFirstChild (  )  )  )  {^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^209^210^^^^185^211^[ADD] decomposeSubExpressions ( parent.getFirstChild (  ) , child, state ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( left != child )  {^189^^^^^185^211^[REPLACE] if  ( !maybeExternMethod ( parent.getFirstChild (  )  )  )  {^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REMOVE]^if  ( isExpressionTreeUnsafe ( n, seenSideEffects )  )  {     seenSideEffects = true;     requiresDecomposition = true; }^197^^^^^185^211^[REMOVE] ^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^parent =  injectionPoint;^205^^^^^185^211^[REPLACE] parent = replacement;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^193^^^^^185^211^[ADD] Node functionExpression = parent.getFirstChild (  ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( maybeExternMethod ( parent.getFirstChild (  )  )  )  {^189^^^^^155^212^[REPLACE] if  ( !maybeExternMethod ( parent.getFirstChild (  )  )  )  {^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( isExpressionTreeUnsafe ( injectionPointParent, state.sideEffects )  )  {^197^^^^^189^207^[REPLACE] if  ( isExpressionTreeUnsafe ( functionExpression, state.sideEffects )  )  {^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node functionExpression = replacement.getFirstChild (  ) ;^193^^^^^189^207^[REPLACE] Node functionExpression = parent.getFirstChild (  ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^203^^^^^189^207^[ADD] Node replacement = rewriteCallExpression ( parent, state ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^return ;^190^191^^^^155^212^[REPLACE] throw new IllegalStateException ( "External object method calls can not be decomposed." ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( isExpressionTreeUnsafe ( nonconditionalExpr, state.sideEffects )  )  {^197^^^^^155^212^[REPLACE] if  ( isExpressionTreeUnsafe ( functionExpression, state.sideEffects )  )  {^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^197^198^^200^^155^212^[ADD] if  ( isExpressionTreeUnsafe ( functionExpression, state.sideEffects )  )  {  state.sideEffects = true;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^state.sideEffects = false;^200^^^^^155^212^[REPLACE] state.sideEffects = true;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^parent =  nonconditionalExpr;^205^^^^^155^212^[REPLACE] parent = replacement;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node replacement = rewriteCallExpression ( subExpression, state ) ;^203^^^^^155^212^[REPLACE] Node replacement = rewriteCallExpression ( parent, state ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^parent =  subExpression;^205^^^^^155^212^[REPLACE] parent = replacement;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node functionExpression = subExpression.getFirstChild (  ) ;^193^^^^^155^212^[REPLACE] Node functionExpression = parent.getFirstChild (  ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^193^^^^^155^212^[ADD] Node functionExpression = parent.getFirstChild (  ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node replacement = rewriteCallExpression ( left, state ) ;^203^^^^^155^212^[REPLACE] Node replacement = rewriteCallExpression ( parent, state ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^throw new IllegalStateException ( "DecomposeExpression depth exceeded on :\n" + ;^190^191^^^^155^212^[REPLACE] throw new IllegalStateException ( "External object method calls can not be decomposed." ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( isSafeAssign ( parent, seenSideEffects )  )  {^162^^^^^155^212^[REPLACE] if  ( isSafeAssign ( parent, state.sideEffects )  )  {^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^162^163^^^^155^212^[ADD] if  ( isSafeAssign ( parent, state.sideEffects )  )  {^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( left  == subExpression )  {^177^^^^^162^184^[REPLACE] if  ( left != child )  {^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^decomposeSubExpressions ( subExpression.getLastChild (  ) , false, state ) ;^180^^^^^162^184^[REPLACE] decomposeSubExpressions ( left.getLastChild (  ) , null, state ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^decomposeSubExpressions ( subExpression.getFirstChild (  ) , null, state ) ;^180^^^^^162^184^[REPLACE] decomposeSubExpressions ( left.getLastChild (  ) , null, state ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node left = subExpression.getFirstChild (  ) ;^175^^^^^162^184^[REPLACE] Node left = parent.getFirstChild (  ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^int type = injectionPointParent .getParent (  )  ;^176^^^^^162^184^[REPLACE] int type = left.getType (  ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^176^^^^^162^184^[ADD] int type = left.getType (  ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( left  ==  child )  {^177^^^^^155^212^[REPLACE] if  ( left != child )  {^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^Preconditions.checkState ( NodeUtil.isGet ( left )  ) ;decomposeSubExpressions ( left.getLastChild (  ) , null, state ) ;^177^178^179^180^181^155^212^[ADD] if  ( left != child )  { Preconditions.checkState ( NodeUtil.isGet ( left )  ) ; if  ( type == Token.GETELEM )  { decomposeSubExpressions ( left.getLastChild (  ) , null, state ) ; }^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( type  !=  Token.GETELEM )  {^179^^^^^155^212^[REPLACE] if  ( type == Token.GETELEM )  {^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^decomposeSubExpressions ( left.getLastChild (  ) , null, state ) ;^179^180^181^^^155^212^[ADD] if  ( type == Token.GETELEM )  { decomposeSubExpressions ( left.getLastChild (  ) , null, state ) ; }^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^decomposeSubExpressions ( left.getLastChild (  ) , this, state ) ;^180^^^^^155^212^[REPLACE] decomposeSubExpressions ( left.getLastChild (  ) , null, state ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^decomposeSubExpressions ( subExpression.getLastChild (  ) , null, state ) ;^180^^^^^155^212^[REPLACE] decomposeSubExpressions ( left.getLastChild (  ) , null, state ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^180^^^^^155^212^[ADD] decomposeSubExpressions ( left.getLastChild (  ) , null, state ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  (parentType  &&  Token.GETELEM )  {^179^^^^^155^212^[REPLACE] if  ( type == Token.GETELEM )  {^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^179^180^181^^^155^212^[ADD] if  ( type == Token.GETELEM )  { decomposeSubExpressions ( left.getLastChild (  ) , null, state ) ; }^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^decomposeSubExpressions ( left.getLastChild (  ) , false, state ) ;^180^^^^^155^212^[REPLACE] decomposeSubExpressions ( left.getLastChild (  ) , null, state ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node left = parent .getLastChild (  )  ;^175^^^^^155^212^[REPLACE] Node left = parent.getFirstChild (  ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^int type = nonconditionalExpr.getType (  ) ;^176^^^^^155^212^[REPLACE] int type = left.getType (  ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REMOVE]^if  (  ( n.getType (  )  )  ==  ( ASSIGN )  )  {     Node lhs = n.getFirstChild (  ) ;     switch  ( lhs.getType (  )  )  {         case NAME :             return true;         case GETPROP :             return ! ( isExpressionTreeUnsafe ( lhs.getFirstChild (  ) , seenSideEffects )  ) ;         case GETELEM :             return  ( ! ( isExpressionTreeUnsafe ( lhs.getFirstChild (  ) , seenSideEffects )  )  )  &&  ( ! ( isExpressionTreeUnsafe ( lhs.getLastChild (  ) , seenSideEffects )  )  ) ;     } }^162^^^^^155^212^[REMOVE] ^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( subExpression  ==  subExpression )  {^177^^^^^162^184^[REPLACE] if  ( left != child )  {^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^177^178^179^180^181^162^184^[ADD] if  ( left != child )  { Preconditions.checkState ( NodeUtil.isGet ( left )  ) ; if  ( type == Token.GETELEM )  { decomposeSubExpressions ( left.getLastChild (  ) , null, state ) ; }^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( parentType  !=  Token.GETELEM )  {^179^^^^^162^184^[REPLACE] if  ( type == Token.GETELEM )  {^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^decomposeSubExpressions ( newExpressionRoot.getLastChild (  ) , false, state ) ;^180^^^^^162^184^[REPLACE] decomposeSubExpressions ( left.getLastChild (  ) , null, state ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  (parentType  &&  Token.GETELEM )  {^179^^^^^162^184^[REPLACE] if  ( type == Token.GETELEM )  {^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^decomposeSubExpressions ( parent.getFirstChild (  ) , null, state ) ;^180^^^^^162^184^[REPLACE] decomposeSubExpressions ( left.getLastChild (  ) , null, state ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node left = parent .getLastChild (  )  ;^175^^^^^162^184^[REPLACE] Node left = parent.getFirstChild (  ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^decomposeSubExpressions ( left.getLastChild (  ) , true, state ) ;^180^^^^^155^212^[REPLACE] decomposeSubExpressions ( left.getLastChild (  ) , null, state ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REMOVE]^exposeExpression ( expressionRoot, expression ) ;^180^^^^^155^212^[REMOVE] ^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( type  ||  Token.GETELEM )  {^179^^^^^155^212^[REPLACE] if  ( type == Token.GETELEM )  {^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^}  if  ( parentType == Token.CALL ) {^185^186^^^^155^212^[REPLACE] } else if  ( parentType == Token.CALL && NodeUtil.isGet ( parent.getFirstChild (  )  )  )  {^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^decomposeSubExpressions ( parent.getFirstChild (  ) , subExpression, state ) ;^209^210^^^^185^211^[REPLACE] decomposeSubExpressions ( parent.getFirstChild (  ) , child, state ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( isExpressionTreeUnsafe ( subExpression, state.sideEffects )  )  {^197^^^^^189^207^[REPLACE] if  ( isExpressionTreeUnsafe ( functionExpression, state.sideEffects )  )  {^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^parent =  newExpressionRoot;^205^^^^^185^211^[REPLACE] parent = replacement;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node replacement = rewriteCallExpression ( injectionPointParent, state ) ;^203^^^^^185^211^[REPLACE] Node replacement = rewriteCallExpression ( parent, state ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^parent =  nonconditionalExpr;^205^^^^^185^211^[REPLACE] parent = replacement;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node functionExpression = left.getFirstChild (  ) ;^193^^^^^185^211^[REPLACE] Node functionExpression = parent.getFirstChild (  ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^189^190^191^192^193^155^212^[ADD] if  ( !maybeExternMethod ( parent.getFirstChild (  )  )  )  { throw new IllegalStateException ( "External object method calls can not be decomposed." ) ; } else { Node functionExpression = parent.getFirstChild (  ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( isExpressionTreeUnsafe ( n, state.sideEffects )  )  {^197^^^^^155^212^[REPLACE] if  ( isExpressionTreeUnsafe ( functionExpression, state.sideEffects )  )  {^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REMOVE]^if  ( isExpressionTreeUnsafe ( n, seenSideEffects )  )  {     seenSideEffects = true;     requiresDecomposition = true; }^197^^^^^155^212^[REMOVE] ^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^parent =  left;^205^^^^^155^212^[REPLACE] parent = replacement;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node parent = nonconditionalExpr.getParent (  ) ;^203^^^^^155^212^[REPLACE] Node replacement = rewriteCallExpression ( parent, state ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^int injectionPointParentType = parent.getType (  ) ;^158^^^^^155^212^[REPLACE] int parentType = parent.getType (  ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node left = subExpression.getFirstChild (  ) ;^175^^^^^155^212^[REPLACE] Node left = parent.getFirstChild (  ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^175^^^^^155^212^[ADD] Node left = parent.getFirstChild (  ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^int type = subExpression.getType (  ) ;^176^^^^^155^212^[REPLACE] int type = left.getType (  ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node functionExpression = injectionPointParent.getFirstChild (  ) ;^193^^^^^155^212^[REPLACE] Node functionExpression = parent.getFirstChild (  ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^child =  subExpression, subExpression^157^^^^^142^230^[REPLACE] child = parent, parent = child.getParent (  )  )  {^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^child =  parent, parent^157^^^^^142^230^[REPLACE] child = parent, parent = child.getParent (  )  )  {^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^157^158^^^^142^230^[ADD] child = parent, parent = child.getParent (  )  )  { int parentType = parent.getType (  ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^for  ( Node child = newExpressionRoot, parent = child.getParent (  ) ;^155^^^^^142^230^[REPLACE] for  ( Node child = nonconditionalExpr, parent = child.getParent (  ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^int parentType = parent.getNext (  ) ;^158^^^^^142^230^[REPLACE] int parentType = parent.getType (  ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node left = newExpressionRoot.getFirstChild (  ) ;^175^^^^^142^230^[REPLACE] Node left = parent.getFirstChild (  ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^int type = injectionPointParent.getType (  ) ;^176^^^^^142^230^[REPLACE] int type = left.getType (  ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node functionExpression = subExpression .getLastChild (  )  ;^193^^^^^142^230^[REPLACE] Node functionExpression = parent.getFirstChild (  ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node parent = nonconditionalExpr.getParent (  ) ;^203^^^^^142^230^[REPLACE] Node replacement = rewriteCallExpression ( parent, state ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( nonconditionalExpr  && replacement )  {^219^^^^^142^230^[REPLACE] if  ( nonconditionalExpr == subExpression )  {^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node parent = injectionPoint.getParent (  ) ;^225^^^^^219^229^[REPLACE] Node parent = nonconditionalExpr.getParent (  ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^boolean needResult = subExpression.getType (  )   ==  Token.EXPR_RESULT;^226^^^^^219^229^[REPLACE] boolean needResult = parent.getType (  )  != Token.EXPR_RESULT;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^226^^^^^219^229^[ADD] boolean needResult = parent.getType (  )  != Token.EXPR_RESULT;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node extractedConditional = extractConditional ( nonconditionalExpr, subExpression, needResult ) ;^227^228^^^^219^229^[REPLACE] Node extractedConditional = extractConditional ( nonconditionalExpr, exprInjectionPoint, needResult ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node parent = left.getNext (  ) ;^225^^^^^142^230^[REPLACE] Node parent = nonconditionalExpr.getParent (  ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^boolean needResult = parent.getType (  )   ==  Token.EXPR_RESULT;^226^^^^^142^230^[REPLACE] boolean needResult = parent.getType (  )  != Token.EXPR_RESULT;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^226^^^^^142^230^[ADD] boolean needResult = parent.getType (  )  != Token.EXPR_RESULT;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node extractedConditional = extractConditional ( nonconditionalExpr, subExpression, needResult ) ;^227^228^^^^142^230^[REPLACE] Node extractedConditional = extractConditional ( nonconditionalExpr, exprInjectionPoint, needResult ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^return false;^237^^^^^235^238^[REPLACE] return true;^[METHOD] maybeExternMethod [TYPE] boolean [PARAMETER] Node node [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  node  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node result = injectionPointParent;^246^^^^^244^261^[REPLACE] Node result = subExpression;^[METHOD] findNonconditionalParent [TYPE] Node [PARAMETER] Node subExpression Node expressionRoot [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^246^^^^^244^261^[ADD] Node result = subExpression;^[METHOD] findNonconditionalParent [TYPE] Node [PARAMETER] Node subExpression Node expressionRoot [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( left != child )  {^251^^^^^244^261^[REPLACE] if  ( isConditionalOp ( parent )  )  {^[METHOD] findNonconditionalParent [TYPE] Node [PARAMETER] Node subExpression Node expressionRoot [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^251^252^^254^255^244^261^[ADD] if  ( isConditionalOp ( parent )  )  {  if  ( child != parent.getFirstChild (  )  )  { result = parent;^[METHOD] findNonconditionalParent [TYPE] Node [PARAMETER] Node subExpression Node expressionRoot [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  (subExpression  ==  parent.newString (  )  )  {^254^^^^^244^261^[REPLACE] if  ( child != parent.getFirstChild (  )  )  {^[METHOD] findNonconditionalParent [TYPE] Node [PARAMETER] Node subExpression Node expressionRoot [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^254^255^256^^^244^261^[ADD] if  ( child != parent.getFirstChild (  )  )  { result = parent; }^[METHOD] findNonconditionalParent [TYPE] Node [PARAMETER] Node subExpression Node expressionRoot [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^result =  subExpression;^255^^^^^244^261^[REPLACE] result = parent;^[METHOD] findNonconditionalParent [TYPE] Node [PARAMETER] Node subExpression Node expressionRoot [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( child  ==  parent.getFirstChild (  )  )  {^254^^^^^244^261^[REPLACE] if  ( child != parent.getFirstChild (  )  )  {^[METHOD] findNonconditionalParent [TYPE] Node [PARAMETER] Node subExpression Node expressionRoot [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^result =  null;^255^^^^^244^261^[REPLACE] result = parent;^[METHOD] findNonconditionalParent [TYPE] Node [PARAMETER] Node subExpression Node expressionRoot [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^for  ( Node child = subExpression,node = child.getParent (  ) ;^248^^^^^244^261^[REPLACE] for  ( Node child = subExpression, parent = child.getParent (  ) ;^[METHOD] findNonconditionalParent [TYPE] Node [PARAMETER] Node subExpression Node expressionRoot [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( child  ==  parent .getLastChild (  )   )  {^254^^^^^244^261^[REPLACE] if  ( child != parent.getFirstChild (  )  )  {^[METHOD] findNonconditionalParent [TYPE] Node [PARAMETER] Node subExpression Node expressionRoot [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^255^^^^^244^261^[ADD] result = parent;^[METHOD] findNonconditionalParent [TYPE] Node [PARAMETER] Node subExpression Node expressionRoot [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^result =  nonconditionalExpr;^255^^^^^244^261^[REPLACE] result = parent;^[METHOD] findNonconditionalParent [TYPE] Node [PARAMETER] Node subExpression Node expressionRoot [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( subExpression  == replacement (  )  )  {^254^^^^^244^261^[REPLACE] if  ( child != parent.getFirstChild (  )  )  {^[METHOD] findNonconditionalParent [TYPE] Node [PARAMETER] Node subExpression Node expressionRoot [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^result =  left;^255^^^^^244^261^[REPLACE] result = parent;^[METHOD] findNonconditionalParent [TYPE] Node [PARAMETER] Node subExpression Node expressionRoot [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^child =  newExpressionRoot, newExpressionRoot^250^^^^^244^261^[REPLACE] child = parent, parent = child.getParent (  )  )  {^[METHOD] findNonconditionalParent [TYPE] Node [PARAMETER] Node subExpression Node expressionRoot [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^250^251^252^^^244^261^[ADD] child = parent, parent = child.getParent (  )  )  { if  ( isConditionalOp ( parent )  )  {^[METHOD] findNonconditionalParent [TYPE] Node [PARAMETER] Node subExpression Node expressionRoot [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^child =  parent, parent^250^^^^^244^261^[REPLACE] child = parent, parent = child.getParent (  )  )  {^[METHOD] findNonconditionalParent [TYPE] Node [PARAMETER] Node subExpression Node expressionRoot [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^for  ( Node child = injectionPointParent, parent = child.getParent (  ) ;^248^^^^^244^261^[REPLACE] for  ( Node child = subExpression, parent = child.getParent (  ) ;^[METHOD] findNonconditionalParent [TYPE] Node [PARAMETER] Node subExpression Node expressionRoot [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^248^249^250^251^^244^261^[ADD] for  ( Node child = subExpression, parent = child.getParent (  ) ; parent != expressionRoot; child = parent, parent = child.getParent (  )  )  { if  ( isConditionalOp ( parent )  )  {^[METHOD] findNonconditionalParent [TYPE] Node [PARAMETER] Node subExpression Node expressionRoot [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^for  ( Node replacement = subExpression, parent = child .getNext (  )  ;^248^^^^^244^261^[REPLACE] for  ( Node child = subExpression, parent = child.getParent (  ) ;^[METHOD] findNonconditionalParent [TYPE] Node [PARAMETER] Node subExpression Node expressionRoot [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^return newExpressionRoot;^260^^^^^244^261^[REPLACE] return result;^[METHOD] findNonconditionalParent [TYPE] Node [PARAMETER] Node subExpression Node expressionRoot [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  (  n == subExpression )  {^280^^^^^277^300^[REPLACE] if  ( n == null || n == stopNode )  {^[METHOD] decomposeSubExpressions [TYPE] void [PARAMETER] Node n Node stopNode DecompositionState state [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  stopNode  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^280^281^282^^^277^300^[ADD] if  ( n == null || n == stopNode )  { return; }^[METHOD] decomposeSubExpressions [TYPE] void [PARAMETER] Node n Node stopNode DecompositionState state [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  stopNode  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^return injectionPoint;^281^^^^^277^300^[REPLACE] return;^[METHOD] decomposeSubExpressions [TYPE] void [PARAMETER] Node n Node stopNode DecompositionState state [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  stopNode  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^decomposeSubExpressions ( n.getNext (  ) , replacement, state ) ;^288^289^^^^277^300^[REPLACE] decomposeSubExpressions ( n.getNext (  ) , stopNode, state ) ;^[METHOD] decomposeSubExpressions [TYPE] void [PARAMETER] Node n Node stopNode DecompositionState state [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  stopNode  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^288^289^^^^277^300^[ADD] decomposeSubExpressions ( n.getNext (  ) , stopNode, state ) ;^[METHOD] decomposeSubExpressions [TYPE] void [PARAMETER] Node n Node stopNode DecompositionState state [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  stopNode  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^n.getParent (  ) , stopNode, state ) ;^289^^^^^277^300^[REPLACE] n.getNext (  ) , stopNode, state ) ;^[METHOD] decomposeSubExpressions [TYPE] void [PARAMETER] Node n Node stopNode DecompositionState state [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  stopNode  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( isExpressionTreeUnsafe ( functionExpression, state.sideEffects )  )  {^293^^^^^277^300^[REPLACE] if  ( isExpressionTreeUnsafe ( n, state.sideEffects )  )  {^[METHOD] decomposeSubExpressions [TYPE] void [PARAMETER] Node n Node stopNode DecompositionState state [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  stopNode  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^state.sideEffects = false;^296^^^^^277^300^[REPLACE] state.sideEffects = true;^[METHOD] decomposeSubExpressions [TYPE] void [PARAMETER] Node n Node stopNode DecompositionState state [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  stopNode  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^296^^^^^277^300^[ADD] state.sideEffects = true;^[METHOD] decomposeSubExpressions [TYPE] void [PARAMETER] Node n Node stopNode DecompositionState state [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  stopNode  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^state.extractBeforeStatement =  extractExpression ( n, null.extractBeforeStatement ) ;^297^298^^^^277^300^[REPLACE] state.extractBeforeStatement = extractExpression ( n, state.extractBeforeStatement ) ;^[METHOD] decomposeSubExpressions [TYPE] void [PARAMETER] Node n Node stopNode DecompositionState state [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  stopNode  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node parent = trueExpr.getParent (  ) ;^313^^^^^312^380^[REPLACE] Node parent = expr.getParent (  ) ;^[METHOD] extractConditional [TYPE] Node [PARAMETER] Node expr Node injectionPoint boolean needResult [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^String resultName = getTempValueName (  ) ;^314^^^^^312^380^[REPLACE] String tempName = getTempValueName (  ) ;^[METHOD] extractConditional [TYPE] Node [PARAMETER] Node expr Node injectionPoint boolean needResult [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^314^^^^^312^380^[ADD] String tempName = getTempValueName (  ) ;^[METHOD] extractConditional [TYPE] Node [PARAMETER] Node expr Node injectionPoint boolean needResult [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node first = tempVarNode.getFirstChild (  ) ;^317^^^^^312^380^[REPLACE] Node first = expr.getFirstChild (  ) ;^[METHOD] extractConditional [TYPE] Node [PARAMETER] Node expr Node injectionPoint boolean needResult [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^317^^^^^312^380^[ADD] Node first = expr.getFirstChild (  ) ;^[METHOD] extractConditional [TYPE] Node [PARAMETER] Node expr Node injectionPoint boolean needResult [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node second = replacementValueNode .getParent (  )  ;^318^^^^^312^380^[REPLACE] Node second = first.getNext (  ) ;^[METHOD] extractConditional [TYPE] Node [PARAMETER] Node expr Node injectionPoint boolean needResult [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node last = stopNode.getFirstChild (  ) ;^319^^^^^312^380^[REPLACE] Node last = expr.getLastChild (  ) ;^[METHOD] extractConditional [TYPE] Node [PARAMETER] Node expr Node injectionPoint boolean needResult [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^expr .hasChildren (  )  ;^322^^^^^312^380^[REPLACE] expr.detachChildren (  ) ;^[METHOD] extractConditional [TYPE] Node [PARAMETER] Node expr Node injectionPoint boolean needResult [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node cond = false;^325^^^^^312^380^[REPLACE] Node cond = null;^[METHOD] extractConditional [TYPE] Node [PARAMETER] Node expr Node injectionPoint boolean needResult [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node falseExpr = new Node ( Token.BLOCK ) ;^326^^^^^312^380^[REPLACE] Node trueExpr = new Node ( Token.BLOCK ) ;^[METHOD] extractConditional [TYPE] Node [PARAMETER] Node expr Node injectionPoint boolean needResult [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node trueExpr = new Node ( Token.BLOCK ) ;^327^^^^^312^380^[REPLACE] Node falseExpr = new Node ( Token.BLOCK ) ;^[METHOD] extractConditional [TYPE] Node [PARAMETER] Node expr Node injectionPoint boolean needResult [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^cond =  tempVarNode;^331^^^^^312^380^[REPLACE] cond = first;^[METHOD] extractConditional [TYPE] Node [PARAMETER] Node expr Node injectionPoint boolean needResult [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^cond =  buildResultExpression ( tempVarNode, needResult, tempName ) ;^339^^^^^312^380^[REPLACE] cond = buildResultExpression ( first, needResult, tempName ) ;^[METHOD] extractConditional [TYPE] Node [PARAMETER] Node expr Node injectionPoint boolean needResult [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^339^^^^^312^380^[ADD] cond = buildResultExpression ( first, needResult, tempName ) ;^[METHOD] extractConditional [TYPE] Node [PARAMETER] Node expr Node injectionPoint boolean needResult [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^cond =  buildResultExpression ( tempVarNode, needResult, tempName ) ;^345^^^^^312^380^[REPLACE] cond = buildResultExpression ( first, needResult, tempName ) ;^[METHOD] extractConditional [TYPE] Node [PARAMETER] Node expr Node injectionPoint boolean needResult [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^345^^^^^312^380^[ADD] cond = buildResultExpression ( first, needResult, tempName ) ;^[METHOD] extractConditional [TYPE] Node [PARAMETER] Node expr Node injectionPoint boolean needResult [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^throw new IllegalStateException ( ;^351^^^^^312^380^[REPLACE] throw new IllegalStateException  (" ")  ;^[METHOD] extractConditional [TYPE] Node [PARAMETER] Node expr Node injectionPoint boolean needResult [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^351^^^^^312^380^[ADD] throw new IllegalStateException  (" ")  ;^[METHOD] extractConditional [TYPE] Node [PARAMETER] Node expr Node injectionPoint boolean needResult [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node cond = null;^354^^^^^312^380^[REPLACE] Node ifNode;^[METHOD] extractConditional [TYPE] Node [PARAMETER] Node expr Node injectionPoint boolean needResult [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( falseExpr.children (  )  )  {^355^^^^^312^380^[REPLACE] if  ( falseExpr.hasChildren (  )  )  {^[METHOD] extractConditional [TYPE] Node [PARAMETER] Node expr Node injectionPoint boolean needResult [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^355^356^357^358^359^312^380^[ADD] if  ( falseExpr.hasChildren (  )  )  { ifNode = new Node ( Token.IF, cond, trueExpr, falseExpr ) ; } else { ifNode = new Node ( Token.IF, cond, trueExpr ) ; }^[METHOD] extractConditional [TYPE] Node [PARAMETER] Node expr Node injectionPoint boolean needResult [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^ifNode = new Node ( Token.IF, cond, trueExpr, falseExpr ) ; ;^358^^^^^355^359^[REPLACE] ifNode = new Node ( Token.IF, cond, trueExpr ) ;^[METHOD] extractConditional [TYPE] Node [PARAMETER] Node expr Node injectionPoint boolean needResult [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^ifNode = new Node ( Token.IF, cond, trueExpr ) ; ;^356^^^^^312^380^[REPLACE] ifNode = new Node ( Token.IF, cond, trueExpr, falseExpr ) ;^[METHOD] extractConditional [TYPE] Node [PARAMETER] Node expr Node injectionPoint boolean needResult [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^ifNode = new Node ( Token.IF, cond, trueExpr, falseExpr ) ; ;^358^^^^^312^380^[REPLACE] ifNode = new Node ( Token.IF, cond, trueExpr ) ;^[METHOD] extractConditional [TYPE] Node [PARAMETER] Node expr Node injectionPoint boolean needResult [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^358^359^^^^312^380^[ADD] ifNode = new Node ( Token.IF, cond, trueExpr ) ; }^[METHOD] extractConditional [TYPE] Node [PARAMETER] Node expr Node injectionPoint boolean needResult [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( left != child )  {^361^^^^^312^380^[REPLACE] if  ( needResult )  {^[METHOD] extractConditional [TYPE] Node [PARAMETER] Node expr Node injectionPoint boolean needResult [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node gramps = replacementValueNode.getParent (  ) ;^375^^^^^361^377^[REPLACE] Node gramps = parent.getParent (  ) ;^[METHOD] extractConditional [TYPE] Node [PARAMETER] Node expr Node injectionPoint boolean needResult [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node tempVarNode = new Node ( Token.VAR, Node.replaceChild ( Token.NAME, tempNamePrefix )  ) ;^362^363^^^^312^380^[REPLACE] Node tempVarNode = new Node ( Token.VAR, Node.newString ( Token.NAME, tempName )  ) ;^[METHOD] extractConditional [TYPE] Node [PARAMETER] Node expr Node injectionPoint boolean needResult [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^362^363^^^^312^380^[ADD] Node tempVarNode = new Node ( Token.VAR, Node.newString ( Token.NAME, tempName )  ) ;^[METHOD] extractConditional [TYPE] Node [PARAMETER] Node expr Node injectionPoint boolean needResult [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node lastParent = injectionPoint.getParent (  ) ;^364^^^^^312^380^[REPLACE] Node injectionPointParent = injectionPoint.getParent (  ) ;^[METHOD] extractConditional [TYPE] Node [PARAMETER] Node expr Node injectionPoint boolean needResult [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node replacementValueNode = Node.newString ( Token.NAME, tempNamePrefix ) ;^369^^^^^312^380^[REPLACE] Node replacementValueNode = Node.newString ( Token.NAME, tempName ) ;^[METHOD] extractConditional [TYPE] Node [PARAMETER] Node expr Node injectionPoint boolean needResult [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node tempVarNode = new Node ( Token.VAR, Node.newString ( Token.NAME, tempNamePrefix )  ) ;^362^363^^^^312^380^[REPLACE] Node tempVarNode = new Node ( Token.VAR, Node.newString ( Token.NAME, tempName )  ) ;^[METHOD] extractConditional [TYPE] Node [PARAMETER] Node expr Node injectionPoint boolean needResult [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node nParent = injectionPoint.getParent (  ) ;^364^^^^^312^380^[REPLACE] Node injectionPointParent = injectionPoint.getParent (  ) ;^[METHOD] extractConditional [TYPE] Node [PARAMETER] Node expr Node injectionPoint boolean needResult [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^364^^^^^312^380^[ADD] Node injectionPointParent = injectionPoint.getParent (  ) ;^[METHOD] extractConditional [TYPE] Node [PARAMETER] Node expr Node injectionPoint boolean needResult [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node replacementValueNode = Node .toStringTree (  )  ;^369^^^^^312^380^[REPLACE] Node replacementValueNode = Node.newString ( Token.NAME, tempName ) ;^[METHOD] extractConditional [TYPE] Node [PARAMETER] Node expr Node injectionPoint boolean needResult [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node gramps = nonconditionalExpr.getNext (  ) ;^375^^^^^312^380^[REPLACE] Node gramps = parent.getParent (  ) ;^[METHOD] extractConditional [TYPE] Node [PARAMETER] Node expr Node injectionPoint boolean needResult [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^return subExpression;^379^^^^^312^380^[REPLACE] return ifNode;^[METHOD] extractConditional [TYPE] Node [PARAMETER] Node expr Node injectionPoint boolean needResult [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( true )  {^393^^^^^391^400^[REPLACE] if  ( needResult )  {^[METHOD] buildResultExpression [TYPE] Node [PARAMETER] Node expr boolean needResult String tempName [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^return trueExpr;^398^^^^^391^400^[REPLACE] return expr;^[METHOD] buildResultExpression [TYPE] Node [PARAMETER] Node expr boolean needResult String tempName [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^return new Node ( Token.ASSIGN, Node .toStringTree (  )  , expr ) ;^394^395^396^^^391^400^[REPLACE] return new Node ( Token.ASSIGN, Node.newString ( Token.NAME, tempName ) , expr ) ;^[METHOD] buildResultExpression [TYPE] Node [PARAMETER] Node expr boolean needResult String tempName [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^return new Node ( Token.ASSIGN, Node.replaceChild ( Token.NAME, tempName ) , expr ) ;^394^395^396^^^391^400^[REPLACE] return new Node ( Token.ASSIGN, Node.newString ( Token.NAME, tempName ) , expr ) ;^[METHOD] buildResultExpression [TYPE] Node [PARAMETER] Node expr boolean needResult String tempName [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^return second;^398^^^^^391^400^[REPLACE] return expr;^[METHOD] buildResultExpression [TYPE] Node [PARAMETER] Node expr boolean needResult String tempName [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node parent = expr .getNext (  )  ;^409^^^^^408^426^[REPLACE] Node parent = expr.getParent (  ) ;^[METHOD] extractExpression [TYPE] Node [PARAMETER] Node expr Node injectionPoint [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node tempVarNode = new Node ( Token.VAR, tempNameNode ) ;^411^^^^^408^426^[REPLACE] String tempName = getTempConstantValueName (  ) ;^[METHOD] extractExpression [TYPE] Node [PARAMETER] Node expr Node injectionPoint [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node replacementValueNode = Node.newString ( Token.NAME, tempNamePrefix ) ;^414^^^^^408^426^[REPLACE] Node replacementValueNode = Node.newString ( Token.NAME, tempName ) ;^[METHOD] extractExpression [TYPE] Node [PARAMETER] Node expr Node injectionPoint [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^parent.addChildAfter ( expr, replacementValueNode ) ;^415^^^^^408^426^[REPLACE] parent.replaceChild ( expr, replacementValueNode ) ;^[METHOD] extractExpression [TYPE] Node [PARAMETER] Node expr Node injectionPoint [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node tempNamePrefixNode = Node.replaceChild ( Token.NAME, tempName ) ;^418^^^^^408^426^[REPLACE] Node tempNameNode = Node.newString ( Token.NAME, tempName ) ;^[METHOD] extractExpression [TYPE] Node [PARAMETER] Node expr Node injectionPoint [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^tempName  subExpression   ;^419^^^^^408^426^[REPLACE] tempNameNode.addChildrenToBack ( expr ) ;^[METHOD] extractExpression [TYPE] Node [PARAMETER] Node expr Node injectionPoint [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^419^^^^^408^426^[ADD] tempNameNode.addChildrenToBack ( expr ) ;^[METHOD] extractExpression [TYPE] Node [PARAMETER] Node expr Node injectionPoint [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node tempVarNode = new Node ( Token.VAR, trueExpr ) ;^420^^^^^408^426^[REPLACE] Node tempVarNode = new Node ( Token.VAR, tempNameNode ) ;^[METHOD] extractExpression [TYPE] Node [PARAMETER] Node expr Node injectionPoint [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^420^^^^^408^426^[ADD] Node tempVarNode = new Node ( Token.VAR, tempNameNode ) ;^[METHOD] extractExpression [TYPE] Node [PARAMETER] Node expr Node injectionPoint [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node injectionPointParent = injectionPoint .getNext (  )  ;^422^^^^^408^426^[REPLACE] Node injectionPointParent = injectionPoint.getParent (  ) ;^[METHOD] extractExpression [TYPE] Node [PARAMETER] Node expr Node injectionPoint [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^injectionPointParent.addChildBefore ( replacement, injectionPoint ) ;^423^^^^^408^426^[REPLACE] injectionPointParent.addChildBefore ( tempVarNode, injectionPoint ) ;^[METHOD] extractExpression [TYPE] Node [PARAMETER] Node expr Node injectionPoint [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^return trueExpr;^425^^^^^408^426^[REPLACE] return tempVarNode;^[METHOD] extractExpression [TYPE] Node [PARAMETER] Node expr Node injectionPoint [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Preconditions.checkArgument ( call.getType (  )   ||  Token.CALL ) ;^439^^^^^438^487^[REPLACE] Preconditions.checkArgument ( call.getType (  )  == Token.CALL ) ;^[METHOD] rewriteCallExpression [TYPE] Node [PARAMETER] Node call DecompositionState state [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Preconditions.checkArgument ( call.newString (  )  == Token.CALL ) ;^439^^^^^438^487^[REPLACE] Preconditions.checkArgument ( call.getType (  )  == Token.CALL ) ;^[METHOD] rewriteCallExpression [TYPE] Node [PARAMETER] Node call DecompositionState state [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^439^440^^^^438^487^[ADD] Preconditions.checkArgument ( call.getType (  )  == Token.CALL ) ; Node first = call.getFirstChild (  ) ;^[METHOD] rewriteCallExpression [TYPE] Node [PARAMETER] Node call DecompositionState state [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node first = thisVarNode.getLastChild (  ) ;^440^^^^^438^487^[REPLACE] Node first = call.getFirstChild (  ) ;^[METHOD] rewriteCallExpression [TYPE] Node [PARAMETER] Node call DecompositionState state [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Preconditions.checkArgument ( NodeUtil.isStatementBlock ( subExpression )  ) ;^441^^^^^438^487^[REPLACE] Preconditions.checkArgument ( NodeUtil.isGet ( first )  ) ;^[METHOD] rewriteCallExpression [TYPE] Node [PARAMETER] Node call DecompositionState state [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Preconditions.checkArgument ( NodeUtil.isStatementBlock ( tempVarNode )  ) ;^441^^^^^438^487^[REPLACE] Preconditions.checkArgument ( NodeUtil.isGet ( first )  ) ;^[METHOD] rewriteCallExpression [TYPE] Node [PARAMETER] Node call DecompositionState state [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node getVarNode = extractExpression ( thisVarNode, state.extractBeforeStatement ) ;^445^446^^^^438^487^[REPLACE] Node getVarNode = extractExpression ( first, state.extractBeforeStatement ) ;^[METHOD] rewriteCallExpression [TYPE] Node [PARAMETER] Node call DecompositionState state [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^state.extractBeforeStatement = thisVarNode; ;^447^^^^^438^487^[REPLACE] state.extractBeforeStatement = getVarNode;^[METHOD] rewriteCallExpression [TYPE] Node [PARAMETER] Node call DecompositionState state [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node getExprNode = node.getFirstChild (  ) .getFirstChild (  ) ;^451^^^^^438^487^[REPLACE] Node getExprNode = getVarNode.getFirstChild (  ) .getFirstChild (  ) ;^[METHOD] rewriteCallExpression [TYPE] Node [PARAMETER] Node call DecompositionState state [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Preconditions.checkArgument ( NodeUtil.isGet ( nonconditionalExpr )  ) ;^452^^^^^438^487^[REPLACE] Preconditions.checkArgument ( NodeUtil.isGet ( getExprNode )  ) ;^[METHOD] rewriteCallExpression [TYPE] Node [PARAMETER] Node call DecompositionState state [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Preconditions.checkArgument ( NodeUtil.isStatementBlock ( parent )  ) ;^452^^^^^438^487^[REPLACE] Preconditions.checkArgument ( NodeUtil.isGet ( getExprNode )  ) ;^[METHOD] rewriteCallExpression [TYPE] Node [PARAMETER] Node call DecompositionState state [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node thisVarNode = extractExpression ( trueExpr.getFirstChild (  ) , state.extractBeforeStatement ) ;^453^454^^^^438^487^[REPLACE] Node thisVarNode = extractExpression ( getExprNode.getFirstChild (  ) , state.extractBeforeStatement ) ;^[METHOD] rewriteCallExpression [TYPE] Node [PARAMETER] Node call DecompositionState state [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^state.extractBeforeStatement = getVarNode; ;^455^^^^^438^487^[REPLACE] state.extractBeforeStatement = thisVarNode;^[METHOD] rewriteCallExpression [TYPE] Node [PARAMETER] Node call DecompositionState state [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node thisNameNode = newExpressionRoot.getFirstChild (  ) ;^458^^^^^438^487^[REPLACE] Node thisNameNode = thisVarNode.getFirstChild (  ) ;^[METHOD] rewriteCallExpression [TYPE] Node [PARAMETER] Node call DecompositionState state [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node functionNameNode = node.getFirstChild (  ) ;^459^^^^^438^487^[REPLACE] Node functionNameNode = getVarNode.getFirstChild (  ) ;^[METHOD] rewriteCallExpression [TYPE] Node [PARAMETER] Node call DecompositionState state [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node newCall = new Node ( Token.CALL, new Node ( Token.GETPROP, replacement.cloneNode (  ) , Node.newString ( "call" )  ) ,^469^470^471^472^^438^487^[REPLACE] Node newCall = new Node ( Token.CALL, new Node ( Token.GETPROP, functionNameNode.cloneNode (  ) , Node.newString ( "call" )  ) ,^[METHOD] rewriteCallExpression [TYPE] Node [PARAMETER] Node call DecompositionState state [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^call.getFirstChild (  ) ;^476^^^^^438^487^[REPLACE] call.removeFirstChild (  ) ;^[METHOD] rewriteCallExpression [TYPE] Node [PARAMETER] Node call DecompositionState state [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( falseExpr.hasChildren (  )  )  {^477^^^^^438^487^[REPLACE] if  ( call.hasChildren (  )  )  {^[METHOD] rewriteCallExpression [TYPE] Node [PARAMETER] Node call DecompositionState state [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^newCall.addChildrenToBack ( call.detachChildren (  )  ) ;^479^^^^^438^487^[REPLACE] newCall.addChildrenToBack ( call.removeChildren (  )  ) ;^[METHOD] rewriteCallExpression [TYPE] Node [PARAMETER] Node call DecompositionState state [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REMOVE]^thisNameNode.cloneNode (  ) , call.getLineno (  ) , call.getCharno (  )  ) ;^479^^^^^438^487^[REMOVE] ^[METHOD] rewriteCallExpression [TYPE] Node [PARAMETER] Node call DecompositionState state [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^newCall.addChildrenToBack ( result.detachChildren (  )  ) ;^479^^^^^438^487^[REPLACE] newCall.addChildrenToBack ( call.removeChildren (  )  ) ;^[METHOD] rewriteCallExpression [TYPE] Node [PARAMETER] Node call DecompositionState state [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node thisVarNodeParent = call.getParent (  ) ;^483^^^^^438^487^[REPLACE] Node callParent = call.getParent (  ) ;^[METHOD] rewriteCallExpression [TYPE] Node [PARAMETER] Node call DecompositionState state [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^483^^^^^438^487^[ADD] Node callParent = call.getParent (  ) ;^[METHOD] rewriteCallExpression [TYPE] Node [PARAMETER] Node call DecompositionState state [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^callParent.addChildAfter ( call, newCall ) ;^484^^^^^438^487^[REPLACE] callParent.replaceChild ( call, newCall ) ;^[METHOD] rewriteCallExpression [TYPE] Node [PARAMETER] Node call DecompositionState state [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^return replacementValueNode;^486^^^^^438^487^[REPLACE] return newCall;^[METHOD] rewriteCallExpression [TYPE] Node [PARAMETER] Node call DecompositionState state [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^this.tempNamePrefix =  tempName;^496^^^^^495^497^[REPLACE] this.tempNamePrefix = tempNamePrefix;^[METHOD] setTempNamePrefix [TYPE] void [PARAMETER] String tempNamePrefix [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^returntempName + safeNameIdSupplier.get (  ) ;^503^^^^^502^504^[REPLACE] return tempNamePrefix + safeNameIdSupplier.get (  ) ;^[METHOD] getTempValueName [TYPE] String [PARAMETER] [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^String resultName = getTempValueName (  ) ;^510^^^^^509^513^[REPLACE] String sName = tempNamePrefix + "const_" + safeNameIdSupplier.get (  ) ;^[METHOD] getTempConstantValueName [TYPE] String [PARAMETER] [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^this.knownConstants.add ( tempNamePrefix ) ;^511^^^^^509^513^[REPLACE] this.knownConstants.add ( sName ) ;^[METHOD] getTempConstantValueName [TYPE] String [PARAMETER] [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^return tempNamePrefix;^512^^^^^509^513^[REPLACE] return sName;^[METHOD] getTempConstantValueName [TYPE] String [PARAMETER] [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node expressionRoot = findExpressionRoot ( newCall ) ;^520^^^^^519^534^[REPLACE] Node expressionRoot = findExpressionRoot ( subExpression ) ;^[METHOD] findInjectionPoint [TYPE] Node [PARAMETER] Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^Preconditions.checkNotNull ( expressionRoot ) ;^520^521^^^^519^534^[ADD] Node expressionRoot = findExpressionRoot ( subExpression ) ; Preconditions.checkNotNull ( expressionRoot ) ;^[METHOD] findInjectionPoint [TYPE] Node [PARAMETER] Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Preconditions.checkNotNull ( node ) ;^521^^^^^519^534^[REPLACE] Preconditions.checkNotNull ( expressionRoot ) ;^[METHOD] findInjectionPoint [TYPE] Node [PARAMETER] Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^521^^^^^519^534^[ADD] Preconditions.checkNotNull ( expressionRoot ) ;^[METHOD] findInjectionPoint [TYPE] Node [PARAMETER] Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node injectionPoint = newExpressionRoot;^523^^^^^519^534^[REPLACE] Node injectionPoint = expressionRoot;^[METHOD] findInjectionPoint [TYPE] Node [PARAMETER] Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node parent = injectionPoint.getNext (  ) ;^525^^^^^519^534^[REPLACE] Node parent = injectionPoint.getParent (  ) ;^[METHOD] findInjectionPoint [TYPE] Node [PARAMETER] Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^while  ( parent.getType (  )   ||  Token.LABEL )  {^526^^^^^519^534^[REPLACE] while  ( parent.getType (  )  == Token.LABEL )  {^[METHOD] findInjectionPoint [TYPE] Node [PARAMETER] Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^injectionPoint =  result;^527^^^^^519^534^[REPLACE] injectionPoint = parent;^[METHOD] findInjectionPoint [TYPE] Node [PARAMETER] Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^527^528^^^^519^534^[ADD] injectionPoint = parent; parent = injectionPoint.getParent (  ) ;^[METHOD] findInjectionPoint [TYPE] Node [PARAMETER] Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^parent =  replacement.getParent (  ) ;^528^^^^^519^534^[REPLACE] parent = injectionPoint.getParent (  ) ;^[METHOD] findInjectionPoint [TYPE] Node [PARAMETER] Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^injectionPoint =  replacementValueNode;^527^^^^^519^534^[REPLACE] injectionPoint = parent;^[METHOD] findInjectionPoint [TYPE] Node [PARAMETER] Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^parent =  newExpressionRoot.getParent (  ) ;^528^^^^^519^534^[REPLACE] parent = injectionPoint.getParent (  ) ;^[METHOD] findInjectionPoint [TYPE] Node [PARAMETER] Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Preconditions.checkNotNull ( NodeUtil.isStatementBlock ( replacementValueNode.getParent (  )  )  ) ;^531^532^^^^519^534^[REPLACE] Preconditions.checkState ( NodeUtil.isStatementBlock ( injectionPoint.getParent (  )  )  ) ;^[METHOD] findInjectionPoint [TYPE] Node [PARAMETER] Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^NodeUtil.isStatementBlock ( last.getNext (  )  )  ) ;^532^^^^^519^534^[REPLACE] NodeUtil.isStatementBlock ( injectionPoint.getParent (  )  )  ) ;^[METHOD] findInjectionPoint [TYPE] Node [PARAMETER] Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^return injectionPoint;^532^533^^^^519^534^[ADD] NodeUtil.isStatementBlock ( injectionPoint.getParent (  )  )  ) ; return injectionPoint;^[METHOD] findInjectionPoint [TYPE] Node [PARAMETER] Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^NodeUtil.isStatementBlock ( node.getNext (  )  )  ) ;^532^^^^^519^534^[REPLACE] NodeUtil.isStatementBlock ( injectionPoint.getParent (  )  )  ) ;^[METHOD] findInjectionPoint [TYPE] Node [PARAMETER] Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^532^^^^^519^534^[ADD] NodeUtil.isStatementBlock ( injectionPoint.getParent (  )  )  ) ;^[METHOD] findInjectionPoint [TYPE] Node [PARAMETER] Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^return nonconditionalExpr;^533^^^^^519^534^[REPLACE] return injectionPoint;^[METHOD] findInjectionPoint [TYPE] Node [PARAMETER] Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^return false;^544^^^^^539^548^[REPLACE] return true;^[METHOD] isConditionalOp [TYPE] boolean [PARAMETER] Node n [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^return true;^546^^^^^539^548^[REPLACE] return false;^[METHOD] isConditionalOp [TYPE] boolean [PARAMETER] Node n [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node child = nonconditionalExpr;^556^^^^^555^583^[REPLACE] Node child = subExpression;^[METHOD] findExpressionRoot [TYPE] Node [PARAMETER] Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^child =  subExpression;^579^^^^^555^583^[REPLACE] child = parent;^[METHOD] findExpressionRoot [TYPE] Node [PARAMETER] Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^return node;^570^^^^^555^583^[REPLACE] return parent;^[METHOD] findExpressionRoot [TYPE] Node [PARAMETER] Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^return this;^577^^^^^555^583^[REPLACE] return null;^[METHOD] findExpressionRoot [TYPE] Node [PARAMETER] Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node second = first.getNext (  ) ;^557^^^^^555^583^[REPLACE] for  ( Node parent : child.getAncestors (  )  )  {^[METHOD] findExpressionRoot [TYPE] Node [PARAMETER] Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^int thisVarNodeType = parent.getNext (  ) ;^558^^^^^555^583^[REPLACE] int parentType = parent.getType (  ) ;^[METHOD] findExpressionRoot [TYPE] Node [PARAMETER] Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^throw new IllegalStateException ( ;^582^^^^^555^583^[REPLACE] throw new IllegalStateException  (" ")  ;^[METHOD] findExpressionRoot [TYPE] Node [PARAMETER] Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^582^^^^^555^583^[ADD] throw new IllegalStateException  (" ")  ;^[METHOD] findExpressionRoot [TYPE] Node [PARAMETER] Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node expressionRoot = findExpressionRoot ( left ) ;^611^^^^^610^616^[REPLACE] Node expressionRoot = findExpressionRoot ( subExpression ) ;^[METHOD] canExposeExpression [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( trueExpr == null )  {^612^^^^^610^616^[REPLACE] if  ( expressionRoot != null )  {^[METHOD] canExposeExpression [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^return isSubexpressionMovable ( expressionRoot, subExpression ) ;^612^613^614^^^610^616^[ADD] if  ( expressionRoot != null )  { return isSubexpressionMovable ( expressionRoot, subExpression ) ; }^[METHOD] canExposeExpression [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^return isSubexpressionMovable ( newCall, subExpression ) ;^613^^^^^610^616^[REPLACE] return isSubexpressionMovable ( expressionRoot, subExpression ) ;^[METHOD] canExposeExpression [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^return isSubexpressionMovable ( replacementValueNode, subExpression ) ;^613^^^^^610^616^[REPLACE] return isSubexpressionMovable ( expressionRoot, subExpression ) ;^[METHOD] canExposeExpression [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^return DecompositionType.DECOMPOSABLE;^615^^^^^610^616^[REPLACE] return DecompositionType.UNDECOMPOSABLE;^[METHOD] canExposeExpression [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^boolean requiresDecomposition = true;^646^^^^^645^735^[REPLACE] boolean requiresDecomposition = false;^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^646^647^^^^645^735^[ADD] boolean requiresDecomposition = false; boolean seenSideEffects = NodeUtil.mayHaveSideEffects ( subExpression ) ;^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^boolean seenSideEffects = NodeUtil.mayHaveSideEffects ( last ) ;^647^^^^^645^735^[REPLACE] boolean seenSideEffects = NodeUtil.mayHaveSideEffects ( subExpression ) ;^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^647^^^^^645^735^[ADD] boolean seenSideEffects = NodeUtil.mayHaveSideEffects ( subExpression ) ;^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node child = newExpressionRoot;^649^^^^^645^735^[REPLACE] Node child = subExpression;^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( parent  ||  expressionRoot )  {^651^^^^^645^735^[REPLACE] if  ( parent == expressionRoot )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^return true ? DecompositionType.DECOMPOSABLE : DecompositionType.MOVABLE;^654^655^656^^^645^735^[REPLACE] return requiresDecomposition ? DecompositionType.DECOMPOSABLE : DecompositionType.MOVABLE;^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( left != child )  {^661^^^^^645^735^[REPLACE] if  ( isConditionalOp ( parent )  )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^661^662^^664^665^645^735^[ADD] if  ( isConditionalOp ( parent )  )  {  if  ( child != parent.getFirstChild (  )  )  { requiresDecomposition = true;^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( isSafeAssign ( parent, state.sideEffects )  )  {^675^^^^^661^728^[REPLACE] if  ( isSafeAssign ( parent, seenSideEffects )  )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( n  &&  child )  {^689^^^^^675^727^[REPLACE] if  ( n == child )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^689^690^^692^693^675^727^[ADD] if  ( n == child )  {  break; }^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( isExpressionTreeUnsafe ( n, true )  )  {^695^696^^^^675^727^[REPLACE] if  ( isExpressionTreeUnsafe ( n, seenSideEffects )  )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^695^696^697^698^699^675^727^[ADD] if  ( isExpressionTreeUnsafe ( n, seenSideEffects )  )  { seenSideEffects = true; requiresDecomposition = true; }^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^state.sideEffects = true; ;^697^^^^^695^699^[REPLACE] seenSideEffects = true;^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^697^^^^^695^699^[ADD] seenSideEffects = true;^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^requiresDecomposition = false;^698^^^^^695^699^[REPLACE] requiresDecomposition = true;^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( requiresDecomposition || parent.getType (  )  == Token.CALL || NodeUtil.isGet ( first )  )  {^718^719^720^^^675^727^[REPLACE] if  ( requiresDecomposition && parent.getType (  )  == Token.CALL && NodeUtil.isGet ( first )  )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^718^719^720^721^722^675^727^[ADD] if  ( requiresDecomposition && parent.getType (  )  == Token.CALL && NodeUtil.isGet ( first )  )  { if  ( maybeExternMethod ( first )  )  { return DecompositionType.UNDECOMPOSABLE;^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( maybeExternMethod ( replacementValueNode )  )  {^721^^^^^718^726^[REPLACE] if  ( maybeExternMethod ( first )  )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^return DecompositionType.UNDECOMPOSABLE;^724^^^^^718^726^[REPLACE] return DecompositionType.DECOMPOSABLE;^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^return DecompositionType.DECOMPOSABLE;^722^^^^^718^726^[REPLACE] return DecompositionType.UNDECOMPOSABLE;^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( maybeExternMethod ( thisVarNode )  )  {^721^^^^^675^727^[REPLACE] if  ( maybeExternMethod ( first )  )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^return DecompositionType.UNDECOMPOSABLE;^724^^^^^721^725^[REPLACE] return DecompositionType.DECOMPOSABLE;^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^return DecompositionType.DECOMPOSABLE;^722^^^^^675^727^[REPLACE] return DecompositionType.UNDECOMPOSABLE;^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^seenSideEffects = false;^697^^^^^675^727^[REPLACE] seenSideEffects = true;^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^697^^^^^675^727^[ADD] seenSideEffects = true;^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^requiresDecomposition = false;^698^^^^^675^727^[REPLACE] requiresDecomposition = true;^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^return DecompositionType.UNDECOMPOSABLE;^724^^^^^675^727^[REPLACE] return DecompositionType.DECOMPOSABLE;^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node functionExpression = parent.getFirstChild (  ) ;^688^^^^^675^727^[REPLACE] for  ( Node n : parent.children (  )  )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node first = trueExpr.getFirstChild (  ) ;^717^^^^^675^727^[REPLACE] Node first = parent.getFirstChild (  ) ;^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^717^^^^^675^727^[ADD] Node first = parent.getFirstChild (  ) ;^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( n  !=  child )  {^689^^^^^661^728^[REPLACE] if  ( n == child )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( isExpressionTreeUnsafe ( n, state.sideEffects )  )  {^695^696^^^^661^728^[REPLACE] if  ( isExpressionTreeUnsafe ( n, seenSideEffects )  )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( requiresDecomposition ) {^718^719^720^^^661^728^[REPLACE] if  ( requiresDecomposition && parent.getType (  )  == Token.CALL && NodeUtil.isGet ( first )  )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REMOVE]^if  ( isSafeAssign ( parent, seenSideEffects )  )  { }else {     for  ( Node n : parent.children (  )  )  {         if  ( n == child )  {             break;         }         if  ( isExpressionTreeUnsafe ( n, seenSideEffects )  )  {             seenSideEffects = true;             requiresDecomposition = true;         }     }     Node first = parent.getFirstChild (  ) ;     if  (  ( requiresDecomposition &&  (  ( parent.getType (  )  )  ==  ( CALL )  )  )  &&  ( isGet ( first )  )  )  {         if  ( maybeExternMethod ( first )  )  {             return UNDECOMPOSABLE;         }else {             return DECOMPOSABLE;         }     } }^718^^^^^661^728^[REMOVE] ^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( maybeExternMethod ( replacement )  )  {^721^^^^^718^726^[REPLACE] if  ( maybeExternMethod ( first )  )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^721^722^723^724^725^718^726^[ADD] if  ( maybeExternMethod ( first )  )  { return DecompositionType.UNDECOMPOSABLE; } else { return DecompositionType.DECOMPOSABLE; }^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( left != child )  {^721^^^^^661^728^[REPLACE] if  ( maybeExternMethod ( first )  )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^return DecompositionType.DECOMPOSABLE;^722^^^^^661^728^[REPLACE] return DecompositionType.UNDECOMPOSABLE;^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^seenSideEffects = false;^697^^^^^661^728^[REPLACE] seenSideEffects = true;^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^requiresDecomposition = false;^698^^^^^661^728^[REPLACE] requiresDecomposition = true;^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^return DecompositionType.UNDECOMPOSABLE;^724^^^^^661^728^[REPLACE] return DecompositionType.DECOMPOSABLE;^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node functionExpression = parent.getFirstChild (  ) ;^688^^^^^661^728^[REPLACE] for  ( Node n : parent.children (  )  )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node first = stopNode.getFirstChild (  ) ;^717^^^^^661^728^[REPLACE] Node first = parent.getFirstChild (  ) ;^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( child  == thisVarNode (  )  )  {^664^^^^^645^735^[REPLACE] if  ( child != parent.getFirstChild (  )  )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^requiresDecomposition = false;^665^^^^^645^735^[REPLACE] requiresDecomposition = true;^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  (second  ==  parent .getLastChild (  )   )  {^664^^^^^645^735^[REPLACE] if  ( child != parent.getFirstChild (  )  )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( isSafeAssign ( parent, state.sideEffects )  )  {^675^^^^^645^735^[REPLACE] if  ( isSafeAssign ( parent, seenSideEffects )  )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( replacement  !=  thisVarNode )  {^689^^^^^675^727^[REPLACE] if  ( n == child )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( isExpressionTreeUnsafe ( n, sideEffects )  )  {^695^696^^^^675^727^[REPLACE] if  ( isExpressionTreeUnsafe ( n, seenSideEffects )  )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^seenSideEffects = false;^697^^^^^695^699^[REPLACE] seenSideEffects = true;^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  (  node.getType (  )  == Token.CALL || NodeUtil.isGet ( first )  )  {^718^719^720^^^675^727^[REPLACE] if  ( requiresDecomposition && parent.getType (  )  == Token.CALL && NodeUtil.isGet ( first )  )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( maybeExternMethod ( thisVarNode )  )  {^721^^^^^718^726^[REPLACE] if  ( maybeExternMethod ( first )  )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( maybeExternMethod ( subExpression )  )  {^721^^^^^675^727^[REPLACE] if  ( maybeExternMethod ( first )  )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node first = parent .getLastChild (  )  ;^717^^^^^675^727^[REPLACE] Node first = parent.getFirstChild (  ) ;^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( replacement  &&  child )  {^689^^^^^645^735^[REPLACE] if  ( n == child )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( isExpressionTreeUnsafe ( n, requiresDecomposition )  )  {^695^696^^^^645^735^[REPLACE] if  ( isExpressionTreeUnsafe ( n, seenSideEffects )  )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^695^696^697^698^699^645^735^[ADD] if  ( isExpressionTreeUnsafe ( n, seenSideEffects )  )  { seenSideEffects = true; requiresDecomposition = true; }^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( requiresDecomposition ) {^718^719^720^^^645^735^[REPLACE] if  ( requiresDecomposition && parent.getType (  )  == Token.CALL && NodeUtil.isGet ( first )  )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REMOVE]^if  ( parent == expressionRoot )  {     return requiresDecomposition ? DECOMPOSABLE : MOVABLE; }^721^^^^^718^726^[REMOVE] ^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( maybeExternMethod ( replacementValueNode )  )  {^721^^^^^645^735^[REPLACE] if  ( maybeExternMethod ( first )  )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^return DecompositionType.DECOMPOSABLE;^722^^^^^645^735^[REPLACE] return DecompositionType.UNDECOMPOSABLE;^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^seenSideEffects = false;^697^^^^^645^735^[REPLACE] seenSideEffects = true;^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^requiresDecomposition = false;^698^^^^^645^735^[REPLACE] requiresDecomposition = true;^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^child =  replacement;^730^^^^^645^735^[REPLACE] child = parent;^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^return DecompositionType.UNDECOMPOSABLE;^724^^^^^645^735^[REPLACE] return DecompositionType.DECOMPOSABLE;^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node second = first.getNext (  ) ;^650^^^^^645^735^[REPLACE] for  ( Node parent : child.getAncestors (  )  )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^int nodeType = parent.getType (  ) ;^659^^^^^645^735^[REPLACE] int parentType = parent.getType (  ) ;^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node functionExpression = parent.getFirstChild (  ) ;^688^^^^^645^735^[REPLACE] for  ( Node n : parent.children (  )  )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node first = subExpression.getLastChild (  ) ;^717^^^^^645^735^[REPLACE] Node first = parent.getFirstChild (  ) ;^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^throw new IllegalStateException ( ;^734^^^^^645^735^[REPLACE] throw new IllegalStateException  (" ")  ;^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( n.getType (  )   &&  Token.ASSIGN )  {^759^^^^^758^772^[REPLACE] if  ( n.getType (  )  == Token.ASSIGN )  {^[METHOD] isSafeAssign [TYPE] boolean [PARAMETER] Node n boolean seenSideEffects [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  lhs  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^Node lhs = n.getFirstChild (  ) ;return true;^759^760^761^762^763^758^772^[ADD] if  ( n.getType (  )  == Token.ASSIGN )  { Node lhs = n.getFirstChild (  ) ; switch  ( lhs.getType (  )  )  { case Token.NAME: return true;^[METHOD] isSafeAssign [TYPE] boolean [PARAMETER] Node n boolean seenSideEffects [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  lhs  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^return false;^763^^^^^758^772^[REPLACE] return true;^[METHOD] isSafeAssign [TYPE] boolean [PARAMETER] Node n boolean seenSideEffects [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  lhs  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^return !isExpressionTreeUnsafe ( lhs.getFirstChild (  ) , true ) ;^765^^^^^758^772^[REPLACE] return !isExpressionTreeUnsafe ( lhs.getFirstChild (  ) , seenSideEffects ) ;^[METHOD] isSafeAssign [TYPE] boolean [PARAMETER] Node n boolean seenSideEffects [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  lhs  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^return   !isExpressionTreeUnsafe ( lhs.getLastChild (  ) , seenSideEffects ) ;^767^768^^^^758^772^[REPLACE] return !isExpressionTreeUnsafe ( lhs.getFirstChild (  ) , seenSideEffects ) && !isExpressionTreeUnsafe ( lhs.getLastChild (  ) , seenSideEffects ) ;^[METHOD] isSafeAssign [TYPE] boolean [PARAMETER] Node n boolean seenSideEffects [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  lhs  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node lhs = stopNode.getFirstChild (  ) ;^760^^^^^758^772^[REPLACE] Node lhs = n.getFirstChild (  ) ;^[METHOD] isSafeAssign [TYPE] boolean [PARAMETER] Node n boolean seenSideEffects [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  lhs  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^return !isExpressionTreeUnsafe ( lhs .getLastChild (  )  , seenSideEffects ) ;^765^^^^^758^772^[REPLACE] return !isExpressionTreeUnsafe ( lhs.getFirstChild (  ) , seenSideEffects ) ;^[METHOD] isSafeAssign [TYPE] boolean [PARAMETER] Node n boolean seenSideEffects [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  lhs  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^return !isExpressionTreeUnsafe ( lhs.getLastChild (  ) , seenSideEffects ) || !isExpressionTreeUnsafe ( lhs.getLastChild (  ) , seenSideEffects ) ;^767^768^^^^758^772^[REPLACE] return !isExpressionTreeUnsafe ( lhs.getFirstChild (  ) , seenSideEffects ) && !isExpressionTreeUnsafe ( lhs.getLastChild (  ) , seenSideEffects ) ;^[METHOD] isSafeAssign [TYPE] boolean [PARAMETER] Node n boolean seenSideEffects [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  lhs  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node lhs = subExpression.getFirstChild (  ) ;^760^^^^^758^772^[REPLACE] Node lhs = n.getFirstChild (  ) ;^[METHOD] isSafeAssign [TYPE] boolean [PARAMETER] Node n boolean seenSideEffects [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  lhs  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^return true;^771^^^^^758^772^[REPLACE] return false;^[METHOD] isSafeAssign [TYPE] boolean [PARAMETER] Node n boolean seenSideEffects [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  lhs  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( true )  {^780^^^^^778^791^[REPLACE] if  ( followingSideEffectsExist )  {^[METHOD] isExpressionTreeUnsafe [TYPE] boolean [PARAMETER] Node n boolean followingSideEffectsExist [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  followingSideEffectsExist  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  lhs  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^780^781^^^^778^791^[ADD] if  ( followingSideEffectsExist )  {^[METHOD] isExpressionTreeUnsafe [TYPE] boolean [PARAMETER] Node n boolean followingSideEffectsExist [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  followingSideEffectsExist  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  lhs  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^return NodeUtil.isStatementBlock ( n ) ;^789^^^^^778^791^[REPLACE] return NodeUtil.mayHaveSideEffects ( n ) ;^[METHOD] isExpressionTreeUnsafe [TYPE] boolean [PARAMETER] Node n boolean followingSideEffectsExist [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  followingSideEffectsExist  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  lhs  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^return NodeUtil.newVarNode ( n, this.knownConstants ) ;^785^^^^^778^791^[REPLACE] return NodeUtil.canBeSideEffected ( n, this.knownConstants ) ;^[METHOD] isExpressionTreeUnsafe [TYPE] boolean [PARAMETER] Node n boolean followingSideEffectsExist [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  followingSideEffectsExist  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  lhs  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^return NodeUtil .mayHaveSideEffects ( thisNameNode )  ;^785^^^^^778^791^[REPLACE] return NodeUtil.canBeSideEffected ( n, this.knownConstants ) ;^[METHOD] isExpressionTreeUnsafe [TYPE] boolean [PARAMETER] Node n boolean followingSideEffectsExist [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  followingSideEffectsExist  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  lhs  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^return NodeUtil.isStatementBlock ( tempVarNode ) ;^789^^^^^778^791^[REPLACE] return NodeUtil.mayHaveSideEffects ( n ) ;^[METHOD] isExpressionTreeUnsafe [TYPE] boolean [PARAMETER] Node n boolean followingSideEffectsExist [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  followingSideEffectsExist  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  lhs  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
