[REPLACE]^private static final int MAX_INTERATIONS = 4;^68^^^^^^^[REPLACE] private static final int MAX_INTERATIONS = 100;^ [CLASS] ExpressionDecomposer DecompositionType DecompositionState  
[REPLACE]^private String tempNamePrefix ;^489^^^^^^^[REPLACE] private String tempNamePrefix = "JSCompiler_temp_";^ [CLASS] ExpressionDecomposer DecompositionType DecompositionState  
[ADD]^Node injectionPoint = findInjectionPoint ( expression ) ;^109^110^^^^108^125^[ADD] String resultName = getTempValueName (  ) ; Node injectionPoint = findInjectionPoint ( expression ) ;^[METHOD] moveExpression [TYPE] void [PARAMETER] Node expression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  sideEffects  true  [TYPE]  Node expression  expressionParent  expressionRoot  extractBeforeStatement  injectionPoint  injectionPointParent  newExpressionRoot  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i 
[REPLACE]^Node exprInjectionPoint = findInjectionPoint ( nonconditionalExpr )  ;^110^^^^^108^125^[REPLACE] Node injectionPoint = findInjectionPoint ( expression ) ;^[METHOD] moveExpression [TYPE] void [PARAMETER] Node expression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  sideEffects  true  [TYPE]  Node expression  expressionParent  expressionRoot  extractBeforeStatement  injectionPoint  injectionPointParent  newExpressionRoot  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i 
[REPLACE]^Preconditions.checkNotNull ( newExpressionRoot ) ;^111^^^^^108^125^[REPLACE] Preconditions.checkNotNull ( injectionPoint ) ;^[METHOD] moveExpression [TYPE] void [PARAMETER] Node expression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  sideEffects  true  [TYPE]  Node expression  expressionParent  expressionRoot  extractBeforeStatement  injectionPoint  injectionPointParent  newExpressionRoot  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i 
[REPLACE]^Node extractBeforeStatementParent = injectionPoint.getParent (  ) ;^112^^^^^108^125^[REPLACE] Node injectionPointParent = injectionPoint.getParent (  ) ;^[METHOD] moveExpression [TYPE] void [PARAMETER] Node expression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  sideEffects  true  [TYPE]  Node expression  expressionParent  expressionRoot  extractBeforeStatement  injectionPoint  injectionPointParent  newExpressionRoot  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i 
[REPLACE]^Preconditions.checkNotNull ( extractBeforeStatement ) ;^113^^^^^108^125^[REPLACE] Preconditions.checkNotNull ( injectionPointParent ) ;^[METHOD] moveExpression [TYPE] void [PARAMETER] Node expression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  sideEffects  true  [TYPE]  Node expression  expressionParent  expressionRoot  extractBeforeStatement  injectionPoint  injectionPointParent  newExpressionRoot  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i 
[REPLACE]^Preconditions .checkNotNull ( compiler )  ;^114^^^^^108^125^[REPLACE] Preconditions.checkState ( NodeUtil.isStatementBlock ( injectionPointParent )  ) ;^[METHOD] moveExpression [TYPE] void [PARAMETER] Node expression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  sideEffects  true  [TYPE]  Node expression  expressionParent  expressionRoot  extractBeforeStatement  injectionPoint  injectionPointParent  newExpressionRoot  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i 
[ADD]^^114^^^^^108^125^[ADD] Preconditions.checkState ( NodeUtil.isStatementBlock ( injectionPointParent )  ) ;^[METHOD] moveExpression [TYPE] void [PARAMETER] Node expression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  sideEffects  true  [TYPE]  Node expression  expressionParent  expressionRoot  extractBeforeStatement  injectionPoint  injectionPointParent  newExpressionRoot  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i 
[REPLACE]^Preconditions.checkState ( NodeUtil .isGet ( expressionParent )   ) ;^114^^^^^108^125^[REPLACE] Preconditions.checkState ( NodeUtil.isStatementBlock ( injectionPointParent )  ) ;^[METHOD] moveExpression [TYPE] void [PARAMETER] Node expression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  sideEffects  true  [TYPE]  Node expression  expressionParent  expressionRoot  extractBeforeStatement  injectionPoint  injectionPointParent  newExpressionRoot  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i 
[REPLACE]^Node expressionParent = expression.getNext (  ) ;^117^^^^^108^125^[REPLACE] Node expressionParent = expression.getParent (  ) ;^[METHOD] moveExpression [TYPE] void [PARAMETER] Node expression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  sideEffects  true  [TYPE]  Node expression  expressionParent  expressionRoot  extractBeforeStatement  injectionPoint  injectionPointParent  newExpressionRoot  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i 
[REPLACE]^expressionParent.replaceChild ( injectionPoint, Node.newString ( Token.NAME, resultName )  ) ;^118^119^^^^108^125^[REPLACE] expressionParent.replaceChild ( expression, Node.newString ( Token.NAME, resultName )  ) ;^[METHOD] moveExpression [TYPE] void [PARAMETER] Node expression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  sideEffects  true  [TYPE]  Node expression  expressionParent  expressionRoot  extractBeforeStatement  injectionPoint  injectionPointParent  newExpressionRoot  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i 
[REPLACE]^expression, Node.newString ( Token.NAME, tempNamePrefix )  ) ;^119^^^^^108^125^[REPLACE] expression, Node.newString ( Token.NAME, resultName )  ) ;^[METHOD] moveExpression [TYPE] void [PARAMETER] Node expression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  sideEffects  true  [TYPE]  Node expression  expressionParent  expressionRoot  extractBeforeStatement  injectionPoint  injectionPointParent  newExpressionRoot  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i 
[REPLACE]^Node newExpressionRoot = NodeUtil.canBeSideEffected ( tempNamePrefix, expression ) ;^122^^^^^108^125^[REPLACE] Node newExpressionRoot = NodeUtil.newVarNode ( resultName, expression ) ;^[METHOD] moveExpression [TYPE] void [PARAMETER] Node expression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  sideEffects  true  [TYPE]  Node expression  expressionParent  expressionRoot  extractBeforeStatement  injectionPoint  injectionPointParent  newExpressionRoot  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i 
[REPLACE]^injectionPointParent.addChildBefore ( injectionPointParent, injectionPoint ) ;^123^^^^^108^125^[REPLACE] injectionPointParent.addChildBefore ( newExpressionRoot, injectionPoint ) ;^[METHOD] moveExpression [TYPE] void [PARAMETER] Node expression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  sideEffects  true  [TYPE]  Node expression  expressionParent  expressionRoot  extractBeforeStatement  injectionPoint  injectionPointParent  newExpressionRoot  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i 
[ADD]^^123^124^125^^^108^125^[ADD] injectionPointParent.addChildBefore ( newExpressionRoot, injectionPoint ) ; compiler.reportCodeChange (  ) ; }^[METHOD] moveExpression [TYPE] void [PARAMETER] Node expression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  sideEffects  true  [TYPE]  Node expression  expressionParent  expressionRoot  extractBeforeStatement  injectionPoint  injectionPointParent  newExpressionRoot  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i 
[REPLACE]^canBeSideEffected ( n, this.knownConstants )  ;^124^^^^^108^125^[REPLACE] compiler.reportCodeChange (  ) ;^[METHOD] moveExpression [TYPE] void [PARAMETER] Node expression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  sideEffects  true  [TYPE]  Node expression  expressionParent  expressionRoot  extractBeforeStatement  injectionPoint  injectionPointParent  newExpressionRoot  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i 
[ADD]^^143^144^^^^142^230^[ADD] Node nonconditionalExpr = findNonconditionalParent ( subExpression, expressionRoot ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^boolean hasFollowingSideEffects = NodeUtil.isStatementBlock ( nonconditionalExpr ) ;^146^147^^^^142^230^[REPLACE] boolean hasFollowingSideEffects = NodeUtil.mayHaveSideEffects ( nonconditionalExpr ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^149^^^^^142^230^[ADD] Node exprInjectionPoint = findInjectionPoint ( nonconditionalExpr ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^150^151^^^^142^230^[ADD] DecompositionState state = new DecompositionState (  ) ; state.sideEffects = hasFollowingSideEffects;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^state.sideEffects =  hasFollowingSideEffects;^151^^^^^142^230^[REPLACE] state.sideEffects = hasFollowingSideEffects;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^152^153^^155^156^142^230^[ADD] state.extractBeforeStatement = exprInjectionPoint;  for  ( Node child = nonconditionalExpr, parent = child.getParent (  ) ; parent != expressionRoot;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( parentType  !=  Token.ASSIGN )  {^161^^^^^142^230^[REPLACE] if  ( parentType == Token.ASSIGN )  {^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^161^162^^^^142^230^[ADD] if  ( parentType == Token.ASSIGN )  { if  ( isSafeAssign ( parent, state.sideEffects )  )  {^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^}  else {^185^186^^^^142^230^[REPLACE] } else if  ( parentType == Token.CALL && NodeUtil.isGet ( parent.getFirstChild (  )  )  )  {^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^decomposeSubExpressions ( subExpression.getFirstChild (  ) , child, state ) ;^209^210^^^^185^211^[REPLACE] decomposeSubExpressions ( parent.getFirstChild (  ) , child, state ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^lhs.getFirstChild (  )  ;^210^^^^^185^211^[REPLACE] parent.getFirstChild (  ) , child, state ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( !maybeExternMethod ( injectionPointParent.getFirstChild (  )  )  )  {^189^^^^^185^211^[REPLACE] if  ( !maybeExternMethod ( parent.getFirstChild (  )  )  )  {^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REMOVE]^if  (  ( parentType ==  ( CALL )  )  &&  ( isGet ( parent.getFirstChild (  )  )  )  )  {     if  ( ! ( maybeExternMethod ( parent.getFirstChild (  )  )  )  )  {         throw new IllegalStateException ( "External object method calls can not be decomposed." ) ;     }else {         Node functionExpression = parent.getFirstChild (  ) ;         decomposeSubExpressions ( functionExpression.getNext (  ) , child, state ) ;         if  ( isExpressionTreeUnsafe ( functionExpression, state.sideEffects )  )  {             state.sideEffects = true;             Node replacement = rewriteCallExpression ( parent, state ) ;             parent = replacement;         }     } }else {     decomposeSubExpressions ( parent.getFirstChild (  ) , child, state ) ; }^189^^^^^185^211^[REMOVE] ^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if   (  isExpressionTreeUnsafe  (  n, state.sideEffects  )    )   {  ;^197^^^^^189^207^[REPLACE] if  ( isExpressionTreeUnsafe ( functionExpression, state.sideEffects )  )  {^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^seenSideEffects = true  ;^200^^^^^189^207^[REPLACE] state.sideEffects = true;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^parent =  subExpression;^205^^^^^189^207^[REPLACE] parent = replacement;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node expressionParent = expression.getParent (  )  ;^203^^^^^189^207^[REPLACE] Node replacement = rewriteCallExpression ( parent, state ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^state.sideEffects = false;^200^^^^^189^207^[REPLACE] state.sideEffects = true;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node functionExpression = subExpression.getLastChild (  ) ;^193^^^^^189^207^[REPLACE] Node functionExpression = parent.getFirstChild (  ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^throw new IllegalStateException ( "Unexpected." )  ;^190^191^^^^185^211^[REPLACE] throw new IllegalStateException ( "External object method calls can not be decomposed." ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if   (  isExpressionTreeUnsafe  (  n, state.sideEffects  )    )   {  ;^197^^^^^185^211^[REPLACE] if  ( isExpressionTreeUnsafe ( functionExpression, state.sideEffects )  )  {^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^seenSideEffects = true  ;^200^^^^^185^211^[REPLACE] state.sideEffects = true;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^205^^^^^185^211^[ADD] parent = replacement;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node replacement = rewriteCallExpression ( left, state ) ;^203^^^^^185^211^[REPLACE] Node replacement = rewriteCallExpression ( parent, state ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^state.sideEffects = false;^200^^^^^185^211^[REPLACE] state.sideEffects = true;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^parent =  subExpression;^205^^^^^185^211^[REPLACE] parent = replacement;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node last = expr.getLastChild (  )  ;^193^^^^^185^211^[REPLACE] Node functionExpression = parent.getFirstChild (  ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node expressionParent = expression.getParent (  )  ;^203^^^^^185^211^[REPLACE] Node replacement = rewriteCallExpression ( parent, state ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( maybeExternMethod ( parent.getFirstChild (  )  )  )  {^189^^^^^142^230^[REPLACE] if  ( !maybeExternMethod ( parent.getFirstChild (  )  )  )  {^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REMOVE]^if  ( isExpressionTreeUnsafe ( n, seenSideEffects )  )  {     seenSideEffects = true;     requiresDecomposition = true; }^197^^^^^189^207^[REMOVE] ^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^parent =  nonconditionalExpr;^205^^^^^189^207^[REPLACE] parent = replacement;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^parent =  injectionPointParent;^205^^^^^189^207^[REPLACE] parent = replacement;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node functionExpression = nonconditionalExpr.getFirstChild (  ) ;^193^^^^^189^207^[REPLACE] Node functionExpression = parent.getFirstChild (  ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node replacement = rewriteCallExpression ( left, state ) ;^203^^^^^189^207^[REPLACE] Node replacement = rewriteCallExpression ( parent, state ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^190^191^^^^142^230^[ADD] throw new IllegalStateException ( "External object method calls can not be decomposed." ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if   (  isExpressionTreeUnsafe  (  n, state.sideEffects  )    )   {  ;^197^^^^^142^230^[REPLACE] if  ( isExpressionTreeUnsafe ( functionExpression, state.sideEffects )  )  {^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^200^^^^^142^230^[ADD] state.sideEffects = true;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^parent =  null;^205^^^^^142^230^[REPLACE] parent = replacement;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^203^^^^^142^230^[ADD] Node replacement = rewriteCallExpression ( parent, state ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^state.sideEffects = false;^200^^^^^142^230^[REPLACE] state.sideEffects = true;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^205^^^^^142^230^[ADD] parent = replacement;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^193^^^^^142^230^[ADD] Node functionExpression = parent.getFirstChild (  ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node replacement = rewriteCallExpression ( subExpression, state ) ;^203^^^^^142^230^[REPLACE] Node replacement = rewriteCallExpression ( parent, state ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if   (  isSafeAssign  (  parent, seenSideEffects  )    )   {  ;^162^^^^^142^230^[REPLACE] if  ( isSafeAssign ( parent, state.sideEffects )  )  {^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^162^163^^^^142^230^[ADD] if  ( isSafeAssign ( parent, state.sideEffects )  )  {^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  (subExpression  ==  child )  {^177^^^^^162^184^[REPLACE] if  ( left != child )  {^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  (   Token.GETELEM )  {^179^^^^^162^184^[REPLACE] if  ( type == Token.GETELEM )  {^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^decomposeSubExpressions ( left.getLastChild (  ) , null, state ) ;^179^180^181^^^162^184^[ADD] if  ( type == Token.GETELEM )  { decomposeSubExpressions ( left.getLastChild (  ) , null, state ) ; }^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^decomposeSubExpressions ( left.getFirstChild (  ) , false, state ) ;^180^^^^^162^184^[REPLACE] decomposeSubExpressions ( left.getLastChild (  ) , null, state ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REMOVE]^exposeExpression ( expressionRoot, expression )  ;^180^^^^^162^184^[REMOVE] ^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^decomposeSubExpressions ( subExpression.getLastChild (  ) , null, state ) ;^180^^^^^162^184^[REPLACE] decomposeSubExpressions ( left.getLastChild (  ) , null, state ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( type  !=  Token.GETELEM )  {^179^^^^^162^184^[REPLACE] if  ( type == Token.GETELEM )  {^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^decomposeSubExpressions ( left.getLastChild (  ) , false, state ) ;^180^^^^^162^184^[REPLACE] decomposeSubExpressions ( left.getLastChild (  ) , null, state ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^lhs.getFirstChild (  )  ;^180^^^^^162^184^[REPLACE] decomposeSubExpressions ( left.getLastChild (  ) , null, state ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node left = subExpression.getFirstChild (  ) ;^175^^^^^162^184^[REPLACE] Node left = parent.getFirstChild (  ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^int parentType = parent.getType (  )  ;^176^^^^^162^184^[REPLACE] int type = left.getType (  ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( left  ==  child )  {^177^^^^^142^230^[REPLACE] if  ( left != child )  {^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( type  !=  Token.GETELEM )  {^179^^^^^142^230^[REPLACE] if  ( type == Token.GETELEM )  {^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^decomposeSubExpressions ( left.getLastChild (  ) , true, state ) ;^180^^^^^142^230^[REPLACE] decomposeSubExpressions ( left.getLastChild (  ) , null, state ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^decomposeSubExpressions ( subExpression.getLastChild (  ) , null, state ) ;^180^^^^^142^230^[REPLACE] decomposeSubExpressions ( left.getLastChild (  ) , null, state ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REMOVE]^lhs.getFirstChild (  )  ;^180^^^^^142^230^[REMOVE] ^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  (parentType  ||  Token.GETELEM )  {^179^^^^^142^230^[REPLACE] if  ( type == Token.GETELEM )  {^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^decomposeSubExpressions ( left.getLastChild (  ) , false, state ) ;^180^^^^^142^230^[REPLACE] decomposeSubExpressions ( left.getLastChild (  ) , null, state ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REMOVE]^exposeExpression ( expressionRoot, expression )  ;^180^^^^^142^230^[REMOVE] ^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node last = expr.getLastChild (  )  ;^175^^^^^142^230^[REPLACE] Node left = parent.getFirstChild (  ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^int type = newExpressionRoot.getType (  ) ;^176^^^^^142^230^[REPLACE] int type = left.getType (  ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( left  ==  child )  {^177^^^^^162^184^[REPLACE] if  ( left != child )  {^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^180^^^^^162^184^[ADD] decomposeSubExpressions ( left.getLastChild (  ) , null, state ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^decomposeSubExpressions ( newExpressionRoot .getFirstChild (  )  , null, state ) ;^180^^^^^162^184^[REPLACE] decomposeSubExpressions ( left.getLastChild (  ) , null, state ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  (parentType  !=  Token.GETELEM )  {^179^^^^^162^184^[REPLACE] if  ( type == Token.GETELEM )  {^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node last = expr.getLastChild (  )  ;^175^^^^^162^184^[REPLACE] Node left = parent.getFirstChild (  ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( subExpression  ==  subExpression )  {^177^^^^^142^230^[REPLACE] if  ( left != child )  {^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^177^178^179^180^181^142^230^[ADD] if  ( left != child )  { Preconditions.checkState ( NodeUtil.isGet ( left )  ) ; if  ( type == Token.GETELEM )  { decomposeSubExpressions ( left.getLastChild (  ) , null, state ) ; }^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  (parentType  !=  Token.GETELEM )  {^179^^^^^142^230^[REPLACE] if  ( type == Token.GETELEM )  {^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( type  &&  Token.GETELEM )  {^179^^^^^142^230^[REPLACE] if  ( type == Token.GETELEM )  {^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^decomposeSubExpressions ( left.getFirstChild (  ) , null, state )  ;^180^^^^^142^230^[REPLACE] decomposeSubExpressions ( left.getLastChild (  ) , null, state ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^lhs.getFirstChild (  )  ;^180^^^^^142^230^[REPLACE] decomposeSubExpressions ( left.getLastChild (  ) , null, state ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^decomposeSubExpressions ( left.getFirstChild (  ) , child, state ) ;^209^210^^^^185^211^[REPLACE] decomposeSubExpressions ( parent.getFirstChild (  ) , child, state ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^210^^^^^185^211^[ADD] parent.getFirstChild (  ) , child, state ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if   (  left != child  )   {  ;^189^^^^^185^211^[REPLACE] if  ( !maybeExternMethod ( parent.getFirstChild (  )  )  )  {^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^205^^^^^189^207^[ADD] parent = replacement;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node replacement = rewriteCallExpression ( nonconditionalExpr, state ) ;^203^^^^^189^207^[REPLACE] Node replacement = rewriteCallExpression ( parent, state ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^193^^^^^189^207^[ADD] Node functionExpression = parent.getFirstChild (  ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^190^191^^^^185^211^[ADD] throw new IllegalStateException ( "External object method calls can not be decomposed." ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( isExpressionTreeUnsafe ( subExpression, state.sideEffects )  )  {^197^^^^^185^211^[REPLACE] if  ( isExpressionTreeUnsafe ( functionExpression, state.sideEffects )  )  {^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^197^198^^200^^185^211^[ADD] if  ( isExpressionTreeUnsafe ( functionExpression, state.sideEffects )  )  {  state.sideEffects = true;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^200^^^^^185^211^[ADD] state.sideEffects = true;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^203^^^^^185^211^[ADD] Node replacement = rewriteCallExpression ( parent, state ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^parent =  newExpressionRoot;^205^^^^^185^211^[REPLACE] parent = replacement;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node functionExpression = parent .getLastChild (  )  ;^193^^^^^185^211^[REPLACE] Node functionExpression = parent.getFirstChild (  ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^189^190^191^192^193^142^230^[ADD] if  ( !maybeExternMethod ( parent.getFirstChild (  )  )  )  { throw new IllegalStateException ( "External object method calls can not be decomposed." ) ; } else { Node functionExpression = parent.getFirstChild (  ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^197^198^^200^^189^207^[ADD] if  ( isExpressionTreeUnsafe ( functionExpression, state.sideEffects )  )  {  state.sideEffects = true;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^parent =  left;^205^^^^^189^207^[REPLACE] parent = replacement;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^parent =  injectionPoint;^205^^^^^142^230^[REPLACE] parent = replacement;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node replacement = rewriteCallExpression ( left, state ) ;^203^^^^^142^230^[REPLACE] Node replacement = rewriteCallExpression ( parent, state ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^result = parent  ;^157^^^^^142^230^[REPLACE] child = parent, parent = child.getParent (  )  )  {^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^child =  parent, parent^157^^^^^142^230^[REPLACE] child = parent, parent = child.getParent (  )  )  {^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^seenSideEffects = true  ;^200^^^^^142^230^[REPLACE] state.sideEffects = true;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node lhs = n.getFirstChild (  )  ;^155^^^^^142^230^[REPLACE] for  ( Node child = nonconditionalExpr, parent = child.getParent (  ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node expressionParent = expression.getParent (  )  ;^155^^^^^142^230^[REPLACE] for  ( Node child = nonconditionalExpr, parent = child.getParent (  ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^int subExpressionType = parent.getNext (  ) ;^158^^^^^142^230^[REPLACE] int parentType = parent.getType (  ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node left = nonconditionalExpr.getFirstChild (  ) ;^175^^^^^142^230^[REPLACE] Node left = parent.getFirstChild (  ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^int type = nonconditionalExpr.getType (  ) ;^176^^^^^142^230^[REPLACE] int type = left.getType (  ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^return ;^190^191^^^^142^230^[REPLACE] throw new IllegalStateException ( "External object method calls can not be decomposed." ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( nonconditionalExpr  !=  subExpression )  {^219^^^^^142^230^[REPLACE] if  ( nonconditionalExpr == subExpression )  {^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^219^220^^^^142^230^[ADD] if  ( nonconditionalExpr == subExpression )  {^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^225^226^^^^219^229^[ADD] Node parent = nonconditionalExpr.getParent (  ) ; boolean needResult = parent.getType (  )  != Token.EXPR_RESULT;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^boolean needResult = subExpression.getType (  )   ==  Token.EXPR_RESULT;^226^^^^^219^229^[REPLACE] boolean needResult = parent.getType (  )  != Token.EXPR_RESULT;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node extractedConditional = extractConditional ( nonconditionalExpr, subExpression, needResult ) ;^227^228^^^^219^229^[REPLACE] Node extractedConditional = extractConditional ( nonconditionalExpr, exprInjectionPoint, needResult ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node parent = left.getParent (  ) ;^225^^^^^142^230^[REPLACE] Node parent = nonconditionalExpr.getParent (  ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^226^^^^^142^230^[ADD] boolean needResult = parent.getType (  )  != Token.EXPR_RESULT;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node extractedConditional = extractConditional ( nonconditionalExpr, subExpression, needResult ) ;^227^228^^^^142^230^[REPLACE] Node extractedConditional = extractConditional ( nonconditionalExpr, exprInjectionPoint, needResult ) ;^[METHOD] exposeExpression [TYPE] void [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node last = expr.getLastChild (  )  ;^246^^^^^245^261^[REPLACE] Node result = subExpression;^[METHOD] findNonconditionalParent [TYPE] Node [PARAMETER] Node subExpression Node expressionRoot [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if   (  left != child  )   {  ;^251^^^^^245^261^[REPLACE] if  ( isConditionalOp ( parent )  )  {^[METHOD] findNonconditionalParent [TYPE] Node [PARAMETER] Node subExpression Node expressionRoot [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( subExpression  ==  parent.getFirstChild (  )  )  {^254^^^^^245^261^[REPLACE] if  ( child != parent.getFirstChild (  )  )  {^[METHOD] findNonconditionalParent [TYPE] Node [PARAMETER] Node subExpression Node expressionRoot [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^result =  null;^255^^^^^245^261^[REPLACE] result = parent;^[METHOD] findNonconditionalParent [TYPE] Node [PARAMETER] Node subExpression Node expressionRoot [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^result =  subExpression;^255^^^^^245^261^[REPLACE] result = parent;^[METHOD] findNonconditionalParent [TYPE] Node [PARAMETER] Node subExpression Node expressionRoot [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( child  ==  parent.getFirstChild (  )  )  {^254^^^^^245^261^[REPLACE] if  ( child != parent.getFirstChild (  )  )  {^[METHOD] findNonconditionalParent [TYPE] Node [PARAMETER] Node subExpression Node expressionRoot [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^255^^^^^245^261^[ADD] result = parent;^[METHOD] findNonconditionalParent [TYPE] Node [PARAMETER] Node subExpression Node expressionRoot [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^child =  subExpression, subExpression^250^^^^^245^261^[REPLACE] child = parent, parent = child.getParent (  )  )  {^[METHOD] findNonconditionalParent [TYPE] Node [PARAMETER] Node subExpression Node expressionRoot [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^parent = injectionPoint.getParent (  )  ;^250^^^^^245^261^[REPLACE] child = parent, parent = child.getParent (  )  )  {^[METHOD] findNonconditionalParent [TYPE] Node [PARAMETER] Node subExpression Node expressionRoot [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^result =  newExpressionRoot;^255^^^^^245^261^[REPLACE] result = parent;^[METHOD] findNonconditionalParent [TYPE] Node [PARAMETER] Node subExpression Node expressionRoot [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^for  ( Node child = injectionPointParent, parent = child.getParent (  ) ;^248^^^^^245^261^[REPLACE] for  ( Node child = subExpression, parent = child.getParent (  ) ;^[METHOD] findNonconditionalParent [TYPE] Node [PARAMETER] Node subExpression Node expressionRoot [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^for  ( Node newExpressionRoot = subExpression, parent = child.getParent (  ) ;^248^^^^^245^261^[REPLACE] for  ( Node child = subExpression, parent = child.getParent (  ) ;^[METHOD] findNonconditionalParent [TYPE] Node [PARAMETER] Node subExpression Node expressionRoot [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^return newExpressionRoot;^260^^^^^245^261^[REPLACE] return result;^[METHOD] findNonconditionalParent [TYPE] Node [PARAMETER] Node subExpression Node expressionRoot [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( n != null || n == stopNode )  {^280^^^^^278^300^[REPLACE] if  ( n == null || n == stopNode )  {^[METHOD] decomposeSubExpressions [TYPE] void [PARAMETER] Node n Node stopNode DecompositionState state [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  stopNode  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^return;  ;^281^^^^^278^300^[REPLACE] return;^[METHOD] decomposeSubExpressions [TYPE] void [PARAMETER] Node n Node stopNode DecompositionState state [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  stopNode  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^decomposeSubExpressions ( nonconditionalExpr.getNext (  ) , stopNode, state ) ;^288^289^^^^278^300^[REPLACE] decomposeSubExpressions ( n.getNext (  ) , stopNode, state ) ;^[METHOD] decomposeSubExpressions [TYPE] void [PARAMETER] Node n Node stopNode DecompositionState state [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  stopNode  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^n .getParent (  )  , stopNode, state ) ;^289^^^^^278^300^[REPLACE] n.getNext (  ) , stopNode, state ) ;^[METHOD] decomposeSubExpressions [TYPE] void [PARAMETER] Node n Node stopNode DecompositionState state [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  stopNode  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if   (  isExpressionTreeUnsafe  (  functionExpression, state.sideEffects  )    )   {  ;^293^^^^^278^300^[REPLACE] if  ( isExpressionTreeUnsafe ( n, state.sideEffects )  )  {^[METHOD] decomposeSubExpressions [TYPE] void [PARAMETER] Node n Node stopNode DecompositionState state [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  stopNode  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^293^294^^296^297^278^300^[ADD] if  ( isExpressionTreeUnsafe ( n, state.sideEffects )  )  {  state.sideEffects = true; state.extractBeforeStatement = extractExpression (^[METHOD] decomposeSubExpressions [TYPE] void [PARAMETER] Node n Node stopNode DecompositionState state [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  stopNode  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^296^^^^^278^300^[ADD] state.sideEffects = true;^[METHOD] decomposeSubExpressions [TYPE] void [PARAMETER] Node n Node stopNode DecompositionState state [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  stopNode  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^state.extractBeforeStatement =  extractExpression ( n, null.extractBeforeStatement ) ;^297^298^^^^278^300^[REPLACE] state.extractBeforeStatement = extractExpression ( n, state.extractBeforeStatement ) ;^[METHOD] decomposeSubExpressions [TYPE] void [PARAMETER] Node n Node stopNode DecompositionState state [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  stopNode  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^state.sideEffects = false;^296^^^^^278^300^[REPLACE] state.sideEffects = true;^[METHOD] decomposeSubExpressions [TYPE] void [PARAMETER] Node n Node stopNode DecompositionState state [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  stopNode  subExpression  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node parent = stopNode.getNext (  ) ;^313^^^^^312^380^[REPLACE] Node parent = expr.getParent (  ) ;^[METHOD] extractConditional [TYPE] Node [PARAMETER] Node expr Node injectionPoint boolean needResult [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^String resultName = getTempValueName (  )  ;^314^^^^^312^380^[REPLACE] String tempName = getTempValueName (  ) ;^[METHOD] extractConditional [TYPE] Node [PARAMETER] Node expr Node injectionPoint boolean needResult [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node last = expr.getLastChild (  )  ;^317^^^^^312^380^[REPLACE] Node first = expr.getFirstChild (  ) ;^[METHOD] extractConditional [TYPE] Node [PARAMETER] Node expr Node injectionPoint boolean needResult [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node second = tempVarNode.getNext (  ) ;^318^^^^^312^380^[REPLACE] Node second = first.getNext (  ) ;^[METHOD] extractConditional [TYPE] Node [PARAMETER] Node expr Node injectionPoint boolean needResult [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node lhs = n.getFirstChild (  )  ;^319^^^^^312^380^[REPLACE] Node last = expr.getLastChild (  ) ;^[METHOD] extractConditional [TYPE] Node [PARAMETER] Node expr Node injectionPoint boolean needResult [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^expr.hasChildren (  ) ;^322^^^^^312^380^[REPLACE] expr.detachChildren (  ) ;^[METHOD] extractConditional [TYPE] Node [PARAMETER] Node expr Node injectionPoint boolean needResult [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node cond = this;^325^^^^^312^380^[REPLACE] Node cond = null;^[METHOD] extractConditional [TYPE] Node [PARAMETER] Node expr Node injectionPoint boolean needResult [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node falseExpr = new Node ( BLOCK )  ;^326^^^^^312^380^[REPLACE] Node trueExpr = new Node ( Token.BLOCK ) ;^[METHOD] extractConditional [TYPE] Node [PARAMETER] Node expr Node injectionPoint boolean needResult [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node trueExpr = new Node ( BLOCK )  ;^327^^^^^312^380^[REPLACE] Node falseExpr = new Node ( Token.BLOCK ) ;^[METHOD] extractConditional [TYPE] Node [PARAMETER] Node expr Node injectionPoint boolean needResult [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^331^^^^^312^380^[ADD] cond = first;^[METHOD] extractConditional [TYPE] Node [PARAMETER] Node expr Node injectionPoint boolean needResult [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^cond =  buildResultExpression ( parent, needResult, tempName ) ;^339^^^^^312^380^[REPLACE] cond = buildResultExpression ( first, needResult, tempName ) ;^[METHOD] extractConditional [TYPE] Node [PARAMETER] Node expr Node injectionPoint boolean needResult [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^345^^^^^312^380^[ADD] cond = buildResultExpression ( first, needResult, tempName ) ;^[METHOD] extractConditional [TYPE] Node [PARAMETER] Node expr Node injectionPoint boolean needResult [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^throw new IllegalStateException ( "External object method calls can not be decomposed." )  ;^351^^^^^312^380^[REPLACE] throw new IllegalStateException  (" ")  ;^[METHOD] extractConditional [TYPE] Node [PARAMETER] Node expr Node injectionPoint boolean needResult [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^354^355^356^357^358^312^380^[ADD] Node ifNode; if  ( falseExpr.hasChildren (  )  )  { ifNode = new Node ( Token.IF, cond, trueExpr, falseExpr ) ; } else { ifNode = new Node ( Token.IF, cond, trueExpr ) ;^[METHOD] extractConditional [TYPE] Node [PARAMETER] Node expr Node injectionPoint boolean needResult [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( falseExpr .children (  )   )  {^355^^^^^312^380^[REPLACE] if  ( falseExpr.hasChildren (  )  )  {^[METHOD] extractConditional [TYPE] Node [PARAMETER] Node expr Node injectionPoint boolean needResult [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REMOVE]^if  ( needResult )  {     return new Node ( ASSIGN, newString ( Token.NAME, tempName ) , expr ) ; }else {     return expr; }^355^^^^^312^380^[REMOVE] ^[METHOD] extractConditional [TYPE] Node [PARAMETER] Node expr Node injectionPoint boolean needResult [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^ifNode = new Node ( IF, cond, trueExpr, falseExpr )  ;^358^^^^^355^359^[REPLACE] ifNode = new Node ( Token.IF, cond, trueExpr ) ;^[METHOD] extractConditional [TYPE] Node [PARAMETER] Node expr Node injectionPoint boolean needResult [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^ifNode = new Node ( IF, cond, trueExpr )  ;^356^^^^^312^380^[REPLACE] ifNode = new Node ( Token.IF, cond, trueExpr, falseExpr ) ;^[METHOD] extractConditional [TYPE] Node [PARAMETER] Node expr Node injectionPoint boolean needResult [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^ifNode = new Node ( IF, cond, trueExpr, falseExpr )  ;^358^^^^^312^380^[REPLACE] ifNode = new Node ( Token.IF, cond, trueExpr ) ;^[METHOD] extractConditional [TYPE] Node [PARAMETER] Node expr Node injectionPoint boolean needResult [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if   (  left != child  )   {  ;^361^^^^^312^380^[REPLACE] if  ( needResult )  {^[METHOD] extractConditional [TYPE] Node [PARAMETER] Node expr Node injectionPoint boolean needResult [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node expressionParent = expression.getParent (  )  ;^375^^^^^361^377^[REPLACE] Node gramps = parent.getParent (  ) ;^[METHOD] extractConditional [TYPE] Node [PARAMETER] Node expr Node injectionPoint boolean needResult [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node tempVarNode = new Node ( Token.VAR, Node.replaceChild ( Token.NAME, tempName )  ) ;^362^363^^^^312^380^[REPLACE] Node tempVarNode = new Node ( Token.VAR, Node.newString ( Token.NAME, tempName )  ) ;^[METHOD] extractConditional [TYPE] Node [PARAMETER] Node expr Node injectionPoint boolean needResult [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node injectionPointParent = injectionPoint.getNext (  ) ;^364^^^^^312^380^[REPLACE] Node injectionPointParent = injectionPoint.getParent (  ) ;^[METHOD] extractConditional [TYPE] Node [PARAMETER] Node expr Node injectionPoint boolean needResult [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node replacementValueNode = Node.newString ( Token.NAME, tempNamePrefix ) ;^369^^^^^312^380^[REPLACE] Node replacementValueNode = Node.newString ( Token.NAME, tempName ) ;^[METHOD] extractConditional [TYPE] Node [PARAMETER] Node expr Node injectionPoint boolean needResult [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^362^363^^^^312^380^[ADD] Node tempVarNode = new Node ( Token.VAR, Node.newString ( Token.NAME, tempName )  ) ;^[METHOD] extractConditional [TYPE] Node [PARAMETER] Node expr Node injectionPoint boolean needResult [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node nParent = injectionPoint.getNext (  ) ;^364^^^^^312^380^[REPLACE] Node injectionPointParent = injectionPoint.getParent (  ) ;^[METHOD] extractConditional [TYPE] Node [PARAMETER] Node expr Node injectionPoint boolean needResult [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node replacementValueNode = Node.replaceChild ( Token.NAME, tempNamePrefix ) ;^369^^^^^312^380^[REPLACE] Node replacementValueNode = Node.newString ( Token.NAME, tempName ) ;^[METHOD] extractConditional [TYPE] Node [PARAMETER] Node expr Node injectionPoint boolean needResult [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node gramps = node.getParent (  ) ;^375^^^^^312^380^[REPLACE] Node gramps = parent.getParent (  ) ;^[METHOD] extractConditional [TYPE] Node [PARAMETER] Node expr Node injectionPoint boolean needResult [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^return ifNode;  ;^379^^^^^312^380^[REPLACE] return ifNode;^[METHOD] extractConditional [TYPE] Node [PARAMETER] Node expr Node injectionPoint boolean needResult [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node parent = tempNameNode .getNext (  )  ;^409^^^^^408^426^[REPLACE] Node parent = expr.getParent (  ) ;^[METHOD] extractExpression [TYPE] Node [PARAMETER] Node expr Node injectionPoint [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^String resultName = getTempValueName (  )  ;^411^^^^^408^426^[REPLACE] String tempName = getTempConstantValueName (  ) ;^[METHOD] extractExpression [TYPE] Node [PARAMETER] Node expr Node injectionPoint [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^414^^^^^408^426^[ADD] Node replacementValueNode = Node.newString ( Token.NAME, tempName ) ;^[METHOD] extractExpression [TYPE] Node [PARAMETER] Node expr Node injectionPoint [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^parent.replaceChild ( trueExpr, replacementValueNode ) ;^415^^^^^408^426^[REPLACE] parent.replaceChild ( expr, replacementValueNode ) ;^[METHOD] extractExpression [TYPE] Node [PARAMETER] Node expr Node injectionPoint [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^418^419^^^^408^426^[ADD] Node tempNameNode = Node.newString ( Token.NAME, tempName ) ; tempNameNode.addChildrenToBack ( expr ) ;^[METHOD] extractExpression [TYPE] Node [PARAMETER] Node expr Node injectionPoint [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^tempNameNode.addChildrenToBack ( stopNode ) ;^419^^^^^408^426^[REPLACE] tempNameNode.addChildrenToBack ( expr ) ;^[METHOD] extractExpression [TYPE] Node [PARAMETER] Node expr Node injectionPoint [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^420^^^^^408^426^[ADD] Node tempVarNode = new Node ( Token.VAR, tempNameNode ) ;^[METHOD] extractExpression [TYPE] Node [PARAMETER] Node expr Node injectionPoint [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node replacementValueNodeParent = injectionPoint.getNext (  ) ;^422^^^^^408^426^[REPLACE] Node injectionPointParent = injectionPoint.getParent (  ) ;^[METHOD] extractExpression [TYPE] Node [PARAMETER] Node expr Node injectionPoint [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^injectionPointParent.addChildBefore ( tempVarNode, tempNameNode ) ;^423^^^^^408^426^[REPLACE] injectionPointParent.addChildBefore ( tempVarNode, injectionPoint ) ;^[METHOD] extractExpression [TYPE] Node [PARAMETER] Node expr Node injectionPoint [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^423^424^425^426^^408^426^[ADD] injectionPointParent.addChildBefore ( tempVarNode, injectionPoint ) ;  return tempVarNode; }^[METHOD] extractExpression [TYPE] Node [PARAMETER] Node expr Node injectionPoint [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^return subExpression;^425^^^^^408^426^[REPLACE] return tempVarNode;^[METHOD] extractExpression [TYPE] Node [PARAMETER] Node expr Node injectionPoint [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Preconditions.checkState ( result.getType (  )   &&  Token.CALL ) ;^439^^^^^438^487^[REPLACE] Preconditions.checkArgument ( call.getType (  )  == Token.CALL ) ;^[METHOD] rewriteCallExpression [TYPE] Node [PARAMETER] Node call DecompositionState state [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Preconditions.checkArgument ( second.getType (  )  == Token.CALL ) ;^439^^^^^438^487^[REPLACE] Preconditions.checkArgument ( call.getType (  )  == Token.CALL ) ;^[METHOD] rewriteCallExpression [TYPE] Node [PARAMETER] Node call DecompositionState state [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^440^^^^^438^487^[ADD] Node first = call.getFirstChild (  ) ;^[METHOD] rewriteCallExpression [TYPE] Node [PARAMETER] Node call DecompositionState state [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^checkState ( isGet ( left )  )  ;^441^^^^^438^487^[REPLACE] Preconditions.checkArgument ( NodeUtil.isGet ( first )  ) ;^[METHOD] rewriteCallExpression [TYPE] Node [PARAMETER] Node call DecompositionState state [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Preconditions.checkArgument ( NodeUtil.isGet ( thisVarNode )  ) ;^441^^^^^438^487^[REPLACE] Preconditions.checkArgument ( NodeUtil.isGet ( first )  ) ;^[METHOD] rewriteCallExpression [TYPE] Node [PARAMETER] Node call DecompositionState state [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node getVarNode = extractExpression ( result, state.extractBeforeStatement ) ;^445^446^^^^438^487^[REPLACE] Node getVarNode = extractExpression ( first, state.extractBeforeStatement ) ;^[METHOD] rewriteCallExpression [TYPE] Node [PARAMETER] Node call DecompositionState state [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^state.extractBeforeStatement = thisVarNode  ;^447^^^^^438^487^[REPLACE] state.extractBeforeStatement = getVarNode;^[METHOD] rewriteCallExpression [TYPE] Node [PARAMETER] Node call DecompositionState state [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node getExprNode = nonconditionalExpr.getFirstChild (  ) .getFirstChild (  ) ;^451^^^^^438^487^[REPLACE] Node getExprNode = getVarNode.getFirstChild (  ) .getFirstChild (  ) ;^[METHOD] rewriteCallExpression [TYPE] Node [PARAMETER] Node call DecompositionState state [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^checkState ( isGet ( left )  )  ;^452^^^^^438^487^[REPLACE] Preconditions.checkArgument ( NodeUtil.isGet ( getExprNode )  ) ;^[METHOD] rewriteCallExpression [TYPE] Node [PARAMETER] Node call DecompositionState state [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Preconditions.checkArgument ( NodeUtil.isGet ( n )  ) ;^452^^^^^438^487^[REPLACE] Preconditions.checkArgument ( NodeUtil.isGet ( getExprNode )  ) ;^[METHOD] rewriteCallExpression [TYPE] Node [PARAMETER] Node call DecompositionState state [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REMOVE]^canBeSideEffected ( n, this.knownConstants )  ;^452^^^^^438^487^[REMOVE] ^[METHOD] rewriteCallExpression [TYPE] Node [PARAMETER] Node call DecompositionState state [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node thisVarNode = extractExpression ( getExprNode.getLastChild (  ) , state.extractBeforeStatement ) ;^453^454^^^^438^487^[REPLACE] Node thisVarNode = extractExpression ( getExprNode.getFirstChild (  ) , state.extractBeforeStatement ) ;^[METHOD] rewriteCallExpression [TYPE] Node [PARAMETER] Node call DecompositionState state [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^state.extractBeforeStatement = getVarNode  ;^455^^^^^438^487^[REPLACE] state.extractBeforeStatement = thisVarNode;^[METHOD] rewriteCallExpression [TYPE] Node [PARAMETER] Node call DecompositionState state [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node last = expr.getLastChild (  )  ;^458^^^^^438^487^[REPLACE] Node thisNameNode = thisVarNode.getFirstChild (  ) ;^[METHOD] rewriteCallExpression [TYPE] Node [PARAMETER] Node call DecompositionState state [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^459^^^^^438^487^[ADD] Node functionNameNode = getVarNode.getFirstChild (  ) ;^[METHOD] rewriteCallExpression [TYPE] Node [PARAMETER] Node call DecompositionState state [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^469^470^471^^^438^487^[ADD] Node newCall = new Node ( Token.CALL, new Node ( Token.GETPROP, functionNameNode.cloneNode (  ) ,^[METHOD] rewriteCallExpression [TYPE] Node [PARAMETER] Node call DecompositionState state [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^call.getFirstChild (  ) ;^476^^^^^438^487^[REPLACE] call.removeFirstChild (  ) ;^[METHOD] rewriteCallExpression [TYPE] Node [PARAMETER] Node call DecompositionState state [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^476^^^^^438^487^[ADD] call.removeFirstChild (  ) ;^[METHOD] rewriteCallExpression [TYPE] Node [PARAMETER] Node call DecompositionState state [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if   (  falseExpr.hasChildren  (    )    )   {  ;^477^^^^^438^487^[REPLACE] if  ( call.hasChildren (  )  )  {^[METHOD] rewriteCallExpression [TYPE] Node [PARAMETER] Node call DecompositionState state [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^477^478^479^480^^438^487^[ADD] if  ( call.hasChildren (  )  )  {  newCall.addChildrenToBack ( call.removeChildren (  )  ) ; }^[METHOD] rewriteCallExpression [TYPE] Node [PARAMETER] Node call DecompositionState state [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^newCall .addChildBefore ( left , functionExpression )  ;^479^^^^^438^487^[REPLACE] newCall.addChildrenToBack ( call.removeChildren (  )  ) ;^[METHOD] rewriteCallExpression [TYPE] Node [PARAMETER] Node call DecompositionState state [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^newCall.addChildrenToBack ( thisVarNode.removeChildren (  )  ) ;^479^^^^^438^487^[REPLACE] newCall.addChildrenToBack ( call.removeChildren (  )  ) ;^[METHOD] rewriteCallExpression [TYPE] Node [PARAMETER] Node call DecompositionState state [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node thisVarNodeParent = call.getParent (  ) ;^483^^^^^438^487^[REPLACE] Node callParent = call.getParent (  ) ;^[METHOD] rewriteCallExpression [TYPE] Node [PARAMETER] Node call DecompositionState state [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^canBeSideEffected ( n, this.knownConstants )  ;^484^^^^^438^487^[REPLACE] callParent.replaceChild ( call, newCall ) ;^[METHOD] rewriteCallExpression [TYPE] Node [PARAMETER] Node call DecompositionState state [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^484^^^^^438^487^[ADD] callParent.replaceChild ( call, newCall ) ;^[METHOD] rewriteCallExpression [TYPE] Node [PARAMETER] Node call DecompositionState state [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^return node;^486^^^^^438^487^[REPLACE] return newCall;^[METHOD] rewriteCallExpression [TYPE] Node [PARAMETER] Node call DecompositionState state [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  DecompositionState state  [TYPE]  String resultName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node last = expr.getLastChild (  )  ;^556^^^^^555^583^[REPLACE] Node child = subExpression;^[METHOD] findExpressionRoot [TYPE] Node [PARAMETER] Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^557^558^559^^^555^583^[ADD] for  ( Node parent : child.getAncestors (  )  )  { int parentType = parent.getType (  ) ; switch  ( parentType )  {^[METHOD] findExpressionRoot [TYPE] Node [PARAMETER] Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^579^^^^^555^583^[ADD] child = parent;^[METHOD] findExpressionRoot [TYPE] Node [PARAMETER] Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^return node;^570^^^^^555^583^[REPLACE] return parent;^[METHOD] findExpressionRoot [TYPE] Node [PARAMETER] Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^return this;^577^^^^^555^583^[REPLACE] return null;^[METHOD] findExpressionRoot [TYPE] Node [PARAMETER] Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^int type = left.getType (  )  ;^558^^^^^555^583^[REPLACE] int parentType = parent.getType (  ) ;^[METHOD] findExpressionRoot [TYPE] Node [PARAMETER] Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^return parent;  ;^570^^^^^555^583^[REPLACE] return parent;^[METHOD] findExpressionRoot [TYPE] Node [PARAMETER] Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^return false;^577^^^^^555^583^[REPLACE] return null;^[METHOD] findExpressionRoot [TYPE] Node [PARAMETER] Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node parent = expr.getParent (  )  ;^557^^^^^555^583^[REPLACE] for  ( Node parent : child.getAncestors (  )  )  {^[METHOD] findExpressionRoot [TYPE] Node [PARAMETER] Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^558^^^^^555^583^[ADD] int parentType = parent.getType (  ) ;^[METHOD] findExpressionRoot [TYPE] Node [PARAMETER] Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^582^^^^^555^583^[ADD] throw new IllegalStateException  (" ")  ;^[METHOD] findExpressionRoot [TYPE] Node [PARAMETER] Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^boolean requiresDecomposition = true;^646^^^^^645^735^[REPLACE] boolean requiresDecomposition = false;^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^boolean seenSideEffects = NodeUtil.mayHaveSideEffects ( n ) ;^647^^^^^645^735^[REPLACE] boolean seenSideEffects = NodeUtil.mayHaveSideEffects ( subExpression ) ;^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node child = left;^649^^^^^645^735^[REPLACE] Node child = subExpression;^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  (replacementValueNode  &&  expressionRoot )  {^651^^^^^645^735^[REPLACE] if  ( parent == expressionRoot )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^651^652^^654^655^645^735^[ADD] if  ( parent == expressionRoot )  {  return requiresDecomposition ? DecompositionType.DECOMPOSABLE^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^return sideEffects ? DecompositionType.DECOMPOSABLE : DecompositionType.MOVABLE;^654^655^656^^^645^735^[REPLACE] return requiresDecomposition ? DecompositionType.DECOMPOSABLE : DecompositionType.MOVABLE;^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if   (  left != child  )   {  ;^661^^^^^645^735^[REPLACE] if  ( isConditionalOp ( parent )  )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if   (  isSafeAssign  (  parent, state.sideEffects  )    )   {  ;^675^^^^^661^728^[REPLACE] if  ( isSafeAssign ( parent, seenSideEffects )  )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( n  ) {^689^^^^^675^727^[REPLACE] if  ( n == child )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^689^690^^692^693^675^727^[ADD] if  ( n == child )  {  break; }^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if   (  isExpressionTreeUnsafe  (  n, state.sideEffects  )    )   {  ;^695^696^^^^675^727^[REPLACE] if  ( isExpressionTreeUnsafe ( n, seenSideEffects )  )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^state.sideEffects = true  ;^697^^^^^695^699^[REPLACE] seenSideEffects = true;^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^698^^^^^695^699^[ADD] requiresDecomposition = true;^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  (  parent.getType (  )  == Token.CALL || NodeUtil.isGet ( first )  )  {^718^719^720^^^675^727^[REPLACE] if  ( requiresDecomposition && parent.getType (  )  == Token.CALL && NodeUtil.isGet ( first )  )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REMOVE]^if  ( isSafeAssign ( parent, seenSideEffects )  )  { }else {     for  ( Node n : parent.children (  )  )  {         if  ( n == child )  {             break;         }         if  ( isExpressionTreeUnsafe ( n, seenSideEffects )  )  {             seenSideEffects = true;             requiresDecomposition = true;         }     }     Node first = parent.getFirstChild (  ) ;     if  (  ( requiresDecomposition &&  (  ( parent.getType (  )  )  ==  ( CALL )  )  )  &&  ( isGet ( first )  )  )  {         if  ( maybeExternMethod ( first )  )  {             return UNDECOMPOSABLE;         }else {             return DECOMPOSABLE;         }     } }^718^^^^^675^727^[REMOVE] ^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( maybeExternMethod ( thisNameNode )  )  {^721^^^^^718^726^[REPLACE] if  ( maybeExternMethod ( first )  )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^721^722^723^724^725^718^726^[ADD] if  ( maybeExternMethod ( first )  )  { return DecompositionType.UNDECOMPOSABLE; } else { return DecompositionType.DECOMPOSABLE; }^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^return !isExpressionTreeUnsafe  (  lhs.getFirstChild  (    )  , seenSideEffects  )  ;  ;^722^^^^^718^726^[REPLACE] return DecompositionType.UNDECOMPOSABLE;^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^return !isExpressionTreeUnsafe  (  lhs.getFirstChild  (    )  , seenSideEffects  )  ;  ;^724^^^^^718^726^[REPLACE] return DecompositionType.DECOMPOSABLE;^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( maybeExternMethod ( replacementValueNode )  )  {^721^^^^^675^727^[REPLACE] if  ( maybeExternMethod ( first )  )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^return DecompositionType.UNDECOMPOSABLE;return DecompositionType.DECOMPOSABLE;^721^722^723^724^725^675^727^[ADD] if  ( maybeExternMethod ( first )  )  { return DecompositionType.UNDECOMPOSABLE; } else { return DecompositionType.DECOMPOSABLE; }^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^return !isExpressionTreeUnsafe  (  lhs.getFirstChild  (    )  , seenSideEffects  )  ;  ;^724^^^^^721^725^[REPLACE] return DecompositionType.DECOMPOSABLE;^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^return !isExpressionTreeUnsafe  (  lhs.getFirstChild  (    )  , seenSideEffects  )  ;  ;^722^^^^^675^727^[REPLACE] return DecompositionType.UNDECOMPOSABLE;^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^for  ( Node second : parent.children (  )  )  {^688^^^^^686^727^[REPLACE] for  ( Node n : parent.children (  )  )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  (thisVarNode  &&  child )  {^689^^^^^686^727^[REPLACE] if  ( n == child )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( isExpressionTreeUnsafe ( n, true )  )  {^695^696^^^^686^727^[REPLACE] if  ( isExpressionTreeUnsafe ( n, seenSideEffects )  )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^requiresDecomposition = false;^698^^^^^695^699^[REPLACE] requiresDecomposition = true;^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^state.sideEffects = true  ;^697^^^^^686^727^[REPLACE] seenSideEffects = true;^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^requiresDecomposition = false;^698^^^^^686^727^[REPLACE] requiresDecomposition = true;^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^return !isExpressionTreeUnsafe  (  lhs.getFirstChild  (    )  , seenSideEffects  )  ;  ;^722^^^^^686^727^[REPLACE] return DecompositionType.UNDECOMPOSABLE;^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^return !isExpressionTreeUnsafe  (  lhs.getFirstChild  (    )  , seenSideEffects  )  ;  ;^724^^^^^686^727^[REPLACE] return DecompositionType.DECOMPOSABLE;^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node ifNode  ;^688^^^^^686^727^[REPLACE] for  ( Node n : parent.children (  )  )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node first = node .getLastChild (  )  ;^717^^^^^686^727^[REPLACE] Node first = parent.getFirstChild (  ) ;^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( n  &&  child )  {^689^^^^^661^728^[REPLACE] if  ( n == child )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if   (  isExpressionTreeUnsafe  (  n, state.sideEffects  )    )   {  ;^695^696^^^^661^728^[REPLACE] if  ( isExpressionTreeUnsafe ( n, seenSideEffects )  )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^697^698^^^^695^699^[ADD] seenSideEffects = true; requiresDecomposition = true;^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( requiresDecomposition || parent.getType (  )  == Token.CALL || NodeUtil.isGet ( first )  )  {^718^719^720^^^661^728^[REPLACE] if  ( requiresDecomposition && parent.getType (  )  == Token.CALL && NodeUtil.isGet ( first )  )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( maybeExternMethod ( result )  )  {^721^^^^^718^726^[REPLACE] if  ( maybeExternMethod ( first )  )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REMOVE]^if  ( parent == expressionRoot )  {     return requiresDecomposition ? DECOMPOSABLE : MOVABLE; }^721^^^^^718^726^[REMOVE] ^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( maybeExternMethod ( thisNameNode )  )  {^721^^^^^661^728^[REPLACE] if  ( maybeExternMethod ( first )  )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^return !isExpressionTreeUnsafe  (  lhs.getFirstChild  (    )  , seenSideEffects  )  ;  ;^722^^^^^661^728^[REPLACE] return DecompositionType.UNDECOMPOSABLE;^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^for  ( Node subExpression : parent.children (  )  )  {^688^^^^^686^727^[REPLACE] for  ( Node n : parent.children (  )  )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  (replacement  &&  child )  {^689^^^^^686^727^[REPLACE] if  ( n == child )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^689^690^^692^693^686^727^[ADD] if  ( n == child )  {  break; }^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( isExpressionTreeUnsafe ( second, seenSideEffects )  )  {^695^696^^^^686^727^[REPLACE] if  ( isExpressionTreeUnsafe ( n, seenSideEffects )  )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^seenSideEffects = false;^697^^^^^686^727^[REPLACE] seenSideEffects = true;^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^688^689^^^692^686^727^[ADD] for  ( Node n : parent.children (  )  )  { if  ( n == child )  { break;^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node last = expr.getLastChild (  )  ;^717^^^^^686^727^[REPLACE] Node first = parent.getFirstChild (  ) ;^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( replacementValueNode  == result (  )  )  {^664^^^^^645^735^[REPLACE] if  ( child != parent.getFirstChild (  )  )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^requiresDecomposition = false;^665^^^^^645^735^[REPLACE] requiresDecomposition = true;^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^665^^^^^645^735^[ADD] requiresDecomposition = true;^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  (thisNameNode  ==  parent.getFirstChild (  )  )  {^664^^^^^645^735^[REPLACE] if  ( child != parent.getFirstChild (  )  )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^requiresDecomposition = true;^664^665^666^^^645^735^[ADD] if  ( child != parent.getFirstChild (  )  )  { requiresDecomposition = true; }^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if   (  isSafeAssign  (  parent, state.sideEffects  )    )   {  ;^675^^^^^645^735^[REPLACE] if  ( isSafeAssign ( parent, seenSideEffects )  )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( isExpressionTreeUnsafe ( thisVarNode, seenSideEffects )  )  {^695^696^^^^675^727^[REPLACE] if  ( isExpressionTreeUnsafe ( n, seenSideEffects )  )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^seenSideEffects = false;^697^^^^^695^699^[REPLACE] seenSideEffects = true;^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( requiresDecomposition ) {^718^719^720^^^675^727^[REPLACE] if  ( requiresDecomposition && parent.getType (  )  == Token.CALL && NodeUtil.isGet ( first )  )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^718^719^720^721^722^675^727^[ADD] if  ( requiresDecomposition && parent.getType (  )  == Token.CALL && NodeUtil.isGet ( first )  )  { if  ( maybeExternMethod ( first )  )  { return DecompositionType.UNDECOMPOSABLE;^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if   (  left != child  )   {  ;^721^^^^^718^726^[REPLACE] if  ( maybeExternMethod ( first )  )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( maybeExternMethod ( replacement )  )  {^721^^^^^675^727^[REPLACE] if  ( maybeExternMethod ( first )  )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^for  ( NodethisNameNode : parent.children (  )  )  {^688^^^^^686^727^[REPLACE] for  ( Node n : parent.children (  )  )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if   (  left != child  )   {  ;^689^^^^^686^727^[REPLACE] if  ( n == child )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( isExpressionTreeUnsafe ( thisNameNode, seenSideEffects )  )  {^695^696^^^^686^727^[REPLACE] if  ( isExpressionTreeUnsafe ( n, seenSideEffects )  )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^698^^^^^686^727^[ADD] requiresDecomposition = true;^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node first = nonconditionalExpr .getLastChild (  )  ;^717^^^^^686^727^[REPLACE] Node first = parent.getFirstChild (  ) ;^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( replacementValueNode  !=  child )  {^689^^^^^645^735^[REPLACE] if  ( n == child )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( isExpressionTreeUnsafe ( thisVarNode, seenSideEffects )  )  {^695^696^^^^645^735^[REPLACE] if  ( isExpressionTreeUnsafe ( n, seenSideEffects )  )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( requiresDecomposition || parent.getType (  )  == Token.CALL || NodeUtil.isStatementBlock ( first )  )  {^718^719^720^^^645^735^[REPLACE] if  ( requiresDecomposition && parent.getType (  )  == Token.CALL && NodeUtil.isGet ( first )  )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REMOVE]^if  ( isSafeAssign ( parent, seenSideEffects )  )  { }else {     for  ( Node n : parent.children (  )  )  {         if  ( n == child )  {             break;         }         if  ( isExpressionTreeUnsafe ( n, seenSideEffects )  )  {             seenSideEffects = true;             requiresDecomposition = true;         }     }     Node first = parent.getFirstChild (  ) ;     if  (  ( requiresDecomposition &&  (  ( parent.getType (  )  )  ==  ( CALL )  )  )  &&  ( isGet ( first )  )  )  {         if  ( maybeExternMethod ( first )  )  {             return UNDECOMPOSABLE;         }else {             return DECOMPOSABLE;         }     } }^718^^^^^645^735^[REMOVE] ^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( maybeExternMethod ( thisVarNode )  )  {^721^^^^^645^735^[REPLACE] if  ( maybeExternMethod ( first )  )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^return DecompositionType.UNDECOMPOSABLE;return DecompositionType.DECOMPOSABLE;^721^722^723^724^725^645^735^[ADD] if  ( maybeExternMethod ( first )  )  { return DecompositionType.UNDECOMPOSABLE; } else { return DecompositionType.DECOMPOSABLE; }^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^return !isExpressionTreeUnsafe  (  lhs.getFirstChild  (    )  , seenSideEffects  )  ;  ;^722^^^^^645^735^[REPLACE] return DecompositionType.UNDECOMPOSABLE;^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^for  ( NodetrueExpr : child.getAncestors (  )  )  {^650^^^^^645^735^[REPLACE] for  ( Node parent : child.getAncestors (  )  )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( node  !=  n )  {^651^^^^^645^735^[REPLACE] if  ( parent == expressionRoot )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^return true ? DecompositionType.DECOMPOSABLE : DecompositionType.MOVABLE;^654^655^656^^^645^735^[REPLACE] return requiresDecomposition ? DecompositionType.DECOMPOSABLE : DecompositionType.MOVABLE;^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^675^676^^^^661^728^[ADD] if  ( isSafeAssign ( parent, seenSideEffects )  )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  (replacementValueNode  !=  child )  {^689^^^^^675^727^[REPLACE] if  ( n == child )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^695^696^697^698^699^675^727^[ADD] if  ( isExpressionTreeUnsafe ( n, seenSideEffects )  )  { seenSideEffects = true; requiresDecomposition = true; }^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( maybeExternMethod ( subExpression )  )  {^721^^^^^718^726^[REPLACE] if  ( maybeExternMethod ( first )  )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^return DecompositionType.UNDECOMPOSABLE;return DecompositionType.DECOMPOSABLE;^721^722^723^724^725^718^726^[ADD] if  ( maybeExternMethod ( first )  )  { return DecompositionType.UNDECOMPOSABLE; } else { return DecompositionType.DECOMPOSABLE; }^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( maybeExternMethod ( tempVarNode )  )  {^721^^^^^675^727^[REPLACE] if  ( maybeExternMethod ( first )  )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^for  ( Nodereplacement : parent.children (  )  )  {^688^^^^^686^727^[REPLACE] for  ( Node n : parent.children (  )  )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( n  ||  child )  {^689^^^^^686^727^[REPLACE] if  ( n == child )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if   (  isExpressionTreeUnsafe  (  n, state.sideEffects  )    )   {  ;^695^696^^^^686^727^[REPLACE] if  ( isExpressionTreeUnsafe ( n, seenSideEffects )  )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^717^^^^^686^727^[ADD] Node first = parent.getFirstChild (  ) ;^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( isExpressionTreeUnsafe ( n, true )  )  {^695^696^^^^661^728^[REPLACE] if  ( isExpressionTreeUnsafe ( n, seenSideEffects )  )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^695^696^697^698^699^661^728^[ADD] if  ( isExpressionTreeUnsafe ( n, seenSideEffects )  )  { seenSideEffects = true; requiresDecomposition = true; }^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( requiresDecomposition || parent.getType (  )  == Token.CALL || NodeUtil.isStatementBlock ( first )  )  {^718^719^720^^^661^728^[REPLACE] if  ( requiresDecomposition && parent.getType (  )  == Token.CALL && NodeUtil.isGet ( first )  )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( maybeExternMethod ( tempVarNode )  )  {^721^^^^^718^726^[REPLACE] if  ( maybeExternMethod ( first )  )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( maybeExternMethod ( thisVarNode )  )  {^721^^^^^661^728^[REPLACE] if  ( maybeExternMethod ( first )  )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REMOVE]^if  ( parent == expressionRoot )  {     return requiresDecomposition ? DECOMPOSABLE : MOVABLE; }^721^^^^^661^728^[REMOVE] ^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^for  ( Node n : parent .hasChildren (  )   )  {^688^^^^^686^727^[REPLACE] for  ( Node n : parent.children (  )  )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( second  !=  child )  {^689^^^^^686^727^[REPLACE] if  ( n == child )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^697^^^^^686^727^[ADD] seenSideEffects = true;^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node first = trueExpr.getFirstChild (  ) ;^717^^^^^686^727^[REPLACE] Node first = parent.getFirstChild (  ) ;^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( child  ==  parent.getFirstChild (  )  )  {^664^^^^^645^735^[REPLACE] if  ( child != parent.getFirstChild (  )  )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( child  == replacementValueNode (  )  )  {^664^^^^^645^735^[REPLACE] if  ( child != parent.getFirstChild (  )  )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  (thisNameNode  &&  subExpression )  {^689^^^^^675^727^[REPLACE] if  ( n == child )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( requiresDecomposition || parent.getType (  )  == Token.CALL || NodeUtil.isStatementBlock ( first )  )  {^718^719^720^^^675^727^[REPLACE] if  ( requiresDecomposition && parent.getType (  )  == Token.CALL && NodeUtil.isGet ( first )  )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( maybeExternMethod ( thisNameNode )  )  {^721^^^^^675^727^[REPLACE] if  ( maybeExternMethod ( first )  )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REMOVE]^if  ( parent == expressionRoot )  {     return requiresDecomposition ? DECOMPOSABLE : MOVABLE; }^721^^^^^675^727^[REMOVE] ^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^for  ( Node stopNode : parent.children (  )  )  {^688^^^^^686^727^[REPLACE] for  ( Node n : parent.children (  )  )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node first = parent.getLastChild (  ) ;^717^^^^^686^727^[REPLACE] Node first = parent.getFirstChild (  ) ;^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( n  !=  thisNameNode )  {^689^^^^^645^735^[REPLACE] if  ( n == child )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if   (  isExpressionTreeUnsafe  (  n, state.sideEffects  )    )   {  ;^695^696^^^^645^735^[REPLACE] if  ( isExpressionTreeUnsafe ( n, seenSideEffects )  )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^695^696^697^698^699^645^735^[ADD] if  ( isExpressionTreeUnsafe ( n, seenSideEffects )  )  { seenSideEffects = true; requiresDecomposition = true; }^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( requiresDecomposition || parent.getType (  )  == Token.CALL || NodeUtil.isGet ( first )  )  {^718^719^720^^^645^735^[REPLACE] if  ( requiresDecomposition && parent.getType (  )  == Token.CALL && NodeUtil.isGet ( first )  )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( maybeExternMethod ( replacementValueNode )  )  {^721^^^^^718^726^[REPLACE] if  ( maybeExternMethod ( first )  )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( maybeExternMethod ( tempVarNode )  )  {^721^^^^^645^735^[REPLACE] if  ( maybeExternMethod ( first )  )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^for  ( Node thisVarNode : parent .hasChildren (  )   )  {^688^^^^^686^727^[REPLACE] for  ( Node n : parent.children (  )  )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^requiresDecomposition = false;^665^^^^^686^727^[REPLACE] requiresDecomposition = true;^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^730^^^^^686^727^[ADD] child = parent;^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^return true ? DecompositionType.DECOMPOSABLE : DecompositionType.MOVABLE;^654^655^656^^^686^727^[REPLACE] return requiresDecomposition ? DecompositionType.DECOMPOSABLE : DecompositionType.MOVABLE;^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^int replacementValueNodeType = parent.getType (  ) ;^659^^^^^686^727^[REPLACE] int parentType = parent.getType (  ) ;^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node first = result.getLastChild (  ) ;^717^^^^^686^727^[REPLACE] Node first = parent.getFirstChild (  ) ;^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^if  ( n  &&  second )  {^689^^^^^686^727^[REPLACE] if  ( n == child )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REMOVE]^if  ( isExpressionTreeUnsafe ( n, state.sideEffects )  )  {     state.sideEffects = true;     state.extractBeforeStatement = extractExpression ( n, state.extractBeforeStatement ) ; }^695^^^^^686^727^[REMOVE] ^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^665^^^^^686^727^[ADD] requiresDecomposition = true;^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^child =  null;^730^^^^^686^727^[REPLACE] child = parent;^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node parent = expr.getParent (  )  ;^650^^^^^686^727^[REPLACE] for  ( Node parent : child.getAncestors (  )  )  {^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[ADD]^^659^^^^^686^727^[ADD] int parentType = parent.getType (  ) ;^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^Node first = replacement.getLastChild (  ) ;^717^^^^^686^727^[REPLACE] Node first = parent.getFirstChild (  ) ;^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
[REPLACE]^throw new IllegalStateException ( "External object method calls can not be decomposed." )  ;^734^^^^^645^735^[REPLACE] throw new IllegalStateException  (" ")  ;^[METHOD] isSubexpressionMovable [TYPE] ExpressionDecomposer$DecompositionType [PARAMETER] Node expressionRoot Node subExpression [CLASS] ExpressionDecomposer DecompositionType DecompositionState   [TYPE]  DecompositionType DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  [TYPE]  AbstractCompiler compiler  [TYPE]  Set constNames  knownConstants  [TYPE]  boolean false  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  true  [TYPE]  Node call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String resultName  sName  tempName  tempNamePrefix  [TYPE]  int MAX_INTERATIONS  i  parentType  type 
