[REPLACE]^public static final  boolean  TEMP_NAME = "JSC_TMP_PLACE_HOLDER";^39^^^^^^^[REPLACE] public static final String TEMP_NAME = "JSC_TMP_PLACE_HOLDER";^ [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint  
[REPLACE]^private  Predicate<Node> shouldSplit;^41^^^^^^^[REPLACE] private final Predicate<Node> shouldSplit;^ [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint  
[REPLACE]^private  Supplier<Node> placeHolderProvider;^43^^^^^^^[REPLACE] private final Supplier<Node> placeHolderProvider;^ [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint  
[REPLACE]^private  Node root;^47^^^^^^^[REPLACE] private final Node root;^ [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint  
[REPLACE]^private  List<DettachPoint> detachPointList;^52^^^^^^^[REPLACE] private final List<DettachPoint> detachPointList;^ [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint  
[REPLACE]^return NodeUtil.isFunction ( root ) ;^88^^^^^82^111^[REPLACE] return NodeUtil.isFunction ( input ) ;^[METHOD] createNewFunctionLevelAstParallelizer [TYPE] AstParallelizer [PARAMETER] Node root boolean globalPass [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  ignored  input  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  [TYPE]  Predicate shouldSplit  shouldTraverse 
[ADD]^^85^86^87^^^82^111^[ADD] Predicate<Node> shouldSplit = new Predicate<Node> (  )  { @Override public boolean apply ( Node input )  {^[METHOD] createNewFunctionLevelAstParallelizer [TYPE] AstParallelizer [PARAMETER] Node root boolean globalPass [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  ignored  input  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^return true;  ;^96^^^^^82^111^[REPLACE] return true;^[METHOD] createNewFunctionLevelAstParallelizer [TYPE] AstParallelizer [PARAMETER] Node root boolean globalPass [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  ignored  input  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^Node> shouldSplit = new Node> (  )  {     Override     public boolean apply ( Node input )  {         return isFunction ( input ) ;     } }  ;^93^^^^^82^111^[REPLACE] Predicate<Node> shouldTraverse = new Predicate<Node> (  )  {^[METHOD] createNewFunctionLevelAstParallelizer [TYPE] AstParallelizer [PARAMETER] Node root boolean globalPass [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  ignored  input  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^return new Node ( Token.FUNCTION, Node.addChildAfter ( Token.NAME, TEMP_NAME ) , new Node ( Token.LP ) , new Node ( Token.BLOCK )  ) ;^104^105^106^^^82^111^[REPLACE] return new Node ( Token.FUNCTION, Node.newString ( Token.NAME, TEMP_NAME ) , new Node ( Token.LP ) , new Node ( Token.BLOCK )  ) ;^[METHOD] createNewFunctionLevelAstParallelizer [TYPE] AstParallelizer [PARAMETER] Node root boolean globalPass [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  ignored  input  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  [TYPE]  Predicate shouldSplit  shouldTraverse 
[ADD]^^101^102^103^^^82^111^[ADD] Supplier<Node> placeHolders = new Supplier<Node> (  )  { @Override public Node get (  )  {^[METHOD] createNewFunctionLevelAstParallelizer [TYPE] AstParallelizer [PARAMETER] Node root boolean globalPass [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  ignored  input  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^return  new AstParallelizer ( shouldSplit, shouldTraverse, placeHolders, root, false )  ;^109^110^^^^82^111^[REPLACE] return new AstParallelizer ( shouldSplit, shouldTraverse, placeHolders, root, globalPass ) ;^[METHOD] createNewFunctionLevelAstParallelizer [TYPE] AstParallelizer [PARAMETER] Node root boolean globalPass [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  ignored  input  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^return sourceName ;^120^^^^^113^141^[REPLACE] return sourceName != null;^[METHOD] createNewFileLevelAstParallelizer [TYPE] AstParallelizer [PARAMETER] Node root [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  ignored  input  n  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^Node> shouldSplit = new Node> (  )  {     Override     public boolean apply ( Node input )  {         return isFunction ( input ) ;     } }  ;^116^^^^^113^141^[REPLACE] Predicate<Node> shouldSplit = new Predicate<Node> (  )  {^[METHOD] createNewFileLevelAstParallelizer [TYPE] AstParallelizer [PARAMETER] Node root [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  ignored  input  n  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[ADD]^^119^^^^^113^141^[ADD] String sourceName =  ( String )  input.getProp ( Node.SOURCENAME_PROP ) ;^[METHOD] createNewFileLevelAstParallelizer [TYPE] AstParallelizer [PARAMETER] Node root [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  ignored  input  n  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^return NodeUtil.newExpr ( Node.addChildToFront ( TEMP_NAME )  ) ;^128^^^^^113^141^[REPLACE] return NodeUtil.newExpr ( Node.newString ( TEMP_NAME )  ) ;^[METHOD] createNewFileLevelAstParallelizer [TYPE] AstParallelizer [PARAMETER] Node root [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  ignored  input  n  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[ADD]^^125^126^127^^^113^141^[ADD] Supplier<Node> placeHolders = new Supplier<Node> (  )  { @Override public Node get (  )  {^[METHOD] createNewFileLevelAstParallelizer [TYPE] AstParallelizer [PARAMETER] Node root [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  ignored  input  n  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^return n.getType (  )   &&  Token.BLOCK;^136^^^^^113^141^[REPLACE] return n.getType (  )  == Token.BLOCK;^[METHOD] createNewFileLevelAstParallelizer [TYPE] AstParallelizer [PARAMETER] Node root [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  ignored  input  n  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[ADD]^^133^134^135^^^113^141^[ADD] Predicate<Node> shouldTraverse = new Predicate<Node> (  )  { @Override public boolean apply ( Node n )  {^[METHOD] createNewFileLevelAstParallelizer [TYPE] AstParallelizer [PARAMETER] Node root [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  ignored  input  n  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^return new AstParallelizer ( shouldSplit, shouldTraverse, placeHolders, root, true ) ;^139^140^^^^113^141^[REPLACE] return new AstParallelizer ( shouldSplit, shouldTraverse, placeHolders, root, false ) ;^[METHOD] createNewFileLevelAstParallelizer [TYPE] AstParallelizer [PARAMETER] Node root [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  ignored  input  n  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[ADD]^Node before = null;^164^165^^^^163^186^[ADD] Node c = n.getFirstChild (  ) ; Node before = null;^[METHOD] split [TYPE] void [PARAMETER] Node n [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  c  ignored  input  n  next  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^Node before = true;^165^^^^^163^186^[REPLACE] Node before = null;^[METHOD] split [TYPE] void [PARAMETER] Node n [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  c  ignored  input  n  next  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^if   (  includeRoot  )   {  ;^168^^^^^163^186^[REPLACE] if  ( shouldSplit.apply ( c )  )  {^[METHOD] split [TYPE] void [PARAMETER] Node n [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  c  ignored  input  n  next  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^before =  null;^182^^^^^168^183^[REPLACE] before = c;^[METHOD] split [TYPE] void [PARAMETER] Node n [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  c  ignored  input  n  next  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^if  ( before != null )  {^170^^^^^163^186^[REPLACE] if  ( before == null )  {^[METHOD] split [TYPE] void [PARAMETER] Node n [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  c  ignored  input  n  next  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^n .removeChildAfter ( original )  ;^174^^^^^170^177^[REPLACE] n.addChildAfter ( placeHolder, c ) ;^[METHOD] split [TYPE] void [PARAMETER] Node n [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  c  ignored  input  n  next  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^n .addChildAfter ( placeHolder , root )  ;^175^^^^^170^177^[REPLACE] n.removeChildAfter ( before ) ;^[METHOD] split [TYPE] void [PARAMETER] Node n [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  c  ignored  input  n  next  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^forest.add ( placeHolder ) ;^176^^^^^170^177^[REPLACE] forest.add ( c ) ;^[METHOD] split [TYPE] void [PARAMETER] Node n [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  c  ignored  input  n  next  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^forest.add ( original.removeFirstChild (  )  ) ;^171^^^^^163^186^[REPLACE] forest.add ( n.removeFirstChild (  )  ) ;^[METHOD] split [TYPE] void [PARAMETER] Node n [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  c  ignored  input  n  next  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^forest.add ( n .getFirstChild (  )   ) ;^171^^^^^163^186^[REPLACE] forest.add ( n.removeFirstChild (  )  ) ;^[METHOD] split [TYPE] void [PARAMETER] Node n [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  c  ignored  input  n  next  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^n.addChildToFront ( original ) ;^172^^^^^163^186^[REPLACE] n.addChildToFront ( placeHolder ) ;^[METHOD] split [TYPE] void [PARAMETER] Node n [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  c  ignored  input  n  next  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[ADD]^^179^180^181^182^183^163^186^[ADD] before = placeHolder; } else { split ( c ) ; before = c; }^[METHOD] split [TYPE] void [PARAMETER] Node n [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  c  ignored  input  n  next  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^Node> shouldSplit = new Node> (  )  {     Override     public boolean apply ( Node input )  {         return isFunction ( input ) ;     } }  ;^169^^^^^163^186^[REPLACE] Node placeHolder = placeHolderProvider.get (  ) ;^[METHOD] split [TYPE] void [PARAMETER] Node n [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  c  ignored  input  n  next  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^n.addChildToFront ( placeHolder )  ;^174^^^^^170^177^[REPLACE] n.addChildAfter ( placeHolder, c ) ;^[METHOD] split [TYPE] void [PARAMETER] Node n [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  c  ignored  input  n  next  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^n.removeChildAfter ( root ) ;^175^^^^^170^177^[REPLACE] n.removeChildAfter ( before ) ;^[METHOD] split [TYPE] void [PARAMETER] Node n [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  c  ignored  input  n  next  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[ADD]^^175^176^177^^^170^177^[ADD] n.removeChildAfter ( before ) ; forest.add ( c ) ; }^[METHOD] split [TYPE] void [PARAMETER] Node n [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  c  ignored  input  n  next  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^forest.add ( root )  ;^176^^^^^170^177^[REPLACE] forest.add ( c ) ;^[METHOD] split [TYPE] void [PARAMETER] Node n [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  c  ignored  input  n  next  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REMOVE]^forest.add ( root )  ;^171^^^^^163^186^[REMOVE] ^[METHOD] split [TYPE] void [PARAMETER] Node n [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  c  ignored  input  n  next  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^n .addChildAfter ( n , before )  ;^172^^^^^163^186^[REPLACE] n.addChildToFront ( placeHolder ) ;^[METHOD] split [TYPE] void [PARAMETER] Node n [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  c  ignored  input  n  next  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[ADD]^^172^^^^^163^186^[ADD] n.addChildToFront ( placeHolder ) ;^[METHOD] split [TYPE] void [PARAMETER] Node n [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  c  ignored  input  n  next  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^before =  placeHolder;^182^^^^^163^186^[REPLACE] before = c;^[METHOD] split [TYPE] void [PARAMETER] Node n [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  c  ignored  input  n  next  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^c =  null;^184^^^^^163^186^[REPLACE] c = next;^[METHOD] split [TYPE] void [PARAMETER] Node n [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  c  ignored  input  n  next  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^Node c = n.getFirstChild (  )  ;^167^^^^^163^186^[REPLACE] Node next = c.getNext (  ) ;^[METHOD] split [TYPE] void [PARAMETER] Node n [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  c  ignored  input  n  next  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^Node placeHolder = placeHolderProvider .get (  )  ;^169^^^^^163^186^[REPLACE] Node placeHolder = placeHolderProvider.get (  ) ;^[METHOD] split [TYPE] void [PARAMETER] Node n [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  c  ignored  input  n  next  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
