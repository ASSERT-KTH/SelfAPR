[REPLACE]^public static  String TEMP_NAME = "JSC_TMP_PLACE_HOLDER";^39^^^^^^^[REPLACE] public static final String TEMP_NAME = "JSC_TMP_PLACE_HOLDER";^ [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint  
[REPLACE]^private  Supplier<Node> placeHolderProvider;^43^^^^^^^[REPLACE] private final Supplier<Node> placeHolderProvider;^ [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint  
[REPLACE]^private  List<Node> forest;^45^^^^^^^[REPLACE] private final List<Node> forest;^ [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint  
[REPLACE]^private  Node root;^47^^^^^^^[REPLACE] private final Node root;^ [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint  
[REPLACE]^private  boolean includeRoot;^49^^^^^^^[REPLACE] private final boolean includeRoot;^ [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint  
[REPLACE]^private  List<DettachPoint> detachPointList;^52^^^^^^^[REPLACE] private final List<DettachPoint> detachPointList;^ [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint  
[REPLACE]^this.shouldSplit =  null;^73^^^^^67^79^[REPLACE] this.shouldSplit = shouldSplit;^[METHOD] <init> [TYPE] Node,boolean) [PARAMETER] Node> shouldSplit Node> shouldTraverse Node> placeHolderProvider Node root boolean includeRoot [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  includeRoot  true  [TYPE]  Node before  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^this.placeHolderProvider =  null;^74^^^^^67^79^[REPLACE] this.placeHolderProvider = placeHolderProvider;^[METHOD] <init> [TYPE] Node,boolean) [PARAMETER] Node> shouldSplit Node> shouldTraverse Node> placeHolderProvider Node root boolean includeRoot [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  includeRoot  true  [TYPE]  Node before  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^this.root =  placeHolder;^75^^^^^67^79^[REPLACE] this.root = root;^[METHOD] <init> [TYPE] Node,boolean) [PARAMETER] Node> shouldSplit Node> shouldTraverse Node> placeHolderProvider Node root boolean includeRoot [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  includeRoot  true  [TYPE]  Node before  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^this.includeRoot =  true;^76^^^^^67^79^[REPLACE] this.includeRoot = includeRoot;^[METHOD] <init> [TYPE] Node,boolean) [PARAMETER] Node> shouldSplit Node> shouldTraverse Node> placeHolderProvider Node root boolean includeRoot [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  includeRoot  true  [TYPE]  Node before  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  [TYPE]  Predicate shouldSplit  shouldTraverse 
[ADD]^^76^^^^^67^79^[ADD] this.includeRoot = includeRoot;^[METHOD] <init> [TYPE] Node,boolean) [PARAMETER] Node> shouldSplit Node> shouldTraverse Node> placeHolderProvider Node root boolean includeRoot [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  includeRoot  true  [TYPE]  Node before  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^this.detachPointList = Lists.newLinkedList (  ) ; ;^77^^^^^67^79^[REPLACE] this.forest = Lists.newLinkedList (  ) ;^[METHOD] <init> [TYPE] Node,boolean) [PARAMETER] Node> shouldSplit Node> shouldTraverse Node> placeHolderProvider Node root boolean includeRoot [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  includeRoot  true  [TYPE]  Node before  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^this.forest = Lists.newLinkedList (  ) ; ;^78^^^^^67^79^[REPLACE] this.detachPointList = Lists.newLinkedList (  ) ;^[METHOD] <init> [TYPE] Node,boolean) [PARAMETER] Node> shouldSplit Node> shouldTraverse Node> placeHolderProvider Node root boolean includeRoot [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  includeRoot  true  [TYPE]  Node before  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  [TYPE]  Predicate shouldSplit  shouldTraverse 
[ADD]^^78^^^^^67^79^[ADD] this.detachPointList = Lists.newLinkedList (  ) ;^[METHOD] <init> [TYPE] Node,boolean) [PARAMETER] Node> shouldSplit Node> shouldTraverse Node> placeHolderProvider Node root boolean includeRoot [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  includeRoot  true  [TYPE]  Node before  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^this.placeHolder =  null;^219^^^^^218^222^[REPLACE] this.placeHolder = placeHolder;^[METHOD] <init> [TYPE] Node) [PARAMETER] Node placeHolder Node before Node orginal [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  includeRoot  true  [TYPE]  Node before  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^this.before =  root;^220^^^^^218^222^[REPLACE] this.before = before;^[METHOD] <init> [TYPE] Node) [PARAMETER] Node placeHolder Node before Node orginal [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  includeRoot  true  [TYPE]  Node before  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^this.original =  root;^221^^^^^218^222^[REPLACE] this.original = orginal;^[METHOD] <init> [TYPE] Node) [PARAMETER] Node placeHolder Node before Node orginal [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  includeRoot  true  [TYPE]  Node before  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^return   input   ;^88^^^^^82^111^[REPLACE] return NodeUtil.isFunction ( input ) ;^[METHOD] createNewFunctionLevelAstParallelizer [TYPE] AstParallelizer [PARAMETER] Node root boolean globalPass [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  ignored  input  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^Predicate<Node> shouldSplit = new Predicate<Node> (  )  { @Override^85^^^^^82^111^[REPLACE] Predicate<Node> shouldSplit = new Predicate<Node> (  )  {^[METHOD] createNewFunctionLevelAstParallelizer [TYPE] AstParallelizer [PARAMETER] Node root boolean globalPass [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  ignored  input  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^return false;^96^^^^^82^111^[REPLACE] return true;^[METHOD] createNewFunctionLevelAstParallelizer [TYPE] AstParallelizer [PARAMETER] Node root boolean globalPass [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  ignored  input  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^Predicate<Node> shouldTraverse = new Predicate<Node> (  )  { @Override^93^^^^^82^111^[REPLACE] Predicate<Node> shouldTraverse = new Predicate<Node> (  )  {^[METHOD] createNewFunctionLevelAstParallelizer [TYPE] AstParallelizer [PARAMETER] Node root boolean globalPass [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  ignored  input  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  [TYPE]  Predicate shouldSplit  shouldTraverse 
[ADD]^^93^94^95^^^82^111^[ADD] Predicate<Node> shouldTraverse = new Predicate<Node> (  )  { @Override public boolean apply ( Node ignored )  {^[METHOD] createNewFunctionLevelAstParallelizer [TYPE] AstParallelizer [PARAMETER] Node root boolean globalPass [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  ignored  input  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^return new Node ( Token.FUNCTION, Node .getParent (  )  , new Node ( Token.LP ) , new Node ( Token.BLOCK )  ) ;^104^105^106^^^82^111^[REPLACE] return new Node ( Token.FUNCTION, Node.newString ( Token.NAME, TEMP_NAME ) , new Node ( Token.LP ) , new Node ( Token.BLOCK )  ) ;^[METHOD] createNewFunctionLevelAstParallelizer [TYPE] AstParallelizer [PARAMETER] Node root boolean globalPass [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  ignored  input  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^Predicate<Node> shouldSplit = new Predicate<Node> (  )  { @Override^101^^^^^82^111^[REPLACE] Supplier<Node> placeHolders = new Supplier<Node> (  )  {^[METHOD] createNewFunctionLevelAstParallelizer [TYPE] AstParallelizer [PARAMETER] Node root boolean globalPass [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  ignored  input  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^return new AstParallelizer ( shouldSplit, shouldTraverse, placeHolders, root, false ) ;^109^110^^^^82^111^[REPLACE] return new AstParallelizer ( shouldSplit, shouldTraverse, placeHolders, root, globalPass ) ;^[METHOD] createNewFunctionLevelAstParallelizer [TYPE] AstParallelizer [PARAMETER] Node root boolean globalPass [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  ignored  input  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^return   input   ;^88^^^^^87^89^[REPLACE] return NodeUtil.isFunction ( input ) ;^[METHOD] apply [TYPE] boolean [PARAMETER] Node input [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  ignored  input  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^return false;^96^^^^^95^97^[REPLACE] return true;^[METHOD] apply [TYPE] boolean [PARAMETER] Node ignored [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  ignored  input  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^return new Node ( Token.FUNCTION, Node .getParent (  )  , new Node ( Token.LP ) , new Node ( Token.BLOCK )  ) ;^104^105^106^^^103^107^[REPLACE] return new Node ( Token.FUNCTION, Node.newString ( Token.NAME, TEMP_NAME ) , new Node ( Token.LP ) , new Node ( Token.BLOCK )  ) ;^[METHOD] get [TYPE] Node [PARAMETER] [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  ignored  input  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^return true ;^120^^^^^113^141^[REPLACE] return sourceName != null;^[METHOD] createNewFileLevelAstParallelizer [TYPE] AstParallelizer [PARAMETER] Node root [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  ignored  input  n  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^Predicate<Node> shouldSplit = new Predicate<Node> (  )  { @Override^116^^^^^113^141^[REPLACE] Predicate<Node> shouldSplit = new Predicate<Node> (  )  {^[METHOD] createNewFileLevelAstParallelizer [TYPE] AstParallelizer [PARAMETER] Node root [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  ignored  input  n  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^String sourceName =  ( String )  root.getParent ( Node.SOURCENAME_PROP ) ;^119^^^^^113^141^[REPLACE] String sourceName =  ( String )  input.getProp ( Node.SOURCENAME_PROP ) ;^[METHOD] createNewFileLevelAstParallelizer [TYPE] AstParallelizer [PARAMETER] Node root [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  ignored  input  n  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^return   Node.newString ( TEMP_NAME )  ;^128^^^^^113^141^[REPLACE] return NodeUtil.newExpr ( Node.newString ( TEMP_NAME )  ) ;^[METHOD] createNewFileLevelAstParallelizer [TYPE] AstParallelizer [PARAMETER] Node root [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  ignored  input  n  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^Predicate<Node> shouldSplit = new Predicate<Node> (  )  { @Override^125^^^^^113^141^[REPLACE] Supplier<Node> placeHolders = new Supplier<Node> (  )  {^[METHOD] createNewFileLevelAstParallelizer [TYPE] AstParallelizer [PARAMETER] Node root [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  ignored  input  n  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^return n.newString (  )  == Token.BLOCK;^136^^^^^113^141^[REPLACE] return n.getType (  )  == Token.BLOCK;^[METHOD] createNewFileLevelAstParallelizer [TYPE] AstParallelizer [PARAMETER] Node root [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  ignored  input  n  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^Predicate<Node> shouldTraverse = new Predicate<Node> (  )  { @Override^133^^^^^113^141^[REPLACE] Predicate<Node> shouldTraverse = new Predicate<Node> (  )  {^[METHOD] createNewFileLevelAstParallelizer [TYPE] AstParallelizer [PARAMETER] Node root [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  ignored  input  n  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^return new AstParallelizer ( shouldSplit, shouldTraverse, placeHolders, root, globalPass ) ;^139^140^^^^113^141^[REPLACE] return new AstParallelizer ( shouldSplit, shouldTraverse, placeHolders, root, false ) ;^[METHOD] createNewFileLevelAstParallelizer [TYPE] AstParallelizer [PARAMETER] Node root [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  ignored  input  n  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^String sourceName =  ( String )  root.getParent ( Node.SOURCENAME_PROP ) ;^119^^^^^118^121^[REPLACE] String sourceName =  ( String )  input.getProp ( Node.SOURCENAME_PROP ) ;^[METHOD] apply [TYPE] boolean [PARAMETER] Node input [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  ignored  input  n  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^return TEMP_NAME ;^120^^^^^118^121^[REPLACE] return sourceName != null;^[METHOD] apply [TYPE] boolean [PARAMETER] Node input [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  ignored  input  n  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^return NodeUtil.newExpr ( Node.addChildToFront ( TEMP_NAME )  ) ;^128^^^^^127^129^[REPLACE] return NodeUtil.newExpr ( Node.newString ( TEMP_NAME )  ) ;^[METHOD] get [TYPE] Node [PARAMETER] [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  ignored  input  n  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^return n.newString (  )  == Token.BLOCK;^136^^^^^135^137^[REPLACE] return n.getType (  )  == Token.BLOCK;^[METHOD] apply [TYPE] boolean [PARAMETER] Node n [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  ignored  input  n  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^detachPointList.add ( new DettachPoint ( root, before, orginal )  ) ;^147^^^^^146^148^[REPLACE] detachPointList.add ( new DettachPoint ( placeHolder, before, orginal )  ) ;^[METHOD] recordSplitPoint [TYPE] void [PARAMETER] Node placeHolder Node before Node orginal [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  ignored  input  n  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^if  ( shouldSplit.apply ( c )  )  {^156^^^^^155^161^[REPLACE] if  ( includeRoot )  {^[METHOD] split [TYPE] List [PARAMETER] [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  ignored  input  n  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[ADD]^forest.add ( root ) ;^156^157^158^^^155^161^[ADD] if  ( includeRoot )  { forest.add ( root ) ; }^[METHOD] split [TYPE] List [PARAMETER] [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  ignored  input  n  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^split ( root ) ;^157^^^^^155^161^[REPLACE] forest.add ( root ) ;^[METHOD] split [TYPE] List [PARAMETER] [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  ignored  input  n  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^forest.add ( root ) ;^159^^^^^155^161^[REPLACE] split ( root ) ;^[METHOD] split [TYPE] List [PARAMETER] [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  ignored  input  n  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^return sourceName != null;^160^^^^^155^161^[REPLACE] return forest;^[METHOD] split [TYPE] List [PARAMETER] [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  ignored  input  n  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^Node c = original.getFirstChild (  ) ;^164^^^^^163^186^[REPLACE] Node c = n.getFirstChild (  ) ;^[METHOD] split [TYPE] void [PARAMETER] Node n [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  c  ignored  input  n  next  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^Node before = true;^165^^^^^163^186^[REPLACE] Node before = null;^[METHOD] split [TYPE] void [PARAMETER] Node n [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  c  ignored  input  n  next  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^while  ( c ==placeHolder )  {^166^^^^^163^186^[REPLACE] while  ( c != null )  {^[METHOD] split [TYPE] void [PARAMETER] Node n [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  c  ignored  input  n  next  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^if  ( includeRoot )  {^168^^^^^163^186^[REPLACE] if  ( shouldSplit.apply ( c )  )  {^[METHOD] split [TYPE] void [PARAMETER] Node n [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  c  ignored  input  n  next  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[ADD]^^168^169^170^171^172^163^186^[ADD] if  ( shouldSplit.apply ( c )  )  { Node placeHolder = placeHolderProvider.get (  ) ; if  ( before == null )  { forest.add ( n.removeFirstChild (  )  ) ; n.addChildToFront ( placeHolder ) ;^[METHOD] split [TYPE] void [PARAMETER] Node n [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  c  ignored  input  n  next  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^before =  placeHolder;^182^^^^^163^186^[REPLACE] before = c;^[METHOD] split [TYPE] void [PARAMETER] Node n [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  c  ignored  input  n  next  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^if  (root != null )  {^170^^^^^163^186^[REPLACE] if  ( before == null )  {^[METHOD] split [TYPE] void [PARAMETER] Node n [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  c  ignored  input  n  next  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^n .removeChildAfter ( next )  ;^174^^^^^163^186^[REPLACE] n.addChildAfter ( placeHolder, c ) ;^[METHOD] split [TYPE] void [PARAMETER] Node n [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  c  ignored  input  n  next  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^n.addChildToFront ( before ) ;^175^^^^^163^186^[REPLACE] n.removeChildAfter ( before ) ;^[METHOD] split [TYPE] void [PARAMETER] Node n [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  c  ignored  input  n  next  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^forest.add ( placeHolder ) ;^176^^^^^163^186^[REPLACE] forest.add ( c ) ;^[METHOD] split [TYPE] void [PARAMETER] Node n [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  c  ignored  input  n  next  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REMOVE]^forest.add ( root ) ;^176^^^^^163^186^[REMOVE] ^[METHOD] split [TYPE] void [PARAMETER] Node n [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  c  ignored  input  n  next  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^forest.add ( original.removeFirstChild (  )  ) ;^171^^^^^163^186^[REPLACE] forest.add ( n.removeFirstChild (  )  ) ;^[METHOD] split [TYPE] void [PARAMETER] Node n [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  c  ignored  input  n  next  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^n .addChildAfter ( ignored , original )  ;^172^^^^^163^186^[REPLACE] n.addChildToFront ( placeHolder ) ;^[METHOD] split [TYPE] void [PARAMETER] Node n [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  c  ignored  input  n  next  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^before =  root;^179^^^^^163^186^[REPLACE] before = placeHolder;^[METHOD] split [TYPE] void [PARAMETER] Node n [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  c  ignored  input  n  next  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^Node placeHolder = placeHolderProvider .get (  )  ;^169^^^^^163^186^[REPLACE] Node placeHolder = placeHolderProvider.get (  ) ;^[METHOD] split [TYPE] void [PARAMETER] Node n [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  c  ignored  input  n  next  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^if  ( before != false )  {^170^^^^^163^186^[REPLACE] if  ( before == null )  {^[METHOD] split [TYPE] void [PARAMETER] Node n [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  c  ignored  input  n  next  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^n.addChildAfter ( root, c ) ;^174^^^^^163^186^[REPLACE] n.addChildAfter ( placeHolder, c ) ;^[METHOD] split [TYPE] void [PARAMETER] Node n [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  c  ignored  input  n  next  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[ADD]^^175^176^177^^^163^186^[ADD] n.removeChildAfter ( before ) ; forest.add ( c ) ; }^[METHOD] split [TYPE] void [PARAMETER] Node n [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  c  ignored  input  n  next  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[ADD]^^171^172^173^174^175^163^186^[ADD] forest.add ( n.removeFirstChild (  )  ) ; n.addChildToFront ( placeHolder ) ; } else { n.addChildAfter ( placeHolder, c ) ; n.removeChildAfter ( before ) ;^[METHOD] split [TYPE] void [PARAMETER] Node n [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  c  ignored  input  n  next  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^forest.add ( original .getFirstChild (  )   ) ;^171^^^^^163^186^[REPLACE] forest.add ( n.removeFirstChild (  )  ) ;^[METHOD] split [TYPE] void [PARAMETER] Node n [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  c  ignored  input  n  next  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^n.removeChildAfter ( placeHolder ) ;^172^^^^^163^186^[REPLACE] n.addChildToFront ( placeHolder ) ;^[METHOD] split [TYPE] void [PARAMETER] Node n [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  c  ignored  input  n  next  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^before =  null;^182^^^^^163^186^[REPLACE] before = c;^[METHOD] split [TYPE] void [PARAMETER] Node n [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  c  ignored  input  n  next  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^c =  root;^184^^^^^163^186^[REPLACE] c = next;^[METHOD] split [TYPE] void [PARAMETER] Node n [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  c  ignored  input  n  next  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^Node next = c.getParent (  ) ;^167^^^^^163^186^[REPLACE] Node next = c.getNext (  ) ;^[METHOD] split [TYPE] void [PARAMETER] Node n [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  c  ignored  input  n  next  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[ADD]^^182^183^^^^163^186^[ADD] before = c; }^[METHOD] split [TYPE] void [PARAMETER] Node n [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  c  ignored  input  n  next  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^if  ( before != originalull )  {^170^^^^^163^186^[REPLACE] if  ( before == null )  {^[METHOD] split [TYPE] void [PARAMETER] Node n [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  c  ignored  input  n  next  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^n .addChildAfter ( original , ignored )  ;^175^^^^^163^186^[REPLACE] n.removeChildAfter ( before ) ;^[METHOD] split [TYPE] void [PARAMETER] Node n [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  c  ignored  input  n  next  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^forest.add ( original.getFirstChild (  )  ) ;^171^^^^^163^186^[REPLACE] forest.add ( n.removeFirstChild (  )  ) ;^[METHOD] split [TYPE] void [PARAMETER] Node n [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  c  ignored  input  n  next  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^n.addChildToFront ( root ) ;^172^^^^^163^186^[REPLACE] n.addChildToFront ( placeHolder ) ;^[METHOD] split [TYPE] void [PARAMETER] Node n [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  c  ignored  input  n  next  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^if  ( before != this  )  {^170^^^^^163^186^[REPLACE] if  ( before == null )  {^[METHOD] split [TYPE] void [PARAMETER] Node n [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  c  ignored  input  n  next  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^n .removeChildAfter ( original )  ;^174^^^^^163^186^[REPLACE] n.addChildAfter ( placeHolder, c ) ;^[METHOD] split [TYPE] void [PARAMETER] Node n [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  c  ignored  input  n  next  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^n.addChildToFront ( original ) ;^172^^^^^163^186^[REPLACE] n.addChildToFront ( placeHolder ) ;^[METHOD] split [TYPE] void [PARAMETER] Node n [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  c  ignored  input  n  next  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^while  ( detachPointList.isEmpty (  )  )  {^193^^^^^191^197^[REPLACE] while  ( !detachPointList.isEmpty (  )  )  {^[METHOD] join [TYPE] void [PARAMETER] [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  c  ignored  input  n  next  orginal  original  placeHolder  root  [TYPE]  DettachPoint entry  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^DettachPoint entry = detachPointList.remove ( detachPointList.add (  )  - 5 - 1 ) ;^194^^^^^191^197^[REPLACE] DettachPoint entry = detachPointList.remove ( detachPointList.size (  )  - 1 ) ;^[METHOD] join [TYPE] void [PARAMETER] [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  c  ignored  input  n  next  orginal  original  placeHolder  root  [TYPE]  DettachPoint entry  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^DettachPoint entry = detachPointList.isEmpty ( detachPointList.size (  )  - 2 - 1 ) ;^194^^^^^191^197^[REPLACE] DettachPoint entry = detachPointList.remove ( detachPointList.size (  )  - 1 ) ;^[METHOD] join [TYPE] void [PARAMETER] [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  c  ignored  input  n  next  orginal  original  placeHolder  root  [TYPE]  DettachPoint entry  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^if  ( placeHolder.getParent (  )  == null )  {^227^^^^^224^236^[REPLACE] if  ( placeHolder.getParent (  )  != null )  {^[METHOD] reattach [TYPE] void [PARAMETER] [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  c  ignored  input  n  next  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^if  (root != null )  {^228^^^^^224^236^[REPLACE] if  ( before == null )  {^[METHOD] reattach [TYPE] void [PARAMETER] [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  c  ignored  input  n  next  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^placeHolder.getParent (  )  .removeChildAfter ( c )  ;^232^^^^^224^236^[REPLACE] placeHolder.getParent (  ) .addChildAfter ( original, before ) ;^[METHOD] reattach [TYPE] void [PARAMETER] [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  c  ignored  input  n  next  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[ADD]^^232^233^234^^^224^236^[ADD] placeHolder.getParent (  ) .addChildAfter ( original, before ) ; placeHolder.getParent (  ) .removeChildAfter ( original ) ; }^[METHOD] reattach [TYPE] void [PARAMETER] [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  c  ignored  input  n  next  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^placeHolder.getProp (  ) .addChildAfter ( original, before ) ;^232^^^^^224^236^[REPLACE] placeHolder.getParent (  ) .addChildAfter ( original, before ) ;^[METHOD] reattach [TYPE] void [PARAMETER] [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  c  ignored  input  n  next  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^placeHolder.getProp (  ) .removeChildAfter ( original ) ;^233^^^^^224^236^[REPLACE] placeHolder.getParent (  ) .removeChildAfter ( original ) ;^[METHOD] reattach [TYPE] void [PARAMETER] [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  c  ignored  input  n  next  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^placeHolder.getProp (  ) .addChildrenToFront ( original ) ;^229^^^^^224^236^[REPLACE] placeHolder.getParent (  ) .addChildrenToFront ( original ) ;^[METHOD] reattach [TYPE] void [PARAMETER] [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  c  ignored  input  n  next  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[ADD]^^229^230^^^^224^236^[ADD] placeHolder.getParent (  ) .addChildrenToFront ( original ) ; placeHolder.getParent (  ) .removeChildAfter ( original ) ;^[METHOD] reattach [TYPE] void [PARAMETER] [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  c  ignored  input  n  next  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^placeHolder.getParent (  )  .addChildAfter ( placeHolder , input )  ;^230^^^^^224^236^[REPLACE] placeHolder.getParent (  ) .removeChildAfter ( original ) ;^[METHOD] reattach [TYPE] void [PARAMETER] [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  c  ignored  input  n  next  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^placeHolder.getProp (  ) .removeChildAfter ( original ) ;^230^^^^^224^236^[REPLACE] placeHolder.getParent (  ) .removeChildAfter ( original ) ;^[METHOD] reattach [TYPE] void [PARAMETER] [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  c  ignored  input  n  next  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[ADD]^^230^^^^^224^236^[ADD] placeHolder.getParent (  ) .removeChildAfter ( original ) ;^[METHOD] reattach [TYPE] void [PARAMETER] [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  c  ignored  input  n  next  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^if  ( before != this  )  {^228^^^^^224^236^[REPLACE] if  ( before == null )  {^[METHOD] reattach [TYPE] void [PARAMETER] [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  c  ignored  input  n  next  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^placeHolder.getParent (  )  .removeChildAfter ( original )  ;^232^^^^^224^236^[REPLACE] placeHolder.getParent (  ) .addChildAfter ( original, before ) ;^[METHOD] reattach [TYPE] void [PARAMETER] [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  c  ignored  input  n  next  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^placeHolder .getProp (  )  .removeChildAfter ( original ) ;^233^^^^^224^236^[REPLACE] placeHolder.getParent (  ) .removeChildAfter ( original ) ;^[METHOD] reattach [TYPE] void [PARAMETER] [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  c  ignored  input  n  next  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^placeHolder.getParent (  ) .removeChildAfter ( original ) ;^229^^^^^224^236^[REPLACE] placeHolder.getParent (  ) .addChildrenToFront ( original ) ;^[METHOD] reattach [TYPE] void [PARAMETER] [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  c  ignored  input  n  next  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^placeHolder.getParent (  ) .addChildrenToFront ( original ) ;^230^^^^^224^236^[REPLACE] placeHolder.getParent (  ) .removeChildAfter ( original ) ;^[METHOD] reattach [TYPE] void [PARAMETER] [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  c  ignored  input  n  next  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^placeHolder .getProp (  )  .removeChildAfter ( original ) ;^230^^^^^224^236^[REPLACE] placeHolder.getParent (  ) .removeChildAfter ( original ) ;^[METHOD] reattach [TYPE] void [PARAMETER] [CLASS] AstParallelizer 1 2 3 4 5 6 DettachPoint   [TYPE]  boolean false  globalPass  includeRoot  true  [TYPE]  Node before  c  ignored  input  n  next  orginal  original  placeHolder  root  [TYPE]  Supplier placeHolderProvider  placeHolders  [TYPE]  List detachPointList  forest  [TYPE]  String TEMP_NAME  sourceName  [TYPE]  Predicate shouldSplit  shouldTraverse 
[REPLACE]^return   input   ;^88^^^^^87^89^[REPLACE] return NodeUtil.isFunction ( input ) ;^[METHOD] apply [TYPE] boolean [PARAMETER] Node input [CLASS] 1   [TYPE]  boolean false  true  [TYPE]  Node input 
[REPLACE]^return false;^96^^^^^95^97^[REPLACE] return true;^[METHOD] apply [TYPE] boolean [PARAMETER] Node ignored [CLASS] 2   [TYPE]  boolean false  true  [TYPE]  Node ignored 
[ADD]^return sourceName != null;^119^120^^^^118^121^[ADD] String sourceName =  ( String )  input.getProp ( Node.SOURCENAME_PROP ) ; return sourceName != null;^[METHOD] apply [TYPE] boolean [PARAMETER] Node input [CLASS] 4   [TYPE]  boolean false  true  [TYPE]  Node input  [TYPE]  String sourceName 
[REPLACE]^return sourceName ;^120^^^^^118^121^[REPLACE] return sourceName != null;^[METHOD] apply [TYPE] boolean [PARAMETER] Node input [CLASS] 4   [TYPE]  boolean false  true  [TYPE]  Node input  [TYPE]  String sourceName 
[REPLACE]^return   Node.newString ( TEMP_NAME )  ;^128^^^^^127^129^[REPLACE] return NodeUtil.newExpr ( Node.newString ( TEMP_NAME )  ) ;^[METHOD] get [TYPE] Node [PARAMETER] [CLASS] 5   [TYPE]  boolean false  true 
[REPLACE]^return n.getType (  )   !=  Token.BLOCK;;^136^^^^^135^137^[REPLACE] return n.getType (  )  == Token.BLOCK;^[METHOD] apply [TYPE] boolean [PARAMETER] Node n [CLASS] 6   [TYPE]  boolean false  true  [TYPE]  Node n 
[REPLACE]^this.placeHolder =  original;^219^^^^^218^222^[REPLACE] this.placeHolder = placeHolder;^[METHOD] <init> [TYPE] Node) [PARAMETER] Node placeHolder Node before Node orginal [CLASS] DettachPoint   [TYPE]  Node before  orginal  original  placeHolder  [TYPE]  boolean false  true 
[REPLACE]^this.before =  placeHolder;^220^^^^^218^222^[REPLACE] this.before = before;^[METHOD] <init> [TYPE] Node) [PARAMETER] Node placeHolder Node before Node orginal [CLASS] DettachPoint   [TYPE]  Node before  orginal  original  placeHolder  [TYPE]  boolean false  true 
[REPLACE]^this.original =  placeHolder;^221^^^^^218^222^[REPLACE] this.original = orginal;^[METHOD] <init> [TYPE] Node) [PARAMETER] Node placeHolder Node before Node orginal [CLASS] DettachPoint   [TYPE]  Node before  orginal  original  placeHolder  [TYPE]  boolean false  true 
[ADD]^^221^^^^^218^222^[ADD] this.original = orginal;^[METHOD] <init> [TYPE] Node) [PARAMETER] Node placeHolder Node before Node orginal [CLASS] DettachPoint   [TYPE]  Node before  orginal  original  placeHolder  [TYPE]  boolean false  true 
[REPLACE]^if  ( placeHolder.getParent (  )  == null )  {^227^^^^^224^236^[REPLACE] if  ( placeHolder.getParent (  )  != null )  {^[METHOD] reattach [TYPE] void [PARAMETER] [CLASS] DettachPoint   [TYPE]  Node before  orginal  original  placeHolder  [TYPE]  boolean false  true 
[REPLACE]^if  (placeHolder != null )  {^228^^^^^224^236^[REPLACE] if  ( before == null )  {^[METHOD] reattach [TYPE] void [PARAMETER] [CLASS] DettachPoint   [TYPE]  Node before  orginal  original  placeHolder  [TYPE]  boolean false  true 
[REPLACE]^placeHolder.getParent (  ) .removeChildAfter ( original, before ) ;^232^^^^^224^236^[REPLACE] placeHolder.getParent (  ) .addChildAfter ( original, before ) ;^[METHOD] reattach [TYPE] void [PARAMETER] [CLASS] DettachPoint   [TYPE]  Node before  orginal  original  placeHolder  [TYPE]  boolean false  true 
[REPLACE]^placeHolder.getParent (  ) .removeChildAfter ( original ) ;^232^^^^^224^236^[REPLACE] placeHolder.getParent (  ) .addChildAfter ( original, before ) ;^[METHOD] reattach [TYPE] void [PARAMETER] [CLASS] DettachPoint   [TYPE]  Node before  orginal  original  placeHolder  [TYPE]  boolean false  true 
[REPLACE]^placeHolder.getParent (  )  .addChildAfter ( original , before )  ;^233^^^^^224^236^[REPLACE] placeHolder.getParent (  ) .removeChildAfter ( original ) ;^[METHOD] reattach [TYPE] void [PARAMETER] [CLASS] DettachPoint   [TYPE]  Node before  orginal  original  placeHolder  [TYPE]  boolean false  true 
[ADD]^^233^^^^^224^236^[ADD] placeHolder.getParent (  ) .removeChildAfter ( original ) ;^[METHOD] reattach [TYPE] void [PARAMETER] [CLASS] DettachPoint   [TYPE]  Node before  orginal  original  placeHolder  [TYPE]  boolean false  true 
[REPLACE]^placeHolder.getParent (  ) .addChildAfter ( original, before ) ;^233^^^^^224^236^[REPLACE] placeHolder.getParent (  ) .removeChildAfter ( original ) ;^[METHOD] reattach [TYPE] void [PARAMETER] [CLASS] DettachPoint   [TYPE]  Node before  orginal  original  placeHolder  [TYPE]  boolean false  true 
[REPLACE]^placeHolder.getParent (  ) .addChildAfter ( original, before ) ;^229^^^^^224^236^[REPLACE] placeHolder.getParent (  ) .addChildrenToFront ( original ) ;^[METHOD] reattach [TYPE] void [PARAMETER] [CLASS] DettachPoint   [TYPE]  Node before  orginal  original  placeHolder  [TYPE]  boolean false  true 
[ADD]^^229^^^^^224^236^[ADD] placeHolder.getParent (  ) .addChildrenToFront ( original ) ;^[METHOD] reattach [TYPE] void [PARAMETER] [CLASS] DettachPoint   [TYPE]  Node before  orginal  original  placeHolder  [TYPE]  boolean false  true 
[REPLACE]^placeHolder.getParent (  )  .addChildAfter ( before , original )  ;^230^^^^^224^236^[REPLACE] placeHolder.getParent (  ) .removeChildAfter ( original ) ;^[METHOD] reattach [TYPE] void [PARAMETER] [CLASS] DettachPoint   [TYPE]  Node before  orginal  original  placeHolder  [TYPE]  boolean false  true 
[REPLACE]^placeHolder.getParent (  ) .addChildAfter ( original, before ) ;^230^^^^^224^236^[REPLACE] placeHolder.getParent (  ) .removeChildAfter ( original ) ;^[METHOD] reattach [TYPE] void [PARAMETER] [CLASS] DettachPoint   [TYPE]  Node before  orginal  original  placeHolder  [TYPE]  boolean false  true 
[ADD]^^230^^^^^224^236^[ADD] placeHolder.getParent (  ) .removeChildAfter ( original ) ;^[METHOD] reattach [TYPE] void [PARAMETER] [CLASS] DettachPoint   [TYPE]  Node before  orginal  original  placeHolder  [TYPE]  boolean false  true 
[REPLACE]^if  ( before != null )  {^228^^^^^224^236^[REPLACE] if  ( before == null )  {^[METHOD] reattach [TYPE] void [PARAMETER] [CLASS] DettachPoint   [TYPE]  Node before  orginal  original  placeHolder  [TYPE]  boolean false  true 
[ADD]^^229^230^^^^224^236^[ADD] placeHolder.getParent (  ) .addChildrenToFront ( original ) ; placeHolder.getParent (  ) .removeChildAfter ( original ) ;^[METHOD] reattach [TYPE] void [PARAMETER] [CLASS] DettachPoint   [TYPE]  Node before  orginal  original  placeHolder  [TYPE]  boolean false  true 
