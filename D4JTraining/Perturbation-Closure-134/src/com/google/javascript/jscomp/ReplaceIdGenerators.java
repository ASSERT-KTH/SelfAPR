[REPLACE]^final DiagnosticType NON_GLOBAL_ID_GENERATOR_CALL = DiagnosticType.error ( "JSC_NON_GLOBAL_ID_GENERATOR_CALL", "Id generator call must be in the global scope" ) ;^36^37^38^39^^36^39^[REPLACE] static final DiagnosticType NON_GLOBAL_ID_GENERATOR_CALL = DiagnosticType.error ( "JSC_NON_GLOBAL_ID_GENERATOR_CALL", "Id generator call must be in the global scope" ) ;^ [CLASS] ReplaceIdGenerators Callback  
[REPLACE]^static final DiagnosticType CONDITIONAL_ID_GENERATOR_CALL  = null ;^41^42^43^44^^41^44^[REPLACE] static final DiagnosticType CONDITIONAL_ID_GENERATOR_CALL = DiagnosticType.error ( "JSC_CONDITIONAL_ID_GENERATOR_CALL", "Id generator call must be unconditional" ) ;^ [CLASS] ReplaceIdGenerators Callback  
[REPLACE]^if  ( parent.newString (  )   ==  Token.CALL )  {^66^^^^^65^94^[REPLACE] if  ( n.getType (  )  != Token.CALL )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] ReplaceIdGenerators Callback   [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType CONDITIONAL_ID_GENERATOR_CALL  NON_GLOBAL_ID_GENERATOR_CALL  [TYPE]  Node ancestor  n  parent  [TYPE]  NameGenerator nameGenerator  [TYPE]  String callName  nextName  [TYPE]  Map nameGenerators 
[ADD]^^66^67^68^^^65^94^[ADD] if  ( n.getType (  )  != Token.CALL )  { return; }^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] ReplaceIdGenerators Callback   [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType CONDITIONAL_ID_GENERATOR_CALL  NON_GLOBAL_ID_GENERATOR_CALL  [TYPE]  Node ancestor  n  parent  [TYPE]  NameGenerator nameGenerator  [TYPE]  String callName  nextName  [TYPE]  Map nameGenerators 
[REPLACE]^return;  ;^67^^^^^65^94^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] ReplaceIdGenerators Callback   [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType CONDITIONAL_ID_GENERATOR_CALL  NON_GLOBAL_ID_GENERATOR_CALL  [TYPE]  Node ancestor  n  parent  [TYPE]  NameGenerator nameGenerator  [TYPE]  String callName  nextName  [TYPE]  Map nameGenerators 
[REPLACE]^String callName = parent.getFirstChild (  ) .getQualifiedName (  ) ;^70^^^^^65^94^[REPLACE] String callName = n.getFirstChild (  ) .getQualifiedName (  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] ReplaceIdGenerators Callback   [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType CONDITIONAL_ID_GENERATOR_CALL  NON_GLOBAL_ID_GENERATOR_CALL  [TYPE]  Node ancestor  n  parent  [TYPE]  NameGenerator nameGenerator  [TYPE]  String callName  nextName  [TYPE]  Map nameGenerators 
[REPLACE]^NameGenerator nameGenerator = nameGenerators.get ( nextName ) ;^71^^^^^65^94^[REPLACE] NameGenerator nameGenerator = nameGenerators.get ( callName ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] ReplaceIdGenerators Callback   [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType CONDITIONAL_ID_GENERATOR_CALL  NON_GLOBAL_ID_GENERATOR_CALL  [TYPE]  Node ancestor  n  parent  [TYPE]  NameGenerator nameGenerator  [TYPE]  String callName  nextName  [TYPE]  Map nameGenerators 
[REPLACE]^if  ( nameGenerator != null )  {^72^^^^^65^94^[REPLACE] if  ( nameGenerator == null )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] ReplaceIdGenerators Callback   [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType CONDITIONAL_ID_GENERATOR_CALL  NON_GLOBAL_ID_GENERATOR_CALL  [TYPE]  Node ancestor  n  parent  [TYPE]  NameGenerator nameGenerator  [TYPE]  String callName  nextName  [TYPE]  Map nameGenerators 
[REPLACE]^return;  ;^73^^^^^65^94^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] ReplaceIdGenerators Callback   [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType CONDITIONAL_ID_GENERATOR_CALL  NON_GLOBAL_ID_GENERATOR_CALL  [TYPE]  Node ancestor  n  parent  [TYPE]  NameGenerator nameGenerator  [TYPE]  String callName  nextName  [TYPE]  Map nameGenerators 
[REPLACE]^if  ( t.inGlobalScope (  )  )  {^76^^^^^65^94^[REPLACE] if  ( !t.inGlobalScope (  )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] ReplaceIdGenerators Callback   [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType CONDITIONAL_ID_GENERATOR_CALL  NON_GLOBAL_ID_GENERATOR_CALL  [TYPE]  Node ancestor  n  parent  [TYPE]  NameGenerator nameGenerator  [TYPE]  String callName  nextName  [TYPE]  Map nameGenerators 
[ADD]^^76^77^78^79^80^65^94^[ADD] if  ( !t.inGlobalScope (  )  )  {  compiler.report ( JSError.make ( t, n, NON_GLOBAL_ID_GENERATOR_CALL )  ) ; return; }^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] ReplaceIdGenerators Callback   [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType CONDITIONAL_ID_GENERATOR_CALL  NON_GLOBAL_ID_GENERATOR_CALL  [TYPE]  Node ancestor  n  parent  [TYPE]  NameGenerator nameGenerator  [TYPE]  String callName  nextName  [TYPE]  Map nameGenerators 
[REPLACE]^return;  ;^79^^^^^65^94^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] ReplaceIdGenerators Callback   [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType CONDITIONAL_ID_GENERATOR_CALL  NON_GLOBAL_ID_GENERATOR_CALL  [TYPE]  Node ancestor  n  parent  [TYPE]  NameGenerator nameGenerator  [TYPE]  String callName  nextName  [TYPE]  Map nameGenerators 
[REPLACE]^if  ( NodeUtil.isControlStructure ( parent )  )  {^83^^^^^65^94^[REPLACE] if  ( NodeUtil.isControlStructure ( ancestor )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] ReplaceIdGenerators Callback   [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType CONDITIONAL_ID_GENERATOR_CALL  NON_GLOBAL_ID_GENERATOR_CALL  [TYPE]  Node ancestor  n  parent  [TYPE]  NameGenerator nameGenerator  [TYPE]  String callName  nextName  [TYPE]  Map nameGenerators 
[ADD]^^83^84^85^86^87^65^94^[ADD] if  ( NodeUtil.isControlStructure ( ancestor )  )  {  compiler.report ( JSError.make ( t, n, CONDITIONAL_ID_GENERATOR_CALL )  ) ; return; }^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] ReplaceIdGenerators Callback   [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType CONDITIONAL_ID_GENERATOR_CALL  NON_GLOBAL_ID_GENERATOR_CALL  [TYPE]  Node ancestor  n  parent  [TYPE]  NameGenerator nameGenerator  [TYPE]  String callName  nextName  [TYPE]  Map nameGenerators 
[REPLACE]^return;  ;^86^^^^^65^94^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] ReplaceIdGenerators Callback   [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType CONDITIONAL_ID_GENERATOR_CALL  NON_GLOBAL_ID_GENERATOR_CALL  [TYPE]  Node ancestor  n  parent  [TYPE]  NameGenerator nameGenerator  [TYPE]  String callName  nextName  [TYPE]  Map nameGenerators 
[REPLACE]^for  ( Node ancestor : parent.getAncestors (  )  )  {^82^^^^^65^94^[REPLACE] for  ( Node ancestor : n.getAncestors (  )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] ReplaceIdGenerators Callback   [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType CONDITIONAL_ID_GENERATOR_CALL  NON_GLOBAL_ID_GENERATOR_CALL  [TYPE]  Node ancestor  n  parent  [TYPE]  NameGenerator nameGenerator  [TYPE]  String callName  nextName  [TYPE]  Map nameGenerators 
[ADD]^^82^83^^85^86^65^94^[ADD] for  ( Node ancestor : n.getAncestors (  )  )  { if  ( NodeUtil.isControlStructure ( ancestor )  )  { compiler.report ( JSError.make ( t, n, CONDITIONAL_ID_GENERATOR_CALL )  ) ; return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] ReplaceIdGenerators Callback   [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType CONDITIONAL_ID_GENERATOR_CALL  NON_GLOBAL_ID_GENERATOR_CALL  [TYPE]  Node ancestor  n  parent  [TYPE]  NameGenerator nameGenerator  [TYPE]  String callName  nextName  [TYPE]  Map nameGenerators 
[REPLACE]^String idGenerator  ;^90^^^^^65^94^[REPLACE] String nextName = nameGenerator.generateNextName (  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] ReplaceIdGenerators Callback   [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType CONDITIONAL_ID_GENERATOR_CALL  NON_GLOBAL_ID_GENERATOR_CALL  [TYPE]  Node ancestor  n  parent  [TYPE]  NameGenerator nameGenerator  [TYPE]  String callName  nextName  [TYPE]  Map nameGenerators 
[REPLACE]^parent.replaceChild ( n, Node.replaceChild ( nextName )  ) ;^91^^^^^65^94^[REPLACE] parent.replaceChild ( n, Node.newString ( nextName )  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] ReplaceIdGenerators Callback   [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType CONDITIONAL_ID_GENERATOR_CALL  NON_GLOBAL_ID_GENERATOR_CALL  [TYPE]  Node ancestor  n  parent  [TYPE]  NameGenerator nameGenerator  [TYPE]  String callName  nextName  [TYPE]  Map nameGenerators 
[REPLACE]^parent.replaceChild ( n, newString ( nextName )  )  ;^91^^^^^65^94^[REPLACE] parent.replaceChild ( n, Node.newString ( nextName )  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] ReplaceIdGenerators Callback   [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType CONDITIONAL_ID_GENERATOR_CALL  NON_GLOBAL_ID_GENERATOR_CALL  [TYPE]  Node ancestor  n  parent  [TYPE]  NameGenerator nameGenerator  [TYPE]  String callName  nextName  [TYPE]  Map nameGenerators 
[REPLACE]^compiler.report (  ) ;^93^^^^^65^94^[REPLACE] compiler.reportCodeChange (  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] ReplaceIdGenerators Callback   [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType CONDITIONAL_ID_GENERATOR_CALL  NON_GLOBAL_ID_GENERATOR_CALL  [TYPE]  Node ancestor  n  parent  [TYPE]  NameGenerator nameGenerator  [TYPE]  String callName  nextName  [TYPE]  Map nameGenerators 
[ADD]^^93^^^^^65^94^[ADD] compiler.reportCodeChange (  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] ReplaceIdGenerators Callback   [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType CONDITIONAL_ID_GENERATOR_CALL  NON_GLOBAL_ID_GENERATOR_CALL  [TYPE]  Node ancestor  n  parent  [TYPE]  NameGenerator nameGenerator  [TYPE]  String callName  nextName  [TYPE]  Map nameGenerators 
[REPLACE]^if  ( n.getType (  )   ==  Token.CALL )  {^66^^^^^65^94^[REPLACE] if  ( n.getType (  )  != Token.CALL )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] Callback   [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  Node ancestor  n  parent  [TYPE]  NameGenerator nameGenerator  [TYPE]  String callName  nextName 
[REPLACE]^return;  ;^67^^^^^65^94^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] Callback   [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  Node ancestor  n  parent  [TYPE]  NameGenerator nameGenerator  [TYPE]  String callName  nextName 
[REPLACE]^String callName = parent.getFirstChild (  ) .getQualifiedName (  ) ;^70^^^^^65^94^[REPLACE] String callName = n.getFirstChild (  ) .getQualifiedName (  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] Callback   [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  Node ancestor  n  parent  [TYPE]  NameGenerator nameGenerator  [TYPE]  String callName  nextName 
[ADD]^^71^^^^^65^94^[ADD] NameGenerator nameGenerator = nameGenerators.get ( callName ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] Callback   [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  Node ancestor  n  parent  [TYPE]  NameGenerator nameGenerator  [TYPE]  String callName  nextName 
[REPLACE]^if  ( nameGenerator != this )  {^72^^^^^65^94^[REPLACE] if  ( nameGenerator == null )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] Callback   [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  Node ancestor  n  parent  [TYPE]  NameGenerator nameGenerator  [TYPE]  String callName  nextName 
[REPLACE]^return;  ;^73^^^^^65^94^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] Callback   [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  Node ancestor  n  parent  [TYPE]  NameGenerator nameGenerator  [TYPE]  String callName  nextName 
[REPLACE]^if  ( t.inGlobalScope (  )  )  {^76^^^^^65^94^[REPLACE] if  ( !t.inGlobalScope (  )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] Callback   [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  Node ancestor  n  parent  [TYPE]  NameGenerator nameGenerator  [TYPE]  String callName  nextName 
[REPLACE]^return;  ;^79^^^^^65^94^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] Callback   [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  Node ancestor  n  parent  [TYPE]  NameGenerator nameGenerator  [TYPE]  String callName  nextName 
[REPLACE]^if  ( NodeUtil.isControlStructure ( parent )  )  {^83^^^^^65^94^[REPLACE] if  ( NodeUtil.isControlStructure ( ancestor )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] Callback   [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  Node ancestor  n  parent  [TYPE]  NameGenerator nameGenerator  [TYPE]  String callName  nextName 
[ADD]^^83^84^85^86^87^65^94^[ADD] if  ( NodeUtil.isControlStructure ( ancestor )  )  {  compiler.report ( JSError.make ( t, n, CONDITIONAL_ID_GENERATOR_CALL )  ) ; return; }^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] Callback   [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  Node ancestor  n  parent  [TYPE]  NameGenerator nameGenerator  [TYPE]  String callName  nextName 
[REPLACE]^return;  ;^86^^^^^65^94^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] Callback   [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  Node ancestor  n  parent  [TYPE]  NameGenerator nameGenerator  [TYPE]  String callName  nextName 
[REPLACE]^for  ( Node ancestor : parent.getAncestors (  )  )  {^82^^^^^65^94^[REPLACE] for  ( Node ancestor : n.getAncestors (  )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] Callback   [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  Node ancestor  n  parent  [TYPE]  NameGenerator nameGenerator  [TYPE]  String callName  nextName 
[REPLACE]^String nextName = nameGenerator.generateNextName (  )  ;^82^^^^^65^94^[REPLACE] for  ( Node ancestor : n.getAncestors (  )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] Callback   [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  Node ancestor  n  parent  [TYPE]  NameGenerator nameGenerator  [TYPE]  String callName  nextName 
[REPLACE]^String callName = n.getFirstChild (  ) .getQualifiedName (  )  ;^90^^^^^65^94^[REPLACE] String nextName = nameGenerator.generateNextName (  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] Callback   [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  Node ancestor  n  parent  [TYPE]  NameGenerator nameGenerator  [TYPE]  String callName  nextName 
[REPLACE]^newString ( nextName )  ;^91^^^^^65^94^[REPLACE] parent.replaceChild ( n, Node.newString ( nextName )  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] Callback   [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  Node ancestor  n  parent  [TYPE]  NameGenerator nameGenerator  [TYPE]  String callName  nextName 
[REPLACE]^parent.replaceChild ( n, newString ( nextName )  )  ;^91^^^^^65^94^[REPLACE] parent.replaceChild ( n, Node.newString ( nextName )  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] Callback   [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  Node ancestor  n  parent  [TYPE]  NameGenerator nameGenerator  [TYPE]  String callName  nextName 
[REPLACE]^compiler .report (  )  ;^93^^^^^65^94^[REPLACE] compiler.reportCodeChange (  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] Callback   [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  Node ancestor  n  parent  [TYPE]  NameGenerator nameGenerator  [TYPE]  String callName  nextName 
