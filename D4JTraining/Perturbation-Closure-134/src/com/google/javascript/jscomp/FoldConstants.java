[REPLACE]^final DiagnosticType DIVIDE_BY_0_ERROR = DiagnosticType.error ( "JSC_DIVIDE_BY_0_ERROR", "Divide by 0" ) ;^40^41^42^^^40^42^[REPLACE] static final DiagnosticType DIVIDE_BY_0_ERROR = DiagnosticType.error ( "JSC_DIVIDE_BY_0_ERROR", "Divide by 0" ) ;^ [CLASS] FoldConstants 1 2  
[REPLACE]^final DiagnosticType INVALID_GETELEM_INDEX_ERROR = DiagnosticType.error ( "JSC_INVALID_GETELEM_INDEX_ERROR", "Array index not integer: {0}" ) ;^44^45^46^47^^44^47^[REPLACE] static final DiagnosticType INVALID_GETELEM_INDEX_ERROR = DiagnosticType.error ( "JSC_INVALID_GETELEM_INDEX_ERROR", "Array index not integer: {0}" ) ;^ [CLASS] FoldConstants 1 2  
[REPLACE]^static final DiagnosticType INDEX_OUT_OF_BOUNDS_ERROR  = null ;^49^50^51^52^^49^52^[REPLACE] static final DiagnosticType INDEX_OUT_OF_BOUNDS_ERROR = DiagnosticType.error ( "JSC_INDEX_OUT_OF_BOUNDS_ERROR", "Array index out of bounds: {0}" ) ;^ [CLASS] FoldConstants 1 2  
[REPLACE]^static  DiagnosticType NEGATING_A_NON_NUMBER_ERROR = DiagnosticType.error ( "JSC_NEGATING_A_NON_NUMBER_ERROR", "Can't negate non-numeric value: {0}" ) ;^54^55^56^57^^54^57^[REPLACE] static final DiagnosticType NEGATING_A_NON_NUMBER_ERROR = DiagnosticType.error ( "JSC_NEGATING_A_NON_NUMBER_ERROR", "Can't negate non-numeric value: {0}" ) ;^ [CLASS] FoldConstants 1 2  
[REPLACE]^static final DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS ;^59^60^61^62^^59^62^[REPLACE] static final DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS = DiagnosticType.error ( "JSC_INVALID_REGULAR_EXPRESSION_FLAGS", "Invalid flags to RegExp constructor: {0}" ) ;^ [CLASS] FoldConstants 1 2  
[REPLACE]^static  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE = DiagnosticType.error ( "JSC_BITWISE_OPERAND_OUT_OF_RANGE", "Operand out of range, bitwise operation will lose information: {0}" ) ;^64^65^66^67^^64^67^[REPLACE] static final DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE = DiagnosticType.error ( "JSC_BITWISE_OPERAND_OUT_OF_RANGE", "Operand out of range, bitwise operation will lose information: {0}" ) ;^ [CLASS] FoldConstants 1 2  
[REPLACE]^static  DiagnosticType SHIFT_AMOUNT_OUT_OF_BOUNDS = DiagnosticType.error ( "JSC_SHIFT_AMOUNT_OUT_OF_BOUNDS", "Shift amount out of bounds: {0}" ) ;^69^70^71^^^69^71^[REPLACE] static final DiagnosticType SHIFT_AMOUNT_OUT_OF_BOUNDS = DiagnosticType.error ( "JSC_SHIFT_AMOUNT_OUT_OF_BOUNDS", "Shift amount out of bounds: {0}" ) ;^ [CLASS] FoldConstants 1 2  
[REPLACE]^final DiagnosticType FRACTIONAL_BITWISE_OPERAND = DiagnosticType.error ( "JSC_FRACTIONAL_BITWISE_OPERAND", "Fractional bitwise operand: {0}" ) ;^73^74^75^^^73^75^[REPLACE] static final DiagnosticType FRACTIONAL_BITWISE_OPERAND = DiagnosticType.error ( "JSC_FRACTIONAL_BITWISE_OPERAND", "Fractional bitwise operand: {0}" ) ;^ [CLASS] FoldConstants 1 2  
[REPLACE]^private static  int AND_PRECEDENCE = NodeUtil.precedence ( Token.AND ) ;^77^^^^^^^[REPLACE] private static final int AND_PRECEDENCE = NodeUtil.precedence ( Token.AND ) ;^ [CLASS] FoldConstants 1 2  
[REPLACE]^private static final int OR_PRECEDENCE ;^78^^^^^^^[REPLACE] private static final int OR_PRECEDENCE = NodeUtil.precedence ( Token.OR ) ;^ [CLASS] FoldConstants 1 2  
[REPLACE]^private  AbstractCompiler compiler;^80^^^^^^^[REPLACE] private final AbstractCompiler compiler;^ [CLASS] FoldConstants 1 2  
[REPLACE]^private static final Pattern REGEXP_FLAGS_RE ;^1681^^^^^^^[REPLACE] private static final Pattern REGEXP_FLAGS_RE = Pattern.compile ( "^[gmi]*$" ) ;^ [CLASS] FoldConstants 1 2  
[REPLACE]^this.compiler =  null;^83^^^^^82^84^[REPLACE] this.compiler = compiler;^[METHOD] <init> [TYPE] AbstractCompiler) [PARAMETER] AbstractCompiler compiler [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE 
[REPLACE]^Node thenBranch = cond.getNext (  ) ;^87^^^^^86^88^[REPLACE] NodeTraversal.traverse ( compiler, jsRoot, this ) ;^[METHOD] process [TYPE] void [PARAMETER] Node externs Node jsRoot [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  [TYPE]  Node externs  jsRoot 
[REPLACE]^int type = parent.getType (  ) ;^91^^^^^90^382^[REPLACE] int type = n.getType (  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( type  &&  Token.BLOCK )  {^93^^^^^90^382^[REPLACE] if  ( type == Token.BLOCK )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^return lower[0];^95^^^^^90^382^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^Node left = parent.getFirstChild (  ) ;^98^^^^^90^382^[REPLACE] Node left = n.getFirstChild (  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( left != null )  {^99^^^^^90^382^[REPLACE] if  ( left == null )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^return lower[0];^100^^^^^90^382^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( type == Token.TYPEOF || NodeUtil.isLiteralValue ( right )  )  {^103^^^^^90^382^[REPLACE] if  ( type == Token.TYPEOF && NodeUtil.isLiteralValue ( left )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^String newValue = null;^103^104^^106^107^90^382^[ADD] if  ( type == Token.TYPEOF && NodeUtil.isLiteralValue ( left )  )  { String newValue = null; switch  ( left.getType (  )  )  { case Token.STRING:^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( "undefined".equals ( right.toString (  )  )  )  {^125^^^^^90^382^[REPLACE] if  ( "undefined".equals ( left.getString (  )  )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^newValue = "undefined";^125^126^127^^^90^382^[ADD] if  ( "undefined".equals ( left.getString (  )  )  )  { newValue = "undefined"; }^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^newValue ;^126^^^^^90^382^[REPLACE] newValue = "undefined";^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( newValue == null )  {^131^^^^^90^382^[REPLACE] if  ( newValue != null )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^parent.replaceChild ( n, Node.newString ( className )  ) ;^132^^^^^90^382^[REPLACE] parent.replaceChild ( n, Node.newString ( newValue )  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REMOVE]^knownLength = left.getString (  ) .length (  ) ;^132^^^^^90^382^[REMOVE] ^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^t.getScope (  ) .reportCodeChange (  ) ;^133^^^^^90^382^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REMOVE]^right.getFirstChild (  ) .getNext (  )  != right.getLastChild (  )  )  {^133^^^^^90^382^[REMOVE] ^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^newValue  =  newValue ;^108^^^^^90^382^[REPLACE] newValue = "string";^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^newValue = "boolean"; ;^111^^^^^90^382^[REPLACE] newValue = "number";^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^^111^^^^^90^382^[ADD] newValue = "number";^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^newValue = "object"; ;^115^^^^^90^382^[REPLACE] newValue = "boolean";^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^newValue = "boolean"; ;^120^^^^^90^382^[REPLACE] newValue = "object";^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^return lower[0];^136^^^^^90^382^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^String newValue = this;^104^^^^^90^382^[REPLACE] String newValue = null;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( "undefined".equals ( right.getString (  )  )  )  {^125^^^^^90^382^[REPLACE] if  ( "undefined".equals ( left.getString (  )  )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^^126^^^^^90^382^[ADD] newValue = "undefined";^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( newValue == true )  {^131^^^^^90^382^[REPLACE] if  ( newValue != null )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^parent .replaceChild ( left )  ;^132^^^^^90^382^[REPLACE] parent.replaceChild ( n, Node.newString ( newValue )  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^parent.replaceChild ( n, Node.newNumber ( className )  ) ;^132^^^^^90^382^[REPLACE] parent.replaceChild ( n, Node.newString ( newValue )  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^t .getScope (  )  .reportCodeChange (  ) ;^133^^^^^90^382^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^newValue  = null ;^108^^^^^90^382^[REPLACE] newValue = "string";^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^newValue  =  newValue ;^126^^^^^90^382^[REPLACE] newValue = "undefined";^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^String newValue = true;^104^^^^^90^382^[REPLACE] String newValue = null;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( type == Token.NOT && type == Token.NEG && type == Token.BITNOT )  {^139^140^141^^^90^382^[REPLACE] if  ( type == Token.NOT || type == Token.NEG || type == Token.BITNOT )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^^139^140^141^142^^90^382^[ADD] if  ( type == Token.NOT || type == Token.NEG || type == Token.BITNOT )  { Preconditions.checkState ( n.hasOneChild (  )  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^}  else {^216^^^^^90^382^[REPLACE] } else if  ( type == Token.NEW )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( Token.NAME  ||  left.getType (  )  )  {^217^^^^^90^382^[REPLACE] if  ( Token.NAME == left.getType (  )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^^217^218^219^220^^90^382^[ADD] if  ( Token.NAME == left.getType (  )  )  { String className = left.getString (  ) ; if  ( "RegExp".equals ( className )  )  { tryFoldRegularExpressionConstructor ( t, n, parent ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( "Array".equals ( className )  )  {^219^^^^^90^382^[REPLACE] if  ( "RegExp".equals ( className )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^}  if  ( left.getNext (  )  != null )  {^221^^^^^90^382^[REPLACE] } else if  ( left.getNext (  )  == null )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^}   t, n, parent, className, Token.ARRAYLIT ) ;^221^222^223^224^^90^382^[ADD] else if  ( left.getNext (  )  == null )  { if  ( "Array".equals ( className )  )  { tryFoldLiteralConstructor ( t, n, parent, className, Token.ARRAYLIT ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( "Array".valueOf ( className )  )  {^222^^^^^90^382^[REPLACE] if  ( "Array".equals ( className )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^^222^223^224^225^226^90^382^[ADD] if  ( "Array".equals ( className )  )  { tryFoldLiteralConstructor ( t, n, parent, className, Token.ARRAYLIT ) ; } else if  ( "Object".equals ( className )  )  { tryFoldLiteralConstructor (^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^}  else {^225^^^^^90^382^[REPLACE] } else if  ( "Object".equals ( className )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^}   t, n, parent, className, Token.OBJECTLIT ) ;^225^226^227^228^^90^382^[ADD] else if  ( "Object".equals ( className )  )  { tryFoldLiteralConstructor ( t, n, parent, className, Token.OBJECTLIT ) ; }^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^tryFoldLiteralConstructor ( t, n, right, className, Token.OBJECTLIT ) ;^226^227^^^^90^382^[REPLACE] tryFoldLiteralConstructor ( t, n, parent, className, Token.OBJECTLIT ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^tryFoldLiteralConstructor ( t, condition, parent, className, Token.ARRAYLIT ) ;^223^224^^^^90^382^[REPLACE] tryFoldLiteralConstructor ( t, n, parent, className, Token.ARRAYLIT ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^}  if  ( "Object".equals ( className )  )  {^225^^^^^90^382^[REPLACE] } else if  ( "Object".equals ( className )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( "RegExp".equals ( className )  )  {^222^^^^^90^382^[REPLACE] if  ( "Array".equals ( className )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^}  if  ( "Object".equals ( newValue )  )  {^225^^^^^90^382^[REPLACE] } else if  ( "Object".equals ( className )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^tryFoldLiteralConstructor ( t, n, parent, newValue, Token.OBJECTLIT ) ;^226^227^^^^90^382^[REPLACE] tryFoldLiteralConstructor ( t, n, parent, className, Token.OBJECTLIT ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^^226^227^^^^90^382^[ADD] tryFoldLiteralConstructor ( t, n, parent, className, Token.OBJECTLIT ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^tryFoldLiteralConstructor ( t, n, parent, newValue, Token.ARRAYLIT ) ;^223^224^^^^90^382^[REPLACE] tryFoldLiteralConstructor ( t, n, parent, className, Token.ARRAYLIT ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^tryFoldRegularExpressionConstructor ( t, n, right ) ;^220^^^^^90^382^[REPLACE] tryFoldRegularExpressionConstructor ( t, n, parent ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^}  else {^221^^^^^90^382^[REPLACE] } else if  ( left.getNext (  )  == null )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( "Array".valueOf ( newValue )  )  {^222^^^^^90^382^[REPLACE] if  ( "Array".equals ( className )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^}  if  ( "Object".valueOf ( className )  )  {^225^^^^^90^382^[REPLACE] } else if  ( "Object".equals ( className )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^tryFoldLiteralConstructor ( t, condition, parent, className, Token.OBJECTLIT ) ;^226^227^^^^90^382^[REPLACE] tryFoldLiteralConstructor ( t, n, parent, className, Token.OBJECTLIT ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^tryFoldLiteralConstructor ( t, parent, parent, className, Token.OBJECTLIT ) ;^226^227^^^^90^382^[REPLACE] tryFoldLiteralConstructor ( t, n, parent, className, Token.OBJECTLIT ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^} else if  ( "Object".equals ( newValue )  )  {^225^^^^^90^382^[REPLACE] } else if  ( "Object".equals ( className )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^String className = left.toString (  ) ;^218^^^^^90^382^[REPLACE] String className = left.getString (  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^^218^^^^^90^382^[ADD] String className = left.getString (  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^} else if  ( left.getNext (  )  != this )  {^221^^^^^90^382^[REPLACE] } else if  ( left.getNext (  )  == null )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( "Array" .valueOf ( negNum )   )  {^222^^^^^90^382^[REPLACE] if  ( "Array".equals ( className )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^} else if  ( "Object".valueOf ( className )  )  {^225^^^^^90^382^[REPLACE] } else if  ( "Object".equals ( className )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^tryFoldLiteralConstructor ( t, n, right, className, Token.ARRAYLIT ) ;^223^224^^^^90^382^[REPLACE] tryFoldLiteralConstructor ( t, n, parent, className, Token.ARRAYLIT ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^^223^224^^^^90^382^[ADD] tryFoldLiteralConstructor ( t, n, parent, className, Token.ARRAYLIT ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( "Array".equals ( newValue )  )  {^222^^^^^90^382^[REPLACE] if  ( "Array".equals ( className )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^String className = right.getString (  ) ;^218^^^^^90^382^[REPLACE] String className = left.getString (  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( Token.NAME  !=  left.getType (  )  )  {^217^^^^^90^382^[REPLACE] if  ( Token.NAME == left.getType (  )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^String className = left.getString (  ) ;tryFoldRegularExpressionConstructor ( t, n, parent ) ;^217^218^219^220^^90^382^[ADD] if  ( Token.NAME == left.getType (  )  )  { String className = left.getString (  ) ; if  ( "RegExp".equals ( className )  )  { tryFoldRegularExpressionConstructor ( t, n, parent ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( "Array" .valueOf ( val )   )  {^222^^^^^90^382^[REPLACE] if  ( "Array".equals ( className )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( "RegExp".equals ( className )  )  { tryFoldRegularExpressionConstructor ( t, n, parent ) ;^220^^^^^90^382^[REPLACE] tryFoldRegularExpressionConstructor ( t, n, parent ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^String className = right.toString (  ) ;^218^^^^^90^382^[REPLACE] String className = left.getString (  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^}  if  ( left.getNext (  )  != true )  {^221^^^^^90^382^[REPLACE] } else if  ( left.getNext (  )  == null )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^} else if  ( left.getNext (  )  != null )  {^221^^^^^90^382^[REPLACE] } else if  ( left.getNext (  )  == null )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^tryFoldLiteralConstructor ( t, parent, parent, className, Token.ARRAYLIT ) ;^223^224^^^^90^382^[REPLACE] tryFoldLiteralConstructor ( t, n, parent, className, Token.ARRAYLIT ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( name2.hasChildren (  )^225^^^^^90^382^[REPLACE] } else if  ( "Object".equals ( className )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^tryFoldLiteralConstructor ( t, n, n, className, Token.OBJECTLIT ) ;^226^227^^^^90^382^[REPLACE] tryFoldLiteralConstructor ( t, n, parent, className, Token.OBJECTLIT ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^} else if  ( "Object" .valueOf ( val )   )  {^225^^^^^90^382^[REPLACE] } else if  ( "Object".equals ( className )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( name2.hasChildren (  )^144^^^^^139^231^[REPLACE] if  ( NodeUtil.isExpressionNode ( parent )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^^144^145^^147^148^139^231^[ADD] if  ( NodeUtil.isExpressionNode ( parent )  )  {  parent.replaceChild ( n, n.removeFirstChild (  )  ) ; t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^return lower[0];^149^^^^^139^231^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( type == Token.NOT || tryMinimizeNot ( t, n, parent )  )  {^153^^^^^139^231^[REPLACE] if  ( type == Token.NOT && tryMinimizeNot ( t, n, parent )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^return lower[0];^154^^^^^139^231^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( !NodeUtil.isLiteralValue ( right )  )  {^157^^^^^139^231^[REPLACE] if  ( !NodeUtil.isLiteralValue ( left )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^return;^157^158^159^^^139^231^[ADD] if  ( !NodeUtil.isLiteralValue ( left )  )  { return; }^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^return lower[0];^158^^^^^139^231^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( left.getType (  )   ||  Token.NAME )  {^171^^^^^139^231^[REPLACE] if  ( left.getType (  )  == Token.NAME )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^} else if  ( left.getString (  ) .equals ( "NaN" )  )  {^172^^^^^139^231^[REPLACE] if  ( left.getString (  ) .equals ( "Infinity" )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^^172^173^174^175^^139^231^[ADD] if  ( left.getString (  ) .equals ( "Infinity" )  )  {  return; } else if  ( left.getString (  ) .equals ( "NaN" )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( left.getString (  ) .equals ( "Infinity" )  )  {^175^^^^^139^231^[REPLACE] } else if  ( left.getString (  ) .equals ( "NaN" )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^return lower[0];^180^^^^^139^231^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^return lower[0];^174^^^^^139^231^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^}   n.removeChild ( left ) ;parent.replaceChild ( n, left ) ;t.getCompiler (  ) .reportCodeChange (  ) ;^175^176^177^178^179^139^231^[ADD] else if  ( left.getString (  ) .equals ( "NaN" )  )  {  n.removeChild ( left ) ; parent.replaceChild ( n, left ) ; t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( left.getString (  ) .getVar ( "Infinity" )  )  {^172^^^^^139^231^[REPLACE] if  ( left.getString (  ) .equals ( "Infinity" )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^} else if  ( left.getString (  )  .valueOf ( negNum )   )  {^175^^^^^139^231^[REPLACE] } else if  ( left.getString (  ) .equals ( "NaN" )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^}  else {^175^^^^^139^231^[REPLACE] } else if  ( left.getString (  ) .equals ( "NaN" )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( val >= Integer.MIN_VALUE || val <= Integer.MAX_VALUE )  {^197^^^^^139^231^[REPLACE] if  ( val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^int intVal =  ( int )  val;parent.replaceChild ( n, Node.newNumber ( ~intVal )  ) ;t.getCompiler (  ) .reportCodeChange (  ) ;^197^198^199^200^201^139^231^[ADD] if  ( val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE )  { int intVal =  ( int )  val; if  ( intVal == val )  { parent.replaceChild ( n, Node.newNumber ( ~intVal )  ) ; t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^error ( t, FRACTIONAL_BITWISE_OPERAND, left ) ;^206^^^^^197^207^[REPLACE] error ( t, BITWISE_OPERAND_OUT_OF_RANGE, left ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^^206^^^^^197^207^[ADD] error ( t, BITWISE_OPERAND_OUT_OF_RANGE, left ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( intVal  !=  val )  {^199^^^^^139^231^[REPLACE] if  ( intVal == val )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^error ( t, FRACTIONAL_BITWISE_OPERAND, right ) ;^203^^^^^199^204^[REPLACE] error ( t, FRACTIONAL_BITWISE_OPERAND, left ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^parent.replaceChild ( n, Node.getType ( ~intVal )  ) ;^200^^^^^139^231^[REPLACE] parent.replaceChild ( n, Node.newNumber ( ~intVal )  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^parent.replaceChild ( n, Node.newNumber ( ~type )  ) ;^200^^^^^139^231^[REPLACE] parent.replaceChild ( n, Node.newNumber ( ~intVal )  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^t.getCompiler (  ) .getVar (  ) ;^201^^^^^139^231^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^t.getScope (  ) .reportCodeChange (  ) ;^201^^^^^139^231^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^int rvalInt =  ( int )  rval;^198^^^^^139^231^[REPLACE] int intVal =  ( int )  val;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( intVal  != type )  {^199^^^^^139^231^[REPLACE] if  ( intVal == val )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^t.getCompiler (  )  .replaceChild ( parent )  ;^201^^^^^139^231^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^^201^^^^^139^231^[ADD] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^t .getScope (  )  .reportCodeChange (  ) ;^201^^^^^139^231^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^return;^170^171^172^^174^139^231^[ADD] try { if  ( left.getType (  )  == Token.NAME )  { if  ( left.getString (  ) .equals ( "Infinity" )  )  { return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( left.getType (  )   !=  Token.NAME )  {^171^^^^^139^231^[REPLACE] if  ( left.getType (  )  == Token.NAME )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( left .newString ( className )  .equals ( "Infinity" )  )  {^172^^^^^139^231^[REPLACE] if  ( left.getString (  ) .equals ( "Infinity" )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^}  if  ( left.getString (  ) .equals ( "NaN" )  )  {^175^^^^^139^231^[REPLACE] } else if  ( left.getString (  ) .equals ( "NaN" )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^double negNum = -left.newNumber (  ) ;^184^^^^^139^231^[REPLACE] double negNum = -left.getDouble (  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^^184^185^^^^139^231^[ADD] double negNum = -left.getDouble (  ) ; parent.replaceChild ( n, Node.newNumber ( negNum )  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^double val = left.getDouble (  ) ;int intVal =  ( int )  val;^195^196^197^198^199^139^231^[ADD] try { double val = left.getDouble (  ) ; if  ( val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE )  { int intVal =  ( int )  val; if  ( intVal == val )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REMOVE]^if  ( intVal == val )  {     parent.replaceChild ( n, newNumber (  ( ~intVal )  )  ) ;     t.getCompiler (  ) .reportCodeChange (  ) ; }else {     error ( t, FRACTIONAL_BITWISE_OPERAND, left ) ; }^197^^^^^139^231^[REMOVE] ^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^error ( t, BITWISE_OPERAND_OUT_OF_RANGE, right ) ;^206^^^^^197^207^[REPLACE] error ( t, BITWISE_OPERAND_OUT_OF_RANGE, left ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^parent.replaceChild ( n, Node.getType ( ~type )  ) ;^200^^^^^139^231^[REPLACE] parent.replaceChild ( n, Node.newNumber ( ~intVal )  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^parent.replaceChild ( n, Node.newNumber ( ~intVal )  ) ;t.getCompiler (  ) .reportCodeChange (  ) ;error ( t, FRACTIONAL_BITWISE_OPERAND, left ) ;^199^200^201^202^203^139^231^[ADD] if  ( intVal == val )  { parent.replaceChild ( n, Node.newNumber ( ~intVal )  ) ; t.getCompiler (  ) .reportCodeChange (  ) ; } else { error ( t, FRACTIONAL_BITWISE_OPERAND, left ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^double val = right.getDouble (  ) ;^196^^^^^139^231^[REPLACE] double val = left.getDouble (  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^^196^^^^^139^231^[ADD] double val = left.getDouble (  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^return lower[0];^215^^^^^139^231^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^int result = NodeUtil.getStringValue ( left )  ? Token.FALSE : Token.TRUE;^163^164^^^^139^231^[REPLACE] int result = NodeUtil.getBooleanValue ( left )  ? Token.FALSE : Token.TRUE;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^double negNum = -left .getType (  )  ;^184^^^^^139^231^[REPLACE] double negNum = -left.getDouble (  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( NodeUtil.isExpressionNode ( right )  )  {^144^^^^^90^382^[REPLACE] if  ( NodeUtil.isExpressionNode ( parent )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^return lower[0];^149^^^^^90^382^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  (  tryMinimizeNot ( t, n, parent )  )  {^153^^^^^90^382^[REPLACE] if  ( type == Token.NOT && tryMinimizeNot ( t, n, parent )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^return lower[0];^154^^^^^90^382^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( !NodeUtil.isLiteralValue ( right )  )  {^157^^^^^90^382^[REPLACE] if  ( !NodeUtil.isLiteralValue ( left )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^return lower[0];^158^^^^^90^382^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( right.getType (  )   !=  Token.NAME )  {^171^^^^^90^382^[REPLACE] if  ( left.getType (  )  == Token.NAME )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( left.getString (  )  .valueOf ( val )   )  {^172^^^^^90^382^[REPLACE] if  ( left.getString (  ) .equals ( "Infinity" )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^}  if  ( left.getString (  ) .equals ( "NaN" )  )  {^175^^^^^90^382^[REPLACE] } else if  ( left.getString (  ) .equals ( "NaN" )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^return lower[0];^180^^^^^90^382^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^return lower[0];^174^^^^^90^382^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^}  else {^175^^^^^90^382^[REPLACE] } else if  ( left.getString (  ) .equals ( "NaN" )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^} else if  ( left.getString (  ) .equals ( "NaN" )  )  {^172^^^^^90^382^[REPLACE] if  ( left.getString (  ) .equals ( "Infinity" )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  (  val <= Integer.MAX_VALUE )  {^197^^^^^90^382^[REPLACE] if  ( val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REMOVE]^if  ( intVal == val )  {     parent.replaceChild ( n, newNumber (  ( ~intVal )  )  ) ;     t.getCompiler (  ) .reportCodeChange (  ) ; }else {     error ( t, FRACTIONAL_BITWISE_OPERAND, left ) ; }^197^^^^^90^382^[REMOVE] ^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( intVal  || type )  {^199^^^^^90^382^[REPLACE] if  ( intVal == val )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^parent.replaceChild ( n, Node.newNumber ( ~intVal )  ) ;t.getCompiler (  ) .reportCodeChange (  ) ;error ( t, FRACTIONAL_BITWISE_OPERAND, left ) ;^199^200^201^202^203^90^382^[ADD] if  ( intVal == val )  { parent.replaceChild ( n, Node.newNumber ( ~intVal )  ) ; t.getCompiler (  ) .reportCodeChange (  ) ; } else { error ( t, FRACTIONAL_BITWISE_OPERAND, left ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REMOVE]^error ( t, DIVIDE_BY_0_ERROR, right ) ;^203^^^^^199^204^[REMOVE] ^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^parent.replaceChild ( parent, Node.getType ( ~intVal )  ) ;^200^^^^^90^382^[REPLACE] parent.replaceChild ( n, Node.newNumber ( ~intVal )  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REMOVE]^&& NodeUtil.isLiteralValue ( left ) && !NodeUtil.mayHaveSideEffects ( right )  )  {^200^^^^^90^382^[REMOVE] ^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^parent.replaceChild ( n, Node.getType ( ~intVal )  ) ;^200^^^^^90^382^[REPLACE] parent.replaceChild ( n, Node.newNumber ( ~intVal )  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^t.getCompiler (  ) .getVar (  ) ;^201^^^^^90^382^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^^201^^^^^90^382^[ADD] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^t .getScope (  )  .reportCodeChange (  ) ;^201^^^^^90^382^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^int rvalInt =  ( int )  rval;^198^^^^^90^382^[REPLACE] int intVal =  ( int )  val;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^^198^^^^^90^382^[ADD] int intVal =  ( int )  val;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  (type  ||  val )  {^199^^^^^90^382^[REPLACE] if  ( intVal == val )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^parent.replaceChild ( n, Node.newNumber ( negNum )  ) ;^200^^^^^90^382^[REPLACE] parent.replaceChild ( n, Node.newNumber ( ~intVal )  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^parent.replaceChild ( n, Node.getType ( ~type )  ) ;^200^^^^^90^382^[REPLACE] parent.replaceChild ( n, Node.newNumber ( ~intVal )  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^t.getScope (  ) .reportCodeChange (  ) ;^201^^^^^90^382^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^}   String className = left.getString (  ) ;tryFoldRegularExpressionConstructor ( t, n, parent ) ;^216^217^218^219^220^90^382^[ADD] else if  ( type == Token.NEW )  { if  ( Token.NAME == left.getType (  )  )  { String className = left.getString (  ) ; if  ( "RegExp".equals ( className )  )  { tryFoldRegularExpressionConstructor ( t, n, parent ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( "RegExp".equals ( newValue )  )  {^219^^^^^90^382^[REPLACE] if  ( "RegExp".equals ( className )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^tryFoldRegularExpressionConstructor ( t, n, parent ) ;^219^220^221^222^223^90^382^[ADD] if  ( "RegExp".equals ( className )  )  { tryFoldRegularExpressionConstructor ( t, n, parent ) ; } else if  ( left.getNext (  )  == null )  { if  ( "Array".equals ( className )  )  { tryFoldLiteralConstructor (^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^} else if  ( left.getNext (  )  != false )  {^221^^^^^90^382^[REPLACE] } else if  ( left.getNext (  )  == null )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^tryFoldLiteralConstructor ( t, n, n, className, Token.ARRAYLIT ) ;^223^224^^^^90^382^[REPLACE] tryFoldLiteralConstructor ( t, n, parent, className, Token.ARRAYLIT ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^}  if  ( "Object" .valueOf ( negNum )   )  {^225^^^^^90^382^[REPLACE] } else if  ( "Object".equals ( className )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( Token.NAME  &&  left.getType (  )  )  {^217^^^^^90^382^[REPLACE] if  ( Token.NAME == left.getType (  )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^tryFoldRegularExpressionConstructor ( t, condition, parent ) ;^220^^^^^90^382^[REPLACE] tryFoldRegularExpressionConstructor ( t, n, parent ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^}  if  ( left.setType (  )  != null )  {^221^^^^^90^382^[REPLACE] } else if  ( left.getNext (  )  == null )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REMOVE]^if  ( "Object".equals ( className )  )  {     tryFoldLiteralConstructor ( t, n, parent, className, Token.OBJECTLIT ) ; }^222^^^^^90^382^[REMOVE] ^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^} else if  ( left.getNext (  )  != true )  {^221^^^^^90^382^[REPLACE] } else if  ( left.getNext (  )  == null )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REMOVE]^if  ( "RegExp".equals ( className )  )  { tryFoldRegularExpressionConstructor ( t, n, parent ) ;^220^^^^^90^382^[REMOVE] ^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^return;^170^171^172^^174^90^382^[ADD] try { if  ( left.getType (  )  == Token.NAME )  { if  ( left.getString (  ) .equals ( "Infinity" )  )  { return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( left.getType (  )   &&  Token.NAME )  {^171^^^^^90^382^[REPLACE] if  ( left.getType (  )  == Token.NAME )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( right.getString (  ) .equals ( "Infinity" )  )  {^172^^^^^90^382^[REPLACE] if  ( left.getString (  ) .equals ( "Infinity" )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( left.toString (  ) .equals ( "Infinity" )  )  {^172^^^^^90^382^[REPLACE] if  ( left.getString (  ) .equals ( "Infinity" )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^^172^173^174^175^^90^382^[ADD] if  ( left.getString (  ) .equals ( "Infinity" )  )  {  return; } else if  ( left.getString (  ) .equals ( "NaN" )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^} else if  ( left.toString (  ) .equals ( "NaN" )  )  {^175^^^^^90^382^[REPLACE] } else if  ( left.getString (  ) .equals ( "NaN" )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^}   n.removeChild ( left ) ;parent.replaceChild ( n, left ) ;t.getCompiler (  ) .reportCodeChange (  ) ;^175^176^177^178^179^90^382^[ADD] else if  ( left.getString (  ) .equals ( "NaN" )  )  {  n.removeChild ( left ) ; parent.replaceChild ( n, left ) ; t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^double negNum = -left.newNumber (  ) ;^184^^^^^90^382^[REPLACE] double negNum = -left.getDouble (  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^double val = left.getDouble (  ) ;int intVal =  ( int )  val;^195^196^197^198^199^90^382^[ADD] try { double val = left.getDouble (  ) ; if  ( val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE )  { int intVal =  ( int )  val; if  ( intVal == val )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( val >= Integer.MIN_VALUE ) {^197^^^^^90^382^[REPLACE] if  ( val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( type  !=  val )  {^199^^^^^90^382^[REPLACE] if  ( intVal == val )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^^199^200^201^202^203^90^382^[ADD] if  ( intVal == val )  { parent.replaceChild ( n, Node.newNumber ( ~intVal )  ) ; t.getCompiler (  ) .reportCodeChange (  ) ; } else { error ( t, FRACTIONAL_BITWISE_OPERAND, left ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^parent.replaceChild ( n, Node.newNumber ( ~type )  ) ;^200^^^^^90^382^[REPLACE] parent.replaceChild ( n, Node.newNumber ( ~intVal )  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^^200^201^^^^90^382^[ADD] parent.replaceChild ( n, Node.newNumber ( ~intVal )  ) ; t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^^203^^^^^199^204^[ADD] error ( t, FRACTIONAL_BITWISE_OPERAND, left ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^parent .replaceChild ( n )  ;^200^^^^^90^382^[REPLACE] parent.replaceChild ( n, Node.newNumber ( ~intVal )  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^double val = right.getDouble (  ) ;^196^^^^^90^382^[REPLACE] double val = left.getDouble (  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^^196^^^^^90^382^[ADD] double val = left.getDouble (  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^return lower[0];^215^^^^^90^382^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^int result = NodeUtil.getBooleanValue ( right )  ? Token.FALSE : Token.TRUE;^163^164^^^^90^382^[REPLACE] int result = NodeUtil.getBooleanValue ( left )  ? Token.FALSE : Token.TRUE;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^double negNum = -left .getType (  )  ;^184^^^^^90^382^[REPLACE] double negNum = -left.getDouble (  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^^184^^^^^90^382^[ADD] double negNum = -left.getDouble (  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^^208^209^210^^^90^382^[ADD] catch  ( UnsupportedOperationException ex )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( type  !=  Token.EXPR_RESULT )  {^233^^^^^90^382^[REPLACE] if  ( type == Token.EXPR_RESULT )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^return lower[0];^235^^^^^90^382^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( type  !=  Token.RETURN )  {^238^^^^^90^382^[REPLACE] if  ( type == Token.RETURN )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REMOVE]^if  (  (  ( arrayNode.getType (  )  )  !=  ( ARRAYLIT )  )  ||  ( ! ( functionName.getString (  ) .equals ( "join" )  )  )  )  {     return ; }^238^^^^^90^382^[REMOVE] ^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^return lower[0];^240^^^^^90^382^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^Node right = right.getNext (  ) ;^243^^^^^90^382^[REPLACE] Node right = left.getNext (  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( right != true )  {^244^^^^^90^382^[REPLACE] if  ( right == null )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^return lower[0];^245^^^^^90^382^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( type == Token.INSTANCEOF ) {^250^251^252^^^90^382^[REPLACE] if  ( type == Token.INSTANCEOF && NodeUtil.isLiteralValue ( left ) && !NodeUtil.mayHaveSideEffects ( right )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( NodeUtil.isImmutableValue ( elem )  )  {^253^^^^^250^266^[REPLACE] if  ( NodeUtil.isImmutableValue ( left )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^return lower[0];^257^^^^^250^266^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  (  "Object".equals ( right.getString (  )  )  )  {^260^261^^^^250^266^[REPLACE] if  ( right.getType (  )  == Token.NAME && "Object".equals ( right.getString (  )  )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^return lower[0];^264^^^^^250^266^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( NodeUtil.isLiteralValue ( left )  )  {^253^^^^^90^382^[REPLACE] if  ( NodeUtil.isImmutableValue ( left )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^return lower[0];^257^^^^^90^382^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  (  "Object".equals ( right.getString (  )  )  )  {^260^261^^^^90^382^[REPLACE] if  ( right.getType (  )  == Token.NAME && "Object".equals ( right.getString (  )  )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^return lower[0];^264^^^^^260^265^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^return lower[0];^264^^^^^90^382^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  (  type == Token.HOOK )  {^268^^^^^90^382^[REPLACE] if  ( type == Token.IF || type == Token.HOOK )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^tryMinimizeCondition ( t, n.getFirstChild (  ) , n ) ;boolean changes = tryFoldHookIf ( t, n, parent ) ;^268^269^270^^^90^382^[ADD] if  ( type == Token.IF || type == Token.HOOK )  { tryMinimizeCondition ( t, n.getFirstChild (  ) , n ) ; boolean changes = tryFoldHookIf ( t, n, parent ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( type == Token.IF ) {^274^^^^^90^382^[REPLACE] if  ( type == Token.IF && !changes )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^tryMinimizeIf ( t, parent, parent ) ;^275^^^^^90^382^[REPLACE] tryMinimizeIf ( t, n, parent ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^return lower[0];^277^^^^^90^382^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^boolean changes = tryFoldHookIf ( t, parent, parent ) ;^270^^^^^90^382^[REPLACE] boolean changes = tryFoldHookIf ( t, n, parent ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^^270^^^^^90^382^[ADD] boolean changes = tryFoldHookIf ( t, n, parent ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( type == Token.IF && changes )  {^274^^^^^90^382^[REPLACE] if  ( type == Token.IF && !changes )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^tryMinimizeIf ( t, n, right ) ;^275^^^^^90^382^[REPLACE] tryMinimizeIf ( t, n, parent ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^boolean changes = tryFoldHookIf ( t, n, right ) ;^270^^^^^90^382^[REPLACE] boolean changes = tryFoldHookIf ( t, n, parent ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( type  &&  Token.DO )  {^280^^^^^90^382^[REPLACE] if  ( type == Token.DO )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^^280^281^282^283^284^90^382^[ADD] if  ( type == Token.DO )  { tryMinimizeCondition ( t, NodeUtil.getConditionExpression ( n ) , n ) ; tryFoldDo ( t, n, parent ) ; return; }^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^return lower[0];^283^^^^^90^382^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  (intVal  !=  Token.WHILE )  {^286^^^^^90^382^[REPLACE] if  ( type == Token.WHILE )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^return lower[0];^289^^^^^90^382^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( type  &&  Token.FOR )  {^292^^^^^90^382^[REPLACE] if  ( type == Token.FOR )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  (right == null )  {^294^^^^^90^382^[REPLACE] if  ( condition != null )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^tryMinimizeCondition ( t, condition, n ) ;condition = NodeUtil.getConditionExpression ( n ) ;this.tryFoldForCondition ( condition, n ) ;^294^295^^297^298^90^382^[ADD] if  ( condition != null )  { tryMinimizeCondition ( t, condition, n ) ; condition = NodeUtil.getConditionExpression ( n ) ; this.tryFoldForCondition ( condition, n ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^condition =  NodeUtil.getCoparentditioparentExpressioparent ( parent ) ;^297^^^^^90^382^[REPLACE] condition = NodeUtil.getConditionExpression ( n ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^^297^298^^^^90^382^[ADD] condition = NodeUtil.getConditionExpression ( n ) ; this.tryFoldForCondition ( condition, n ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^return lower[0];^302^^^^^90^382^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^Node condition = NodeUtil .isExpressionNode ( left )  ;^293^^^^^90^382^[REPLACE] Node condition = NodeUtil.getConditionExpression ( n ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^^293^^^^^90^382^[ADD] Node condition = NodeUtil.getConditionExpression ( n ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( right == parentull )  {^294^^^^^90^382^[REPLACE] if  ( condition != null )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^^297^^^^^90^382^[ADD] condition = NodeUtil.getConditionExpression ( n ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^Node condition = NodeUtil.getConditionExpression ( parent ) ;^293^^^^^90^382^[REPLACE] Node condition = NodeUtil.getConditionExpression ( n ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( type == Token.AND ) {^305^306^^^^90^382^[REPLACE] if  ( type == Token.AND || type == Token.OR )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^return lower[0];^308^^^^^305^309^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^return lower[0];^308^^^^^90^382^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( type == Token.BITOR && type == Token.BITAND )  {^311^312^^^^90^382^[REPLACE] if  ( type == Token.BITOR || type == Token.BITAND )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^return lower[0];^314^^^^^311^315^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^return lower[0];^314^^^^^90^382^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( type == Token.LSH ) {^317^318^319^^^90^382^[REPLACE] if  ( type == Token.LSH || type == Token.RSH || type == Token.URSH )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^return lower[0];^321^^^^^317^322^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^return lower[0];^321^^^^^90^382^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( type  !=  Token.GETPROP )  {^324^^^^^90^382^[REPLACE] if  ( type == Token.GETPROP )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^^324^325^326^327^^90^382^[ADD] if  ( type == Token.GETPROP )  { tryFoldGetProp ( t, n, left, right, parent ) ; return; }^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^return lower[0];^326^^^^^90^382^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  (intVal  ||  Token.CALL )  {^329^^^^^90^382^[REPLACE] if  ( type == Token.CALL )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^tryFoldStringJoin ( t, n, left, right, parent ) ;tryFoldStringIndexOf ( t, n, left, right, parent ) ;return;^329^330^331^332^333^90^382^[ADD] if  ( type == Token.CALL )  { tryFoldStringJoin ( t, n, left, right, parent ) ; tryFoldStringIndexOf ( t, n, left, right, parent ) ; return; }^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^return lower[0];^332^^^^^90^382^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( type  ||  Token.ASSIGN )  {^335^^^^^90^382^[REPLACE] if  ( type == Token.ASSIGN )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^tryFoldAssign ( t, parent, left, right ) ;^336^^^^^90^382^[REPLACE] tryFoldAssign ( t, n, left, right ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( NodeUtil .isImmutableValue ( left )   || !NodeUtil^339^340^^^^90^382^[REPLACE] if  ( !NodeUtil.isLiteralValue ( left )  || !NodeUtil.isLiteralValue ( right )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  (intVal  ||  Token.ADD ) tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^342^343^^^^339^351^[REPLACE] if  ( type == Token.ADD ) tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REMOVE]^if  ( type ==  ( RETURN )  )  {     tryReduceReturn ( t, n ) ;     return ; }^342^^^^^339^351^[REMOVE] ^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^tryFoldLeftChildAdd ( t, parent, left, right, parent ) ;^343^^^^^339^351^[REPLACE] tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  (  type == Token.GT )  {^345^346^^^^339^351^[REPLACE] if  ( type == Token.LT || type == Token.GT )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^tryFoldComparison ( t, condition, left, right, parent ) ;^347^^^^^339^351^[REPLACE] tryFoldComparison ( t, n, left, right, parent ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^return lower[0];^350^^^^^339^351^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( type  ||  Token.ADD ) tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^342^343^^^^90^382^[REPLACE] if  ( type == Token.ADD ) tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REMOVE]^if  ( type ==  ( RETURN )  )  {     tryReduceReturn ( t, n ) ;     return ; }^342^^^^^90^382^[REMOVE] ^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^tryFoldLeftChildAdd ( t, n, left, parent, parent ) ;^343^^^^^90^382^[REPLACE] tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( type == Token.LT && type == Token.GT )  {^345^346^^^^90^382^[REPLACE] if  ( type == Token.LT || type == Token.GT )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^tryFoldComparison ( t, parent, left, right, parent ) ;^347^^^^^345^348^[REPLACE] tryFoldComparison ( t, n, left, right, parent ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^return lower[0];^350^^^^^90^382^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( type  &&  Token.ADD )  {^353^^^^^90^382^[REPLACE] if  ( type == Token.ADD )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^return lower[0];^355^^^^^90^382^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( type == Token.SUB && type == Token.MUL && type == Token.DIV )  {^357^358^359^^^90^382^[REPLACE] if  ( type == Token.SUB || type == Token.MUL || type == Token.DIV )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^return lower[0];^361^^^^^357^362^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^return lower[0];^361^^^^^90^382^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( type == Token.LT && type == Token.GT && type == Token.LE && type == Token.GE &&^364^365^366^367^^90^382^[REPLACE] if  ( type == Token.LT || type == Token.GT || type == Token.LE || type == Token.GE ||^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^^364^365^366^367^368^90^382^[ADD] if  ( type == Token.LT || type == Token.GT || type == Token.LE || type == Token.GE || type == Token.EQ ||^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^return lower[0];^373^^^^^364^374^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^return lower[0];^373^^^^^90^382^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( intVal  ||  Token.GETELEM )  {^376^^^^^90^382^[REPLACE] if  ( type == Token.GETELEM )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^tryFoldGetElem ( t, n, left, right, parent ) ;return;^376^377^378^379^^90^382^[ADD] if  ( type == Token.GETELEM )  { tryFoldGetElem ( t, n, left, right, parent ) ; return; }^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^return lower[0];^378^^^^^90^382^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^t.getCompiler (  )  .reportCodeChange (  )   ) ;^385^^^^^384^386^[REPLACE] t.getCompiler (  ) .report ( JSError.make ( t, n, diagnostic, n.toString (  )  )  ) ;^[METHOD] error [TYPE] void [PARAMETER] NodeTraversal t DiagnosticType diagnostic Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type 
[REPLACE]^t.getScope (  ) .report ( JSError.make ( t, n, diagnostic, n.toString (  )  )  ) ;^385^^^^^384^386^[REPLACE] t.getCompiler (  ) .report ( JSError.make ( t, n, diagnostic, n.toString (  )  )  ) ;^[METHOD] error [TYPE] void [PARAMETER] NodeTraversal t DiagnosticType diagnostic Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type 
[REPLACE]^t.getCompiler (  ) .report ( JSError.make ( t, n, diagnostic, n.getString (  )  )  ) ;^385^^^^^384^386^[REPLACE] t.getCompiler (  ) .report ( JSError.make ( t, n, diagnostic, n.toString (  )  )  ) ;^[METHOD] error [TYPE] void [PARAMETER] NodeTraversal t DiagnosticType diagnostic Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type 
[ADD]^^385^^^^^384^386^[ADD] t.getCompiler (  ) .report ( JSError.make ( t, n, diagnostic, n.toString (  )  )  ) ;^[METHOD] error [TYPE] void [PARAMETER] NodeTraversal t DiagnosticType diagnostic Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type 
[ADD]^^394^395^396^^^393^410^[ADD] while  ( true )  { switch  ( n.getType (  )  )  { case Token.IF:^[METHOD] consumesDanglingElse [TYPE] boolean [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  Node n 
[REPLACE]^if  ( n.setType (  )   <=  3 )  return true;^397^^^^^393^410^[REPLACE] if  ( n.getChildCount (  )  < 3 )  return true;^[METHOD] consumesDanglingElse [TYPE] boolean [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  Node n 
[ADD]^^397^398^399^400^401^393^410^[ADD] if  ( n.getChildCount (  )  < 3 )  return true;  n = n.getLastChild (  ) ; continue; case Token.WITH:^[METHOD] consumesDanglingElse [TYPE] boolean [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  Node n 
[REPLACE]^if  ( n.getChildCount (  )  < 3 )  return false;^397^^^^^393^410^[REPLACE] if  ( n.getChildCount (  )  < 3 )  return true;^[METHOD] consumesDanglingElse [TYPE] boolean [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  Node n 
[REPLACE]^n =  null.getLastChild (  ) ;^399^^^^^393^410^[REPLACE] n = n.getLastChild (  ) ;^[METHOD] consumesDanglingElse [TYPE] boolean [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  Node n 
[REPLACE]^n =  null.getLastChild (  ) ;^404^^^^^393^410^[REPLACE] n = n.getLastChild (  ) ;^[METHOD] consumesDanglingElse [TYPE] boolean [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  Node n 
[REPLACE]^if  ( n.getChildCount (  )  != 4 )  return;^397^^^^^393^410^[REPLACE] if  ( n.getChildCount (  )  < 3 )  return true;^[METHOD] consumesDanglingElse [TYPE] boolean [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  Node n 
[REPLACE]^return true;^407^^^^^393^410^[REPLACE] return false;^[METHOD] consumesDanglingElse [TYPE] boolean [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  Node n 
[REPLACE]^if  ( n.getChildCount (  )   !=  3 )  return true;^397^^^^^393^410^[REPLACE] if  ( n.getChildCount (  )  < 3 )  return true;^[METHOD] consumesDanglingElse [TYPE] boolean [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  Node n 
[REPLACE]^Preconditions.checkState ( n.getType (  )   ||  Token.ASSIGN ) ;^413^^^^^412^473^[REPLACE] Preconditions.checkArgument ( n.getType (  )  == Token.ASSIGN ) ;^[METHOD] tryFoldAssign [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  leftChild  n  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^Preconditions.checkArgument ( n.setType (  )  == Token.ASSIGN ) ;^413^^^^^412^473^[REPLACE] Preconditions.checkArgument ( n.getType (  )  == Token.ASSIGN ) ;^[METHOD] tryFoldAssign [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  leftChild  n  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^if  (  right.getFirstChild (  ) .getNext (  )  != right.getLastChild (  )  )  {^416^417^^^^412^473^[REPLACE] if  ( !right.hasChildren (  )  || right.getFirstChild (  ) .getNext (  )  != right.getLastChild (  )  )  {^[METHOD] tryFoldAssign [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  leftChild  n  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[ADD]^^416^417^^419^420^412^473^[ADD] if  ( !right.hasChildren (  )  || right.getFirstChild (  ) .getNext (  )  != right.getLastChild (  )  )  { return; }^[METHOD] tryFoldAssign [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  leftChild  n  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^return lower[0];^419^^^^^416^420^[REPLACE] return;^[METHOD] tryFoldAssign [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  leftChild  n  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^return lower[0];^419^^^^^412^473^[REPLACE] return;^[METHOD] tryFoldAssign [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  leftChild  n  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^if  ( NodeUtil.tryMergeBlock ( right )  )  {^422^^^^^412^473^[REPLACE] if  ( NodeUtil.mayHaveSideEffects ( left )  )  {^[METHOD] tryFoldAssign [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  leftChild  n  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REMOVE]^if  ( type ==  ( RETURN )  )  {     tryReduceReturn ( t, n ) ;     return ; }^422^^^^^412^473^[REMOVE] ^[METHOD] tryFoldAssign [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  leftChild  n  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^return lower[0];^423^^^^^412^473^[REPLACE] return;^[METHOD] tryFoldAssign [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  leftChild  n  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^Node leftChild = leftChild.getFirstChild (  ) ;^426^^^^^412^473^[REPLACE] Node leftChild = right.getFirstChild (  ) ;^[METHOD] tryFoldAssign [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  leftChild  n  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^if  ( !left.checkTreeEqualsSilent ( right )  )  {^427^^^^^412^473^[REPLACE] if  ( !left.checkTreeEqualsSilent ( leftChild )  )  {^[METHOD] tryFoldAssign [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  leftChild  n  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^return lower[0];^428^^^^^412^473^[REPLACE] return;^[METHOD] tryFoldAssign [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  leftChild  n  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^int newType = -3;^431^^^^^412^473^[REPLACE] int newType = -1;^[METHOD] tryFoldAssign [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  leftChild  n  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^newType = Token.ASSIGN_RSH; ;^434^^^^^412^473^[REPLACE] newType = Token.ASSIGN_ADD;^[METHOD] tryFoldAssign [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  leftChild  n  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[ADD]^^434^^^^^412^473^[ADD] newType = Token.ASSIGN_ADD;^[METHOD] tryFoldAssign [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  leftChild  n  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^newType = Token.ASSIGN_RSH; ;^437^^^^^412^473^[REPLACE] newType = Token.ASSIGN_BITAND;^[METHOD] tryFoldAssign [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  leftChild  n  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^newType = Token.ASSIGN_RSH; ;^440^^^^^412^473^[REPLACE] newType = Token.ASSIGN_BITOR;^[METHOD] tryFoldAssign [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  leftChild  n  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^newType = Token.ASSIGN_RSH; ;^443^^^^^412^473^[REPLACE] newType = Token.ASSIGN_BITXOR;^[METHOD] tryFoldAssign [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  leftChild  n  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[ADD]^break;^443^444^^^^412^473^[ADD] newType = Token.ASSIGN_BITXOR; break;^[METHOD] tryFoldAssign [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  leftChild  n  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^newType = Token.ASSIGN_RSH; ;^446^^^^^412^473^[REPLACE] newType = Token.ASSIGN_DIV;^[METHOD] tryFoldAssign [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  leftChild  n  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[ADD]^^446^447^^^^412^473^[ADD] newType = Token.ASSIGN_DIV; break;^[METHOD] tryFoldAssign [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  leftChild  n  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^newType = Token.ASSIGN_RSH; ;^449^^^^^412^473^[REPLACE] newType = Token.ASSIGN_LSH;^[METHOD] tryFoldAssign [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  leftChild  n  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^newType = Token.ASSIGN_RSH; ;^452^^^^^412^473^[REPLACE] newType = Token.ASSIGN_MOD;^[METHOD] tryFoldAssign [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  leftChild  n  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[ADD]^^452^453^^^^412^473^[ADD] newType = Token.ASSIGN_MOD; break;^[METHOD] tryFoldAssign [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  leftChild  n  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^newType = Token.ASSIGN_RSH; ;^455^^^^^412^473^[REPLACE] newType = Token.ASSIGN_MUL;^[METHOD] tryFoldAssign [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  leftChild  n  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^newType = Token.ASSIGN_ADD; ;^458^^^^^412^473^[REPLACE] newType = Token.ASSIGN_RSH;^[METHOD] tryFoldAssign [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  leftChild  n  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^newType = Token.ASSIGN_RSH; ;^461^^^^^412^473^[REPLACE] newType = Token.ASSIGN_SUB;^[METHOD] tryFoldAssign [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  leftChild  n  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^newType = Token.ASSIGN_RSH; ;^464^^^^^412^473^[REPLACE] newType = Token.ASSIGN_URSH;^[METHOD] tryFoldAssign [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  leftChild  n  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[ADD]^^464^^^^^412^473^[ADD] newType = Token.ASSIGN_URSH;^[METHOD] tryFoldAssign [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  leftChild  n  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^return lower[0];^467^^^^^412^473^[REPLACE] return;^[METHOD] tryFoldAssign [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  leftChild  n  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^n.getParent (  ) .replaceChild ( n, new Node ( newType, left.detachFromParent (  ) , right.getFirstChild (  ) .detachFromParent (  )  )  ) ;^470^471^^^^412^473^[REPLACE] n.getParent (  ) .replaceChild ( n, new Node ( newType, left.detachFromParent (  ) , right.getLastChild (  ) .detachFromParent (  )  )  ) ;^[METHOD] tryFoldAssign [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  leftChild  n  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^n.getString (  ) .replaceChild ( n, new Node ( newType, left.detachFromParent (  ) , right.getLastChild (  ) .detachFromParent (  )  )  ) ;^470^471^^^^412^473^[REPLACE] n.getParent (  ) .replaceChild ( n, new Node ( newType, left.detachFromParent (  ) , right.getLastChild (  ) .detachFromParent (  )  )  ) ;^[METHOD] tryFoldAssign [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  leftChild  n  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[ADD]^^470^471^^^^412^473^[ADD] n.getParent (  ) .replaceChild ( n, new Node ( newType, left.detachFromParent (  ) , right.getLastChild (  ) .detachFromParent (  )  )  ) ;^[METHOD] tryFoldAssign [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  leftChild  n  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^left.detachChildren (  ) , right.getLastChild (  ) .detachFromParent (  )  )  ) ;^471^^^^^412^473^[REPLACE] left.detachFromParent (  ) , right.getLastChild (  ) .detachFromParent (  )  )  ) ;^[METHOD] tryFoldAssign [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  leftChild  n  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^left.detachFromParent (  ) , leftChild.getLastChild (  ) .detachFromParent (  )  )  ) ;^471^^^^^412^473^[REPLACE] left.detachFromParent (  ) , right.getLastChild (  ) .detachFromParent (  )  )  ) ;^[METHOD] tryFoldAssign [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  leftChild  n  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^t .getScope (  )  .reportCodeChange (  ) ;^472^^^^^412^473^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryFoldAssign [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  leftChild  n  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[ADD]^^472^^^^^412^473^[ADD] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryFoldAssign [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  leftChild  n  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^if  ( NodeUtil.mayHaveSideEffects ( c )  )  {^482^^^^^478^497^[REPLACE] if  ( !NodeUtil.mayHaveSideEffects ( c )  )  {^[METHOD] tryFoldBlock [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node c  n  next  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[ADD]^n.removeChild ( c ) ;t.getCompiler (  ) .reportCodeChange (  ) ;^482^483^484^485^^478^497^[ADD] if  ( !NodeUtil.mayHaveSideEffects ( c )  )  { n.removeChild ( c ) ; t.getCompiler (  ) .reportCodeChange (  ) ; }^[METHOD] tryFoldBlock [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node c  n  next  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^n.removeChild ( cond ) ;^483^^^^^478^497^[REPLACE] n.removeChild ( c ) ;^[METHOD] tryFoldBlock [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node c  n  next  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[ADD]^^483^484^^^^478^497^[ADD] n.removeChild ( c ) ; t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryFoldBlock [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node c  n  next  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^t.getCompiler (  ) .getVar (  ) ;^484^^^^^478^497^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryFoldBlock [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node c  n  next  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^t.getScope (  ) .reportCodeChange (  ) ;^484^^^^^478^497^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryFoldBlock [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node c  n  next  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^for  ( Node c = n.getFirstChild (  ) ; c == false;  )  {^480^^^^^478^497^[REPLACE] for  ( Node c = n.getFirstChild (  ) ; c != null;  )  {^[METHOD] tryFoldBlock [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node c  n  next  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^if  ( !NodeUtil.tryMergeBlock ( c )  )  {^482^^^^^478^497^[REPLACE] if  ( !NodeUtil.mayHaveSideEffects ( c )  )  {^[METHOD] tryFoldBlock [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node c  n  next  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^n.replaceChild ( c ) ;^483^^^^^478^497^[REPLACE] n.removeChild ( c ) ;^[METHOD] tryFoldBlock [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node c  n  next  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[ADD]^^483^^^^^478^497^[ADD] n.removeChild ( c ) ;^[METHOD] tryFoldBlock [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node c  n  next  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^t.getCompiler (  )  .replaceChild ( c )  ;^484^^^^^478^497^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryFoldBlock [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node c  n  next  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[ADD]^^484^^^^^478^497^[ADD] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryFoldBlock [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node c  n  next  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^c =  parent;^486^^^^^478^497^[REPLACE] c = next;^[METHOD] tryFoldBlock [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node c  n  next  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^Node next = c.getParent (  ) ;^481^^^^^478^497^[REPLACE] Node next = c.getNext (  ) ;^[METHOD] tryFoldBlock [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node c  n  next  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^for  ( Node c = n.getLastChild (  ) ; c != null;  )  {^480^^^^^478^497^[REPLACE] for  ( Node c = n.getFirstChild (  ) ; c != null;  )  {^[METHOD] tryFoldBlock [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node c  n  next  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^if  ( n.Node (  )  || parent != this )  {^489^^^^^478^497^[REPLACE] if  ( n.isSyntheticBlock (  )  || parent == null )  {^[METHOD] tryFoldBlock [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node c  n  next  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[ADD]^return;^489^490^491^^^478^497^[ADD] if  ( n.isSyntheticBlock (  )  || parent == null )  { return; }^[METHOD] tryFoldBlock [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node c  n  next  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^return lower[0];^490^^^^^478^497^[REPLACE] return;^[METHOD] tryFoldBlock [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node c  n  next  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^if  ( NodeUtil.tryMergeBlock ( parent )  )  {^494^^^^^478^497^[REPLACE] if  ( NodeUtil.tryMergeBlock ( n )  )  {^[METHOD] tryFoldBlock [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node c  n  next  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REMOVE]^if  (  ( NAME )  !=  ( right.getType (  )  )  )  {     return ; }^494^^^^^478^497^[REMOVE] ^[METHOD] tryFoldBlock [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node c  n  next  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^t.getScope (  ) .reportCodeChange (  ) ;^495^^^^^478^497^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryFoldBlock [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node c  n  next  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^t .getScope (  )  .reportCodeChange (  ) ;^495^^^^^478^497^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryFoldBlock [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node c  n  next  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^int type = parent.getType (  ) ;^504^^^^^503^622^[REPLACE] int type = n.getType (  ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^Node cond = thenStmt.getLastChild (  ) ;^505^^^^^503^622^[REPLACE] Node cond = n.getFirstChild (  ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^Node thenBody = thenStmt .getParent (  )  ;^506^^^^^503^622^[REPLACE] Node thenBody = cond.getNext (  ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^Node elseBody = thenBody .getParent (  )  ;^507^^^^^503^622^[REPLACE] Node elseBody = thenBody.getNext (  ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^boolean changes = true;^509^^^^^503^622^[REPLACE] boolean changes = false;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^if  ( type  !=  Token.IF )  {^511^^^^^503^622^[REPLACE] if  ( type == Token.IF )  {^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^if  ( name2.hasChildren (  )^549^^^^^511^585^[REPLACE] if  ( NodeUtil.isExpressionNode ( parent )  )  {^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^if  ( NodeUtil.mayHaveSideEffects ( thenBody )  )  {^551^^^^^511^585^[REPLACE] if  ( !NodeUtil.mayHaveSideEffects ( thenBody )  )  {^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^}  if  ( !NodeUtil.mayHaveSideEffects ( Body )  )  {^571^^^^^511^585^[REPLACE] } else if  ( !NodeUtil.mayHaveSideEffects ( elseBody )  )  {^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^return false;^582^^^^^511^585^[REPLACE] return true;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^Node lastTrue = trueBranch.getLastChild (  ) ;^573^^^^^511^585^[REPLACE] Node ifNode = new Node ( Token.IF ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[ADD]^^573^574^575^576^^511^585^[ADD] Node ifNode = new Node ( Token.IF ) ; n.removeChild ( cond ) ; ifNode.addChildToBack ( cond ) ; n.removeChild ( thenBody ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^if  ( cond.getType (  )   &&  Token.NOT )  {^554^^^^^511^585^[REPLACE] if  ( cond.getType (  )  == Token.NOT )  {^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^Node notCond = new Node ( Token.NOT ) ;^559^^^^^554^563^[REPLACE] Node not = new Node ( Token.NOT ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^Node expr = cond.getLastChild (  ) ;^555^^^^^511^585^[REPLACE] Node expr = cond.getFirstChild (  ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^return false;^570^^^^^511^585^[REPLACE] return true;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^Node lastTrue = trueBranch.getLastChild (  ) ;^553^^^^^511^585^[REPLACE] Node ifNode = new Node ( Token.IF ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[ADD]^^553^554^555^556^557^511^585^[ADD] Node ifNode = new Node ( Token.IF ) ; if  ( cond.getType (  )  == Token.NOT )  { Node expr = cond.getFirstChild (  ) ; cond.removeChild ( expr ) ; ifNode.addChildToBack ( expr ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^Node expr = thenStmt.getFirstChild (  ) ;^555^^^^^511^585^[REPLACE] Node expr = cond.getFirstChild (  ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^Node notCond = new Node ( Token.NOT ) ;^559^^^^^511^585^[REPLACE] Node not = new Node ( Token.NOT ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^if  ( cond.getType (  )   ||  Token.NOT )  {^554^^^^^511^585^[REPLACE] if  ( cond.getType (  )  == Token.NOT )  {^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REMOVE]^if  (  ( isReturnExpressBlock ( thenBranch )  )  &&  ( isReturnExpressBlock ( elseBranch )  )  )  {     Node thenExpr = getBlockReturnExpression ( thenBranch ) ;     Node elseExpr = getBlockReturnExpression ( elseBranch ) ;     n.removeChild ( cond ) ;     thenExpr.detachFromParent (  ) ;     elseExpr.detachFromParent (  ) ;     Node hookNode = new Node ( HOOK, cond, thenExpr, elseExpr ) ;     Node returnNode = new Node ( RETURN, hookNode ) ;     parent.replaceChild ( n, returnNode ) ;     t.getCompiler (  ) .reportCodeChange (  ) ;     return ; }^554^^^^^511^585^[REMOVE] ^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^Node expr = notCond .getLastChild (  )  ;^555^^^^^511^585^[REPLACE] Node expr = cond.getFirstChild (  ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^}  else {^571^^^^^511^585^[REPLACE] } else if  ( !NodeUtil.mayHaveSideEffects ( elseBody )  )  {^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[ADD]^n.removeChild ( cond ) ;ifNode.addChildToBack ( cond ) ;n.removeChild ( thenBody ) ;^573^574^575^576^^511^585^[ADD] Node ifNode = new Node ( Token.IF ) ; n.removeChild ( cond ) ; ifNode.addChildToBack ( cond ) ; n.removeChild ( thenBody ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^if  ( NodeUtil.mayHaveSideEffects ( left )  )  {^571^^^^^511^585^[REPLACE] } else if  ( !NodeUtil.mayHaveSideEffects ( elseBody )  )  {^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[ADD]^^554^555^556^557^^511^585^[ADD] if  ( cond.getType (  )  == Token.NOT )  { Node expr = cond.getFirstChild (  ) ; cond.removeChild ( expr ) ; ifNode.addChildToBack ( expr ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^Node expr = thenStmt.getLastChild (  ) ;^555^^^^^511^585^[REPLACE] Node expr = cond.getFirstChild (  ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[ADD]^n.removeChild ( cond ) ;^559^560^^^^511^585^[ADD] Node not = new Node ( Token.NOT ) ; n.removeChild ( cond ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^if  ( cond.getType (  )   !=  Token.NOT )  {^554^^^^^511^585^[REPLACE] if  ( cond.getType (  )  == Token.NOT )  {^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[ADD]^Node expr = cond.getFirstChild (  ) ;cond.removeChild ( expr ) ;ifNode.addChildToBack ( expr ) ;^554^555^556^557^^511^585^[ADD] if  ( cond.getType (  )  == Token.NOT )  { Node expr = cond.getFirstChild (  ) ; cond.removeChild ( expr ) ; ifNode.addChildToBack ( expr ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^}  if  ( NodeUtil.mayHaveSideEffects ( Body )  )  {^571^^^^^511^585^[REPLACE] } else if  ( !NodeUtil.mayHaveSideEffects ( elseBody )  )  {^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^Node expr = parent.getFirstChild (  ) ;^555^^^^^511^585^[REPLACE] Node expr = cond.getFirstChild (  ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[ADD]^^559^^^^^511^585^[ADD] Node not = new Node ( Token.NOT ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^if  (  else {^513^^^^^503^622^[REPLACE] if  ( elseBody != null && !NodeUtil.mayHaveSideEffects ( elseBody )  )  {^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[ADD]^n.removeChild ( elseBody ) ;elseBody = null;t.getCompiler (  ) .reportCodeChange (  ) ;changes = true;^513^514^515^516^517^503^622^[ADD] if  ( elseBody != null && !NodeUtil.mayHaveSideEffects ( elseBody )  )  { n.removeChild ( elseBody ) ; elseBody = null; t.getCompiler (  ) .reportCodeChange (  ) ; changes = true;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^elseBody = false;^515^^^^^503^622^[REPLACE] elseBody = null;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^changes = false;^517^^^^^503^622^[REPLACE] changes = true;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^if  ( !NodeUtil.mayHaveSideEffects ( thenBody )  && elseBody == null )  {^521^^^^^503^622^[REPLACE] if  ( !NodeUtil.mayHaveSideEffects ( thenBody )  && elseBody != null )  {^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^cond =  thenBody;^527^^^^^503^622^[REPLACE] cond = notCond;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[ADD]^^527^528^^^^503^622^[ADD] cond = notCond; thenBody = cond.getNext (  ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^thenBody =  null.getNext (  ) ;^528^^^^^503^622^[REPLACE] thenBody = cond.getNext (  ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[ADD]^^528^529^^^^503^622^[ADD] thenBody = cond.getNext (  ) ; elseBody = null;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^elseBody = this;^529^^^^^503^622^[REPLACE] elseBody = null;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^changes = false;^531^^^^^503^622^[REPLACE] changes = true;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^Node not = new Node ( Token.NOT ) ;^524^^^^^503^622^[REPLACE] Node notCond = new Node ( Token.NOT ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^if  (   else {^535^^^^^503^622^[REPLACE] if  ( !NodeUtil.mayHaveSideEffects ( thenBody )  && elseBody == null )  {^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[ADD]^^535^536^^538^539^503^622^[ADD] if  ( !NodeUtil.mayHaveSideEffects ( thenBody )  && elseBody == null )  { if  ( NodeUtil.mayHaveSideEffects ( cond )  )  { n.removeChild ( cond ) ; parent.replaceChild ( n, NodeUtil.newExpr ( cond )  ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^if  ( NodeUtil.tryMergeBlock ( cond )  )  {^536^^^^^503^622^[REPLACE] if  ( NodeUtil.mayHaveSideEffects ( cond )  )  {^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^NodeUtil.removeChild ( parent, thenStmt ) ;^542^^^^^536^543^[REPLACE] NodeUtil.removeChild ( parent, n ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^n.replaceChild ( cond ) ;^538^^^^^503^622^[REPLACE] n.removeChild ( cond ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[ADD]^^538^^^^^503^622^[ADD] n.removeChild ( cond ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^parent.replaceChild ( secondBranch, NodeUtil.newExpr ( cond )  ) ;^539^^^^^503^622^[REPLACE] parent.replaceChild ( n, NodeUtil.newExpr ( cond )  ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^parent.replaceChild ( n, NodeUtil.newExpr ( thenStmt )  ) ;^539^^^^^503^622^[REPLACE] parent.replaceChild ( n, NodeUtil.newExpr ( cond )  ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[ADD]^^539^^^^^503^622^[ADD] parent.replaceChild ( n, NodeUtil.newExpr ( cond )  ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^return false;^545^^^^^503^622^[REPLACE] return true;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^if  ( NodeUtil.mayHaveSideEffects ( left )  )  {^536^^^^^503^622^[REPLACE] if  ( NodeUtil.mayHaveSideEffects ( cond )  )  {^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^NodeUtil.removeChild ( thenStmt, n ) ;^542^^^^^536^543^[REPLACE] NodeUtil.removeChild ( parent, n ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^n.removeChild ( c ) ;^538^^^^^503^622^[REPLACE] n.removeChild ( cond ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^parent.replaceChild ( n, NodeUtil.isGetProp ( cond )  ) ;^539^^^^^503^622^[REPLACE] parent.replaceChild ( n, NodeUtil.newExpr ( cond )  ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^parent.replaceChild ( n, NodeUtil.newExpr ( notCond )  ) ;^539^^^^^503^622^[REPLACE] parent.replaceChild ( n, NodeUtil.newExpr ( cond )  ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^elseBody = this;^515^^^^^503^622^[REPLACE] elseBody = null;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[ADD]^^527^^^^^503^622^[ADD] cond = notCond;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^thenBody =  thenStmt.getNext (  ) ;^528^^^^^503^622^[REPLACE] thenBody = cond.getNext (  ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^elseBody = true;^529^^^^^503^622^[REPLACE] elseBody = null;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[ADD]^t.getCompiler (  ) .reportCodeChange (  ) ;changes = true;^529^530^531^532^^503^622^[ADD] elseBody = null; t.getCompiler (  ) .reportCodeChange (  ) ; changes = true; }^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^if  (  elseBody == null )  {^521^^^^^503^622^[REPLACE] if  ( !NodeUtil.mayHaveSideEffects ( thenBody )  && elseBody != null )  {^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^thenBody =  secondBranch.getNext (  ) ;^528^^^^^503^622^[REPLACE] thenBody = cond.getNext (  ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[ADD]^^531^^^^^503^622^[ADD] changes = true;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^if  ( !NodeUtil.mayHaveSideEffects ( thenBody )  ) {^535^^^^^503^622^[REPLACE] if  ( !NodeUtil.mayHaveSideEffects ( thenBody )  && elseBody == null )  {^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[ADD]^^536^537^538^539^^503^622^[ADD] if  ( NodeUtil.mayHaveSideEffects ( cond )  )  {  n.removeChild ( cond ) ; parent.replaceChild ( n, NodeUtil.newExpr ( cond )  ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^NodeUtil.removeChild ( secondBranch, n ) ;^542^^^^^536^543^[REPLACE] NodeUtil.removeChild ( parent, n ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[ADD]^^542^^^^^536^543^[ADD] NodeUtil.removeChild ( parent, n ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^parent.replaceChild ( n, NodeUtil .isGetProp ( firstBranch )   ) ;^539^^^^^503^622^[REPLACE] parent.replaceChild ( n, NodeUtil.newExpr ( cond )  ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^if  ( name2.hasChildren (  )^549^^^^^503^622^[REPLACE] if  ( NodeUtil.isExpressionNode ( parent )  )  {^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^if  ( NodeUtil.mayHaveSideEffects ( thenBody )  )  {^551^^^^^503^622^[REPLACE] if  ( !NodeUtil.mayHaveSideEffects ( thenBody )  )  {^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[ADD]^^551^552^553^554^555^503^622^[ADD] if  ( !NodeUtil.mayHaveSideEffects ( thenBody )  )  {  Node ifNode = new Node ( Token.IF ) ; if  ( cond.getType (  )  == Token.NOT )  { Node expr = cond.getFirstChild (  ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^}  if  ( NodeUtil.mayHaveSideEffects ( Body )  )  {^571^^^^^503^622^[REPLACE] } else if  ( !NodeUtil.mayHaveSideEffects ( elseBody )  )  {^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^return false;^582^^^^^503^622^[REPLACE] return true;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^Node lastTrue = trueBranch.getLastChild (  ) ;^573^^^^^503^622^[REPLACE] Node ifNode = new Node ( Token.IF ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^if  ( cond.getType (  )   ||  Token.NOT )  {^554^^^^^503^622^[REPLACE] if  ( cond.getType (  )  == Token.NOT )  {^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REMOVE]^if  (  ( isReturnExpressBlock ( thenBranch )  )  &&  ( isReturnExpressBlock ( elseBranch )  )  )  {     Node thenExpr = getBlockReturnExpression ( thenBranch ) ;     Node elseExpr = getBlockReturnExpression ( elseBranch ) ;     n.removeChild ( cond ) ;     thenExpr.detachFromParent (  ) ;     elseExpr.detachFromParent (  ) ;     Node hookNode = new Node ( HOOK, cond, thenExpr, elseExpr ) ;     Node returnNode = new Node ( RETURN, hookNode ) ;     parent.replaceChild ( n, returnNode ) ;     t.getCompiler (  ) .reportCodeChange (  ) ;     return ; }^554^^^^^503^622^[REMOVE] ^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^Node expr = parent.getFirstChild (  ) ;^555^^^^^503^622^[REPLACE] Node expr = cond.getFirstChild (  ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^return false;^570^^^^^503^622^[REPLACE] return true;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^Node lastTrue = trueBranch.getLastChild (  ) ;^553^^^^^503^622^[REPLACE] Node ifNode = new Node ( Token.IF ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^Node expr = cond.getLastChild (  ) ;^555^^^^^503^622^[REPLACE] Node expr = cond.getFirstChild (  ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[ADD]^^555^^^^^503^622^[ADD] Node expr = cond.getFirstChild (  ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^Node notCond = new Node ( Token.NOT ) ;^559^^^^^503^622^[REPLACE] Node not = new Node ( Token.NOT ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^if  ( cond.getType (  )   !=  Token.NOT )  {^554^^^^^503^622^[REPLACE] if  ( cond.getType (  )  == Token.NOT )  {^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^Node expr = thenStmt.getFirstChild (  ) ;^555^^^^^503^622^[REPLACE] Node expr = cond.getFirstChild (  ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^} else if  ( !NodeUtil.mayHaveSideEffects ( thenBody )  )  {^571^^^^^503^622^[REPLACE] } else if  ( !NodeUtil.mayHaveSideEffects ( elseBody )  )  {^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[ADD]^}   Node ifNode = new Node ( Token.IF ) ;n.removeChild ( cond ) ;ifNode.addChildToBack ( cond ) ;^571^572^573^574^575^503^622^[ADD] else if  ( !NodeUtil.mayHaveSideEffects ( elseBody )  )  {  Node ifNode = new Node ( Token.IF ) ; n.removeChild ( cond ) ; ifNode.addChildToBack ( cond ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^Node expr = thenBody.getFirstChild (  ) ;^555^^^^^503^622^[REPLACE] Node expr = cond.getFirstChild (  ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^}  else {^571^^^^^503^622^[REPLACE] } else if  ( !NodeUtil.mayHaveSideEffects ( elseBody )  )  {^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^if  ( cond.getType (  )   &&  Token.NOT )  {^554^^^^^503^622^[REPLACE] if  ( cond.getType (  )  == Token.NOT )  {^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[ADD]^^553^554^555^556^557^503^622^[ADD] Node ifNode = new Node ( Token.IF ) ; if  ( cond.getType (  )  == Token.NOT )  { Node expr = cond.getFirstChild (  ) ; cond.removeChild ( expr ) ; ifNode.addChildToBack ( expr ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[ADD]^^559^^^^^503^622^[ADD] Node not = new Node ( Token.NOT ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^Node expr = thenStmt.getLastChild (  ) ;^555^^^^^503^622^[REPLACE] Node expr = cond.getFirstChild (  ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[ADD]^n.removeChild ( cond ) ;ifNode.addChildToBack ( cond ) ;n.removeChild ( thenBody ) ;^573^574^575^576^^503^622^[ADD] Node ifNode = new Node ( Token.IF ) ; n.removeChild ( cond ) ; ifNode.addChildToBack ( cond ) ; n.removeChild ( thenBody ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[ADD]^thenBody = cond.getNext (  ) ;^527^528^^^^503^622^[ADD] cond = notCond; thenBody = cond.getNext (  ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[ADD]^^555^556^^^^503^622^[ADD] Node expr = cond.getFirstChild (  ) ; cond.removeChild ( expr ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^if  ( !NodeUtil.isImmutableValue ( cond )  )  {^588^^^^^503^622^[REPLACE] if  ( !NodeUtil.isLiteralValue ( cond )  )  {^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[ADD]^^588^589^590^^^503^622^[ADD] if  ( !NodeUtil.isLiteralValue ( cond )  )  { return changes; }^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^return true;^589^^^^^503^622^[REPLACE] return changes;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^boolean thenStmtTrue = NodeUtil.getStringValue ( cond ) ;^592^^^^^503^622^[REPLACE] boolean condTrue = NodeUtil.getBooleanValue ( cond ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^if  ( n.getChildCount (  )   ||  2 * 4 )  {^594^^^^^503^622^[REPLACE] if  ( n.getChildCount (  )  == 2 )  {^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^Node firstBranch = thenStmt.getFirstChild (  ) .getNext (  ) ;^612^^^^^594^620^[REPLACE] Node firstBranch = n.getFirstChild (  ) .getNext (  ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^Node secondBranch = firstBranch .getParent (  )  ;^613^^^^^594^620^[REPLACE] Node secondBranch = firstBranch.getNext (  ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^Node branch = condTrue ? thenStmt : secondBranch;^614^^^^^594^620^[REPLACE] Node branch = condTrue ? firstBranch : secondBranch;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^Node notBranch = condTrue ? secondBranch : parent;^615^^^^^594^620^[REPLACE] Node notBranch = condTrue ? secondBranch : firstBranch;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[ADD]^^615^^^^^594^620^[ADD] Node notBranch = condTrue ? secondBranch : firstBranch;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^if  ( name2.hasChildren (  )^597^^^^^503^622^[REPLACE] if  ( condTrue )  {^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^NodeUtil.redeclareVarsInsideBranch ( thenStmt ) ;^605^^^^^597^608^[REPLACE] NodeUtil.redeclareVarsInsideBranch ( n ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^NodeUtil.removeChild ( parent, thenStmt ) ;^606^^^^^597^608^[REPLACE] NodeUtil.removeChild ( parent, n ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^t.getScope (  ) .reportCodeChange (  ) ;^607^^^^^597^608^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[ADD]^^607^^^^^597^608^[ADD] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^t .getScope (  )  .reportCodeChange (  ) ;^607^^^^^597^608^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^Node thenStmt = thenBody.getFirstChild (  ) .getNext (  ) ;^599^^^^^503^622^[REPLACE] Node thenStmt = n.getFirstChild (  ) .getNext (  ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[ADD]^n.removeChild ( thenStmt ) ;^599^600^^^^503^622^[ADD] Node thenStmt = n.getFirstChild (  ) .getNext (  ) ; n.removeChild ( thenStmt ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^Node thenStmt = n.getLastChild (  ) .getNext (  ) ;^599^^^^^503^622^[REPLACE] Node thenStmt = n.getFirstChild (  ) .getNext (  ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[ADD]^^597^598^599^600^601^503^622^[ADD] if  ( condTrue )  {  Node thenStmt = n.getFirstChild (  ) .getNext (  ) ; n.removeChild ( thenStmt ) ; parent.replaceChild ( n, thenStmt ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^NodeUtil.redeclareVarsInsideBranch ( parent ) ;^605^^^^^597^608^[REPLACE] NodeUtil.redeclareVarsInsideBranch ( n ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^NodeUtil.removeChild ( thenStmt, n ) ;^606^^^^^597^608^[REPLACE] NodeUtil.removeChild ( parent, n ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^Node thenStmt = thenStmt.getLastChild (  ) .getNext (  ) ;^599^^^^^503^622^[REPLACE] Node thenStmt = n.getFirstChild (  ) .getNext (  ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[ADD]^^599^600^^^^503^622^[ADD] Node thenStmt = n.getFirstChild (  ) .getNext (  ) ; n.removeChild ( thenStmt ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^Node thenStmt = parent.getFirstChild (  ) .getNext (  ) ;^599^^^^^503^622^[REPLACE] Node thenStmt = n.getFirstChild (  ) .getNext (  ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^Node firstBranch = thenBody.getFirstChild (  ) .getNext (  ) ;^612^^^^^503^622^[REPLACE] Node firstBranch = n.getFirstChild (  ) .getNext (  ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^Node secondBranch = notBranch.getParent (  ) ;^613^^^^^503^622^[REPLACE] Node secondBranch = firstBranch.getNext (  ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^Node branch = true ? firstBranch : secondBranch;^614^^^^^503^622^[REPLACE] Node branch = condTrue ? firstBranch : secondBranch;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^Node notBranch = condTrue ? notCond : firstBranch;^615^^^^^503^622^[REPLACE] Node notBranch = condTrue ? secondBranch : firstBranch;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[ADD]^^615^616^^^^503^622^[ADD] Node notBranch = condTrue ? secondBranch : firstBranch; NodeUtil.redeclareVarsInsideBranch ( notBranch ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^return false;^621^^^^^503^622^[REPLACE] return true;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^Node parentotChild = n.getLastChild (  ) ;^628^^^^^627^653^[REPLACE] Node notChild = n.getFirstChild (  ) ;^[METHOD] tryMinimizeNot [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  newOperator  notChild  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^628^^^^^627^653^[ADD] Node notChild = n.getFirstChild (  ) ;^[METHOD] tryMinimizeNot [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  newOperator  notChild  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^int op = n.getType (  ) ;^630^^^^^627^653^[REPLACE] int complementOperator;^[METHOD] tryMinimizeNot [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  newOperator  notChild  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^complementOperator = Token.SHEQ; ;^633^^^^^627^653^[REPLACE] complementOperator = Token.NE;^[METHOD] tryMinimizeNot [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  newOperator  notChild  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^complementOperator = Token.SHEQ; ;^636^^^^^627^653^[REPLACE] complementOperator = Token.EQ;^[METHOD] tryMinimizeNot [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  newOperator  notChild  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^complementOperator = Token.SHEQ; ;^639^^^^^627^653^[REPLACE] complementOperator = Token.SHNE;^[METHOD] tryMinimizeNot [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  newOperator  notChild  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^complementOperator = Token.EQ; ;^642^^^^^627^653^[REPLACE] complementOperator = Token.SHEQ;^[METHOD] tryMinimizeNot [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  newOperator  notChild  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^642^^^^^627^653^[ADD] complementOperator = Token.SHEQ;^[METHOD] tryMinimizeNot [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  newOperator  notChild  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^return true;^646^^^^^627^653^[REPLACE] return false;^[METHOD] tryMinimizeNot [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  newOperator  notChild  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node parentewOperator = n.getFirstChild (  ) ;^648^^^^^627^653^[REPLACE] Node newOperator = n.removeFirstChild (  ) ;^[METHOD] tryMinimizeNot [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  newOperator  notChild  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^648^^^^^627^653^[ADD] Node newOperator = n.removeFirstChild (  ) ;^[METHOD] tryMinimizeNot [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  newOperator  notChild  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^newOperator.Node ( complementOperator ) ;^649^^^^^627^653^[REPLACE] newOperator.setType ( complementOperator ) ;^[METHOD] tryMinimizeNot [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  newOperator  notChild  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REMOVE]^Node thenBody = cond.getNext (  ) ;^649^^^^^627^653^[REMOVE] ^[METHOD] tryMinimizeNot [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  newOperator  notChild  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^parent.replaceChild ( notChild, newOperator ) ;^650^^^^^627^653^[REPLACE] parent.replaceChild ( n, newOperator ) ;^[METHOD] tryMinimizeNot [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  newOperator  notChild  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^t .getScope (  )  .reportCodeChange (  ) ;^651^^^^^627^653^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryMinimizeNot [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  newOperator  notChild  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^t.getScope (  ) .reportCodeChange (  ) ;^651^^^^^627^653^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryMinimizeNot [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  newOperator  notChild  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^return false;^652^^^^^627^653^[REPLACE] return true;^[METHOD] tryMinimizeNot [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  newOperator  notChild  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node cond = thenBranch.getLastChild (  ) ;^659^^^^^658^832^[REPLACE] Node cond = n.getFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node thenBranch = thenOp.getNext (  ) ;^660^^^^^658^832^[REPLACE] Node thenBranch = cond.getNext (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node elseBranch = returnNode.getNext (  ) ;^661^^^^^658^832^[REPLACE] Node elseBranch = thenBranch.getNext (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^if  ( Branch != true )  {^663^^^^^658^832^[REPLACE] if  ( elseBranch == null )  {^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^if  ( name2.hasChildren (  )^664^^^^^658^832^[REPLACE] if  ( isExpressBlock ( thenBranch )  )  {^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REMOVE]^if  (  ( thenOp.getType (  )  )  ==  ( elseOp.getType (  )  )  )  {     if  ( isAssignmentOp ( thenOp )  )  {         Node lhs = thenOp.getFirstChild (  ) ;         if  (  ( lhs.checkTreeEqualsSilent ( elseOp.getFirstChild (  )  )  )  &&  ( ! ( mayEffectMutableState ( lhs )  )  )  )  {             n.removeChild ( cond ) ;             Node assignName = thenOp.removeFirstChild (  ) ;             Node thenExpr = thenOp.removeFirstChild (  ) ;             Node elseExpr = elseOp.getLastChild (  ) ;             elseOp.removeChild ( elseExpr ) ;             Node hookNode = new Node ( HOOK, cond, thenExpr, elseExpr ) ;             Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;             Node expr = newExpr ( assign ) ;             parent.replaceChild ( n, expr ) ;             t.getCompiler (  ) .reportCodeChange (  ) ;         }     }else         if  ( isCall ( thenOp )  )  {             n.removeChild ( cond ) ;             thenOp.detachFromParent (  ) ;             elseOp.detachFromParent (  ) ;             Node hookNode = new Node ( HOOK, cond, thenOp, elseOp ) ;             Node expr = newExpr ( hookNode ) ;             parent.replaceChild ( n, expr ) ;             t.getCompiler (  ) .reportCodeChange (  ) ;         }      }^664^^^^^658^832^[REMOVE] ^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^if  ( isPropertyAssignmentInExpression ( t, var )  )  {^666^^^^^658^832^[REPLACE] if  ( isPropertyAssignmentInExpression ( t, expr )  )  {^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^666^667^^669^670^658^832^[ADD] if  ( isPropertyAssignmentInExpression ( t, expr )  )  {  return; }^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^return lower[0];^669^^^^^658^832^[REPLACE] return;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^if  ( cond.getType (  )   !=  Token.NOT )  {^672^^^^^658^832^[REPLACE] if  ( cond.getType (  )  == Token.NOT )  {^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^if  ( isLowerPrecedenceInExpression ( t, cond, OR_PRECEDENCE )  ) {^674^675^676^^^658^832^[REPLACE] if  ( isLowerPrecedenceInExpression ( t, cond, OR_PRECEDENCE )  && isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^return lower[0];^678^^^^^674^679^[REPLACE] return;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^return lower[0];^678^^^^^658^832^[REPLACE] return;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^return lower[0];^687^^^^^658^832^[REPLACE] return;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node or = new Node ( Token.OR, thenOp.removeFirstChild (  ) , expr.removeFirstChild (  )  ) ;^681^682^^^^658^832^[REPLACE] Node or = new Node ( Token.OR, cond.removeFirstChild (  ) , expr.removeFirstChild (  )  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^681^682^^^^658^832^[ADD] Node or = new Node ( Token.OR, cond.removeFirstChild (  ) , expr.removeFirstChild (  )  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^if  ( isLowerPrecedenceInExpression ( t, thenOp, OR_PRECEDENCE )  ) {^674^675^676^^^658^832^[REPLACE] if  ( isLowerPrecedenceInExpression ( t, cond, OR_PRECEDENCE )  && isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^674^675^676^^678^658^832^[ADD] if  ( isLowerPrecedenceInExpression ( t, cond, OR_PRECEDENCE )  && isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  { return;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^if  ( isLowerPrecedenceInExpression ( t, cond,true )  ) {^691^692^693^^^658^832^[REPLACE] if  ( isLowerPrecedenceInExpression ( t, cond, AND_PRECEDENCE )  || isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , AND_PRECEDENCE )  )  {^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^691^692^693^^695^658^832^[ADD] if  ( isLowerPrecedenceInExpression ( t, cond, AND_PRECEDENCE )  || isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , AND_PRECEDENCE )  )  { return;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^return lower[0];^695^^^^^691^696^[REPLACE] return;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^return lower[0];^695^^^^^658^832^[REPLACE] return;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node expr = getBlockExpression ( var ) ;^665^^^^^658^832^[REPLACE] Node expr = getBlockExpression ( thenBranch ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node or = new Node ( Token.OR, cond.removeFirstChild (  ) , var.removeFirstChild (  )  ) ;^681^682^^^^658^832^[REPLACE] Node or = new Node ( Token.OR, cond.removeFirstChild (  ) , expr.removeFirstChild (  )  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node newExpr = NodeUtil.newExpr ( var ) ;^683^^^^^658^832^[REPLACE] Node newExpr = NodeUtil.newExpr ( or ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node and = new Node ( Token.AND, thenOp, expr.removeFirstChild (  )  ) ;^699^^^^^658^832^[REPLACE] Node and = new Node ( Token.AND, cond, expr.removeFirstChild (  )  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node.isGetProp = NodeUtil.newExpr ( thenOp ) ;^700^^^^^658^832^[REPLACE] Node newExpr = NodeUtil.newExpr ( and ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^700^701^^^^658^832^[ADD] Node newExpr = NodeUtil.newExpr ( and ) ; parent.replaceChild ( n, newExpr ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^if  ( cond.getType (  )   &&  Token.NOT )  {^672^^^^^658^832^[REPLACE] if  ( cond.getType (  )  == Token.NOT )  {^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^if  ( isLowerPrecedenceInExpression ( t, cond, OR_PRECEDENCE )  || isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^674^675^676^^^658^832^[REPLACE] if  ( isLowerPrecedenceInExpression ( t, cond, OR_PRECEDENCE )  && isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node or = new Node ( Token.OR, thenOp.getFirstChild (  ) , expr.removeFirstChild (  )  ) ;^681^682^^^^658^832^[REPLACE] Node or = new Node ( Token.OR, cond.removeFirstChild (  ) , expr.removeFirstChild (  )  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node newExpr = NodeUtil .isGetProp ( elseAssign )  ;^683^^^^^658^832^[REPLACE] Node newExpr = NodeUtil.newExpr ( or ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^if  ( isLowerPrecedenceInExpression ( t, cond, thenBranchIsVar )  || isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , true )  )  {^674^675^676^^^658^832^[REPLACE] if  ( isLowerPrecedenceInExpression ( t, cond, OR_PRECEDENCE )  && isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^if  ( isLowerPrecedenceInExpression ( t, cond, AND_PRECEDENCE )  ) {^691^692^693^^^658^832^[REPLACE] if  ( isLowerPrecedenceInExpression ( t, cond, AND_PRECEDENCE )  || isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , AND_PRECEDENCE )  )  {^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^return lower[0];^705^^^^^658^832^[REPLACE] return;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node expr = getBlockExpression ( returnNode ) ;^665^^^^^658^832^[REPLACE] Node expr = getBlockExpression ( thenBranch ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node or = new Node ( Token.OR, cond .getFirstChild (  )  , expr^681^682^^^^658^832^[REPLACE] Node or = new Node ( Token.OR, cond.removeFirstChild (  ) , expr.removeFirstChild (  )  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node.isGetProp = NodeUtil.newExpr ( var ) ;^683^^^^^658^832^[REPLACE] Node newExpr = NodeUtil.newExpr ( or ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node newExpr = NodeUtil.newExpr ( thenAssign ) ;^700^^^^^658^832^[REPLACE] Node newExpr = NodeUtil.newExpr ( and ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^if  ( isLowerPrecedenceInExpression ( t, cond,true )  ) {^674^675^676^^^658^832^[REPLACE] if  ( isLowerPrecedenceInExpression ( t, cond, OR_PRECEDENCE )  && isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node or = new Node ( Token.OR, cond.getFirstChild (  ) , var.removeFirstChild (  )  ) ;^681^682^^^^658^832^[REPLACE] Node or = new Node ( Token.OR, cond.removeFirstChild (  ) , expr.removeFirstChild (  )  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^if  ( isLowerPrecedenceInExpression ( t, cond, true )  || isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^674^675^676^^^658^832^[REPLACE] if  ( isLowerPrecedenceInExpression ( t, cond, OR_PRECEDENCE )  && isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node expr = getBlockExpression ( name2 ) ;^665^^^^^658^832^[REPLACE] Node expr = getBlockExpression ( thenBranch ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node or = new Node ( Token.OR, cond.getFirstChild (  ) , expr.removeFirstChild (  )  ) ;^681^682^^^^658^832^[REPLACE] Node or = new Node ( Token.OR, cond.removeFirstChild (  ) , expr.removeFirstChild (  )  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node and = new Node ( Token.AND, cond, var.removeFirstChild (  )  ) ;^699^^^^^658^832^[REPLACE] Node and = new Node ( Token.AND, cond, expr.removeFirstChild (  )  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^Node newExpr = NodeUtil.newExpr ( and ) ;^699^700^^^^658^832^[ADD] Node and = new Node ( Token.AND, cond, expr.removeFirstChild (  )  ) ; Node newExpr = NodeUtil.newExpr ( and ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^683^684^^^^658^832^[ADD] Node newExpr = NodeUtil.newExpr ( or ) ; parent.replaceChild ( n, newExpr ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node newExpr = NodeUtil.newExpr ( thenOp ) ;^700^^^^^658^832^[REPLACE] Node newExpr = NodeUtil.newExpr ( and ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^tryRemoveRepeatedStatements ( t, parent ) ;^708^^^^^658^832^[REPLACE] tryRemoveRepeatedStatements ( t, n ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^if  ( cond.getType (  )  == Token.NOT ) {^712^^^^^658^832^[REPLACE] if  ( cond.getType (  )  == Token.NOT && !consumesDanglingElse ( elseBranch )  )  {^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^return lower[0];^717^^^^^658^832^[REPLACE] return;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^if  (  isReturnExpressBlock ( var )  )  { else {^721^^^^^658^832^[REPLACE] if  ( isReturnExpressBlock ( thenBranch )  && isReturnExpressBlock ( elseBranch )  )  {^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^return lower[0];^735^^^^^658^832^[REPLACE] return;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node thenExpr = getBlockReturnExpression ( newExpr ) ;^722^^^^^658^832^[REPLACE] Node thenExpr = getBlockReturnExpression ( thenBranch ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node thenExpr = getBlockReturnExpression ( thenBranch ) ;^723^^^^^658^832^[REPLACE] Node elseExpr = getBlockReturnExpression ( elseBranch ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node hookNode = new Node ( Token.HOOK, cond, var, elseExpr ) ;^731^^^^^658^832^[REPLACE] Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^Node returnNode = new Node ( Token.RETURN, hookNode ) ;parent.replaceChild ( n, returnNode ) ;t.getCompiler (  ) .reportCodeChange (  ) ;return;^731^732^733^734^735^658^832^[ADD] Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ; Node returnNode = new Node ( Token.RETURN, hookNode ) ; parent.replaceChild ( n, returnNode ) ; t.getCompiler (  ) .reportCodeChange (  ) ; return;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node returnNode = new Node ( Token.RETURN, thenOp ) ;^732^^^^^658^832^[REPLACE] Node returnNode = new Node ( Token.RETURN, hookNode ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node thenExpr = getBlockReturnExpression ( var ) ;^722^^^^^658^832^[REPLACE] Node thenExpr = getBlockReturnExpression ( thenBranch ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node hookNode = new Node ( Token.HOOK, thenOp, thenExpr, elseExpr ) ;^731^^^^^658^832^[REPLACE] Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^732^^^^^658^832^[ADD] Node returnNode = new Node ( Token.RETURN, hookNode ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^boolean newExprIsExpressionBlock = isExpressBlock ( thenBranch ) ;^738^^^^^658^832^[REPLACE] boolean thenBranchIsExpressionBlock = isExpressBlock ( thenBranch ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^boolean newExprIsExpressionBlock = isExpressBlock ( elseBranch ) ;^739^^^^^658^832^[REPLACE] boolean elseBranchIsExpressionBlock = isExpressBlock ( elseBranch ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^if  (  true )  { else {^741^^^^^658^832^[REPLACE] if  ( thenBranchIsExpressionBlock && elseBranchIsExpressionBlock )  {^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^Node thenOp = getBlockExpression ( thenBranch ) .getFirstChild (  ) ;Node elseOp = getBlockExpression ( elseBranch ) .getFirstChild (  ) ;^741^742^743^744^^658^832^[ADD] if  ( thenBranchIsExpressionBlock && elseBranchIsExpressionBlock )  { Node thenOp = getBlockExpression ( thenBranch ) .getFirstChild (  ) ; Node elseOp = getBlockExpression ( elseBranch ) .getFirstChild (  ) ; if  ( thenOp.getType (  )  == elseOp.getType (  )  )  {^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^if  ( thenOp.getType (  )   &&  elseOp.getType (  )  )  {^744^^^^^658^832^[REPLACE] if  ( thenOp.getType (  )  == elseOp.getType (  )  )  {^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^if  ( name2.hasChildren (  )^746^^^^^658^832^[REPLACE] if  ( NodeUtil.isAssignmentOp ( thenOp )  )  {^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^}  if  ( NodeUtil.isCall ( thenOp )  )  {^769^^^^^658^832^[REPLACE] } else if  ( NodeUtil.isCall ( thenOp )  )  {^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node hookNode = new Node ( Token.HOOK, cond, thenOp, parent ) ;^774^^^^^658^832^[REPLACE] Node hookNode = new Node ( Token.HOOK, cond, thenOp, elseOp ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node expr = NodeUtil.newExpr ( thenAssign ) ;^775^^^^^658^832^[REPLACE] Node expr = NodeUtil.newExpr ( hookNode ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node hookNode = new Node ( Token.HOOK, thenOp, thenOp, elseOp ) ;^774^^^^^658^832^[REPLACE] Node hookNode = new Node ( Token.HOOK, cond, thenOp, elseOp ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^Node expr = NodeUtil.newExpr ( hookNode ) ;parent.replaceChild ( n, expr ) ;t.getCompiler (  ) .reportCodeChange (  ) ;^774^775^776^777^778^658^832^[ADD] Node hookNode = new Node ( Token.HOOK, cond, thenOp, elseOp ) ; Node expr = NodeUtil.newExpr ( hookNode ) ; parent.replaceChild ( n, expr ) ; t.getCompiler (  ) .reportCodeChange (  ) ; }^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node expr = NodeUtil.isGetProp ( hookNode ) ;^775^^^^^658^832^[REPLACE] Node expr = NodeUtil.newExpr ( hookNode ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^if  ( lhs.checkTreeEqualsSilent ( Op.getFirstChild (  )  )  ||^748^749^750^751^^658^832^[REPLACE] if  ( lhs.checkTreeEqualsSilent ( elseOp.getFirstChild (  )  )  &&^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node assignName = n.removeFirstChild (  ) ;^756^^^^^748^768^[REPLACE] Node assignName = thenOp.removeFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^756^757^^^^748^768^[ADD] Node assignName = thenOp.removeFirstChild (  ) ; Node thenExpr = thenOp.removeFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node thenExpr = or.removeFirstChild (  ) ;^757^^^^^748^768^[REPLACE] Node thenExpr = thenOp.removeFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node elseExpr = thenBranch.getLastChild (  ) ;^758^^^^^748^768^[REPLACE] Node elseExpr = elseOp.getLastChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node hookNode = new Node ( Token.HOOK, cond, var, elseExpr ) ;^761^762^^^^748^768^[REPLACE] Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^761^762^^^^748^768^[ADD] Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node assign = new Node ( thenOp.getNext (  ) , assignName, thenOp ) ;^763^764^^^^748^768^[REPLACE] Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node expr = NodeUtil.isGetProp ( assign ) ;^765^^^^^748^768^[REPLACE] Node expr = NodeUtil.newExpr ( assign ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node lhs = thenExpr.getFirstChild (  ) ;^747^^^^^658^832^[REPLACE] Node lhs = thenOp.getFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node assignName = thenExpr.removeFirstChild (  ) ;^756^^^^^658^832^[REPLACE] Node assignName = thenOp.removeFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node thenExpr = thenOp .getFirstChild (  )  ;^757^^^^^658^832^[REPLACE] Node thenExpr = thenOp.removeFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node elseExpr = thenAssign.getLastChild (  ) ;^758^^^^^658^832^[REPLACE] Node elseExpr = elseOp.getLastChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node hookNode = new Node ( Token.HOOK, thenExpr, thenExpr, elseExpr ) ;^761^762^^^^658^832^[REPLACE] Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^761^762^^^^658^832^[ADD] Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node assign = new Node ( thenOp.getNext (  ) , assignName, hookNode ) ;^763^764^^^^658^832^[REPLACE] Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node expr = NodeUtil.isGetProp ( thenBranch ) ;^765^^^^^658^832^[REPLACE] Node expr = NodeUtil.newExpr ( assign ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^748^749^^^^658^832^[ADD] if  ( lhs.checkTreeEqualsSilent ( elseOp.getFirstChild (  )  )  &&^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node assignName = newExpr.removeFirstChild (  ) ;^756^^^^^748^768^[REPLACE] Node assignName = thenOp.removeFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^Node thenExpr = thenOp.removeFirstChild (  ) ;^756^757^^^^748^768^[ADD] Node assignName = thenOp.removeFirstChild (  ) ; Node thenExpr = thenOp.removeFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node thenExpr = thenBranch.removeFirstChild (  ) ;^757^^^^^748^768^[REPLACE] Node thenExpr = thenOp.removeFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node elseExpr = thenOp .getFirstChild (  )  ;^758^^^^^748^768^[REPLACE] Node elseExpr = elseOp.getLastChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node hookNode = new Node ( Token.HOOK, cond, name2, elseExpr ) ;^761^762^^^^748^768^[REPLACE] Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node expr = NodeUtil .isGetProp ( thenExpr )  ;^765^^^^^748^768^[REPLACE] Node expr = NodeUtil.newExpr ( assign ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^}   n.removeChild ( cond ) ;thenOp.detachFromParent (  ) ;elseOp.detachFromParent (  ) ;^769^770^771^772^773^658^832^[ADD] else if  ( NodeUtil.isCall ( thenOp )  )  {  n.removeChild ( cond ) ; thenOp.detachFromParent (  ) ; elseOp.detachFromParent (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node hookNode = new Node ( Token.HOOK, cond, returnNode, elseOp ) ;^774^^^^^658^832^[REPLACE] Node hookNode = new Node ( Token.HOOK, cond, thenOp, elseOp ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^774^775^776^777^778^658^832^[ADD] Node hookNode = new Node ( Token.HOOK, cond, thenOp, elseOp ) ; Node expr = NodeUtil.newExpr ( hookNode ) ; parent.replaceChild ( n, expr ) ; t.getCompiler (  ) .reportCodeChange (  ) ; }^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node expr = NodeUtil.newExpr ( thenOp ) ;^775^^^^^658^832^[REPLACE] Node expr = NodeUtil.newExpr ( hookNode ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^775^^^^^658^832^[ADD] Node expr = NodeUtil.newExpr ( hookNode ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node lhs = thenAssign.getLastChild (  ) ;^747^^^^^658^832^[REPLACE] Node lhs = thenOp.getFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^756^757^^^^658^832^[ADD] Node assignName = thenOp.removeFirstChild (  ) ; Node thenExpr = thenOp.removeFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node thenExpr = thenExpr.getFirstChild (  ) ;^757^^^^^658^832^[REPLACE] Node thenExpr = thenOp.removeFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node elseExpr = thenOp.getFirstChild (  ) ;^758^^^^^658^832^[REPLACE] Node elseExpr = elseOp.getLastChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node hookNode = new Node ( Token.HOOK, cond, var, elseExpr ) ;^761^762^^^^658^832^[REPLACE] Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node assign = new Node ( or.getType (  ) , assignName, hookNode ) ;^763^764^^^^658^832^[REPLACE] Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node expr = NodeUtil.newExpr ( thenBranch ) ;^765^^^^^658^832^[REPLACE] Node expr = NodeUtil.newExpr ( assign ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node hookNode = new Node ( Token.HOOK, thenExpr, thenOp, elseOp ) ;^774^^^^^658^832^[REPLACE] Node hookNode = new Node ( Token.HOOK, cond, thenOp, elseOp ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^} else if  ( NodeUtil.has ( thenOp )  )  {^769^^^^^658^832^[REPLACE] } else if  ( NodeUtil.isCall ( thenOp )  )  {^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node hookNode = new Node ( Token.HOOK, cond, thenOp, newExpr ) ;^774^^^^^658^832^[REPLACE] Node hookNode = new Node ( Token.HOOK, cond, thenOp, elseOp ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node expr =   thenOp   ;^775^^^^^658^832^[REPLACE] Node expr = NodeUtil.newExpr ( hookNode ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node hookNode = new Node ( Token.HOOK, cond, newExpr, elseOp ) ;^774^^^^^658^832^[REPLACE] Node hookNode = new Node ( Token.HOOK, cond, thenOp, elseOp ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node expr = NodeUtil.newExpr ( thenBranch ) ;^775^^^^^658^832^[REPLACE] Node expr = NodeUtil.newExpr ( hookNode ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^775^776^^^^658^832^[ADD] Node expr = NodeUtil.newExpr ( hookNode ) ; parent.replaceChild ( n, expr ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node assignName = thenBranch.removeFirstChild (  ) ;^756^^^^^748^768^[REPLACE] Node assignName = thenOp.removeFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^756^^^^^748^768^[ADD] Node assignName = thenOp.removeFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^757^758^^^^748^768^[ADD] Node thenExpr = thenOp.removeFirstChild (  ) ; Node elseExpr = elseOp.getLastChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node elseExpr = elseOp.getFirstChild (  ) ;^758^^^^^748^768^[REPLACE] Node elseExpr = elseOp.getLastChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node hookNode = new Node ( Token.HOOK, thenOp, thenExpr, elseExpr ) ;^761^762^^^^748^768^[REPLACE] Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node assign = new Node ( thenOp.getNext (  ) , assignName, hookNode ) ;^763^764^^^^748^768^[REPLACE] Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node expr = NodeUtil.newExpr ( thenBranch ) ;^765^^^^^748^768^[REPLACE] Node expr = NodeUtil.newExpr ( assign ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node lhs = thenExpr.getLastChild (  ) ;^747^^^^^658^832^[REPLACE] Node lhs = thenOp.getFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^747^^^^^658^832^[ADD] Node lhs = thenOp.getFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node thenExpr = thenExpr.removeFirstChild (  ) ;^757^^^^^658^832^[REPLACE] Node thenExpr = thenOp.removeFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node elseExpr = parent.getFirstChild (  ) ;^758^^^^^658^832^[REPLACE] Node elseExpr = elseOp.getLastChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^763^764^^^^658^832^[ADD] Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^if  ( lhs.checkTreeEqualsSilent ( elseOp.getFirstChild (  )  )  ||^748^749^750^751^^658^832^[REPLACE] if  ( lhs.checkTreeEqualsSilent ( elseOp.getFirstChild (  )  )  &&^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REMOVE]^if  (  ( isReturnExpressBlock ( thenBranch )  )  &&  ( isReturnExpressBlock ( elseBranch )  )  )  {     Node thenExpr = getBlockReturnExpression ( thenBranch ) ;     Node elseExpr = getBlockReturnExpression ( elseBranch ) ;     n.removeChild ( cond ) ;     thenExpr.detachFromParent (  ) ;     elseExpr.detachFromParent (  ) ;     Node hookNode = new Node ( HOOK, cond, thenExpr, elseExpr ) ;     Node returnNode = new Node ( RETURN, hookNode ) ;     parent.replaceChild ( n, returnNode ) ;     t.getCompiler (  ) .reportCodeChange (  ) ;     return ; }^748^^^^^658^832^[REMOVE] ^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node assignName = or.removeFirstChild (  ) ;^756^^^^^748^768^[REPLACE] Node assignName = thenOp.removeFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node thenExpr = n.removeFirstChild (  ) ;^757^^^^^748^768^[REPLACE] Node thenExpr = thenOp.removeFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node elseExpr = thenOp.getLastChild (  ) ;^758^^^^^748^768^[REPLACE] Node elseExpr = elseOp.getLastChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, thenBranch ) ;^761^762^^^^748^768^[REPLACE] Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^763^764^^^^748^768^[ADD] Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node expr = NodeUtil.isGetProp ( thenBranch ) ;^765^^^^^748^768^[REPLACE] Node expr = NodeUtil.newExpr ( assign ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^}  if  ( NodeUtil .isLiteralValue ( thenBranch )   )  {^769^^^^^658^832^[REPLACE] } else if  ( NodeUtil.isCall ( thenOp )  )  {^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^774^^^^^658^832^[REPLACE] Node hookNode = new Node ( Token.HOOK, cond, thenOp, elseOp ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^return lower[0];^780^^^^^658^832^[REPLACE] return;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node thenOp = getBlockExpression ( thenBranch ) .getVar (  ) ;^742^^^^^658^832^[REPLACE] Node thenOp = getBlockExpression ( thenBranch ) .getFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node elseOp = getBlockExpression ( var ) .getFirstChild (  ) ;^743^^^^^658^832^[REPLACE] Node elseOp = getBlockExpression ( elseBranch ) .getFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^743^744^^746^747^658^832^[ADD] Node elseOp = getBlockExpression ( elseBranch ) .getFirstChild (  ) ; if  ( thenOp.getType (  )  == elseOp.getType (  )  )  { if  ( NodeUtil.isAssignmentOp ( thenOp )  )  { Node lhs = thenOp.getFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node lhs = n.getFirstChild (  ) ;^747^^^^^658^832^[REPLACE] Node lhs = thenOp.getFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node assignName = returnNode .getFirstChild (  )  ;^756^^^^^658^832^[REPLACE] Node assignName = thenOp.removeFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node elseExpr = newExpr .getFirstChild (  )  ;^758^^^^^658^832^[REPLACE] Node elseExpr = elseOp.getLastChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, var ) ;^761^762^^^^658^832^[REPLACE] Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node assign = new Node ( thenOp.getType (  ) , assignName, thenOp ) ;^763^764^^^^658^832^[REPLACE] Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node hookNode = new Node ( Token.HOOK, cond, thenOp, thenExpr ) ;^774^^^^^658^832^[REPLACE] Node hookNode = new Node ( Token.HOOK, cond, thenOp, elseOp ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^if  ( thenOp.getType (  )   &&   else {^744^^^^^658^832^[REPLACE] if  ( thenOp.getType (  )  == elseOp.getType (  )  )  {^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^}  else {^769^^^^^658^832^[REPLACE] } else if  ( NodeUtil.isCall ( thenOp )  )  {^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node expr = NodeUtil.isGetProp ( thenAssign ) ;^775^^^^^658^832^[REPLACE] Node expr = NodeUtil.newExpr ( hookNode ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node assignName = thenExpr.removeFirstChild (  ) ;^756^^^^^748^768^[REPLACE] Node assignName = thenOp.removeFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node thenExpr = thenOp.getFirstChild (  ) ;^757^^^^^748^768^[REPLACE] Node thenExpr = thenOp.removeFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^757^^^^^748^768^[ADD] Node thenExpr = thenOp.removeFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node assign = new Node ( thenOp.getType (  ) , assignName, thenOp ) ;^763^764^^^^748^768^[REPLACE] Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node lhs = returnNode.getFirstChild (  ) ;^747^^^^^658^832^[REPLACE] Node lhs = thenOp.getFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node thenExpr = or.removeFirstChild (  ) ;^757^^^^^658^832^[REPLACE] Node thenExpr = thenOp.removeFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node elseExpr = newExpr.getLastChild (  ) ;^758^^^^^658^832^[REPLACE] Node elseExpr = elseOp.getLastChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node assign = new Node ( thenOp.getType (  ) , assignName, thenAssign ) ;^763^764^^^^658^832^[REPLACE] Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node expr = NodeUtil .isGetProp ( lhs )  ;^765^^^^^658^832^[REPLACE] Node expr = NodeUtil.newExpr ( assign ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node assignName = thenAssign.removeFirstChild (  ) ;^756^^^^^748^768^[REPLACE] Node assignName = thenOp.removeFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node elseExpr = newExpr.getFirstChild (  ) ;^758^^^^^748^768^[REPLACE] Node elseExpr = elseOp.getLastChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node hookNode = new Node ( Token.HOOK, thenExpr, thenExpr, elseExpr ) ;^761^762^^^^748^768^[REPLACE] Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node assign = new Node ( or.getType (  ) , assignName, hookNode ) ;^763^764^^^^748^768^[REPLACE] Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node hookNode = new Node ( Token.HOOK, cond, thenBranch, elseOp ) ;^774^^^^^658^832^[REPLACE] Node hookNode = new Node ( Token.HOOK, cond, thenOp, elseOp ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node expr = NodeUtil.isGetProp ( thenOp ) ;^775^^^^^658^832^[REPLACE] Node expr = NodeUtil.newExpr ( hookNode ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node lhs = thenOp.getLastChild (  ) ;^747^^^^^658^832^[REPLACE] Node lhs = thenOp.getFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node assignName = newExpr.removeFirstChild (  ) ;^756^^^^^658^832^[REPLACE] Node assignName = thenOp.removeFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^756^^^^^658^832^[ADD] Node assignName = thenOp.removeFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^757^758^^^^658^832^[ADD] Node thenExpr = thenOp.removeFirstChild (  ) ; Node elseExpr = elseOp.getLastChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node elseExpr = or.getLastChild (  ) ;^758^^^^^658^832^[REPLACE] Node elseExpr = elseOp.getLastChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node hookNode = new Node ( Token.HOOK, cond, thenAssign, elseExpr ) ;^761^762^^^^658^832^[REPLACE] Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node assign = new Node ( thenOp .setType ( newType )  , assignName, hookNode ) ;^763^764^^^^658^832^[REPLACE] Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^Node lhs = thenOp.getFirstChild (  ) ;^746^747^748^^^658^832^[ADD] if  ( NodeUtil.isAssignmentOp ( thenOp )  )  { Node lhs = thenOp.getFirstChild (  ) ; if  ( lhs.checkTreeEqualsSilent ( elseOp.getFirstChild (  )  )  &&^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^}  if  ( NodeUtil.isCall ( or )  )  {^769^^^^^658^832^[REPLACE] } else if  ( NodeUtil.isCall ( thenOp )  )  {^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node assignName = parent.removeFirstChild (  ) ;^756^^^^^748^768^[REPLACE] Node assignName = thenOp.removeFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node thenExpr = thenExpr.removeFirstChild (  ) ;^757^^^^^748^768^[REPLACE] Node thenExpr = thenOp.removeFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node assign = new Node ( thenExpr.getType (  ) , assignName, hookNode ) ;^763^764^^^^748^768^[REPLACE] Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node lhs = newExpr.getFirstChild (  ) ;^747^^^^^658^832^[REPLACE] Node lhs = thenOp.getFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node assignName = returnNode.removeFirstChild (  ) ;^756^^^^^658^832^[REPLACE] Node assignName = thenOp.removeFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node thenExpr = n.getFirstChild (  ) ;^757^^^^^658^832^[REPLACE] Node thenExpr = thenOp.removeFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node elseExpr = thenAssign .getFirstChild (  )  ;^758^^^^^658^832^[REPLACE] Node elseExpr = elseOp.getLastChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node hookNode = new Node ( Token.HOOK, cond, returnNode, elseExpr ) ;^761^762^^^^658^832^[REPLACE] Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node assign = new Node ( thenOp.getType (  ) , assignName, thenBranch ) ;^763^764^^^^658^832^[REPLACE] Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^parent.replaceChild ( n, expr ) ;^765^766^^^^658^832^[ADD] Node expr = NodeUtil.newExpr ( assign ) ; parent.replaceChild ( n, expr ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node assignName = or.getFirstChild (  ) ;^756^^^^^748^768^[REPLACE] Node assignName = thenOp.removeFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node thenExpr = newExpr.removeFirstChild (  ) ;^757^^^^^748^768^[REPLACE] Node thenExpr = thenOp.removeFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node elseExpr = or.getLastChild (  ) ;^758^^^^^748^768^[REPLACE] Node elseExpr = elseOp.getLastChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, var ) ;^761^762^^^^748^768^[REPLACE] Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^if  ( name2.hasChildren (  )^769^^^^^658^832^[REPLACE] } else if  ( NodeUtil.isCall ( thenOp )  )  {^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node thenOp = getBlockExpression ( var ) .getFirstChild (  ) ;^742^^^^^658^832^[REPLACE] Node thenOp = getBlockExpression ( thenBranch ) .getFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node elseOp = getBlockExpression ( returnNode ) .getFirstChild (  ) ;^743^^^^^658^832^[REPLACE] Node elseOp = getBlockExpression ( elseBranch ) .getFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node lhs = thenExpr .getLastChild (  )  ;^747^^^^^658^832^[REPLACE] Node lhs = thenOp.getFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node thenExpr = thenOp.getFirstChild (  ) ;^757^^^^^658^832^[REPLACE] Node thenExpr = thenOp.removeFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^boolean name2IsVar = isVarBlock ( thenBranch ) ;^783^^^^^658^832^[REPLACE] boolean thenBranchIsVar = isVarBlock ( thenBranch ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^boolean varIsVar = isVarBlock ( elseBranch ) ;^784^^^^^658^832^[REPLACE] boolean elseBranchIsVar = isVarBlock ( elseBranch ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^if  ( thenBranchIsVar || BranchIsExpressionBlock || NodeUtil.isAssign ( getBlockExpression ( Branch ) .getFirstChild (  )  )  )  {^787^788^^^^658^832^[REPLACE] if  ( thenBranchIsVar && elseBranchIsExpressionBlock && NodeUtil.isAssign ( getBlockExpression ( elseBranch ) .getFirstChild (  )  )  )  {^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^} else if  (  thenBranchIsExpressionBlock || NodeUtil.isAssign ( getBlockExpression ( thenBranch ) .getFirstChild (  )  )  )  {^810^811^^^^658^832^[REPLACE] } else if  ( elseBranchIsVar && thenBranchIsExpressionBlock && NodeUtil.isAssign ( getBlockExpression ( thenBranch ) .getFirstChild (  )  )  )  {^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^if  ( name2.hasChildren (  ) || maybeName1.getType (  )  == Token.NAME || maybeName1.getString (  ) .equals ( name2.getString (  )  )  )  {^819^820^821^^^810^831^[REPLACE] if  ( name2.hasChildren (  ) && maybeName1.getType (  )  == Token.NAME && maybeName1.getString (  ) .equals ( name2.getString (  )  )  )  {^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node thenExpr = name2.getFirstChild (  ) .detachFromParent (  ) ;^822^^^^^810^831^[REPLACE] Node thenExpr = thenAssign.getLastChild (  ) .detachFromParent (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^Node elseExpr = name2.removeChildren (  ) ;^822^823^^^^810^831^[ADD] Node thenExpr = thenAssign.getLastChild (  ) .detachFromParent (  ) ; Node elseExpr = name2.removeChildren (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node elseExpr = var.removeChildren (  ) ;^823^^^^^810^831^[REPLACE] Node elseExpr = name2.removeChildren (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^cond.detachFromParent (  ) ;Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;var.detachFromParent (  ) ;name2.addChildrenToBack ( hookNode ) ;^823^824^825^826^827^810^831^[ADD] Node elseExpr = name2.removeChildren (  ) ; cond.detachFromParent (  ) ; Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ; var.detachFromParent (  ) ; name2.addChildrenToBack ( hookNode ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, parent ) ;^825^^^^^810^831^[REPLACE] Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node var = getBlockVar ( or ) ;^813^^^^^810^831^[REPLACE] Node var = getBlockVar ( elseBranch ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node thenAssign = getBlockExpression ( var ) .getFirstChild (  ) ;^814^^^^^810^831^[REPLACE] Node thenAssign = getBlockExpression ( thenBranch ) .getFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node maybeName1 = n .getLastChild (  )  ;^816^^^^^810^831^[REPLACE] Node maybeName1 = thenAssign.getFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^816^^^^^810^831^[ADD] Node maybeName1 = thenAssign.getFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node name2 = thenAssign .getLastChild (  )  ;^817^^^^^810^831^[REPLACE] Node name2 = var.getFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^817^^^^^810^831^[ADD] Node name2 = var.getFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node thenExpr = var .getFirstChild (  )  .detachFromParent (  ) ;^822^^^^^810^831^[REPLACE] Node thenExpr = thenAssign.getLastChild (  ) .detachFromParent (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^822^^^^^810^831^[ADD] Node thenExpr = thenAssign.getLastChild (  ) .detachFromParent (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node elseExpr = thenAssign.detachChildren (  ) ;^823^^^^^810^831^[REPLACE] Node elseExpr = name2.removeChildren (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node hookNode = new Node ( Token.HOOK, cond, thenOp, elseOp ) ;^825^^^^^810^831^[REPLACE] Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^if  ( name2.hasChildren (  ) ) {^819^820^821^^^658^832^[REPLACE] if  ( name2.hasChildren (  ) && maybeName1.getType (  )  == Token.NAME && maybeName1.getString (  ) .equals ( name2.getString (  )  )  )  {^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node thenExpr = parent.getLastChild (  ) .detachFromParent (  ) ;^822^^^^^819^830^[REPLACE] Node thenExpr = thenAssign.getLastChild (  ) .detachFromParent (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node elseExpr = returnNode.removeChildren (  ) ;^823^^^^^819^830^[REPLACE] Node elseExpr = name2.removeChildren (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node hookNode = new Node ( Token.HOOK, cond, newExpr, elseExpr ) ;^825^^^^^819^830^[REPLACE] Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node var = getBlockVar ( name1 ) ;^813^^^^^658^832^[REPLACE] Node var = getBlockVar ( elseBranch ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node thenAssign = getBlockExpression ( name2 ) .getFirstChild (  ) ;^814^^^^^658^832^[REPLACE] Node thenAssign = getBlockExpression ( thenBranch ) .getFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^814^^^^^658^832^[ADD] Node thenAssign = getBlockExpression ( thenBranch ) .getFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node maybeName1 = thenAssign.getLastChild (  ) ;^816^^^^^658^832^[REPLACE] Node maybeName1 = thenAssign.getFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^816^^^^^658^832^[ADD] Node maybeName1 = thenAssign.getFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node name2 = thenExpr.getFirstChild (  ) ;^817^^^^^658^832^[REPLACE] Node name2 = var.getFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node thenExpr = name1.getLastChild (  ) .detachFromParent (  ) ;^822^^^^^658^832^[REPLACE] Node thenExpr = thenAssign.getLastChild (  ) .detachFromParent (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node elseExpr = thenBranch.removeChildren (  ) ;^823^^^^^658^832^[REPLACE] Node elseExpr = name2.removeChildren (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, thenBranch ) ;^825^^^^^658^832^[REPLACE] Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^if  ( name1.hasChildren (  ) || maybeName2.getType (  )  == Token.NAME || name1.getString (  ) .equals ( maybeName2.getString (  )  )  )  {^796^797^798^^^787^831^[REPLACE] if  ( name1.hasChildren (  ) && maybeName2.getType (  )  == Token.NAME && name1.getString (  ) .equals ( maybeName2.getString (  )  )  )  {^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node thenExpr = returnNode.detachChildren (  ) ;^799^^^^^796^807^[REPLACE] Node thenExpr = name1.removeChildren (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node elseExpr = var .getFirstChild (  )  .detachFromParent (  ) ;^800^^^^^796^807^[REPLACE] Node elseExpr = elseAssign.getLastChild (  ) .detachFromParent (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^cond.detachFromParent (  ) ;Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;var.detachFromParent (  ) ;name1.addChildrenToBack ( hookNode ) ;^800^801^802^803^804^796^807^[ADD] Node elseExpr = elseAssign.getLastChild (  ) .detachFromParent (  ) ; cond.detachFromParent (  ) ; Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ; var.detachFromParent (  ) ; name1.addChildrenToBack ( hookNode ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node hookNode = new Node ( Token.HOOK, cond, var, elseExpr ) ;^802^^^^^796^807^[REPLACE] Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node var = getBlockVar ( newExpr ) ;^790^^^^^787^831^[REPLACE] Node var = getBlockVar ( thenBranch ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node elseAssign = getBlockExpression ( name1 ) .getFirstChild (  ) ;^791^^^^^787^831^[REPLACE] Node elseAssign = getBlockExpression ( elseBranch ) .getFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node name1 = thenExpr.getLastChild (  ) ;^793^^^^^787^831^[REPLACE] Node name1 = var.getFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^793^^^^^787^831^[ADD] Node name1 = var.getFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node maybeName2 = elseAssign.getLastChild (  ) ;^794^^^^^787^831^[REPLACE] Node maybeName2 = elseAssign.getFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node thenExpr = var.removeChildren (  ) ;^799^^^^^787^831^[REPLACE] Node thenExpr = name1.removeChildren (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node elseExpr = thenAssign.getLastChild (  ) .detachFromParent (  ) ;^800^^^^^787^831^[REPLACE] Node elseExpr = elseAssign.getLastChild (  ) .detachFromParent (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node hookNode = new Node ( Token.HOOK, cond, name2, elseExpr ) ;^802^^^^^787^831^[REPLACE] Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^if  ( name1.hasChildren (  ) ) {^796^797^798^^^658^832^[REPLACE] if  ( name1.hasChildren (  ) && maybeName2.getType (  )  == Token.NAME && name1.getString (  ) .equals ( maybeName2.getString (  )  )  )  {^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node thenExpr = returnNode.removeChildren (  ) ;^799^^^^^796^807^[REPLACE] Node thenExpr = name1.removeChildren (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node elseExpr = var.getLastChild (  ) .detachFromParent (  ) ;^800^^^^^796^807^[REPLACE] Node elseExpr = elseAssign.getLastChild (  ) .detachFromParent (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, parent ) ;^802^^^^^796^807^[REPLACE] Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^}  if  (  thenBranchIsExpressionBlock || NodeUtil.isAssign ( getBlockExpression ( thenBranch ) .getFirstChild (  )  )  )  {^810^811^^^^658^832^[REPLACE] } else if  ( elseBranchIsVar && thenBranchIsExpressionBlock && NodeUtil.isAssign ( getBlockExpression ( thenBranch ) .getFirstChild (  )  )  )  {^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^if  (  maybeName1.getType (  )  == Token.NAME || maybeName1.getString (  ) .equals ( name2.getString (  )  )  )  {^819^820^821^^^810^831^[REPLACE] if  ( name2.hasChildren (  ) && maybeName1.getType (  )  == Token.NAME && maybeName1.getString (  ) .equals ( name2.getString (  )  )  )  {^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^819^820^821^822^823^810^831^[ADD] if  ( name2.hasChildren (  ) && maybeName1.getType (  )  == Token.NAME && maybeName1.getString (  ) .equals ( name2.getString (  )  )  )  { Node thenExpr = thenAssign.getLastChild (  ) .detachFromParent (  ) ; Node elseExpr = name2.removeChildren (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node thenExpr = thenAssign.getLastChild (  ) .getVar (  ) ;^822^^^^^810^831^[REPLACE] Node thenExpr = thenAssign.getLastChild (  ) .detachFromParent (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node hookNode = new Node ( Token.HOOK, cond, name2, elseExpr ) ;^825^^^^^810^831^[REPLACE] Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node var = getBlockVar ( name1 ) ;^813^^^^^810^831^[REPLACE] Node var = getBlockVar ( elseBranch ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node thenAssign = getBlockExpression ( thenOp ) .getFirstChild (  ) ;^814^^^^^810^831^[REPLACE] Node thenAssign = getBlockExpression ( thenBranch ) .getFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^814^^^^^810^831^[ADD] Node thenAssign = getBlockExpression ( thenBranch ) .getFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node maybeName1 = name1 .getLastChild (  )  ;^816^^^^^810^831^[REPLACE] Node maybeName1 = thenAssign.getFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node name2 = thenBranch.getFirstChild (  ) ;^817^^^^^810^831^[REPLACE] Node name2 = var.getFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node thenExpr = name2.getLastChild (  ) .detachFromParent (  ) ;^822^^^^^810^831^[REPLACE] Node thenExpr = thenAssign.getLastChild (  ) .detachFromParent (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node elseExpr = parent.detachChildren (  ) ;^823^^^^^810^831^[REPLACE] Node elseExpr = name2.removeChildren (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node hookNode = new Node ( Token.HOOK, thenOp, thenExpr, elseExpr ) ;^825^^^^^810^831^[REPLACE] Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^if  ( name2.hasChildren (  ) || maybeName1.getType (  )  == Token.NAME || maybeName1.getString (  ) .equals ( name2.getString (  )  )  )  {^819^820^821^^^658^832^[REPLACE] if  ( name2.hasChildren (  ) && maybeName1.getType (  )  == Token.NAME && maybeName1.getString (  ) .equals ( name2.getString (  )  )  )  {^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^819^820^821^822^823^658^832^[ADD] if  ( name2.hasChildren (  ) && maybeName1.getType (  )  == Token.NAME && maybeName1.getString (  ) .equals ( name2.getString (  )  )  )  { Node thenExpr = thenAssign.getLastChild (  ) .detachFromParent (  ) ; Node elseExpr = name2.removeChildren (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node thenExpr = newExpr.getLastChild (  ) .detachFromParent (  ) ;^822^^^^^819^830^[REPLACE] Node thenExpr = thenAssign.getLastChild (  ) .detachFromParent (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node elseExpr = thenBranch.removeChildren (  ) ;^823^^^^^819^830^[REPLACE] Node elseExpr = name2.removeChildren (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, thenExpr ) ;^825^^^^^819^830^[REPLACE] Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node var = getBlockVar ( thenOp ) ;^790^^^^^658^832^[REPLACE] Node var = getBlockVar ( thenBranch ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node elseAssign = getBlockExpression ( var ) .getFirstChild (  ) ;^791^^^^^658^832^[REPLACE] Node elseAssign = getBlockExpression ( elseBranch ) .getFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node name1 = returnNode.getFirstChild (  ) ;^793^^^^^658^832^[REPLACE] Node name1 = var.getFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node maybeName2 = elseAssign.getLastChild (  ) ;^794^^^^^658^832^[REPLACE] Node maybeName2 = elseAssign.getFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node thenExpr = returnNode.detachChildren (  ) ;^799^^^^^658^832^[REPLACE] Node thenExpr = name1.removeChildren (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node elseExpr = var.getFirstChild (  ) .detachFromParent (  ) ;^800^^^^^658^832^[REPLACE] Node elseExpr = elseAssign.getLastChild (  ) .detachFromParent (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, parent ) ;^802^^^^^658^832^[REPLACE] Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node var = getBlockVar ( or ) ;^813^^^^^658^832^[REPLACE] Node var = getBlockVar ( elseBranch ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node thenAssign = getBlockExpression ( thenBranch ) .getVar (  ) ;^814^^^^^658^832^[REPLACE] Node thenAssign = getBlockExpression ( thenBranch ) .getFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node maybeName1 = n.getFirstChild (  ) ;^816^^^^^658^832^[REPLACE] Node maybeName1 = thenAssign.getFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node name2 = var .getLastChild (  )  ;^817^^^^^658^832^[REPLACE] Node name2 = var.getFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node thenExpr = var.getLastChild (  ) .getVar (  ) ;^822^^^^^658^832^[REPLACE] Node thenExpr = thenAssign.getLastChild (  ) .detachFromParent (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node elseExpr = var.removeChildren (  ) ;^823^^^^^658^832^[REPLACE] Node elseExpr = name2.removeChildren (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^cond.detachFromParent (  ) ;Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;var.detachFromParent (  ) ;name2.addChildrenToBack ( hookNode ) ;^823^824^825^826^827^658^832^[ADD] Node elseExpr = name2.removeChildren (  ) ; cond.detachFromParent (  ) ; Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ; var.detachFromParent (  ) ; name2.addChildrenToBack ( hookNode ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node hookNode = new Node ( Token.HOOK, cond, var, elseExpr ) ;^825^^^^^658^832^[REPLACE] Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^825^826^827^828^829^658^832^[ADD] Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ; var.detachFromParent (  ) ; name2.addChildrenToBack ( hookNode ) ; parent.replaceChild ( n, var ) ; t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Preconditions.checkState ( n.getType (  )   ||  Token.IF ) ;^857^^^^^856^884^[REPLACE] Preconditions.checkState ( n.getType (  )  == Token.IF ) ;^[METHOD] tryRemoveRepeatedStatements [TYPE] void [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node cond  falseBranch  lastFalse  lastTrue  n  parent  trueBranch  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Preconditions.checkState ( trueBranch.getType (  )  == Token.IF ) ;^857^^^^^856^884^[REPLACE] Preconditions.checkState ( n.getType (  )  == Token.IF ) ;^[METHOD] tryRemoveRepeatedStatements [TYPE] void [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node cond  falseBranch  lastFalse  lastTrue  n  parent  trueBranch  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node parent = n.getString (  ) ;^859^^^^^856^884^[REPLACE] Node parent = n.getParent (  ) ;^[METHOD] tryRemoveRepeatedStatements [TYPE] void [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node cond  falseBranch  lastFalse  lastTrue  n  parent  trueBranch  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^if  ( !NodeUtil.isStatementBlock ( trueBranch )  )  {^860^^^^^856^884^[REPLACE] if  ( !NodeUtil.isStatementBlock ( parent )  )  {^[METHOD] tryRemoveRepeatedStatements [TYPE] void [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node cond  falseBranch  lastFalse  lastTrue  n  parent  trueBranch  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^return lower[0];^863^^^^^856^884^[REPLACE] return;^[METHOD] tryRemoveRepeatedStatements [TYPE] void [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node cond  falseBranch  lastFalse  lastTrue  n  parent  trueBranch  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node cond = trueBranch.getLastChild (  ) ;^866^^^^^856^884^[REPLACE] Node cond = n.getFirstChild (  ) ;^[METHOD] tryRemoveRepeatedStatements [TYPE] void [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node cond  falseBranch  lastFalse  lastTrue  n  parent  trueBranch  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^866^867^^^^856^884^[ADD] Node cond = n.getFirstChild (  ) ; Node trueBranch = cond.getNext (  ) ;^[METHOD] tryRemoveRepeatedStatements [TYPE] void [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node cond  falseBranch  lastFalse  lastTrue  n  parent  trueBranch  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node trueBranch = trueBranch.getNext (  ) ;^867^^^^^856^884^[REPLACE] Node trueBranch = cond.getNext (  ) ;^[METHOD] tryRemoveRepeatedStatements [TYPE] void [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node cond  falseBranch  lastFalse  lastTrue  n  parent  trueBranch  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node falseBranch = parent.getNext (  ) ;^868^^^^^856^884^[REPLACE] Node falseBranch = trueBranch.getNext (  ) ;^[METHOD] tryRemoveRepeatedStatements [TYPE] void [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node cond  falseBranch  lastFalse  lastTrue  n  parent  trueBranch  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Preconditions .checkState (  )  ;^869^^^^^856^884^[REPLACE] Preconditions.checkNotNull ( trueBranch ) ;^[METHOD] tryRemoveRepeatedStatements [TYPE] void [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node cond  falseBranch  lastFalse  lastTrue  n  parent  trueBranch  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Preconditions.checkState ( parent ) ;^870^^^^^856^884^[REPLACE] Preconditions.checkNotNull ( falseBranch ) ;^[METHOD] tryRemoveRepeatedStatements [TYPE] void [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node cond  falseBranch  lastFalse  lastTrue  n  parent  trueBranch  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^while  ( false )  {^872^^^^^856^884^[REPLACE] while  ( true )  {^[METHOD] tryRemoveRepeatedStatements [TYPE] void [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node cond  falseBranch  lastFalse  lastTrue  n  parent  trueBranch  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^872^873^^^^856^884^[ADD] while  ( true )  { Node lastTrue = trueBranch.getLastChild (  ) ;^[METHOD] tryRemoveRepeatedStatements [TYPE] void [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node cond  falseBranch  lastFalse  lastTrue  n  parent  trueBranch  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^if  ( lastTrue != null || lastFalse == null || !lastTrue.checkTreeEqualsSilent ( lastFalse )  )  {^875^876^^^^856^884^[REPLACE] if  ( lastTrue == null || lastFalse == null || !lastTrue.checkTreeEqualsSilent ( lastFalse )  )  {^[METHOD] tryRemoveRepeatedStatements [TYPE] void [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node cond  falseBranch  lastFalse  lastTrue  n  parent  trueBranch  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node lastTrue = n.getLastChild (  ) ;^873^^^^^856^884^[REPLACE] Node lastTrue = trueBranch.getLastChild (  ) ;^[METHOD] tryRemoveRepeatedStatements [TYPE] void [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node cond  falseBranch  lastFalse  lastTrue  n  parent  trueBranch  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node lastFalse = trueBranch.getFirstChild (  ) ;^874^^^^^856^884^[REPLACE] Node lastFalse = falseBranch.getLastChild (  ) ;^[METHOD] tryRemoveRepeatedStatements [TYPE] void [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node cond  falseBranch  lastFalse  lastTrue  n  parent  trueBranch  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^874^^^^^856^884^[ADD] Node lastFalse = falseBranch.getLastChild (  ) ;^[METHOD] tryRemoveRepeatedStatements [TYPE] void [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node cond  falseBranch  lastFalse  lastTrue  n  parent  trueBranch  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^if  ( trueBranch != null || lastFalse == null || !lastTrue.checkTreeEqualsSilent ( lastFalse )  )  {^875^876^^^^856^884^[REPLACE] if  ( lastTrue == null || lastFalse == null || !lastTrue.checkTreeEqualsSilent ( lastFalse )  )  {^[METHOD] tryRemoveRepeatedStatements [TYPE] void [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node cond  falseBranch  lastFalse  lastTrue  n  parent  trueBranch  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^875^876^877^878^^856^884^[ADD] if  ( lastTrue == null || lastFalse == null || !lastTrue.checkTreeEqualsSilent ( lastFalse )  )  { break; }^[METHOD] tryRemoveRepeatedStatements [TYPE] void [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node cond  falseBranch  lastFalse  lastTrue  n  parent  trueBranch  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node lastTrue = parent.getLastChild (  ) ;^873^^^^^856^884^[REPLACE] Node lastTrue = trueBranch.getLastChild (  ) ;^[METHOD] tryRemoveRepeatedStatements [TYPE] void [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node cond  falseBranch  lastFalse  lastTrue  n  parent  trueBranch  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node lastFalse = trueBranch .getFirstChild (  )  ;^874^^^^^856^884^[REPLACE] Node lastFalse = falseBranch.getLastChild (  ) ;^[METHOD] tryRemoveRepeatedStatements [TYPE] void [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node cond  falseBranch  lastFalse  lastTrue  n  parent  trueBranch  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node result = n.getLastChild (  ) ;^890^^^^^889^909^[REPLACE] Node result = n.getFirstChild (  ) ;^[METHOD] tryReduceReturn [TYPE] void [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  operand  result  [TYPE]  String name  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^if  ( result == null )  {^891^^^^^889^909^[REPLACE] if  ( result != null )  {^[METHOD] tryReduceReturn [TYPE] void [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  operand  result  [TYPE]  String name  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^891^892^893^894^^889^909^[ADD] if  ( result != null )  { switch  ( result.getType (  )  )  { case Token.VOID: Node operand = result.getFirstChild (  ) ;^[METHOD] tryReduceReturn [TYPE] void [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  operand  result  [TYPE]  String name  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^if  ( !NodeUtil .mayEffectMutableState ( n )   )  {^895^^^^^889^909^[REPLACE] if  ( !NodeUtil.mayHaveSideEffects ( operand )  )  {^[METHOD] tryReduceReturn [TYPE] void [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  operand  result  [TYPE]  String name  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^n.getFirstChild (  ) ;^896^^^^^889^909^[REPLACE] n.removeFirstChild (  ) ;^[METHOD] tryReduceReturn [TYPE] void [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  operand  result  [TYPE]  String name  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^896^^^^^889^909^[ADD] n.removeFirstChild (  ) ;^[METHOD] tryReduceReturn [TYPE] void [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  operand  result  [TYPE]  String name  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^t.getCompiler (  ) .getVar (  ) ;^897^^^^^889^909^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryReduceReturn [TYPE] void [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  operand  result  [TYPE]  String name  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^897^^^^^889^909^[ADD] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryReduceReturn [TYPE] void [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  operand  result  [TYPE]  String name  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^t.getScope (  ) .reportCodeChange (  ) ;^897^^^^^889^909^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryReduceReturn [TYPE] void [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  operand  result  [TYPE]  String name  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^if  ( name.valueOf ( "undefined" )  )  {^902^^^^^889^909^[REPLACE] if  ( name.equals ( "undefined" )  )  {^[METHOD] tryReduceReturn [TYPE] void [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  operand  result  [TYPE]  String name  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^n.getFirstChild (  ) ;^903^^^^^889^909^[REPLACE] n.removeFirstChild (  ) ;^[METHOD] tryReduceReturn [TYPE] void [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  operand  result  [TYPE]  String name  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^t.getScope (  ) .reportCodeChange (  ) ;^904^^^^^889^909^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryReduceReturn [TYPE] void [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  operand  result  [TYPE]  String name  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^904^^^^^889^909^[ADD] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryReduceReturn [TYPE] void [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  operand  result  [TYPE]  String name  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^return lower[0];^899^^^^^889^909^[REPLACE] return;^[METHOD] tryReduceReturn [TYPE] void [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  operand  result  [TYPE]  String name  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^return lower[0];^906^^^^^889^909^[REPLACE] return;^[METHOD] tryReduceReturn [TYPE] void [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  operand  result  [TYPE]  String name  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node operand = operand.getFirstChild (  ) ;^894^^^^^889^909^[REPLACE] Node operand = result.getFirstChild (  ) ;^[METHOD] tryReduceReturn [TYPE] void [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  operand  result  [TYPE]  String name  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^894^^^^^889^909^[ADD] Node operand = result.getFirstChild (  ) ;^[METHOD] tryReduceReturn [TYPE] void [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  operand  result  [TYPE]  String name  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^String name = operand.getString (  ) ;^901^^^^^889^909^[REPLACE] String name = result.getString (  ) ;^[METHOD] tryReduceReturn [TYPE] void [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  operand  result  [TYPE]  String name  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^901^^^^^889^909^[ADD] String name = result.getString (  ) ;^[METHOD] tryReduceReturn [TYPE] void [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  operand  result  [TYPE]  String name  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^if  ( NodeUtil.mayHaveSideEffects ( operand )  )  {^895^^^^^889^909^[REPLACE] if  ( !NodeUtil.mayHaveSideEffects ( operand )  )  {^[METHOD] tryReduceReturn [TYPE] void [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  operand  result  [TYPE]  String name  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^n .getFirstChild (  )  ;^903^^^^^889^909^[REPLACE] n.removeFirstChild (  ) ;^[METHOD] tryReduceReturn [TYPE] void [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  operand  result  [TYPE]  String name  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^final boolean[] found = { true };^915^^^^^914^923^[REPLACE] final boolean[] found = { false };^[METHOD] isPropertyAssignmentInExpression [TYPE] boolean [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  parent  [TYPE]  boolean[] found  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^found[3] |=  ( n.getType (  )  == Token.GETPROP ;^918^919^^^^914^923^[REPLACE] found[0] |=  ( n.getType (  )  == Token.GETPROP && parent.getType (  )  == Token.ASSIGN ) ;^[METHOD] isPropertyAssignmentInExpression [TYPE] boolean [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  parent  [TYPE]  boolean[] found  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^return found[4];^922^^^^^914^923^[REPLACE] return found[0];^[METHOD] isPropertyAssignmentInExpression [TYPE] boolean [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  parent  [TYPE]  boolean[] found  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^found[2] |=  ( n.getType (  )  == Token.GETPROP  ^  parent.getType (  )  == Token.ASSIGN ) ;^918^919^^^^917^920^[REPLACE] found[0] |=  ( n.getType (  )  == Token.GETPROP && parent.getType (  )  == Token.ASSIGN ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^918^919^^^^917^920^[ADD] found[0] |=  ( n.getType (  )  == Token.GETPROP && parent.getType (  )  == Token.ASSIGN ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^final boolean[] lower = { true };^931^^^^^929^938^[REPLACE] final boolean[] lower = { false };^[METHOD] isLowerPrecedenceInExpression [TYPE] boolean [PARAMETER] NodeTraversal t Node n final int precedence [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  parent  [TYPE]  boolean[] lower  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  result  type 
[REPLACE]^lower[4] |= NodeUtil.precedence ( n.getType (  )  )   >  precedence;^934^^^^^929^938^[REPLACE] lower[0] |= NodeUtil.precedence ( n.getType (  )  )  < precedence;^[METHOD] isLowerPrecedenceInExpression [TYPE] boolean [PARAMETER] NodeTraversal t Node n final int precedence [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  parent  [TYPE]  boolean[] lower  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  result  type 
[REPLACE]^return lower[3];^937^^^^^929^938^[REPLACE] return lower[0];^[METHOD] isLowerPrecedenceInExpression [TYPE] boolean [PARAMETER] NodeTraversal t Node n final int precedence [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  parent  [TYPE]  boolean[] lower  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  result  type 
[REPLACE]^lower[0 >>> 4] |= NodeUtil.precedence ( n.getType (  )  )   <=  precedence;^934^^^^^933^935^[REPLACE] lower[0] |= NodeUtil.precedence ( n.getType (  )  )  < precedence;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  result  type 
[REPLACE]^Node result = true;^945^^^^^944^1003^[REPLACE] Node result = null;^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^int type = parent.getType (  ) ;^947^^^^^944^1003^[REPLACE] int type = n.getType (  ) ;^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[ADD]^^947^^^^^944^1003^[ADD] int type = n.getType (  ) ;^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^if  ( NodeUtil.isImmutableValue ( elem )  )  {^948^^^^^944^1003^[REPLACE] if  ( NodeUtil.isLiteralValue ( left )  )  {^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^}  else {^962^^^^^944^1003^[REPLACE] } else if  ( NodeUtil.isLiteralValue ( right )  )  {^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^if  (  pt == Token.WHILE && pt == Token.DO && ( pt == Token.FOR && NodeUtil.getConditionExpression ( parent )  == n )  && ( pt == Token.HOOK && parent.getFirstChild (  )  == n )  )  {^972^973^974^^^944^1003^[REPLACE] if  ( pt == Token.IF || pt == Token.WHILE || pt == Token.DO || ( pt == Token.FOR && NodeUtil.getConditionExpression ( parent )  == n )  || ( pt == Token.HOOK && parent.getFirstChild (  )  == n )  )  {^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[ADD]^^972^973^974^975^^944^1003^[ADD] if  ( pt == Token.IF || pt == Token.WHILE || pt == Token.DO || ( pt == Token.FOR && NodeUtil.getConditionExpression ( parent )  == n )  || ( pt == Token.HOOK && parent.getFirstChild (  )  == n )  )  { boolean rval = NodeUtil.getBooleanValue ( right ) ;^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^if  ( type == Token.OR && rval || type == Token.AND && rval )  {^979^980^^^^972^990^[REPLACE] if  ( type == Token.OR && !rval || type == Token.AND && rval )  {^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^if  ( !NodeUtil.mayHaveSideEffects ( result )  )  {^986^^^^^972^990^[REPLACE] if  ( !NodeUtil.mayHaveSideEffects ( left )  )  {^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^result = left; ;^987^^^^^972^990^[REPLACE] result = right;^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^result = right; ;^981^^^^^972^990^[REPLACE] result = left;^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^if  ( !NodeUtil .mayEffectMutableState ( result )   )  {^986^^^^^972^990^[REPLACE] if  ( !NodeUtil.mayHaveSideEffects ( left )  )  {^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[ADD]^^987^^^^^972^990^[ADD] result = right;^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^boolean rval = NodeUtil.getBooleanValue ( result ) ;^975^^^^^972^990^[REPLACE] boolean rval = NodeUtil.getBooleanValue ( right ) ;^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[ADD]^^975^^^^^972^990^[ADD] boolean rval = NodeUtil.getBooleanValue ( right ) ;^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^if  (  type == Token.AND && rval )  {^979^980^^^^944^1003^[REPLACE] if  ( type == Token.OR && !rval || type == Token.AND && rval )  {^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^if  ( !NodeUtil.tryMergeBlock ( left )  )  {^986^^^^^979^989^[REPLACE] if  ( !NodeUtil.mayHaveSideEffects ( left )  )  {^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^result = left; ;^987^^^^^979^989^[REPLACE] result = right;^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[ADD]^^987^^^^^979^989^[ADD] result = right;^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^result = right; ;^981^^^^^979^989^[REPLACE] result = left;^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^if  ( !NodeUtil .mayEffectMutableState ( result )   )  {^986^^^^^944^1003^[REPLACE] if  ( !NodeUtil.mayHaveSideEffects ( left )  )  {^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[ADD]^result = right;^986^987^988^^^944^1003^[ADD] if  ( !NodeUtil.mayHaveSideEffects ( left )  )  { result = right; }^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^result = left; ;^987^^^^^944^1003^[REPLACE] result = right;^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^result = right; ;^981^^^^^944^1003^[REPLACE] result = left;^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^int pt = right.getType (  ) ;^971^^^^^944^1003^[REPLACE] int pt = parent.getType (  ) ;^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^boolean rval = NodeUtil.getBooleanValue ( result ) ;^975^^^^^944^1003^[REPLACE] boolean rval = NodeUtil.getBooleanValue ( right ) ;^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[ADD]^^975^^^^^944^1003^[ADD] boolean rval = NodeUtil.getBooleanValue ( right ) ;^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^if  ( type == Token.OR && rval ) {^979^980^^^^972^990^[REPLACE] if  ( type == Token.OR && !rval || type == Token.AND && rval )  {^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^if  ( !  left    )  {^986^^^^^972^990^[REPLACE] if  ( !NodeUtil.mayHaveSideEffects ( left )  )  {^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^if  ( !NodeUtil .mayEffectMutableState ( parent )   )  {^986^^^^^972^990^[REPLACE] if  ( !NodeUtil.mayHaveSideEffects ( left )  )  {^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^if  ( type == Token.OR && rval || type == Token.AND && rval )  {^979^980^^^^944^1003^[REPLACE] if  ( type == Token.OR && !rval || type == Token.AND && rval )  {^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^if  ( !NodeUtil.mayHaveSideEffects ( result )  )  {^986^^^^^979^989^[REPLACE] if  ( !NodeUtil.mayHaveSideEffects ( left )  )  {^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REMOVE]^if  (  ( NAME )  !=  ( right.getType (  )  )  )  {     return ; }^986^^^^^979^989^[REMOVE] ^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^if  ( !NodeUtil.tryMergeBlock ( left )  )  {^986^^^^^944^1003^[REPLACE] if  ( !NodeUtil.mayHaveSideEffects ( left )  )  {^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^boolean rval = NodeUtil.getStringValue ( result ) ;^975^^^^^944^1003^[REPLACE] boolean rval = NodeUtil.getBooleanValue ( right ) ;^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^if  ( lval && type == Token.OR ) {^953^954^^^^944^1003^[REPLACE] if  ( lval && type == Token.OR || !lval && type == Token.AND )  {^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^result = left; ;^960^^^^^953^961^[REPLACE] result = right;^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^result = right; ;^955^^^^^953^961^[REPLACE] result = left;^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^result = right; ;^955^^^^^944^1003^[REPLACE] result = left;^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[ADD]^^955^^^^^944^1003^[ADD] result = left;^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^result = left; ;^960^^^^^944^1003^[REPLACE] result = right;^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^boolean lval = NodeUtil .getStringValue ( left )  ;^949^^^^^944^1003^[REPLACE] boolean lval = NodeUtil.getBooleanValue ( left ) ;^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[ADD]^^949^^^^^944^1003^[ADD] boolean lval = NodeUtil.getBooleanValue ( left ) ;^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^if  ( lval && type == Token.OR || lval && type == Token.AND )  {^953^954^^^^944^1003^[REPLACE] if  ( lval && type == Token.OR || !lval && type == Token.AND )  {^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^}  if  ( NodeUtil.isLiteralValue ( right )  )  {^962^^^^^944^1003^[REPLACE] } else if  ( NodeUtil.isLiteralValue ( right )  )  {^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^if  ( type == Token.OR && lval ) {^979^980^^^^972^990^[REPLACE] if  ( type == Token.OR && !rval || type == Token.AND && rval )  {^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[ADD]^^979^980^981^982^^972^990^[ADD] if  ( type == Token.OR && !rval || type == Token.AND && rval )  { result = left; } else {^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^if  ( !NodeUtil.tryMergeBlock ( result )  )  {^986^^^^^972^990^[REPLACE] if  ( !NodeUtil.mayHaveSideEffects ( left )  )  {^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REMOVE]^if  (  ( NAME )  !=  ( right.getType (  )  )  )  {     return ; }^986^^^^^972^990^[REMOVE] ^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[ADD]^^981^^^^^972^990^[ADD] result = left;^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^if  ( !NodeUtil .mayEffectMutableState ( left )   )  {^986^^^^^979^989^[REPLACE] if  ( !NodeUtil.mayHaveSideEffects ( left )  )  {^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^if  ( !NodeUtil.tryMergeBlock ( result )  )  {^986^^^^^944^1003^[REPLACE] if  ( !NodeUtil.mayHaveSideEffects ( left )  )  {^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^if  ( pt == Token.IF && pt == Token.WHILE && pt == Token.DO && ( pt == Token.FOR && NodeUtil.getConditionExpression ( parent )  == n )  && ( pt == Token.HOOK && parent.getFirstChild (  )  == n )  )  {^972^973^974^^^944^1003^[REPLACE] if  ( pt == Token.IF || pt == Token.WHILE || pt == Token.DO || ( pt == Token.FOR && NodeUtil.getConditionExpression ( parent )  == n )  || ( pt == Token.HOOK && parent.getFirstChild (  )  == n )  )  {^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^if  (  type == Token.AND && rval )  {^979^980^^^^972^990^[REPLACE] if  ( type == Token.OR && !rval || type == Token.AND && rval )  {^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^if  ( !NodeUtil.tryMergeBlock ( left )  )  {^986^^^^^972^990^[REPLACE] if  ( !NodeUtil.mayHaveSideEffects ( left )  )  {^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[ADD]^^986^987^988^^^972^990^[ADD] if  ( !NodeUtil.mayHaveSideEffects ( left )  )  { result = right; }^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[ADD]^^979^980^981^982^^944^1003^[ADD] if  ( type == Token.OR && !rval || type == Token.AND && rval )  { result = left; } else {^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^if  ( !NodeUtil .mayEffectMutableState ( right )   )  {^986^^^^^979^989^[REPLACE] if  ( !NodeUtil.mayHaveSideEffects ( left )  )  {^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[ADD]^^986^987^988^^^944^1003^[ADD] if  ( !NodeUtil.mayHaveSideEffects ( left )  )  { result = right; }^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^boolean lval = NodeUtil.getBooleanValue ( right ) ;^949^^^^^944^1003^[REPLACE] boolean lval = NodeUtil.getBooleanValue ( left ) ;^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^if  ( result == parentull )  {^997^^^^^944^1003^[REPLACE] if  ( result != null )  {^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^n.removeChild ( right ) ;^999^^^^^944^1003^[REPLACE] n.removeChild ( result ) ;^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^parent.addChildAfter ( n, result ) ;^1000^^^^^944^1003^[REPLACE] parent.replaceChild ( n, result ) ;^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[ADD]^^1000^1001^^^^944^1003^[ADD] parent.replaceChild ( n, result ) ; t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^t .getScope (  )  .reportCodeChange (  ) ;^1001^^^^^944^1003^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[ADD]^^1001^^^^^944^1003^[ADD] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^if  (  left.getType (  )  == Token.ADD || left.getChildCount (  )  == 2 )  {^1020^1021^1022^^^1018^1043^[REPLACE] if  ( NodeUtil.isLiteralValue ( right )  && left.getType (  )  == Token.ADD && left.getChildCount (  )  == 2 )  {^[METHOD] tryFoldLeftChildAdd [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  ll  lr  n  parent  right  [TYPE]  String leftString  result  rightString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^if  ( parent.setType (  )   ==  Token.STRING ) return;^1030^1031^^^^1018^1043^[REPLACE] if  ( lr.getType (  )  != Token.STRING ) return;^[METHOD] tryFoldLeftChildAdd [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  ll  lr  n  parent  right  [TYPE]  String leftString  result  rightString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^return lower[0];^1031^^^^^1018^1043^[REPLACE] return;^[METHOD] tryFoldLeftChildAdd [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  ll  lr  n  parent  right  [TYPE]  String leftString  result  rightString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^if  ( leftString == null && true )  {^1035^^^^^1018^1043^[REPLACE] if  ( leftString != null && rightString != null )  {^[METHOD] tryFoldLeftChildAdd [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  ll  lr  n  parent  right  [TYPE]  String leftString  result  rightString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^String result =result + rightString;^1037^^^^^1018^1043^[REPLACE] String result = leftString + rightString;^[METHOD] tryFoldLeftChildAdd [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  ll  lr  n  parent  right  [TYPE]  String leftString  result  rightString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^Node ll = right.getFirstChild (  ) ;^1024^^^^^1018^1043^[REPLACE] Node ll = left.getFirstChild (  ) ;^[METHOD] tryFoldLeftChildAdd [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  ll  lr  n  parent  right  [TYPE]  String leftString  result  rightString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^Node lr = lr.getNext (  ) ;^1025^^^^^1018^1043^[REPLACE] Node lr = ll.getNext (  ) ;^[METHOD] tryFoldLeftChildAdd [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  ll  lr  n  parent  right  [TYPE]  String leftString  result  rightString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^String leftString = NodeUtil.getStringValue ( parent ) ;^1033^^^^^1018^1043^[REPLACE] String leftString = NodeUtil.getStringValue ( lr ) ;^[METHOD] tryFoldLeftChildAdd [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  ll  lr  n  parent  right  [TYPE]  String leftString  result  rightString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^String parentString = NodeUtil.getStringValue ( right ) ;^1034^^^^^1018^1043^[REPLACE] String rightString = NodeUtil.getStringValue ( right ) ;^[METHOD] tryFoldLeftChildAdd [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  ll  lr  n  parent  right  [TYPE]  String leftString  result  rightString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[ADD]^^1034^^^^^1018^1043^[ADD] String rightString = NodeUtil.getStringValue ( right ) ;^[METHOD] tryFoldLeftChildAdd [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  ll  lr  n  parent  right  [TYPE]  String leftString  result  rightString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^if  ( lr.getType (  )   ==  Token.STRING ) return;^1030^1031^^^^1018^1043^[REPLACE] if  ( lr.getType (  )  != Token.STRING ) return;^[METHOD] tryFoldLeftChildAdd [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  ll  lr  n  parent  right  [TYPE]  String leftString  result  rightString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^if  ( leftString == null && rightString != null )  {^1035^^^^^1018^1043^[REPLACE] if  ( leftString != null && rightString != null )  {^[METHOD] tryFoldLeftChildAdd [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  ll  lr  n  parent  right  [TYPE]  String leftString  result  rightString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[ADD]^^1035^1036^1037^1038^1039^1018^1043^[ADD] if  ( leftString != null && rightString != null )  { left.removeChild ( ll ) ; String result = leftString + rightString; n.replaceChild ( left, ll ) ; n.replaceChild ( right, Node.newString ( result )  ) ;^[METHOD] tryFoldLeftChildAdd [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  ll  lr  n  parent  right  [TYPE]  String leftString  result  rightString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^String result = leftString  >  rightString;^1037^^^^^1018^1043^[REPLACE] String result = leftString + rightString;^[METHOD] tryFoldLeftChildAdd [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  ll  lr  n  parent  right  [TYPE]  String leftString  result  rightString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^String result = leftString +result;^1037^^^^^1018^1043^[REPLACE] String result = leftString + rightString;^[METHOD] tryFoldLeftChildAdd [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  ll  lr  n  parent  right  [TYPE]  String leftString  result  rightString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^if  ( left.getType (  )  == Token.STRING && right.getType (  )  == Token.STRING )  {^1050^1051^^^^1048^1064^[REPLACE] if  ( left.getType (  )  == Token.STRING || right.getType (  )  == Token.STRING )  {^[METHOD] tryFoldAdd [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  right  [TYPE]  String leftString  rightString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[ADD]^^1050^1051^^^1054^1048^1064^[ADD] if  ( left.getType (  )  == Token.STRING || right.getType (  )  == Token.STRING )  { String leftString = NodeUtil.getStringValue ( left ) ;^[METHOD] tryFoldAdd [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  right  [TYPE]  String leftString  rightString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^tryFoldArithmetic ( t, n, left, left, parent ) ;^1062^^^^^1048^1064^[REPLACE] tryFoldArithmetic ( t, n, left, right, parent ) ;^[METHOD] tryFoldAdd [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  right  [TYPE]  String leftString  rightString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^if  ( leftString == this && rightString != this )  {^1056^^^^^1048^1064^[REPLACE] if  ( leftString != null && rightString != null )  {^[METHOD] tryFoldAdd [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  right  [TYPE]  String leftString  rightString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^parent.replaceChild ( n, Node.newString ( leftString  &&  rightString )  ) ;^1057^^^^^1048^1064^[REPLACE] parent.replaceChild ( n, Node.newString ( leftString + rightString )  ) ;^[METHOD] tryFoldAdd [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  right  [TYPE]  String leftString  rightString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^parent.replaceChild ( n, Node.newString ( leftString  >  rightString )  ) ;^1057^^^^^1048^1064^[REPLACE] parent.replaceChild ( n, Node.newString ( leftString + rightString )  ) ;^[METHOD] tryFoldAdd [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  right  [TYPE]  String leftString  rightString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[ADD]^^1057^1058^^^^1048^1064^[ADD] parent.replaceChild ( n, Node.newString ( leftString + rightString )  ) ; t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryFoldAdd [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  right  [TYPE]  String leftString  rightString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^t.getCompiler (  ) .getVar (  ) ;^1058^^^^^1048^1064^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryFoldAdd [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  right  [TYPE]  String leftString  rightString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^t.getScope (  ) .reportCodeChange (  ) ;^1058^^^^^1048^1064^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryFoldAdd [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  right  [TYPE]  String leftString  rightString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^String rightString = NodeUtil.getStringValue ( left ) ;^1054^^^^^1048^1064^[REPLACE] String leftString = NodeUtil.getStringValue ( left ) ;^[METHOD] tryFoldAdd [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  right  [TYPE]  String leftString  rightString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^String rightString = NodeUtil.getBooleanValue ( right ) ;^1055^^^^^1048^1064^[REPLACE] String rightString = NodeUtil.getStringValue ( right ) ;^[METHOD] tryFoldAdd [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  right  [TYPE]  String leftString  rightString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^if  ( leftString == null && rightString != null )  {^1056^^^^^1048^1064^[REPLACE] if  ( leftString != null && rightString != null )  {^[METHOD] tryFoldAdd [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  right  [TYPE]  String leftString  rightString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[ADD]^^1056^1057^1058^1059^^1048^1064^[ADD] if  ( leftString != null && rightString != null )  { parent.replaceChild ( n, Node.newString ( leftString + rightString )  ) ; t.getCompiler (  ) .reportCodeChange (  ) ; }^[METHOD] tryFoldAdd [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  right  [TYPE]  String leftString  rightString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^parent.replaceChild ( n, Node.getString ( leftString  ==  rightString )  ) ;^1057^^^^^1048^1064^[REPLACE] parent.replaceChild ( n, Node.newString ( leftString + rightString )  ) ;^[METHOD] tryFoldAdd [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  right  [TYPE]  String leftString  rightString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[ADD]^^1057^^^^^1048^1064^[ADD] parent.replaceChild ( n, Node.newString ( leftString + rightString )  ) ;^[METHOD] tryFoldAdd [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  right  [TYPE]  String leftString  rightString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^t .getScope (  )  .reportCodeChange (  ) ;^1058^^^^^1048^1064^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryFoldAdd [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  right  [TYPE]  String leftString  rightString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[ADD]^String rightString = NodeUtil.getStringValue ( right ) ;^1054^1055^^^^1048^1064^[ADD] String leftString = NodeUtil.getStringValue ( left ) ; String rightString = NodeUtil.getStringValue ( right ) ;^[METHOD] tryFoldAdd [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  right  [TYPE]  String leftString  rightString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^String rightString = NodeUtil .getBooleanValue ( parent )  ;^1055^^^^^1048^1064^[REPLACE] String rightString = NodeUtil.getStringValue ( right ) ;^[METHOD] tryFoldAdd [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  right  [TYPE]  String leftString  rightString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^if  ( left.getType (  )  == Token.NUMBER || right.getType (  )  == Token.NUMBER )  {^1072^1073^^^^1070^1106^[REPLACE] if  ( left.getType (  )  == Token.NUMBER && right.getType (  )  == Token.NUMBER )  {^[METHOD] tryFoldArithmetic [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^if  ( rval  &&  0 )  {^1089^^^^^1072^1105^[REPLACE] if  ( rval == 0 )  {^[METHOD] tryFoldArithmetic [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[ADD]^error ( t, DIVIDE_BY_0_ERROR, right ) ;return;^1089^1090^1091^1092^^1072^1105^[ADD] if  ( rval == 0 )  { error ( t, DIVIDE_BY_0_ERROR, right ) ; return; }^[METHOD] tryFoldArithmetic [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^return lower[0];^1091^^^^^1072^1105^[REPLACE] return;^[METHOD] tryFoldArithmetic [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^if  ( String.valueOf ( result ) .length (  )  - 3 <= String.valueOf ( rval ) .length (  )  - 3 + String.valueOf ( rval ) .length (  )  - 3 + 1 )  {^1100^1101^^^^1072^1105^[REPLACE] if  ( String.valueOf ( result ) .length (  )  <= String.valueOf ( lval ) .length (  )  + String.valueOf ( rval ) .length (  )  + 1 )  {^[METHOD] tryFoldArithmetic [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[ADD]^^1100^1101^1102^1103^1104^1072^1105^[ADD] if  ( String.valueOf ( result ) .length (  )  <= String.valueOf ( lval ) .length (  )  + String.valueOf ( rval ) .length (  )  + 1 )  { parent.replaceChild ( n, Node.newNumber ( result )  ) ; t.getCompiler (  ) .reportCodeChange (  ) ; }^[METHOD] tryFoldArithmetic [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^parent.replaceChild ( n, Node .newString ( this )   ) ;^1102^^^^^1100^1104^[REPLACE] parent.replaceChild ( n, Node.newNumber ( result )  ) ;^[METHOD] tryFoldArithmetic [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[ADD]^^1102^^^^^1100^1104^[ADD] parent.replaceChild ( n, Node.newNumber ( result )  ) ;^[METHOD] tryFoldArithmetic [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^parent.replaceChild ( n, Node.newNumber ( negNum )  ) ;^1102^^^^^1100^1104^[REPLACE] parent.replaceChild ( n, Node.newNumber ( result )  ) ;^[METHOD] tryFoldArithmetic [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^t.getScope (  ) .reportCodeChange (  ) ;^1103^^^^^1100^1104^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryFoldArithmetic [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^t .getScope (  )  .reportCodeChange (  ) ;^1103^^^^^1100^1104^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryFoldArithmetic [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^result = lval +result;^1080^^^^^1072^1105^[REPLACE] result = lval + rval;^[METHOD] tryFoldArithmetic [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^result = lvalInt | rvalInt; ;^1083^^^^^1072^1105^[REPLACE] result = lval - rval;^[METHOD] tryFoldArithmetic [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^result = lval  ;^1086^^^^^1072^1105^[REPLACE] result = lval * rval;^[METHOD] tryFoldArithmetic [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[ADD]^^1086^^^^^1072^1105^[ADD] result = lval * rval;^[METHOD] tryFoldArithmetic [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^result = lvalInt | rvalInt; ;^1093^^^^^1072^1105^[REPLACE] result = lval / rval;^[METHOD] tryFoldArithmetic [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[ADD]^^1093^^^^^1072^1105^[ADD] result = lval / rval;^[METHOD] tryFoldArithmetic [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^double rv = right.getDouble (  ) ;^1074^^^^^1072^1105^[REPLACE] double result;^[METHOD] tryFoldArithmetic [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^double lval = right.getDouble (  ) ;^1075^^^^^1072^1105^[REPLACE] double lval = left.getDouble (  ) ;^[METHOD] tryFoldArithmetic [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[ADD]^double rval = right.getDouble (  ) ;^1075^1076^^^^1072^1105^[ADD] double lval = left.getDouble (  ) ; double rval = right.getDouble (  ) ;^[METHOD] tryFoldArithmetic [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^double rval = parent.getDouble (  ) ;^1076^^^^^1072^1105^[REPLACE] double rval = right.getDouble (  ) ;^[METHOD] tryFoldArithmetic [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^return ;^1096^^^^^1072^1105^[REPLACE] throw new Error ( "Unknown arithmetic operator" ) ;^[METHOD] tryFoldArithmetic [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^if  ( rval  !=  0 )  {^1089^^^^^1070^1106^[REPLACE] if  ( rval == 0 )  {^[METHOD] tryFoldArithmetic [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[ADD]^error ( t, DIVIDE_BY_0_ERROR, right ) ;return;^1089^1090^1091^1092^^1070^1106^[ADD] if  ( rval == 0 )  { error ( t, DIVIDE_BY_0_ERROR, right ) ; return; }^[METHOD] tryFoldArithmetic [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^return lower[0];^1091^^^^^1070^1106^[REPLACE] return;^[METHOD] tryFoldArithmetic [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^if  ( String.valueOf ( result ) .size (  )  <= String.valueOf ( lval ) .size (  )  + String.valueOf ( result ) .size (  )  + 1 )  {^1100^1101^^^^1070^1106^[REPLACE] if  ( String.valueOf ( result ) .length (  )  <= String.valueOf ( lval ) .length (  )  + String.valueOf ( rval ) .length (  )  + 1 )  {^[METHOD] tryFoldArithmetic [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^parent.replaceChild ( n, Node.newNumber ( rval )  ) ;^1102^^^^^1100^1104^[REPLACE] parent.replaceChild ( n, Node.newNumber ( result )  ) ;^[METHOD] tryFoldArithmetic [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[ADD]^^1102^1103^^^^1100^1104^[ADD] parent.replaceChild ( n, Node.newNumber ( result )  ) ; t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryFoldArithmetic [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^t.getCompiler (  ) .getVar (  ) ;^1103^^^^^1100^1104^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryFoldArithmetic [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^result = lval  <=  rval;^1080^^^^^1070^1106^[REPLACE] result = lval + rval;^[METHOD] tryFoldArithmetic [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^result = lvalInt | rvalInt; ;^1083^^^^^1070^1106^[REPLACE] result = lval - rval;^[METHOD] tryFoldArithmetic [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^result = lval  ;^1086^^^^^1070^1106^[REPLACE] result = lval * rval;^[METHOD] tryFoldArithmetic [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^result = lval  ;^1093^^^^^1070^1106^[REPLACE] result = lval / rval;^[METHOD] tryFoldArithmetic [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^double rv = right.getDouble (  ) ;^1074^^^^^1070^1106^[REPLACE] double result;^[METHOD] tryFoldArithmetic [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^double lval = right.getDouble (  ) ;^1075^^^^^1070^1106^[REPLACE] double lval = left.getDouble (  ) ;^[METHOD] tryFoldArithmetic [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^double rval = parent.getDouble (  ) ;^1076^^^^^1070^1106^[REPLACE] double rval = right.getDouble (  ) ;^[METHOD] tryFoldArithmetic [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^throw new Error ( "Unknown bitwise operator" ) ; ;^1096^^^^^1070^1106^[REPLACE] throw new Error ( "Unknown arithmetic operator" ) ;^[METHOD] tryFoldArithmetic [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^if  (  right.getType (  )  == Token.NUMBER )  {^1114^1115^^^^1112^1153^[REPLACE] if  ( left.getType (  )  == Token.NUMBER && right.getType (  )  == Token.NUMBER )  {^[METHOD] tryFoldBitAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^if  (  lval > Integer.MAX_VALUE && rval < Integer.MIN_VALUE && rval > Integer.MAX_VALUE )  {^1122^1123^^^^1114^1152^[REPLACE] if  ( lval < Integer.MIN_VALUE || lval > Integer.MAX_VALUE || rval < Integer.MIN_VALUE || rval > Integer.MAX_VALUE )  {^[METHOD] tryFoldBitAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^return lower[0];^1126^^^^^1122^1127^[REPLACE] return;^[METHOD] tryFoldBitAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^if  ( lvalInt  ==  lval )  {^1131^^^^^1114^1152^[REPLACE] if  ( lvalInt != lval )  {^[METHOD] tryFoldBitAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REMOVE]^if  ( rvalInt != rval )  {     return ; }^1131^^^^^1114^1152^[REMOVE] ^[METHOD] tryFoldBitAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^return lower[0];^1132^^^^^1114^1152^[REPLACE] return;^[METHOD] tryFoldBitAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^if  ( rvalInt  ==  rval )  {^1136^^^^^1114^1152^[REPLACE] if  ( rvalInt != rval )  {^[METHOD] tryFoldBitAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[ADD]^return;^1136^1137^1138^^^1114^1152^[ADD] if  ( rvalInt != rval )  { return; }^[METHOD] tryFoldBitAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^return lower[0];^1137^^^^^1114^1152^[REPLACE] return;^[METHOD] tryFoldBitAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^result = lvalInt | rvalInt;^1142^^^^^1114^1152^[REPLACE] result = lvalInt & rvalInt;^[METHOD] tryFoldBitAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^result = lvalInt & rvalInt;^1145^^^^^1114^1152^[REPLACE] result = lvalInt | rvalInt;^[METHOD] tryFoldBitAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^return lower[0];^1126^^^^^1114^1152^[REPLACE] return;^[METHOD] tryFoldBitAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^double rv = right.getDouble (  ) ;^1116^^^^^1114^1152^[REPLACE] double result;^[METHOD] tryFoldBitAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^double lval = right.getDouble (  ) ;^1117^^^^^1114^1152^[REPLACE] double lval = left.getDouble (  ) ;^[METHOD] tryFoldBitAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^double rval = parent.getDouble (  ) ;^1118^^^^^1114^1152^[REPLACE] double rval = right.getDouble (  ) ;^[METHOD] tryFoldBitAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^int rvalInt =  ( int )  rval;^1130^^^^^1114^1152^[REPLACE] int lvalInt =  ( int )  lval;^[METHOD] tryFoldBitAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^int lvalInt =  ( int )  lval;^1135^^^^^1114^1152^[REPLACE] int rvalInt =  ( int )  rval;^[METHOD] tryFoldBitAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^throw new Error ( "Unknown arithmetic operator" ) ; ;^1148^^^^^1114^1152^[REPLACE] throw new Error ( "Unknown bitwise operator" ) ;^[METHOD] tryFoldBitAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[ADD]^^1148^^^^^1114^1152^[ADD] throw new Error ( "Unknown bitwise operator" ) ;^[METHOD] tryFoldBitAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^if  (  lval > Integer.MAX_VALUE && rval < Integer.MIN_VALUE && rval > Integer.MAX_VALUE )  {^1122^1123^^^^1112^1153^[REPLACE] if  ( lval < Integer.MIN_VALUE || lval > Integer.MAX_VALUE || rval < Integer.MIN_VALUE || rval > Integer.MAX_VALUE )  {^[METHOD] tryFoldBitAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^if  (rvalInt  ==  lval )  {^1131^^^^^1112^1153^[REPLACE] if  ( lvalInt != lval )  {^[METHOD] tryFoldBitAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^return lower[0];^1132^^^^^1112^1153^[REPLACE] return;^[METHOD] tryFoldBitAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^if  (resultInt  == result )  {^1136^^^^^1112^1153^[REPLACE] if  ( rvalInt != rval )  {^[METHOD] tryFoldBitAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^return lower[0];^1137^^^^^1112^1153^[REPLACE] return;^[METHOD] tryFoldBitAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^result = lvalInt |result;^1142^^^^^1112^1153^[REPLACE] result = lvalInt & rvalInt;^[METHOD] tryFoldBitAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[ADD]^^1142^1143^^^^1112^1153^[ADD] result = lvalInt & rvalInt; break;^[METHOD] tryFoldBitAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^result = lvalInt & rvalInt;^1145^^^^^1112^1153^[REPLACE] result = lvalInt | rvalInt;^[METHOD] tryFoldBitAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^return lower[0];^1126^^^^^1112^1153^[REPLACE] return;^[METHOD] tryFoldBitAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^double rv = right.getDouble (  ) ;^1116^^^^^1112^1153^[REPLACE] double result;^[METHOD] tryFoldBitAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^double lval = right.getDouble (  ) ;^1117^^^^^1112^1153^[REPLACE] double lval = left.getDouble (  ) ;^[METHOD] tryFoldBitAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[ADD]^^1117^^^^^1112^1153^[ADD] double lval = left.getDouble (  ) ;^[METHOD] tryFoldBitAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^double rval = parent.getDouble (  ) ;^1118^^^^^1112^1153^[REPLACE] double rval = right.getDouble (  ) ;^[METHOD] tryFoldBitAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^int rvalInt =  ( int )  rval;^1130^^^^^1112^1153^[REPLACE] int lvalInt =  ( int )  lval;^[METHOD] tryFoldBitAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[ADD]^^1130^^^^^1112^1153^[ADD] int lvalInt =  ( int )  lval;^[METHOD] tryFoldBitAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^int lvalInt =  ( int )  lval;^1135^^^^^1112^1153^[REPLACE] int rvalInt =  ( int )  rval;^[METHOD] tryFoldBitAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^throw new Error ( "Unknown arithmetic operator" ) ; ;^1148^^^^^1112^1153^[REPLACE] throw new Error ( "Unknown bitwise operator" ) ;^[METHOD] tryFoldBitAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[ADD]^^1148^^^^^1112^1153^[ADD] throw new Error ( "Unknown bitwise operator" ) ;^[METHOD] tryFoldBitAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^if  (  right.getType (  )  == Token.NUMBER )  {^1161^1162^^^^1159^1212^[REPLACE] if  ( left.getType (  )  == Token.NUMBER && right.getType (  )  == Token.NUMBER )  {^[METHOD] tryFoldShift [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^if  (  lval <= Integer.MAX_VALUE )  )  {^1170^^^^^1161^1211^[REPLACE] if  ( ! ( lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE )  )  {^[METHOD] tryFoldShift [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[ADD]^error ( t, BITWISE_OPERAND_OUT_OF_RANGE, left ) ;return;^1170^1171^1172^1173^^1161^1211^[ADD] if  ( ! ( lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE )  )  { error ( t, BITWISE_OPERAND_OUT_OF_RANGE, left ) ; return; }^[METHOD] tryFoldShift [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^return lower[0];^1172^^^^^1161^1211^[REPLACE] return;^[METHOD] tryFoldShift [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^if  (  ( rval >= 0 &&false )  )  {^1177^^^^^1161^1211^[REPLACE] if  ( ! ( rval >= 0 && rval < 32 )  )  {^[METHOD] tryFoldShift [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^return lower[0];^1179^^^^^1161^1211^[REPLACE] return;^[METHOD] tryFoldShift [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^if  (resultInt  == result )  {^1184^^^^^1161^1211^[REPLACE] if  ( lvalInt != lval )  {^[METHOD] tryFoldShift [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^return lower[0];^1186^^^^^1161^1211^[REPLACE] return;^[METHOD] tryFoldShift [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^if  (resultInt  == result )  {^1190^^^^^1161^1211^[REPLACE] if  ( rvalInt != rval )  {^[METHOD] tryFoldShift [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[ADD]^error ( t, FRACTIONAL_BITWISE_OPERAND, right ) ;return;^1190^1191^1192^1193^^1161^1211^[ADD] if  ( rvalInt != rval )  { error ( t, FRACTIONAL_BITWISE_OPERAND, right ) ; return; }^[METHOD] tryFoldShift [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^return lower[0];^1192^^^^^1161^1211^[REPLACE] return;^[METHOD] tryFoldShift [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^result = lvalInt  > result;^1197^^^^^1161^1211^[REPLACE] result = lvalInt << rvalInt;^[METHOD] tryFoldShift [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^result = lvalInt  !=  rvalInt;^1200^^^^^1161^1211^[REPLACE] result = lvalInt >> rvalInt;^[METHOD] tryFoldShift [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[ADD]^^1200^^^^^1161^1211^[ADD] result = lvalInt >> rvalInt;^[METHOD] tryFoldShift [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^result = lvalInt  >=  rvalInt;^1203^^^^^1161^1211^[REPLACE] result = lvalInt >>> rvalInt;^[METHOD] tryFoldShift [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[ADD]^^1203^1204^^^^1161^1211^[ADD] result = lvalInt >>> rvalInt; break;^[METHOD] tryFoldShift [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^double rv = right.getDouble (  ) ;^1164^^^^^1161^1211^[REPLACE] double result;^[METHOD] tryFoldShift [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[ADD]^^1164^^^^^1161^1211^[ADD] double result;^[METHOD] tryFoldShift [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^double lval = right.getType (  ) ;^1165^^^^^1161^1211^[REPLACE] double lval = left.getDouble (  ) ;^[METHOD] tryFoldShift [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[ADD]^^1165^1166^^^^1161^1211^[ADD] double lval = left.getDouble (  ) ; double rval = right.getDouble (  ) ;^[METHOD] tryFoldShift [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^double rval = parent.getDouble (  ) ;^1166^^^^^1161^1211^[REPLACE] double rval = right.getDouble (  ) ;^[METHOD] tryFoldShift [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^int rvalInt =  ( int )  rval;^1183^^^^^1161^1211^[REPLACE] int lvalInt =  ( int )  lval;^[METHOD] tryFoldShift [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^int lvalInt =  ( int )  lval;^1189^^^^^1161^1211^[REPLACE] int rvalInt =  ( int )  rval;^[METHOD] tryFoldShift [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^return ;^1206^1207^^^^1161^1211^[REPLACE] throw new AssertionError ( "Unknown shift operator: " + Node.tokenToName ( n.getType (  )  )  ) ;^[METHOD] tryFoldShift [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[ADD]^^1206^1207^1208^^^1161^1211^[ADD] throw new AssertionError ( "Unknown shift operator: " + Node.tokenToName ( n.getType (  )  )  ) ; }^[METHOD] tryFoldShift [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^if  (  lval <= Integer.MAX_VALUE )  )  {^1170^^^^^1159^1212^[REPLACE] if  ( ! ( lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE )  )  {^[METHOD] tryFoldShift [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[ADD]^error ( t, BITWISE_OPERAND_OUT_OF_RANGE, left ) ;return;^1170^1171^1172^1173^^1159^1212^[ADD] if  ( ! ( lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE )  )  { error ( t, BITWISE_OPERAND_OUT_OF_RANGE, left ) ; return; }^[METHOD] tryFoldShift [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^return lower[0];^1172^^^^^1159^1212^[REPLACE] return;^[METHOD] tryFoldShift [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^if  (  ( rval >= 0 ) {^1177^^^^^1159^1212^[REPLACE] if  ( ! ( rval >= 0 && rval < 32 )  )  {^[METHOD] tryFoldShift [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[ADD]^error ( t, SHIFT_AMOUNT_OUT_OF_BOUNDS, right ) ;return;^1177^1178^1179^1180^^1159^1212^[ADD] if  ( ! ( rval >= 0 && rval < 32 )  )  { error ( t, SHIFT_AMOUNT_OUT_OF_BOUNDS, right ) ; return; }^[METHOD] tryFoldShift [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^return lower[0];^1179^^^^^1159^1212^[REPLACE] return;^[METHOD] tryFoldShift [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^if  ( lvalInt  ==  lval )  {^1184^^^^^1159^1212^[REPLACE] if  ( lvalInt != lval )  {^[METHOD] tryFoldShift [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[ADD]^^1184^1185^1186^1187^^1159^1212^[ADD] if  ( lvalInt != lval )  { error ( t, FRACTIONAL_BITWISE_OPERAND, left ) ; return; }^[METHOD] tryFoldShift [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^return lower[0];^1186^^^^^1159^1212^[REPLACE] return;^[METHOD] tryFoldShift [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^if  (resultInt  == result )  {^1190^^^^^1159^1212^[REPLACE] if  ( rvalInt != rval )  {^[METHOD] tryFoldShift [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^return lower[0];^1192^^^^^1159^1212^[REPLACE] return;^[METHOD] tryFoldShift [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^result = lvalInt  <=  rvalInt;^1197^^^^^1159^1212^[REPLACE] result = lvalInt << rvalInt;^[METHOD] tryFoldShift [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[ADD]^break;^1197^1198^^^^1159^1212^[ADD] result = lvalInt << rvalInt; break;^[METHOD] tryFoldShift [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^result = lvalInt | rvalInt; ;^1200^^^^^1159^1212^[REPLACE] result = lvalInt >> rvalInt;^[METHOD] tryFoldShift [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^result = lvalInt  <=  rvalInt;^1203^^^^^1159^1212^[REPLACE] result = lvalInt >>> rvalInt;^[METHOD] tryFoldShift [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[ADD]^break;^1203^1204^^^^1159^1212^[ADD] result = lvalInt >>> rvalInt; break;^[METHOD] tryFoldShift [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^double rv = right.getDouble (  ) ;^1164^^^^^1159^1212^[REPLACE] double result;^[METHOD] tryFoldShift [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[ADD]^^1164^1165^^^^1159^1212^[ADD] double result; double lval = left.getDouble (  ) ;^[METHOD] tryFoldShift [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^double lval = left.getType (  ) ;^1165^^^^^1159^1212^[REPLACE] double lval = left.getDouble (  ) ;^[METHOD] tryFoldShift [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[ADD]^^1165^^^^^1159^1212^[ADD] double lval = left.getDouble (  ) ;^[METHOD] tryFoldShift [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^double rval = parent .getType (  )  ;^1166^^^^^1159^1212^[REPLACE] double rval = right.getDouble (  ) ;^[METHOD] tryFoldShift [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^int rvalInt =  ( int )  rval;^1183^^^^^1159^1212^[REPLACE] int lvalInt =  ( int )  lval;^[METHOD] tryFoldShift [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^int lvalInt =  ( int )  lval;^1189^^^^^1159^1212^[REPLACE] int rvalInt =  ( int )  rval;^[METHOD] tryFoldShift [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^return ;^1206^1207^^^^1159^1212^[REPLACE] throw new AssertionError ( "Unknown shift operator: " + Node.tokenToName ( n.getType (  )  )  ) ;^[METHOD] tryFoldShift [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^int op = n.getNext (  ) ;^1221^^^^^1219^1408^[REPLACE] int op = n.getType (  ) ;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^boolean changes = false;^1222^^^^^1219^1408^[REPLACE] boolean result;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^boolean parentLiteral = NodeUtil.isLiteralValue ( right ) ;^1226^^^^^1219^1408^[REPLACE] boolean rightLiteral = NodeUtil.isLiteralValue ( right ) ;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^boolean undefinedRight =  (  ( Token.NAME == parent.getType (  ) ;^1227^1228^1229^1230^^1219^1408^[REPLACE] boolean undefinedRight =  (  ( Token.NAME == right.getType (  ) && right.getString (  ) .equals ( "undefined" )  ) ||  ( Token.VOID == right.getType (  ) && NodeUtil.isLiteralValue ( right.getFirstChild (  )  )  )  ) ;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( NodeUtil.isLiteralValue ( left.getFirstChild (  )  )  )  {^1234^^^^^1219^1408^[REPLACE] if  ( !NodeUtil.isLiteralValue ( left.getFirstChild (  )  )  )  {^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^} else if  ( rightLiteral )  {^1236^^^^^1219^1408^[REPLACE] } else if  ( !rightLiteral )  {^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^result = !equivalent; ;^1244^^^^^1236^1264^[REPLACE] result = equivalent;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^result = equivalent; ;^1247^^^^^1236^1264^[REPLACE] result = !equivalent;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^result = !undefinedRight; ;^1250^^^^^1236^1264^[REPLACE] result = undefinedRight;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1250^1251^^^^1236^1264^[ADD] result = undefinedRight; break;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^result = undefinedRight; ;^1253^^^^^1236^1264^[REPLACE] result = !undefinedRight;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1253^^^^^1236^1264^[ADD] result = !undefinedRight;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^result = true;^1259^^^^^1236^1264^[REPLACE] result = false;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return lower[0];^1262^^^^^1236^1264^[REPLACE] return;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^boolean nullRight =  ( Token.NULL != right.getType (  )  ) ;^1239^^^^^1236^1264^[REPLACE] boolean nullRight =  ( Token.NULL == right.getType (  )  ) ;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1239^^^^^1236^1264^[ADD] boolean nullRight =  ( Token.NULL == right.getType (  )  ) ;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^boolean equivalent =undefinedLeft ;^1240^^^^^1236^1264^[REPLACE] boolean equivalent = undefinedRight || nullRight;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return lower[0];^1237^^^^^1219^1408^[REPLACE] return;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^result = !equivalent; ;^1244^^^^^1219^1408^[REPLACE] result = equivalent;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^result = equivalent; ;^1247^^^^^1219^1408^[REPLACE] result = !equivalent;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^result = !undefinedRight; ;^1250^^^^^1219^1408^[REPLACE] result = undefinedRight;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^result = undefinedRight; ;^1253^^^^^1219^1408^[REPLACE] result = !undefinedRight;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1253^1254^^^^1219^1408^[ADD] result = !undefinedRight; break;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^result = true;^1259^^^^^1219^1408^[REPLACE] result = false;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return lower[0];^1262^^^^^1219^1408^[REPLACE] return;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^boolean nullRight =  ( Token.NULL != parent.getType (  )  ) ;^1239^^^^^1219^1408^[REPLACE] boolean nullRight =  ( Token.NULL == right.getType (  )  ) ;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^boolean equivalent =undefinedLeft ;^1240^^^^^1219^1408^[REPLACE] boolean equivalent = undefinedRight || nullRight;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1240^^^^^1219^1408^[ADD] boolean equivalent = undefinedRight || nullRight;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return lower[0];^1235^^^^^1219^1408^[REPLACE] return;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[ADD]^break;^1244^1245^^^^1236^1264^[ADD] result = equivalent; break;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[ADD]^break;^1253^1254^^^^1236^1264^[ADD] result = !undefinedRight; break;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^boolean nullRight =  ( Token.NULL !=null (  )  ) ;^1239^^^^^1236^1264^[REPLACE] boolean nullRight =  ( Token.NULL == right.getType (  )  ) ;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^boolean equivalent = true  &&  nullRight;^1240^^^^^1236^1264^[REPLACE] boolean equivalent = undefinedRight || nullRight;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( undefinedLeft )  {^1268^^^^^1219^1408^[REPLACE] if  ( undefinedRight )  {^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[ADD]^result =  ( op == Token.EQ ) ;break;^1268^1269^1270^1271^^1219^1408^[ADD] if  ( undefinedRight )  { result =  ( op == Token.EQ ) ; break; }^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^result =  ( op  !=  Token.EQ ) ;^1269^^^^^1219^1408^[REPLACE] result =  ( op == Token.EQ ) ;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( rightLiteral )  {^1275^^^^^1219^1408^[REPLACE] if  ( undefinedRight )  {^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^result = true;^1276^^^^^1219^1408^[REPLACE] result = false;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( tt != Token.THIS || tt != Token.TRUE || tt != Token.FALSE || tt != Token.NULL )^1282^1283^1284^1285^^1219^1408^[REPLACE] if  ( tt != Token.THIS && tt != Token.TRUE && tt != Token.FALSE && tt != Token.NULL )^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return lower[0];^1286^^^^^1219^1408^[REPLACE] return;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( rightLiteral )  {^1302^^^^^1219^1408^[REPLACE] if  ( undefinedRight )  {^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[ADD]^result = false;break;^1302^1303^1304^1305^^1219^1408^[ADD] if  ( undefinedRight )  { result = false; break; }^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^result = true;^1303^^^^^1219^1408^[REPLACE] result = false;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( Token.STRING  ==  parent.setType (  )  )  {^1306^^^^^1219^1408^[REPLACE] if  ( Token.STRING != right.getType (  )  )  {^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return lower[0];^1307^^^^^1219^1408^[REPLACE] return;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( undefinedLeft )  {^1324^^^^^1219^1408^[REPLACE] if  ( undefinedRight )  {^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^result = true;^1325^^^^^1219^1408^[REPLACE] result = false;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1325^^^^^1219^1408^[ADD] result = false;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( Token.NUMBER  ==  right.getType (  )  )  {^1328^^^^^1219^1408^[REPLACE] if  ( Token.NUMBER != right.getType (  )  )  {^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return lower[0];^1329^^^^^1219^1408^[REPLACE] return;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( name2.hasChildren (  )^1347^^^^^1219^1408^[REPLACE] if  ( rightLiteral )  {^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( undefinedRight )  {^1349^^^^^1219^1408^[REPLACE] if  ( undefinedLeft )  {^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^result = !equivalent; ;^1355^^^^^1219^1408^[REPLACE] result = equivalent;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^result = equivalent; ;^1358^^^^^1219^1408^[REPLACE] result = !equivalent;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1358^^^^^1219^1408^[ADD] result = !equivalent;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^result = !undefinedRight; ;^1361^^^^^1219^1408^[REPLACE] result = undefinedRight;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1361^^^^^1219^1408^[ADD] result = undefinedRight;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^result = undefinedRight; ;^1364^^^^^1219^1408^[REPLACE] result = !undefinedRight;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^result = true;^1370^^^^^1219^1408^[REPLACE] result = false;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1370^^^^^1219^1408^[ADD] result = false;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return lower[0];^1373^^^^^1219^1408^[REPLACE] return;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^boolean nullRight =  ( Token.NULL !=false (  )  ) ;^1350^^^^^1219^1408^[REPLACE] boolean nullRight =  ( Token.NULL == right.getType (  )  ) ;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^boolean equivalent = true  &&  nullRight;^1351^^^^^1219^1408^[REPLACE] boolean equivalent = undefinedRight || nullRight;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1351^^^^^1219^1408^[ADD] boolean equivalent = undefinedRight || nullRight;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1361^1362^^^^1219^1408^[ADD] result = undefinedRight; break;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^boolean undefinedLeft =  ( right.toString (  ) .equals ( "undefined" )  ) ;^1348^^^^^1219^1408^[REPLACE] boolean undefinedLeft =  ( left.getString (  ) .equals ( "undefined" )  ) ;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^boolean nullRight =  ( Token.NULL != right.getType (  )  ) ;^1350^^^^^1219^1408^[REPLACE] boolean nullRight =  ( Token.NULL == right.getType (  )  ) ;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^boolean equivalent = undefinedRight  !=  nullRight;^1351^^^^^1219^1408^[REPLACE] boolean equivalent = undefinedRight || nullRight;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1355^^^^^1219^1408^[ADD] result = equivalent;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1364^1365^^^^1219^1408^[ADD] result = !undefinedRight; break;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[ADD]^break;^1370^1371^^^^1219^1408^[ADD] result = false; break;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^boolean equivalent = undefinedRight  >  nullRight;^1351^^^^^1219^1408^[REPLACE] boolean equivalent = undefinedRight || nullRight;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( Token.NAME  == null (  )  )  {^1379^^^^^1219^1408^[REPLACE] if  ( Token.NAME != right.getType (  )  )  {^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return lower[0];^1380^^^^^1219^1408^[REPLACE] return;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( !ln.valueOf ( rn )  )  {^1384^^^^^1219^1408^[REPLACE] if  ( !ln.equals ( rn )  )  {^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return lower[0];^1385^^^^^1219^1408^[REPLACE] return;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1253^^^^^1219^1408^[ADD] result = !undefinedRight;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1259^^^^^1219^1408^[ADD] result = false;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^result =  ( op  ||  Token.EQ ) ;^1269^^^^^1219^1408^[REPLACE] result =  ( op == Token.EQ ) ;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^result = left.getType (  )   !=  right.getType (  ) ;^1289^^^^^1219^1408^[REPLACE] result = left.getType (  )  == right.getType (  ) ;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1289^^^^^1219^1408^[ADD] result = left.getType (  )  == right.getType (  ) ;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^result = left.getType (  )  == right.getType (  ) ; ;^1293^^^^^1219^1408^[REPLACE] result = left.getType (  )  != right.getType (  ) ;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^result = !left.getString (  ) .equals ( right.getString (  )  ) ; ;^1311^^^^^1219^1408^[REPLACE] result = left.getString (  ) .equals ( right.getString (  )  ) ;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1311^1312^^^^1219^1408^[ADD] result = left.getString (  ) .equals ( right.getString (  )  ) ; break;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^result = left.getString (  ) .equals ( right.getString (  )  ) ; ;^1315^^^^^1219^1408^[REPLACE] result = !left.getString (  ) .equals ( right.getString (  )  ) ;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^case Token.EQ: result = lv  &&  lv; break;^1335^^^^^1219^1408^[REPLACE] case Token.EQ: result = lv == rv; break;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^case Token.NE: result = lv  ==  rv; break;^1336^^^^^1219^1408^[REPLACE] case Token.NE: result = lv != rv; break;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1336^1337^^^^1219^1408^[ADD] case Token.NE: result = lv != rv; break; case Token.LE: result = lv <= rv; break;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^case Token.LE: result = lv  !=  rv; break;^1337^^^^^1219^1408^[REPLACE] case Token.LE: result = lv <= rv; break;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^case Token.LT: result = lv  !=   rv; break;^1338^^^^^1219^1408^[REPLACE] case Token.LT: result = lv <  rv; break;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^case Token.EQ: result = lv == rv; break; ;^1339^^^^^1219^1408^[REPLACE] case Token.GE: result = lv >= rv; break;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^case Token.GT: result = lv  <=   rv; break;^1340^^^^^1219^1408^[REPLACE] case Token.GT: result = lv >  rv; break;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1340^^^^^1219^1408^[ADD] case Token.GT: result = lv >  rv; break;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^result = true;^1393^^^^^1219^1408^[REPLACE] result = false;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return lower[0];^1297^^^^^1219^1408^[REPLACE] return;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return lower[0];^1319^^^^^1219^1408^[REPLACE] return;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return lower[0];^1342^^^^^1219^1408^[REPLACE] return;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return lower[0];^1396^^^^^1219^1408^[REPLACE] return;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return lower[0];^1402^^^^^1219^1408^[REPLACE] return;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^boolean nullRight =  ( Token.NULL != right.setType (  )  ) ;^1239^^^^^1219^1408^[REPLACE] boolean nullRight =  ( Token.NULL == right.getType (  )  ) ;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1239^1240^^^^1219^1408^[ADD] boolean nullRight =  ( Token.NULL == right.getType (  )  ) ; boolean equivalent = undefinedRight || nullRight;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^boolean equivalent = undefinedRight && nullRight;^1240^^^^^1219^1408^[REPLACE] boolean equivalent = undefinedRight || nullRight;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^int tt = parent.getType (  ) ;^1281^^^^^1219^1408^[REPLACE] int tt = right.getType (  ) ;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^double lv = right.getType (  ) ;^1331^^^^^1219^1408^[REPLACE] double lv = left.getDouble (  ) ;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^double rv = parent.getDouble (  ) ;^1332^^^^^1219^1408^[REPLACE] double rv = right.getDouble (  ) ;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1332^^^^^1219^1408^[ADD] double rv = right.getDouble (  ) ;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^boolean undefinedLeft =  ( right.getString (  ) .equals ( "undefined" )  ) ;^1348^^^^^1219^1408^[REPLACE] boolean undefinedLeft =  ( left.getString (  ) .equals ( "undefined" )  ) ;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^boolean equivalent = undefinedRight ;^1351^^^^^1219^1408^[REPLACE] boolean equivalent = undefinedRight || nullRight;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^String ln = right.getString (  ) ;^1382^^^^^1219^1408^[REPLACE] String ln = left.getString (  ) ;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^String rn = parent.getString (  ) ;^1383^^^^^1219^1408^[REPLACE] String rn = right.getString (  ) ;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^parent.addChildAfter ( n, new Node ( undefinedRight ? Token.TRUE : Token.FALSE )  ) ;^1405^1406^^^^1219^1408^[REPLACE] parent.replaceChild ( n, new Node ( result ? Token.TRUE : Token.FALSE )  ) ;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^t.getCompiler (  )  .replaceChild ( n )  ;^1407^^^^^1219^1408^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^t .getScope (  )  .reportCodeChange (  ) ;^1407^^^^^1219^1408^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( NodeUtil.isGetProp ( left )  ) {^1417^^^^^1416^1455^[REPLACE] if  ( !NodeUtil.isGetProp ( left )  || !NodeUtil.isImmutableValue ( right )  )  {^[METHOD] tryFoldStringIndexOf [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  isIndexOf  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  [TYPE]  String lstring  searchValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1417^1418^1419^^^1416^1455^[ADD] if  ( !NodeUtil.isGetProp ( left )  || !NodeUtil.isImmutableValue ( right )  )  { return; }^[METHOD] tryFoldStringIndexOf [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  isIndexOf  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  [TYPE]  String lstring  searchValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return lower[0];^1418^^^^^1416^1455^[REPLACE] return;^[METHOD] tryFoldStringIndexOf [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  isIndexOf  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  [TYPE]  String lstring  searchValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^Node lstringNode = parent.getFirstChild (  ) ;^1421^^^^^1416^1455^[REPLACE] Node lstringNode = left.getFirstChild (  ) ;^[METHOD] tryFoldStringIndexOf [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  isIndexOf  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  [TYPE]  String lstring  searchValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^Node functionName = secondArg .getParent (  )  ;^1422^^^^^1416^1455^[REPLACE] Node functionName = lstringNode.getNext (  ) ;^[METHOD] tryFoldStringIndexOf [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  isIndexOf  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  [TYPE]  String lstring  searchValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  (  ( lstringNode.getType (  )  != Token.STRING )  && ( !functionName.getString (  ) .getVar ( "indexOf" )  && !functionName.getString (  ) .equals ( "lastIndexOf" )  )  )  {^1424^1425^1426^^^1416^1455^[REPLACE] if  (  ( lstringNode.getType (  )  != Token.STRING )  || ( !functionName.getString (  ) .equals ( "indexOf" )  && !functionName.getString (  ) .equals ( "lastIndexOf" )  )  )  {^[METHOD] tryFoldStringIndexOf [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  isIndexOf  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  [TYPE]  String lstring  searchValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return lower[0];^1427^^^^^1424^1428^[REPLACE] return;^[METHOD] tryFoldStringIndexOf [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  isIndexOf  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  [TYPE]  String lstring  searchValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return lower[0];^1427^^^^^1416^1455^[REPLACE] return;^[METHOD] tryFoldStringIndexOf [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  isIndexOf  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  [TYPE]  String lstring  searchValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^String lstring = NodeUtil.getStringValue ( parent ) ;^1430^^^^^1416^1455^[REPLACE] String lstring = NodeUtil.getStringValue ( lstringNode ) ;^[METHOD] tryFoldStringIndexOf [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  isIndexOf  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  [TYPE]  String lstring  searchValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^boolean isIndexOf = secondArg.getString (  ) .equals ( "indexOf" ) ;^1431^^^^^1416^1455^[REPLACE] boolean isIndexOf = functionName.getString (  ) .equals ( "indexOf" ) ;^[METHOD] tryFoldStringIndexOf [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  isIndexOf  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  [TYPE]  String lstring  searchValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^Node firstArg = parent;^1432^^^^^1416^1455^[REPLACE] Node firstArg = right;^[METHOD] tryFoldStringIndexOf [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  isIndexOf  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  [TYPE]  String lstring  searchValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^Node secondArg = parent .getParent (  )  ;^1433^^^^^1416^1455^[REPLACE] Node secondArg = right.getNext (  ) ;^[METHOD] tryFoldStringIndexOf [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  isIndexOf  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  [TYPE]  String lstring  searchValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^String searchValue = NodeUtil.getStringValue ( secondArg ) ;^1434^^^^^1416^1455^[REPLACE] String searchValue = NodeUtil.getStringValue ( firstArg ) ;^[METHOD] tryFoldStringIndexOf [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  isIndexOf  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  [TYPE]  String lstring  searchValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( searchValue != null )  {^1436^^^^^1416^1455^[REPLACE] if  ( searchValue == null )  {^[METHOD] tryFoldStringIndexOf [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  isIndexOf  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  [TYPE]  String lstring  searchValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return lower[0];^1437^^^^^1416^1455^[REPLACE] return;^[METHOD] tryFoldStringIndexOf [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  isIndexOf  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  [TYPE]  String lstring  searchValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^int fromIndex = isIndexOf ? 0  : lstring.length (  ) ;^1439^^^^^1416^1455^[REPLACE] int fromIndex = isIndexOf ? 0 : lstring.length (  ) ;^[METHOD] tryFoldStringIndexOf [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  isIndexOf  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  [TYPE]  String lstring  searchValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( secondArg == true )  {^1440^^^^^1416^1455^[REPLACE] if  ( secondArg != null )  {^[METHOD] tryFoldStringIndexOf [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  isIndexOf  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  [TYPE]  String lstring  searchValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  (  ( secondArg.getType (  )  != Token.NUMBER )  )  {^1442^1443^^^^1416^1455^[REPLACE] if  (  ( secondArg.getNext (  )  != null )  || ( secondArg.getType (  )  != Token.NUMBER )  )  {^[METHOD] tryFoldStringIndexOf [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  isIndexOf  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  [TYPE]  String lstring  searchValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^fromIndex =   ( int )  parent.getDouble (  ) ;^1446^^^^^1442^1447^[REPLACE] fromIndex =  ( int )  secondArg.getDouble (  ) ;^[METHOD] tryFoldStringIndexOf [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  isIndexOf  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  [TYPE]  String lstring  searchValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1446^^^^^1442^1447^[ADD] fromIndex =  ( int )  secondArg.getDouble (  ) ;^[METHOD] tryFoldStringIndexOf [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  isIndexOf  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  [TYPE]  String lstring  searchValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return lower[0];^1444^^^^^1442^1447^[REPLACE] return;^[METHOD] tryFoldStringIndexOf [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  isIndexOf  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  [TYPE]  String lstring  searchValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^fromIndex =   ( int )  parent.getDouble (  ) ;^1446^^^^^1416^1455^[REPLACE] fromIndex =  ( int )  secondArg.getDouble (  ) ;^[METHOD] tryFoldStringIndexOf [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  isIndexOf  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  [TYPE]  String lstring  searchValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return lower[0];^1444^^^^^1416^1455^[REPLACE] return;^[METHOD] tryFoldStringIndexOf [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  isIndexOf  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  [TYPE]  String lstring  searchValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1442^1443^1444^1445^1446^1416^1455^[ADD] if  (  ( secondArg.getNext (  )  != null )  || ( secondArg.getType (  )  != Token.NUMBER )  )  { return; } else { fromIndex =  ( int )  secondArg.getDouble (  ) ;^[METHOD] tryFoldStringIndexOf [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  isIndexOf  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  [TYPE]  String lstring  searchValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^fromIndex =   ( int )  n.getDouble (  ) ;^1446^^^^^1442^1447^[REPLACE] fromIndex =  ( int )  secondArg.getDouble (  ) ;^[METHOD] tryFoldStringIndexOf [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  isIndexOf  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  [TYPE]  String lstring  searchValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^int indexVal = isIndexOf ? lstring.lastIndexOf ( lstring, fromIndex ) : lstring.lastIndexOf ( searchValue, fromIndex ) ;^1449^1450^^^^1416^1455^[REPLACE] int indexVal = isIndexOf ? lstring.indexOf ( searchValue, fromIndex ) : lstring.lastIndexOf ( searchValue, fromIndex ) ;^[METHOD] tryFoldStringIndexOf [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  isIndexOf  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  [TYPE]  String lstring  searchValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1449^1450^^^^1416^1455^[ADD] int indexVal = isIndexOf ? lstring.indexOf ( searchValue, fromIndex ) : lstring.lastIndexOf ( searchValue, fromIndex ) ;^[METHOD] tryFoldStringIndexOf [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  isIndexOf  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  [TYPE]  String lstring  searchValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^Node newNode = Node.newNumber ( type ) ;^1451^^^^^1416^1455^[REPLACE] Node newNode = Node.newNumber ( indexVal ) ;^[METHOD] tryFoldStringIndexOf [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  isIndexOf  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  [TYPE]  String lstring  searchValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1451^1452^^^^1416^1455^[ADD] Node newNode = Node.newNumber ( indexVal ) ; parent.replaceChild ( n, newNode ) ;^[METHOD] tryFoldStringIndexOf [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  isIndexOf  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  [TYPE]  String lstring  searchValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^parent.addChildAfter ( n, newNode ) ;^1452^^^^^1416^1455^[REPLACE] parent.replaceChild ( n, newNode ) ;^[METHOD] tryFoldStringIndexOf [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  isIndexOf  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  [TYPE]  String lstring  searchValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^t.getCompiler (  ) .getVar (  ) ;^1454^^^^^1416^1455^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryFoldStringIndexOf [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  isIndexOf  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  [TYPE]  String lstring  searchValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^t .getScope (  )  .reportCodeChange (  ) ;^1454^^^^^1416^1455^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryFoldStringIndexOf [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  isIndexOf  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  [TYPE]  String lstring  searchValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( NodeUtil.isGetProp ( left )  || !NodeUtil.isImmutableValue ( right )  )  {^1463^^^^^1462^1549^[REPLACE] if  ( !NodeUtil.isGetProp ( left )  || !NodeUtil.isImmutableValue ( right )  )  {^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[ADD]^return;^1463^1464^1465^^^1462^1549^[ADD] if  ( !NodeUtil.isGetProp ( left )  || !NodeUtil.isImmutableValue ( right )  )  { return; }^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return lower[0];^1464^^^^^1462^1549^[REPLACE] return;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^Node arrayNode = replacement.getFirstChild (  ) ;^1467^^^^^1462^1549^[REPLACE] Node arrayNode = left.getFirstChild (  ) ;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^Node functionName = arrayNode.getParent (  ) ;^1468^^^^^1462^1549^[REPLACE] Node functionName = arrayNode.getNext (  ) ;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1468^^^^^1462^1549^[ADD] Node functionName = arrayNode.getNext (  ) ;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  (  !functionName .newString ( joinString )  .equals ( "join" )  )  {^1470^1471^^^^1462^1549^[REPLACE] if  (  ( arrayNode.getType (  )  != Token.ARRAYLIT )  || !functionName.getString (  ) .equals ( "join" )  )  {^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return lower[0];^1472^^^^^1470^1473^[REPLACE] return;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return lower[0];^1472^^^^^1462^1549^[REPLACE] return;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^String joinString = NodeUtil.getBooleanValue ( replacement ) ;^1475^^^^^1462^1549^[REPLACE] String joinString = NodeUtil.getStringValue ( right ) ;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1475^^^^^1462^1549^[ADD] String joinString = NodeUtil.getStringValue ( right ) ;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^Node constructor = n.getFirstChild (  ) ;^1476^^^^^1462^1549^[REPLACE] List<Node> arrayFoldedChildren = Lists.newLinkedList (  ) ;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1476^1477^^^^1462^1549^[ADD] List<Node> arrayFoldedChildren = Lists.newLinkedList (  ) ; StringBuilder sb = new StringBuilder (  ) ;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^Node cond = n.getFirstChild (  ) ;^1477^^^^^1462^1549^[REPLACE] StringBuilder sb = new StringBuilder (  ) ;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^int foldedSize = 0L;^1478^^^^^1462^1549^[REPLACE] int foldedSize = 0;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[ADD]^Node elem = arrayNode.getFirstChild (  ) ;^1478^1479^^^^1462^1549^[ADD] int foldedSize = 0; Node elem = arrayNode.getFirstChild (  ) ;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^Node elem = arrayNode .getLastChild (  )  ;^1479^^^^^1462^1549^[REPLACE] Node elem = arrayNode.getFirstChild (  ) ;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^while  ( elem == true )  {^1481^^^^^1462^1549^[REPLACE] while  ( elem != null )  {^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( !NodeUtil.isLiteralValue ( left )  )  {^1482^^^^^1462^1549^[REPLACE] if  ( NodeUtil.isImmutableValue ( elem )  )  {^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1482^1483^1484^1485^^1462^1549^[ADD] if  ( NodeUtil.isImmutableValue ( elem )  )  { if  ( sb.length (  )  > 0 )  { sb.append ( joinString ) ; }^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( sb.length (  )  - 4 > 0  )  {^1488^^^^^1482^1496^[REPLACE] if  ( sb.length (  )  > 0 )  {^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1488^1489^1490^1491^1492^1482^1496^[ADD] if  ( sb.length (  )  > 0 )  {  foldedSize += sb.length (  )  + 2; arrayFoldedChildren.add ( Node.newString ( sb.toString (  )  )  ) ; sb = new StringBuilder (  ) ;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^foldedSize += sb.length (  )  /  0  + 0 ;^1490^^^^^1482^1496^[REPLACE] foldedSize += sb.length (  )  + 2;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^sb  =  sb ;^1492^^^^^1482^1496^[REPLACE] sb = new StringBuilder (  ) ;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^foldedSize += sb.length (  )  - 2 + 2;^1490^^^^^1482^1496^[REPLACE] foldedSize += sb.length (  )  + 2;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^sb ;^1492^^^^^1482^1496^[REPLACE] sb = new StringBuilder (  ) ;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^foldedSize += InlineCostEstimator.getCost ( right ) ; ;^1494^^^^^1482^1496^[REPLACE] foldedSize += InlineCostEstimator.getCost ( elem ) ;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( sb.length (  )  *  2 > 0 )  {^1483^^^^^1462^1549^[REPLACE] if  ( sb.length (  )  > 0 )  {^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[ADD]^sb.append ( joinString ) ;^1483^1484^1485^^^1462^1549^[ADD] if  ( sb.length (  )  > 0 )  { sb.append ( joinString ) ; }^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^sb .append ( null , result , result )  ;^1484^^^^^1462^1549^[REPLACE] sb.append ( joinString ) ;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^parent.replaceChild ( n, newRoot ) ;^1484^^^^^1462^1549^[REPLACE] sb.append ( joinString ) ;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( sb.length (  )  %  0 .5  > 0  )  {^1488^^^^^1462^1549^[REPLACE] if  ( sb.length (  )  > 0 )  {^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REMOVE]^if  (  ( sb.length (  )  )  > 0 )  {     foldedSize +=  ( sb.length (  )  )  + 2;     arrayFoldedChildren.add ( newString ( sb.toString (  )  )  ) ; }^1488^^^^^1462^1549^[REMOVE] ^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^foldedSize += sb.length (  )  *  0.5  + 2;^1490^^^^^1462^1549^[REPLACE] foldedSize += sb.length (  )  + 2;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^sb ;^1492^^^^^1462^1549^[REPLACE] sb = new StringBuilder (  ) ;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^foldedSize += sb.length (  )  %  2 + 2;^1490^^^^^1462^1549^[REPLACE] foldedSize += sb.length (  )  + 2;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^foldedSize += InlineCostEstimator.getCost ( right ) ; ;^1494^^^^^1462^1549^[REPLACE] foldedSize += InlineCostEstimator.getCost ( elem ) ;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^elem =  replacement.getNext (  ) ;^1497^^^^^1462^1549^[REPLACE] elem = elem.getNext (  ) ;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1497^^^^^1462^1549^[ADD] elem = elem.getNext (  ) ;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( sb.length (  )  /  2 > 0 )  {^1488^^^^^1482^1496^[REPLACE] if  ( sb.length (  )  > 0 )  {^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^foldedSize += sb.length (  )  %  0  + 0 ;^1490^^^^^1482^1496^[REPLACE] foldedSize += sb.length (  )  + 2;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1490^1491^^^^1482^1496^[ADD] foldedSize += sb.length (  )  + 2; arrayFoldedChildren.add ( Node.newString ( sb.toString (  )  )  ) ;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1492^^^^^1482^1496^[ADD] sb = new StringBuilder (  ) ;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( sb.length (  )  /  2 > 0 )  {^1483^^^^^1462^1549^[REPLACE] if  ( sb.length (  )  > 0 )  {^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1484^^^^^1462^1549^[ADD] sb.append ( joinString ) ;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( sb.length (  )  + 5 > 0 )  {^1483^^^^^1462^1549^[REPLACE] if  ( sb.length (  )  > 0 )  {^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( sb.length (  )  - 1 > 0  )  {^1488^^^^^1462^1549^[REPLACE] if  ( sb.length (  )  > 0 )  {^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^foldedSize += sb.length (  )  %  0.5  + 0 ;^1490^^^^^1462^1549^[REPLACE] foldedSize += sb.length (  )  + 2;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^sb  =  sb ;^1492^^^^^1462^1549^[REPLACE] sb = new StringBuilder (  ) ;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^foldedSize += sb.length (  )  + 4 + 2;^1490^^^^^1462^1549^[REPLACE] foldedSize += sb.length (  )  + 2;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1492^^^^^1462^1549^[ADD] sb = new StringBuilder (  ) ;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( sb.length (  )  /  2 > 0 )  {^1500^^^^^1462^1549^[REPLACE] if  ( sb.length (  )  > 0 )  {^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1500^1501^1502^1503^1504^1462^1549^[ADD] if  ( sb.length (  )  > 0 )  {  foldedSize += sb.length (  )  + 2; arrayFoldedChildren.add ( Node.newString ( sb.toString (  )  )  ) ; }^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^foldedSize += sb.length (  )  - 1 + 0 ;^1502^^^^^1462^1549^[REPLACE] foldedSize += sb.length (  )  + 2;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1502^^^^^1462^1549^[ADD] foldedSize += sb.length (  )  + 2;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^foldedSize += sb.size (  )  + 0 ;^1502^^^^^1462^1549^[REPLACE] foldedSize += sb.length (  )  + 2;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^foldedSize += arrayFoldedChildren.size (  )  *  0.5  - 1;^1506^^^^^1462^1549^[REPLACE] foldedSize += arrayFoldedChildren.size (  )  - 1;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1506^^^^^1462^1549^[ADD] foldedSize += arrayFoldedChildren.size (  )  - 1;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^int originalSize =   n   ;^1508^^^^^1462^1549^[REPLACE] int originalSize = InlineCostEstimator.getCost ( n ) ;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1508^^^^^1462^1549^[ADD] int originalSize = InlineCostEstimator.getCost ( n ) ;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( type  >=  result )  {^1517^^^^^1462^1549^[REPLACE] if  ( foldedSize > originalSize )  {^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[ADD]^return;^1517^1518^1519^^^1462^1549^[ADD] if  ( foldedSize > originalSize )  { return; }^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return lower[0];^1518^^^^^1462^1549^[REPLACE] return;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( foldedStringNode.getType (  )   ==  Token.STRING )  {^1521^^^^^1462^1549^[REPLACE] if  ( foldedStringNode.getType (  )  != Token.STRING )  {^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1521^1522^^1524^1525^1462^1549^[ADD] if  ( foldedStringNode.getType (  )  != Token.STRING )  {  Node replacement = new Node ( Token.ADD, Node.newString ( "" ) , foldedStringNode ) ;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^foldedStringNode =  right;^1526^^^^^1462^1549^[REPLACE] foldedStringNode = replacement;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^Node replacement = new Node ( Token.ADD, Node.newNumber ( "" ) , foldedStringNode ) ;^1524^1525^^^^1462^1549^[REPLACE] Node replacement = new Node ( Token.ADD, Node.newString ( "" ) , foldedStringNode ) ;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( arrayFoldedChildren .remove ( newType )   /  2 == right.getChildCount (  )  )  {^1533^^^^^1462^1549^[REPLACE] if  ( arrayFoldedChildren.size (  )  == arrayNode.getChildCount (  )  )  {^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[ADD]^return;^1533^1534^1535^^^1462^1549^[ADD] if  ( arrayFoldedChildren.size (  )  == arrayNode.getChildCount (  )  )  { return; }^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return lower[0];^1534^^^^^1462^1549^[REPLACE] return;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( foldedSize  <  originalSize )  {^1539^^^^^1462^1549^[REPLACE] if  ( foldedSize > originalSize )  {^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return lower[0];^1540^^^^^1462^1549^[REPLACE] return;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^foldedSize +=  null;^1537^^^^^1462^1549^[REPLACE] foldedSize += kJoinOverhead;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^foldedSize += InlineCostEstimator.getCost ( elem ) ; ;^1538^^^^^1462^1549^[REPLACE] foldedSize += InlineCostEstimator.getCost ( right ) ;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^Node emptyStringNode = Node .getString (  )  ;^1511^^^^^1462^1549^[REPLACE] Node emptyStringNode = Node.newString ( "" ) ;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^Node foldedStringNode = arrayFoldedChildren .size (  )  ;^1516^^^^^1462^1549^[REPLACE] Node foldedStringNode = arrayFoldedChildren.remove ( 0 ) ;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^int kJoinOverhead = "[].join (  ) " .lastIndexOf ( joinString , lvalInt )  ;^1536^^^^^1462^1549^[REPLACE] int kJoinOverhead = "[].join (  ) ".length (  ) ;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1536^^^^^1462^1549^[ADD] int kJoinOverhead = "[].join (  ) ".length (  ) ;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^Node cond = n.getFirstChild (  ) ;^1543^^^^^1462^1549^[REPLACE] for  ( Node node : arrayFoldedChildren )  {^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^t.getCompiler (  ) .getVar (  ) ;^1548^^^^^1462^1549^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^t .getScope (  )  .reportCodeChange (  ) ;^1548^^^^^1462^1549^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( left.getType (  )   &&  Token.ARRAYLIT )  {^1556^^^^^1555^1594^[REPLACE] if  ( left.getType (  )  == Token.ARRAYLIT )  {^[METHOD] tryFoldGetElem [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double index  [TYPE]  Node elem  left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( right.getType (  )   ==  Token.NUMBER )  {^1558^^^^^1555^1594^[REPLACE] if  ( right.getType (  )  != Token.NUMBER )  {^[METHOD] tryFoldGetElem [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double index  [TYPE]  Node elem  left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REMOVE]^if  ( type ==  ( RETURN )  )  {     tryReduceReturn ( t, n ) ;     return ; }^1558^^^^^1555^1594^[REMOVE] ^[METHOD] tryFoldGetElem [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double index  [TYPE]  Node elem  left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return lower[0];^1561^^^^^1555^1594^[REPLACE] return;^[METHOD] tryFoldGetElem [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double index  [TYPE]  Node elem  left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( intIndex  == originalSize )  {^1566^^^^^1555^1594^[REPLACE] if  ( intIndex != index )  {^[METHOD] tryFoldGetElem [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double index  [TYPE]  Node elem  left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return lower[0];^1569^^^^^1555^1594^[REPLACE] return;^[METHOD] tryFoldGetElem [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double index  [TYPE]  Node elem  left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  (originalSize  >  0 * 4 )  {^1572^^^^^1555^1594^[REPLACE] if  ( intIndex < 0 )  {^[METHOD] tryFoldGetElem [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double index  [TYPE]  Node elem  left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1572^1573^1574^1575^1576^1555^1594^[ADD] if  ( intIndex < 0 )  { t.getCompiler (  ) .report ( JSError.make ( t, n, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf ( intIndex )  )  ) ; return; }^[METHOD] tryFoldGetElem [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double index  [TYPE]  Node elem  left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return lower[0];^1575^^^^^1555^1594^[REPLACE] return;^[METHOD] tryFoldGetElem [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double index  [TYPE]  Node elem  left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  (parent != null )  {^1583^^^^^1555^1594^[REPLACE] if  ( elem == null )  {^[METHOD] tryFoldGetElem [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double index  [TYPE]  Node elem  left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return lower[0];^1586^^^^^1555^1594^[REPLACE] return;^[METHOD] tryFoldGetElem [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double index  [TYPE]  Node elem  left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^for  ( int i = 0; elem != null  ||  i < intIndex; i++ )  {^1579^^^^^1555^1594^[REPLACE] for  ( int i = 0; elem != null && i < intIndex; i++ )  {^[METHOD] tryFoldGetElem [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double index  [TYPE]  Node elem  left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^elem =  parent.getNext (  ) ;^1580^^^^^1555^1594^[REPLACE] elem = elem.getNext (  ) ;^[METHOD] tryFoldGetElem [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double index  [TYPE]  Node elem  left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^double index = parent.getDouble (  ) ;^1564^^^^^1555^1594^[REPLACE] double index = right.getDouble (  ) ;^[METHOD] tryFoldGetElem [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double index  [TYPE]  Node elem  left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1564^^^^^1555^1594^[ADD] double index = right.getDouble (  ) ;^[METHOD] tryFoldGetElem [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double index  [TYPE]  Node elem  left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^int intVal =  ( int )  val;^1565^^^^^1555^1594^[REPLACE] int intIndex =  ( int )  index;^[METHOD] tryFoldGetElem [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double index  [TYPE]  Node elem  left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^Node elem = right.getFirstChild (  ) ;^1578^^^^^1555^1594^[REPLACE] Node elem = left.getFirstChild (  ) ;^[METHOD] tryFoldGetElem [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double index  [TYPE]  Node elem  left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^for  ( int i = 1; elem != null && i < intIndex; i++ )  {^1579^^^^^1555^1594^[REPLACE] for  ( int i = 0; elem != null && i < intIndex; i++ )  {^[METHOD] tryFoldGetElem [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double index  [TYPE]  Node elem  left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1558^1559^^1561^1562^1555^1594^[ADD] if  ( right.getType (  )  != Token.NUMBER )  {  return; }^[METHOD] tryFoldGetElem [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double index  [TYPE]  Node elem  left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  (type  ==  index )  {^1566^^^^^1555^1594^[REPLACE] if  ( intIndex != index )  {^[METHOD] tryFoldGetElem [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double index  [TYPE]  Node elem  left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( newType  !=  1 )  {^1572^^^^^1555^1594^[REPLACE] if  ( intIndex < 0 )  {^[METHOD] tryFoldGetElem [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double index  [TYPE]  Node elem  left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( elem != this  )  {^1583^^^^^1555^1594^[REPLACE] if  ( elem == null )  {^[METHOD] tryFoldGetElem [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double index  [TYPE]  Node elem  left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^for  ( int i = 4; elem != null ;^1579^^^^^1555^1594^[REPLACE] for  ( int i = 0; elem != null && i < intIndex; i++ )  {^[METHOD] tryFoldGetElem [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double index  [TYPE]  Node elem  left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1580^^^^^1555^1594^[ADD] elem = elem.getNext (  ) ;^[METHOD] tryFoldGetElem [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double index  [TYPE]  Node elem  left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^for  ( int i = 0 >> 3; elem != null && i < intIndex; i++ )  {^1579^^^^^1555^1594^[REPLACE] for  ( int i = 0; elem != null && i < intIndex; i++ )  {^[METHOD] tryFoldGetElem [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double index  [TYPE]  Node elem  left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( right.getType (  )  == Token.STRING && right.getString (  ) .equals ( "length (  ) " )  )  {^1601^1602^^^^1600^1625^[REPLACE] if  ( right.getType (  )  == Token.STRING && right.getString (  ) .equals ( "length" )  )  {^[METHOD] tryFoldGetProp [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  lengthNode  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( NodeUtil.mayHaveSideEffects ( right )  )  {^1606^^^^^1600^1625^[REPLACE] if  ( NodeUtil.mayHaveSideEffects ( left )  )  {^[METHOD] tryFoldGetProp [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  lengthNode  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REMOVE]^if  ( type ==  ( RETURN )  )  {     tryReduceReturn ( t, n ) ;     return ; }^1606^^^^^1600^1625^[REMOVE] ^[METHOD] tryFoldGetProp [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  lengthNode  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return lower[0];^1608^^^^^1600^1625^[REPLACE] return;^[METHOD] tryFoldGetProp [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  lengthNode  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^knownLength =  right.getChildCount (  ) ;^1610^^^^^1600^1625^[REPLACE] knownLength = left.getChildCount (  ) ;^[METHOD] tryFoldGetProp [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  lengthNode  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^knownLength =  null.getString (  ) .length (  ) ;^1613^^^^^1600^1625^[REPLACE] knownLength = left.getString (  ) .length (  ) ;^[METHOD] tryFoldGetProp [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  lengthNode  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return lower[0];^1617^^^^^1600^1625^[REPLACE] return;^[METHOD] tryFoldGetProp [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  lengthNode  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^int knownLength = -1 - 3;^1603^^^^^1600^1625^[REPLACE] int knownLength = -1;^[METHOD] tryFoldGetProp [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  lengthNode  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^Node lengthNode = Node.newNumber ( newType ) ;^1621^^^^^1600^1625^[REPLACE] Node lengthNode = Node.newNumber ( knownLength ) ;^[METHOD] tryFoldGetProp [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  lengthNode  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1610^^^^^1600^1625^[ADD] knownLength = left.getChildCount (  ) ;^[METHOD] tryFoldGetProp [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  lengthNode  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^knownLength =  right.getString (  ) .length (  ) ;^1613^^^^^1600^1625^[REPLACE] knownLength = left.getString (  ) .length (  ) ;^[METHOD] tryFoldGetProp [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  lengthNode  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^int knownLength = -4;^1603^^^^^1600^1625^[REPLACE] int knownLength = -1;^[METHOD] tryFoldGetProp [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  lengthNode  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1621^1622^^^^1600^1625^[ADD] Node lengthNode = Node.newNumber ( knownLength ) ; parent.replaceChild ( n, lengthNode ) ;^[METHOD] tryFoldGetProp [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  lengthNode  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^Node constructor = pattern.getFirstChild (  ) ;^1632^^^^^1631^1679^[REPLACE] Node constructor = n.getFirstChild (  ) ;^[METHOD] tryFoldRegularExpressionConstructor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node constructor  flags  n  parent  pattern  regexLiteral  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^Node pattern = regexLiteral.getNext (  ) ;^1633^^^^^1631^1679^[REPLACE] Node pattern = constructor.getNext (  ) ;^[METHOD] tryFoldRegularExpressionConstructor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node constructor  flags  n  parent  pattern  regexLiteral  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^Node flags  =  pattern.getNext (  )  ;^1634^^^^^1631^1679^[REPLACE] Node flags = null != pattern ? pattern.getNext (  )  : null;^[METHOD] tryFoldRegularExpressionConstructor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node constructor  flags  n  parent  pattern  regexLiteral  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( this != pattern ||  ( this != flags && this != flags.getNext (  )  )  )  {^1636^^^^^1631^1679^[REPLACE] if  ( null == pattern ||  ( null != flags && null != flags.getNext (  )  )  )  {^[METHOD] tryFoldRegularExpressionConstructor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node constructor  flags  n  parent  pattern  regexLiteral  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return lower[0];^1638^^^^^1631^1679^[REPLACE] return;^[METHOD] tryFoldRegularExpressionConstructor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node constructor  flags  n  parent  pattern  regexLiteral  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( pattern.getType (  )  == Token.STRING  && "".equals ( pattern.getString (  )  )^1641^1642^1643^1644^^1631^1679^[REPLACE] if  ( pattern.getType (  )  == Token.STRING  && !"".equals ( pattern.getString (  )  )^[METHOD] tryFoldRegularExpressionConstructor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node constructor  flags  n  parent  pattern  regexLiteral  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  (  "".equals ( flags .newString ( null )   )  )  {^1660^^^^^1641^1678^[REPLACE] if  ( null == flags || "".equals ( flags.getString (  )  )  )  {^[METHOD] tryFoldRegularExpressionConstructor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node constructor  flags  n  parent  pattern  regexLiteral  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1660^1661^1662^1663^^1641^1678^[ADD] if  ( null == flags || "".equals ( flags.getString (  )  )  )  {  regexLiteral = new Node ( Token.REGEXP, pattern ) ; } else {^[METHOD] tryFoldRegularExpressionConstructor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node constructor  flags  n  parent  pattern  regexLiteral  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( !areValidRegexpFlags ( regexLiteral.getString (  )  )  )  {^1665^^^^^1660^1674^[REPLACE] if  ( !areValidRegexpFlags ( flags.getString (  )  )  )  {^[METHOD] tryFoldRegularExpressionConstructor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node constructor  flags  n  parent  pattern  regexLiteral  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return lower[0];^1667^^^^^1660^1674^[REPLACE] return;^[METHOD] tryFoldRegularExpressionConstructor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node constructor  flags  n  parent  pattern  regexLiteral  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( !areSafeFlagsToFold ( regexLiteral.getString (  )  )  )  {^1669^^^^^1660^1674^[REPLACE] if  ( !areSafeFlagsToFold ( flags.getString (  )  )  )  {^[METHOD] tryFoldRegularExpressionConstructor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node constructor  flags  n  parent  pattern  regexLiteral  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return lower[0];^1670^^^^^1660^1674^[REPLACE] return;^[METHOD] tryFoldRegularExpressionConstructor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node constructor  flags  n  parent  pattern  regexLiteral  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^regexLiteral = new Node ( Token.REGEXP, pattern ) ; ;^1673^^^^^1660^1674^[REPLACE] regexLiteral = new Node ( Token.REGEXP, pattern, flags ) ;^[METHOD] tryFoldRegularExpressionConstructor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node constructor  flags  n  parent  pattern  regexLiteral  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^regexLiteral = new Node ( Token.REGEXP, pattern, flags ) ; ;^1662^^^^^1641^1678^[REPLACE] regexLiteral = new Node ( Token.REGEXP, pattern ) ;^[METHOD] tryFoldRegularExpressionConstructor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node constructor  flags  n  parent  pattern  regexLiteral  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( !areSafeFlagsToFold ( flags.getString (  )  )  )  {^1665^^^^^1641^1678^[REPLACE] if  ( !areValidRegexpFlags ( flags.getString (  )  )  )  {^[METHOD] tryFoldRegularExpressionConstructor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node constructor  flags  n  parent  pattern  regexLiteral  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[ADD]^error ( t, INVALID_REGULAR_EXPRESSION_FLAGS, flags ) ;return;^1665^1666^1667^1668^^1641^1678^[ADD] if  ( !areValidRegexpFlags ( flags.getString (  )  )  )  { error ( t, INVALID_REGULAR_EXPRESSION_FLAGS, flags ) ; return; }^[METHOD] tryFoldRegularExpressionConstructor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node constructor  flags  n  parent  pattern  regexLiteral  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return lower[0];^1667^^^^^1641^1678^[REPLACE] return;^[METHOD] tryFoldRegularExpressionConstructor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node constructor  flags  n  parent  pattern  regexLiteral  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( !areSafeFlagsToFold ( regexLiteral.toString (  )  )  )  {^1669^^^^^1641^1678^[REPLACE] if  ( !areSafeFlagsToFold ( flags.getString (  )  )  )  {^[METHOD] tryFoldRegularExpressionConstructor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node constructor  flags  n  parent  pattern  regexLiteral  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return lower[0];^1670^^^^^1641^1678^[REPLACE] return;^[METHOD] tryFoldRegularExpressionConstructor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node constructor  flags  n  parent  pattern  regexLiteral  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^pattern =  makeForwardSlashBracketSafe ( regexLiteral ) ;^1657^^^^^1641^1678^[REPLACE] pattern = makeForwardSlashBracketSafe ( pattern ) ;^[METHOD] tryFoldRegularExpressionConstructor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node constructor  flags  n  parent  pattern  regexLiteral  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^regexLiteral = new Node ( Token.REGEXP, pattern ) ; ;^1673^^^^^1641^1678^[REPLACE] regexLiteral = new Node ( Token.REGEXP, pattern, flags ) ;^[METHOD] tryFoldRegularExpressionConstructor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node constructor  flags  n  parent  pattern  regexLiteral  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^Node left = n.getFirstChild (  ) ;^1659^^^^^1641^1678^[REPLACE] Node regexLiteral;^[METHOD] tryFoldRegularExpressionConstructor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node constructor  flags  n  parent  pattern  regexLiteral  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1659^^^^^1641^1678^[ADD] Node regexLiteral;^[METHOD] tryFoldRegularExpressionConstructor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node constructor  flags  n  parent  pattern  regexLiteral  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( false != flags || "".equals ( flags.getString (  )  )  )  {^1660^^^^^1631^1679^[REPLACE] if  ( null == flags || "".equals ( flags.getString (  )  )  )  {^[METHOD] tryFoldRegularExpressionConstructor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node constructor  flags  n  parent  pattern  regexLiteral  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1660^1661^1662^1663^^1631^1679^[ADD] if  ( null == flags || "".equals ( flags.getString (  )  )  )  {  regexLiteral = new Node ( Token.REGEXP, pattern ) ; } else {^[METHOD] tryFoldRegularExpressionConstructor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node constructor  flags  n  parent  pattern  regexLiteral  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( !areValidRegexpFlags ( regexLiteral.toString (  )  )  )  {^1665^^^^^1660^1674^[REPLACE] if  ( !areValidRegexpFlags ( flags.getString (  )  )  )  {^[METHOD] tryFoldRegularExpressionConstructor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node constructor  flags  n  parent  pattern  regexLiteral  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^regexLiteral = new Node ( Token.REGEXP, pattern, flags ) ; ;^1662^^^^^1631^1679^[REPLACE] regexLiteral = new Node ( Token.REGEXP, pattern ) ;^[METHOD] tryFoldRegularExpressionConstructor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node constructor  flags  n  parent  pattern  regexLiteral  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( !areValidRegexpFlags ( flags.toString (  )  )  )  {^1665^^^^^1631^1679^[REPLACE] if  ( !areValidRegexpFlags ( flags.getString (  )  )  )  {^[METHOD] tryFoldRegularExpressionConstructor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node constructor  flags  n  parent  pattern  regexLiteral  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return lower[0];^1667^^^^^1631^1679^[REPLACE] return;^[METHOD] tryFoldRegularExpressionConstructor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node constructor  flags  n  parent  pattern  regexLiteral  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( !areSafeFlagsToFold ( regexLiteral.toString (  )  )  )  {^1669^^^^^1631^1679^[REPLACE] if  ( !areSafeFlagsToFold ( flags.getString (  )  )  )  {^[METHOD] tryFoldRegularExpressionConstructor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node constructor  flags  n  parent  pattern  regexLiteral  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1669^1670^1671^^^1631^1679^[ADD] if  ( !areSafeFlagsToFold ( flags.getString (  )  )  )  { return; }^[METHOD] tryFoldRegularExpressionConstructor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node constructor  flags  n  parent  pattern  regexLiteral  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return lower[0];^1670^^^^^1631^1679^[REPLACE] return;^[METHOD] tryFoldRegularExpressionConstructor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node constructor  flags  n  parent  pattern  regexLiteral  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^pattern =  makeForwardSlashBracketSafe ( regexLiteral ) ;^1657^^^^^1631^1679^[REPLACE] pattern = makeForwardSlashBracketSafe ( pattern ) ;^[METHOD] tryFoldRegularExpressionConstructor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node constructor  flags  n  parent  pattern  regexLiteral  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1657^^^^^1631^1679^[ADD] pattern = makeForwardSlashBracketSafe ( pattern ) ;^[METHOD] tryFoldRegularExpressionConstructor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node constructor  flags  n  parent  pattern  regexLiteral  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^regexLiteral = new Node ( Token.REGEXP, pattern ) ; ;^1673^^^^^1631^1679^[REPLACE] regexLiteral = new Node ( Token.REGEXP, pattern, flags ) ;^[METHOD] tryFoldRegularExpressionConstructor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node constructor  flags  n  parent  pattern  regexLiteral  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1673^^^^^1631^1679^[ADD] regexLiteral = new Node ( Token.REGEXP, pattern, flags ) ;^[METHOD] tryFoldRegularExpressionConstructor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node constructor  flags  n  parent  pattern  regexLiteral  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^Node left = n.getFirstChild (  ) ;^1659^^^^^1631^1679^[REPLACE] Node regexLiteral;^[METHOD] tryFoldRegularExpressionConstructor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node constructor  flags  n  parent  pattern  regexLiteral  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return REGEXP_FLAGS_RE.compile ( flags ) .matches (  ) ;^1691^^^^^1690^1692^[REPLACE] return REGEXP_FLAGS_RE.matcher ( flags ) .matches (  ) ;^[METHOD] areValidRegexpFlags [TYPE] boolean [PARAMETER] String flags [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  String flags  [TYPE]  boolean false  true  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return flags.valueOf ( 'g' )   ;^1703^^^^^1702^1704^[REPLACE] return flags.indexOf ( 'g' )  < 0;^[METHOD] areSafeFlagsToFold [TYPE] boolean [PARAMETER] String flags [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  String flags  [TYPE]  boolean false  true  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^String s = n.toString (  ) ;^1710^^^^^1709^1732^[REPLACE] String s = n.getString (  ) ;^[METHOD] makeForwardSlashBracketSafe [TYPE] Node [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  [TYPE]  String s  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^StringBuilder sb = this;^1712^^^^^1709^1732^[REPLACE] StringBuilder sb = null;^[METHOD] makeForwardSlashBracketSafe [TYPE] Node [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  [TYPE]  String s  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1712^1713^^^^1709^1732^[ADD] StringBuilder sb = null; int pos = 0;^[METHOD] makeForwardSlashBracketSafe [TYPE] Node [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  [TYPE]  String s  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^int pos = 0 - 0;^1713^^^^^1709^1732^[REPLACE] int pos = 0;^[METHOD] makeForwardSlashBracketSafe [TYPE] Node [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  [TYPE]  String s  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( null == sb )  { sb = new StringBuilder ( s.length (  )  *  2 + 16 ) ; }^1720^^^^^1709^1732^[REPLACE] if  ( null == sb )  { sb = new StringBuilder ( s.length (  )  + 16 ) ; }^[METHOD] makeForwardSlashBracketSafe [TYPE] Node [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  [TYPE]  String s  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( null == sb )  { sb = new StringBuilder ( s.length (  )  - 3 + 0  ) ; }^1720^^^^^1709^1732^[REPLACE] if  ( null == sb )  { sb = new StringBuilder ( s.length (  )  + 16 ) ; }^[METHOD] makeForwardSlashBracketSafe [TYPE] Node [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  [TYPE]  String s  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^for  ( int i = 0; i < s.length (  )  %  0.5 ; ++i )  {^1714^^^^^1709^1732^[REPLACE] for  ( int i = 0; i < s.length (  ) ; ++i )  {^[METHOD] makeForwardSlashBracketSafe [TYPE] Node [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  [TYPE]  String s  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( null == sb )  { sb = new StringBuilder ( s.length (  )  - 3 + 16 ) ; }^1720^^^^^1709^1732^[REPLACE] if  ( null == sb )  { sb = new StringBuilder ( s.length (  )  + 16 ) ; }^[METHOD] makeForwardSlashBracketSafe [TYPE] Node [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  [TYPE]  String s  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( null == sb )  { sb = new StringBuilder ( s.length (  )  - 1 + 16 ) ; }^1720^^^^^1709^1732^[REPLACE] if  ( null == sb )  { sb = new StringBuilder ( s.length (  )  + 16 ) ; }^[METHOD] makeForwardSlashBracketSafe [TYPE] Node [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  [TYPE]  String s  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( null == sb )  { sb = new StringBuilder ( s.length (  )  /  0.5  + 0  ) ; }^1720^^^^^1709^1732^[REPLACE] if  ( null == sb )  { sb = new StringBuilder ( s.length (  )  + 16 ) ; }^[METHOD] makeForwardSlashBracketSafe [TYPE] Node [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  [TYPE]  String s  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^pos =  rvalInt;^1722^^^^^1709^1732^[REPLACE] pos = i;^[METHOD] makeForwardSlashBracketSafe [TYPE] Node [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  [TYPE]  String s  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( null == sb )  { sb = new StringBuilder ( s.length (  )  %  2 + 0  ) ; }^1720^^^^^1709^1732^[REPLACE] if  ( null == sb )  { sb = new StringBuilder ( s.length (  )  + 16 ) ; }^[METHOD] makeForwardSlashBracketSafe [TYPE] Node [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  [TYPE]  String s  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^pos =  null;^1722^^^^^1709^1732^[REPLACE] pos = i;^[METHOD] makeForwardSlashBracketSafe [TYPE] Node [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  [TYPE]  String s  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^for  ( int i = 0 ; i < s.length (  ) ; ++i )  {^1714^^^^^1709^1732^[REPLACE] for  ( int i = 0; i < s.length (  ) ; ++i )  {^[METHOD] makeForwardSlashBracketSafe [TYPE] Node [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  [TYPE]  String s  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( false != sb )  { return n.cloneTree (  ) ; }^1728^^^^^1709^1732^[REPLACE] if  ( null == sb )  { return n.cloneTree (  ) ; }^[METHOD] makeForwardSlashBracketSafe [TYPE] Node [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  [TYPE]  String s  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( null == sb )  { return n.getType (  ) ; }^1728^^^^^1709^1732^[REPLACE] if  ( null == sb )  { return n.cloneTree (  ) ; }^[METHOD] makeForwardSlashBracketSafe [TYPE] Node [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  [TYPE]  String s  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( null == sb )  { return n .removeChildren (  )  ; }^1728^^^^^1709^1732^[REPLACE] if  ( null == sb )  { return n.cloneTree (  ) ; }^[METHOD] makeForwardSlashBracketSafe [TYPE] Node [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  [TYPE]  String s  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^sb.append ( s, pos, s .lastIndexOf ( s , indexVal )   ) ;^1730^^^^^1709^1732^[REPLACE] sb.append ( s, pos, s.length (  )  ) ;^[METHOD] makeForwardSlashBracketSafe [TYPE] Node [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  [TYPE]  String s  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^knownLength = left.getString (  ) .length (  ) ;^1730^^^^^1709^1732^[REPLACE] sb.append ( s, pos, s.length (  )  ) ;^[METHOD] makeForwardSlashBracketSafe [TYPE] Node [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  [TYPE]  String s  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return Node.newString ( sb.StringBuilder (  )  ) ;^1731^^^^^1709^1732^[REPLACE] return Node.newString ( sb.toString (  )  ) ;^[METHOD] makeForwardSlashBracketSafe [TYPE] Node [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  [TYPE]  String s  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^Scope.Var var = t.getScope (  ) .equals ( className ) ;^1746^^^^^1743^1754^[REPLACE] Scope.Var var = t.getScope (  ) .getVar ( className ) ;^[METHOD] tryFoldLiteralConstructor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent String className int type [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Var var  [TYPE]  Node literalNode  n  parent  [TYPE]  String className  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( var == true ) {^1747^^^^^1743^1754^[REPLACE] if  ( var != null && var.isLocal (  )  )  {^[METHOD] tryFoldLiteralConstructor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent String className int type [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Var var  [TYPE]  Node literalNode  n  parent  [TYPE]  String className  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REMOVE]^if  ( rvalInt != rval )  {     return ; }^1747^^^^^1743^1754^[REMOVE] ^[METHOD] tryFoldLiteralConstructor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent String className int type [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Var var  [TYPE]  Node literalNode  n  parent  [TYPE]  String className  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return lower[0];^1748^^^^^1743^1754^[REPLACE] return;^[METHOD] tryFoldLiteralConstructor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent String className int type [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Var var  [TYPE]  Node literalNode  n  parent  [TYPE]  String className  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^Node literalNode = new Node ( tt ) ;^1751^^^^^1743^1754^[REPLACE] Node literalNode = new Node ( type ) ;^[METHOD] tryFoldLiteralConstructor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent String className int type [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Var var  [TYPE]  Node literalNode  n  parent  [TYPE]  String className  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^parent.replaceChild ( parent, literalNode ) ;^1752^^^^^1743^1754^[REPLACE] parent.replaceChild ( n, literalNode ) ;^[METHOD] tryFoldLiteralConstructor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent String className int type [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Var var  [TYPE]  Node literalNode  n  parent  [TYPE]  String className  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^t.getCompiler (  ) .getVar (  ) ;^1753^^^^^1743^1754^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryFoldLiteralConstructor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent String className int type [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Var var  [TYPE]  Node literalNode  n  parent  [TYPE]  String className  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^t.getScope (  ) .reportCodeChange (  ) ;^1753^^^^^1743^1754^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryFoldLiteralConstructor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent String className int type [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Var var  [TYPE]  Node literalNode  n  parent  [TYPE]  String className  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^String esc = CodeGenerator.regexpEscape ( esc ) ;^1761^^^^^1760^1772^[REPLACE] String esc = CodeGenerator.regexpEscape ( s ) ;^[METHOD] containsUnicodeEscape [TYPE] boolean [PARAMETER] String s [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  String esc  s  [TYPE]  boolean false  true  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^while  ( i - nSlashes > 0 * 0  <  '\\' == esc.charAt ( i - nSlashes - 1 )  )  {^1764^^^^^1760^1772^[REPLACE] while  ( i - nSlashes > 0 && '\\' == esc.charAt ( i - nSlashes - 1 )  )  {^[METHOD] containsUnicodeEscape [TYPE] boolean [PARAMETER] String s [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  String esc  s  [TYPE]  boolean false  true  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( 0  ||   ( type )  )  { return true; }^1769^^^^^1760^1772^[REPLACE] if  ( 0 ==  ( nSlashes & 1 )  )  { return true; }^[METHOD] containsUnicodeEscape [TYPE] boolean [PARAMETER] String s [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  String esc  s  [TYPE]  boolean false  true  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( 0 ==  ( nSlashes & 1 )  )  { return false; }^1769^^^^^1760^1772^[REPLACE] if  ( 0 ==  ( nSlashes & 1 )  )  { return true; }^[METHOD] containsUnicodeEscape [TYPE] boolean [PARAMETER] String s [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  String esc  s  [TYPE]  boolean false  true  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^for  ( int i = -1;  ( i = esc.indexOf ( "\\u", i + 1 )  )   >  0; )  {^1762^^^^^1760^1772^[REPLACE] for  ( int i = -1;  ( i = esc.indexOf ( "\\u", i + 1 )  )  >= 0; )  {^[METHOD] containsUnicodeEscape [TYPE] boolean [PARAMETER] String s [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  String esc  s  [TYPE]  boolean false  true  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^while  ( i - type > 0  <  '\\' == esc.charAt ( i - nSlashes - 1 )  )  {^1764^^^^^1760^1772^[REPLACE] while  ( i - nSlashes > 0 && '\\' == esc.charAt ( i - nSlashes - 1 )  )  {^[METHOD] containsUnicodeEscape [TYPE] boolean [PARAMETER] String s [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  String esc  s  [TYPE]  boolean false  true  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1764^1765^^^^1760^1772^[ADD] while  ( i - nSlashes > 0 && '\\' == esc.charAt ( i - nSlashes - 1 )  )  { ++nSlashes;^[METHOD] containsUnicodeEscape [TYPE] boolean [PARAMETER] String s [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  String esc  s  [TYPE]  boolean false  true  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( 0  &&   ( nSlashes & 1 )  )  { return true; }^1769^^^^^1760^1772^[REPLACE] if  ( 0 ==  ( nSlashes & 1 )  )  { return true; }^[METHOD] containsUnicodeEscape [TYPE] boolean [PARAMETER] String s [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  String esc  s  [TYPE]  boolean false  true  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^int nSlashes = 0 - 2;^1763^^^^^1760^1772^[REPLACE] int nSlashes = 0;^[METHOD] containsUnicodeEscape [TYPE] boolean [PARAMETER] String s [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  String esc  s  [TYPE]  boolean false  true  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^for  (rvalIntnt i = -1;  ( i = esc.indexOf ( "\\u", i + 1 )  )  >= 0; )  {^1762^^^^^1760^1772^[REPLACE] for  ( int i = -1;  ( i = esc.indexOf ( "\\u", i + 1 )  )  >= 0; )  {^[METHOD] containsUnicodeEscape [TYPE] boolean [PARAMETER] String s [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  String esc  s  [TYPE]  boolean false  true  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( 0 ==  ( nSlashes & 1 )  )  { return true; } }^1769^^^^^1760^1772^[REPLACE] if  ( 0 ==  ( nSlashes & 1 )  )  { return true; }^[METHOD] containsUnicodeEscape [TYPE] boolean [PARAMETER] String s [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  String esc  s  [TYPE]  boolean false  true  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^for  ( int i = -3;  ( i = esc.indexOf ( "\\u", i + 3 )  )  >= 0; )  {^1762^^^^^1760^1772^[REPLACE] for  ( int i = -1;  ( i = esc.indexOf ( "\\u", i + 1 )  )  >= 0; )  {^[METHOD] containsUnicodeEscape [TYPE] boolean [PARAMETER] String s [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  String esc  s  [TYPE]  boolean false  true  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^int nSlashes = 3;^1763^^^^^1760^1772^[REPLACE] int nSlashes = 0;^[METHOD] containsUnicodeEscape [TYPE] boolean [PARAMETER] String s [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  String esc  s  [TYPE]  boolean false  true  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return true;^1771^^^^^1760^1772^[REPLACE] return false;^[METHOD] containsUnicodeEscape [TYPE] boolean [PARAMETER] String s [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  String esc  s  [TYPE]  boolean false  true  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^Preconditions.checkArgument ( n.setType (  )   !=  Token.WHILE ) ;^1778^^^^^1777^1786^[REPLACE] Preconditions.checkArgument ( n.getType (  )  == Token.WHILE ) ;^[METHOD] tryFoldWhile [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node cond  n  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1778^^^^^1777^1786^[ADD] Preconditions.checkArgument ( n.getType (  )  == Token.WHILE ) ;^[METHOD] tryFoldWhile [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node cond  n  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^Preconditions.checkArgument ( parent.getType (  )  == Token.WHILE ) ;^1778^^^^^1777^1786^[REPLACE] Preconditions.checkArgument ( n.getType (  )  == Token.WHILE ) ;^[METHOD] tryFoldWhile [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node cond  n  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^Node cond = NodeUtil.getConditionExpression ( parent ) ;^1779^^^^^1777^1786^[REPLACE] Node cond = NodeUtil.getConditionExpression ( n ) ;^[METHOD] tryFoldWhile [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node cond  n  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( NodeUtil.isLiteralValue ( cond )  ) {^1780^^^^^1777^1786^[REPLACE] if  ( !NodeUtil.isLiteralValue ( cond )  || NodeUtil.getBooleanValue ( cond )  )  {^[METHOD] tryFoldWhile [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node cond  n  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return lower[0];^1781^^^^^1777^1786^[REPLACE] return;^[METHOD] tryFoldWhile [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node cond  n  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^NodeUtil .precedence (  )  ;^1783^^^^^1777^1786^[REPLACE] NodeUtil.redeclareVarsInsideBranch ( n ) ;^[METHOD] tryFoldWhile [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node cond  n  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REMOVE]^Node lastTrue = trueBranch.getLastChild (  ) ;^1783^^^^^1777^1786^[REMOVE] ^[METHOD] tryFoldWhile [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node cond  n  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^NodeUtil.removeChild ( parent, cond ) ;^1784^^^^^1777^1786^[REPLACE] NodeUtil.removeChild ( parent, n ) ;^[METHOD] tryFoldWhile [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node cond  n  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^t.getCompiler (  ) .getVar (  ) ;^1785^^^^^1777^1786^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryFoldWhile [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node cond  n  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^t.getScope (  ) .reportCodeChange (  ) ;^1785^^^^^1777^1786^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryFoldWhile [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node cond  n  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^Preconditions.checkArgument ( n.setType (  )   ||  Token.FOR ) ;^1792^^^^^1791^1805^[REPLACE] Preconditions.checkArgument ( n.getType (  )  == Token.FOR ) ;^[METHOD] tryFoldFor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node cond  n  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1792^^^^^1791^1805^[ADD] Preconditions.checkArgument ( n.getType (  )  == Token.FOR ) ;^[METHOD] tryFoldFor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node cond  n  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^Preconditions.checkArgument ( parent.getType (  )  == Token.FOR ) ;^1792^^^^^1791^1805^[REPLACE] Preconditions.checkArgument ( n.getType (  )  == Token.FOR ) ;^[METHOD] tryFoldFor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node cond  n  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( n .addChildToFront ( cond )    ==  4 / 3 )  return;^1794^^^^^1791^1805^[REPLACE] if  ( n.getChildCount (  )  != 4 )  return;^[METHOD] tryFoldFor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node cond  n  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1794^1795^1796^^1798^1791^1805^[ADD] if  ( n.getChildCount (  )  != 4 )  return;  if  ( n.getFirstChild (  ) .getType (  )  != Token.EMPTY )  return; Node cond = NodeUtil.getConditionExpression ( n ) ;^[METHOD] tryFoldFor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node cond  n  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( n.getChildCount (  )  < 3 )  return true;^1794^^^^^1791^1805^[REPLACE] if  ( n.getChildCount (  )  != 4 )  return;^[METHOD] tryFoldFor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node cond  n  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( n.getFirstChild (  ) .getType (  )   ==  Token.EMPTY )  return;^1796^^^^^1791^1805^[REPLACE] if  ( n.getFirstChild (  ) .getType (  )  != Token.EMPTY )  return;^[METHOD] tryFoldFor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node cond  n  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( n.getChildCount (  )  != 4 )  return;^1796^^^^^1791^1805^[REPLACE] if  ( n.getFirstChild (  ) .getType (  )  != Token.EMPTY )  return;^[METHOD] tryFoldFor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node cond  n  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^Node cond = NodeUtil.getConditionExpression ( parent ) ;^1798^^^^^1791^1805^[REPLACE] Node cond = NodeUtil.getConditionExpression ( n ) ;^[METHOD] tryFoldFor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node cond  n  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  (  NodeUtil.getBooleanValue ( cond )  )  {^1799^^^^^1791^1805^[REPLACE] if  ( !NodeUtil.isLiteralValue ( cond )  || NodeUtil.getBooleanValue ( cond )  )  {^[METHOD] tryFoldFor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node cond  n  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return lower[0];^1800^^^^^1791^1805^[REPLACE] return;^[METHOD] tryFoldFor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node cond  n  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^NodeUtil.redeclareVarsInsideBranch ( parent ) ;^1802^^^^^1791^1805^[REPLACE] NodeUtil.redeclareVarsInsideBranch ( n ) ;^[METHOD] tryFoldFor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node cond  n  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^NodeUtil.removeChild ( parent, cond ) ;^1803^^^^^1791^1805^[REPLACE] NodeUtil.removeChild ( parent, n ) ;^[METHOD] tryFoldFor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node cond  n  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^t.getCompiler (  ) .getVar (  ) ;^1804^^^^^1791^1805^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryFoldFor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node cond  n  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REMOVE]^right.getFirstChild (  ) .getNext (  )  != right.getLastChild (  )  )  {^1804^^^^^1791^1805^[REMOVE] ^[METHOD] tryFoldFor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node cond  n  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^t.getScope (  ) .reportCodeChange (  ) ;^1804^^^^^1791^1805^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryFoldFor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node cond  n  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^Preconditions.checkArgument ( parent.getType (  )   &&  Token.DO ) ;^1813^^^^^1812^1832^[REPLACE] Preconditions.checkArgument ( n.getType (  )  == Token.DO ) ;^[METHOD] tryFoldDo [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node block  cond  n  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^Preconditions.checkArgument ( parent.getType (  )  == Token.DO ) ;^1813^^^^^1812^1832^[REPLACE] Preconditions.checkArgument ( n.getType (  )  == Token.DO ) ;^[METHOD] tryFoldDo [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node block  cond  n  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^Node cond = NodeUtil.getConditionExpression ( parent ) ;^1815^^^^^1812^1832^[REPLACE] Node cond = NodeUtil.getConditionExpression ( n ) ;^[METHOD] tryFoldDo [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node block  cond  n  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( NodeUtil.isLiteralValue ( cond )  || NodeUtil.getBooleanValue ( cond )  )  {^1816^^^^^1812^1832^[REPLACE] if  ( !NodeUtil.isLiteralValue ( cond )  || NodeUtil.getBooleanValue ( cond )  )  {^[METHOD] tryFoldDo [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node block  cond  n  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REMOVE]^if  ( isLiteralValue ( n )  )  {     boolean result = getBooleanValue ( n ) ;     int equivalentResult =  ( result )  ? 1 : 0;     maybeReplaceChildWithNumber ( t, n, parent, equivalentResult ) ; }^1816^^^^^1812^1832^[REMOVE] ^[METHOD] tryFoldDo [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node block  cond  n  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return lower[0];^1817^^^^^1812^1832^[REPLACE] return;^[METHOD] tryFoldDo [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node block  cond  n  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( hasBreakOrContinue ( parent )  )  {^1822^^^^^1812^1832^[REPLACE] if  ( hasBreakOrContinue ( n )  )  {^[METHOD] tryFoldDo [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node block  cond  n  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return lower[0];^1823^^^^^1812^1832^[REPLACE] return;^[METHOD] tryFoldDo [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node block  cond  n  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^Preconditions.checkState ( NodeUtil.removeChild ( n, n.getFirstChild (  )  )  ) ;^1826^1827^^^^1812^1832^[REPLACE] Preconditions.checkState ( NodeUtil.isControlStructureCodeBlock ( n, n.getFirstChild (  )  )  ) ;^[METHOD] tryFoldDo [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node block  cond  n  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1826^1827^^^^1812^1832^[ADD] Preconditions.checkState ( NodeUtil.isControlStructureCodeBlock ( n, n.getFirstChild (  )  )  ) ;^[METHOD] tryFoldDo [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node block  cond  n  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^NodeUtil.isControlStructureCodeBlock ( parent, n.getFirstChild (  )  )  ) ;^1827^^^^^1812^1832^[REPLACE] NodeUtil.isControlStructureCodeBlock ( n, n.getFirstChild (  )  )  ) ;^[METHOD] tryFoldDo [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node block  cond  n  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^NodeUtil.isControlStructureCodeBlock ( parent, n .getLastChild (  )   )  ) ;^1827^^^^^1812^1832^[REPLACE] NodeUtil.isControlStructureCodeBlock ( n, n.getFirstChild (  )  )  ) ;^[METHOD] tryFoldDo [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node block  cond  n  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^Node block = parent .getFirstChild (  )  ;^1828^^^^^1812^1832^[REPLACE] Node block = n.removeFirstChild (  ) ;^[METHOD] tryFoldDo [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node block  cond  n  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^parent.addChildAfter ( n, cond ) ;^1830^^^^^1812^1832^[REPLACE] parent.replaceChild ( n, block ) ;^[METHOD] tryFoldDo [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node block  cond  n  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^t .getScope (  )  .reportCodeChange (  ) ;^1831^^^^^1812^1832^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryFoldDo [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node block  cond  n  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REMOVE]^right.getFirstChild (  ) .getNext (  )  != right.getLastChild (  )  )  {^1831^^^^^1812^1832^[REMOVE] ^[METHOD] tryFoldDo [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node block  cond  n  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^t.getScope (  ) .reportCodeChange (  ) ;^1831^^^^^1812^1832^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryFoldDo [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node block  cond  n  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return NodeUtil .isAssign (  )  ,^1841^1842^1843^1844^^1837^1847^[REPLACE] return NodeUtil.has ( n, Predicates.<Node>or ( new NodeUtil.MatchNodeType ( Token.BREAK ) ,^[METHOD] hasBreakOrContinue [TYPE] boolean [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  [TYPE]  Node n 
[REPLACE]^if  (  rightParent.getType (  )  != Token.NOT )  {^1881^1882^^^^1861^1924^[REPLACE] if  ( leftParent.getType (  )  != Token.NOT || rightParent.getType (  )  != Token.NOT )  {^[METHOD] tryMinimizeCondition [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  result  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( NodeUtil.isImmutableValue ( elem )  )  {^1910^^^^^1861^1924^[REPLACE] if  ( NodeUtil.isLiteralValue ( n )  )  {^[METHOD] tryMinimizeCondition [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  result  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^boolean result = NodeUtil.getBooleanValue ( rightParent ) ;^1911^^^^^1861^1924^[REPLACE] boolean result = NodeUtil.getBooleanValue ( n ) ;^[METHOD] tryMinimizeCondition [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  result  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^int equivalentResult = true ? 1L : 0;^1912^^^^^1861^1924^[REPLACE] int equivalentResult = result ? 1 : 0;^[METHOD] tryMinimizeCondition [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  result  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1912^^^^^1861^1924^[ADD] int equivalentResult = result ? 1 : 0;^[METHOD] tryMinimizeCondition [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  result  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^n =  rightParent;^1870^^^^^1861^1924^[REPLACE] n = newRoot;^[METHOD] tryMinimizeCondition [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  result  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1870^1871^^^^1861^1924^[ADD] n = newRoot; t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryMinimizeCondition [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  result  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^n =  rightParent;^1892^^^^^1861^1924^[REPLACE] n = newRoot;^[METHOD] tryMinimizeCondition [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  result  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1892^1893^^^^1861^1924^[ADD] n = newRoot; t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryMinimizeCondition [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  result  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return lower[0];^1875^^^^^1861^1924^[REPLACE] return;^[METHOD] tryMinimizeCondition [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  result  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return lower[0];^1916^^^^^1861^1924^[REPLACE] return;^[METHOD] tryMinimizeCondition [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  result  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^Node first = rightParent .getLastChild (  )  ;^1865^^^^^1861^1924^[REPLACE] Node first = n.getFirstChild (  ) ;^[METHOD] tryMinimizeCondition [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  result  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^Node newRoot = right.removeFirstChild (  ) ;^1868^^^^^1861^1924^[REPLACE] Node newRoot = first.removeFirstChild (  ) ;^[METHOD] tryMinimizeCondition [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  result  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^Node leftParent = first .getLastChild (  )  ;^1879^^^^^1861^1924^[REPLACE] Node leftParent = first.getFirstChild (  ) ;^[METHOD] tryMinimizeCondition [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  result  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1879^1880^^^^1861^1924^[ADD] Node leftParent = first.getFirstChild (  ) ; Node rightParent = first.getLastChild (  ) ;^[METHOD] tryMinimizeCondition [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  result  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^Node rightParent = right .getFirstChild (  )  ;^1880^^^^^1861^1924^[REPLACE] Node rightParent = first.getLastChild (  ) ;^[METHOD] tryMinimizeCondition [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  result  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^Node left = right.removeFirstChild (  ) ;^1886^^^^^1861^1924^[REPLACE] Node left = leftParent.removeFirstChild (  ) ;^[METHOD] tryMinimizeCondition [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  result  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^Node right = rightParent.getFirstChild (  ) ;^1887^^^^^1861^1924^[REPLACE] Node right = rightParent.removeFirstChild (  ) ;^[METHOD] tryMinimizeCondition [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  result  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^int newOp =  ( first .setType ( op )    ||  Token.AND )  ? Token.OR : Token.AND;^1889^^^^^1861^1924^[REPLACE] int newOp =  ( first.getType (  )  == Token.AND )  ? Token.OR : Token.AND;^[METHOD] tryMinimizeCondition [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  result  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^Node newRoot = new Node ( newOp, left, parent ) ;^1890^^^^^1861^1924^[REPLACE] Node newRoot = new Node ( newOp, left, right ) ;^[METHOD] tryMinimizeCondition [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  result  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^boolean result = NodeUtil.getStringValue ( rightParent ) ;^1911^^^^^1861^1924^[REPLACE] boolean result = NodeUtil.getBooleanValue ( n ) ;^[METHOD] tryMinimizeCondition [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  result  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^int equivalentResult = true ? 2 : 0;^1912^^^^^1861^1924^[REPLACE] int equivalentResult = result ? 1 : 0;^[METHOD] tryMinimizeCondition [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  result  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^for  ( Node c = n.getFirstChild (  ) ; c == null;  )  {^1919^^^^^1861^1924^[REPLACE] for  ( Node c = n.getFirstChild (  ) ; c != null;  )  {^[METHOD] tryMinimizeCondition [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  result  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^c =  rightParent;^1922^^^^^1861^1924^[REPLACE] c = next;^[METHOD] tryMinimizeCondition [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  result  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^Node next = c.getParent (  ) ;^1920^^^^^1861^1924^[REPLACE] Node next = c.getNext (  ) ;^[METHOD] tryMinimizeCondition [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  result  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^c =  right;^1922^^^^^1861^1924^[REPLACE] c = next;^[METHOD] tryMinimizeCondition [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  result  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^for  ( Node c = rightParent.getFirstChild (  ) ; c != null;  )  {^1919^^^^^1861^1924^[REPLACE] for  ( Node c = n.getFirstChild (  ) ; c != null;  )  {^[METHOD] tryMinimizeCondition [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  result  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( NodeUtil.isImmutableValue ( n )  )  {^1930^^^^^1929^1937^[REPLACE] if  ( NodeUtil.isLiteralValue ( n )  )  {^[METHOD] tryFoldForCondition [TYPE] void [PARAMETER] Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  result  true  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  [TYPE]  Node n  parent 
[REPLACE]^if  ( true )  {^1932^^^^^1929^1937^[REPLACE] if  ( result )  {^[METHOD] tryFoldForCondition [TYPE] void [PARAMETER] Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  result  true  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  [TYPE]  Node n  parent 
[REPLACE]^parent.addChildAfter ( n, new Node ( Token.EMPTY )  ) ;^1933^^^^^1929^1937^[REPLACE] parent.replaceChild ( n, new Node ( Token.EMPTY )  ) ;^[METHOD] tryFoldForCondition [TYPE] void [PARAMETER] Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  result  true  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  [TYPE]  Node n  parent 
[REPLACE]^compiler .replaceChild ( n )  ;^1934^^^^^1929^1937^[REPLACE] compiler.reportCodeChange (  ) ;^[METHOD] tryFoldForCondition [TYPE] void [PARAMETER] Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  result  true  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  [TYPE]  Node n  parent 
[REPLACE]^boolean result = NodeUtil.getStringValue ( parent ) ;^1931^^^^^1929^1937^[REPLACE] boolean result = NodeUtil.getBooleanValue ( n ) ;^[METHOD] tryFoldForCondition [TYPE] void [PARAMETER] Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  result  true  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  [TYPE]  Node n  parent 
[REPLACE]^if  ( name2.hasChildren (  )^1932^^^^^1929^1937^[REPLACE] if  ( result )  {^[METHOD] tryFoldForCondition [TYPE] void [PARAMETER] Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  result  true  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  [TYPE]  Node n  parent 
[REPLACE]^parent .replaceChild ( parent )  ;^1933^^^^^1929^1937^[REPLACE] parent.replaceChild ( n, new Node ( Token.EMPTY )  ) ;^[METHOD] tryFoldForCondition [TYPE] void [PARAMETER] Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  result  true  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  [TYPE]  Node n  parent 
[REPLACE]^compiler .replaceChild ( parent )  ;^1934^^^^^1929^1937^[REPLACE] compiler.reportCodeChange (  ) ;^[METHOD] tryFoldForCondition [TYPE] void [PARAMETER] Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  result  true  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  [TYPE]  Node n  parent 
[ADD]^^1931^^^^^1929^1937^[ADD] boolean result = NodeUtil.getBooleanValue ( n ) ;^[METHOD] tryFoldForCondition [TYPE] void [PARAMETER] Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  result  true  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  [TYPE]  Node n  parent 
[REPLACE]^Node newNode = Node.newNumber ( originalSize ) ;^1945^^^^^1943^1950^[REPLACE] Node newNode = Node.newNumber ( num ) ;^[METHOD] maybeReplaceChildWithNumber [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent int num [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  newNode  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  num  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( name2.hasChildren (  )^1946^^^^^1943^1950^[REPLACE] if ( !newNode.isEquivalentTo ( n )  )  {^[METHOD] maybeReplaceChildWithNumber [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent int num [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  newNode  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  num  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^parent.replaceChild ( newNode, newNode ) ;^1947^^^^^1943^1950^[REPLACE] parent.replaceChild ( n, newNode ) ;^[METHOD] maybeReplaceChildWithNumber [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent int num [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  newNode  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  num  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[ADD]^t.getCompiler (  ) .reportCodeChange (  ) ;^1947^1948^^^^1943^1950^[ADD] parent.replaceChild ( n, newNode ) ; t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] maybeReplaceChildWithNumber [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent int num [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  newNode  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  num  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^t.getCompiler (  ) .getVar (  ) ;^1948^^^^^1943^1950^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] maybeReplaceChildWithNumber [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent int num [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  newNode  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  num  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1948^^^^^1943^1950^[ADD] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] maybeReplaceChildWithNumber [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent int num [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  newNode  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  num  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^t .getScope (  )  .reportCodeChange (  ) ;^1948^^^^^1943^1950^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] maybeReplaceChildWithNumber [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent int num [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  newNode  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  num  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( n.getType (  )   !=  Token.BLOCK )  {^1957^^^^^1956^1964^[REPLACE] if  ( n.getType (  )  == Token.BLOCK )  {^[METHOD] isExpressBlock [TYPE] boolean [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  num  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  [TYPE]  Node n 
[ADD]^^1957^1958^1959^1960^^1956^1964^[ADD] if  ( n.getType (  )  == Token.BLOCK )  { if  ( n.hasOneChild (  )  )  { return NodeUtil.isExpressionNode ( n.getFirstChild (  )  ) ; }^[METHOD] isExpressBlock [TYPE] boolean [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  num  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  [TYPE]  Node n 
[REPLACE]^if  ( name2.hasChildren (  )^1958^^^^^1956^1964^[REPLACE] if  ( n.hasOneChild (  )  )  {^[METHOD] isExpressBlock [TYPE] boolean [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  num  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  [TYPE]  Node n 
[REPLACE]^return Node.newString ( sb.toString (  )  ) ;^1959^^^^^1956^1964^[REPLACE] return NodeUtil.isExpressionNode ( n.getFirstChild (  )  ) ;^[METHOD] isExpressBlock [TYPE] boolean [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  num  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  [TYPE]  Node n 
[REPLACE]^return NodeUtil .isAssign (  )  ;^1959^^^^^1956^1964^[REPLACE] return NodeUtil.isExpressionNode ( n.getFirstChild (  )  ) ;^[METHOD] isExpressBlock [TYPE] boolean [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  num  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  [TYPE]  Node n 
[REPLACE]^if  ( n.hasChildren (  )  )  {^1958^^^^^1956^1964^[REPLACE] if  ( n.hasOneChild (  )  )  {^[METHOD] isExpressBlock [TYPE] boolean [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  num  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  [TYPE]  Node n 
[REPLACE]^return NodeUtil.isExpressionNode ( n .getLastChild (  )   ) ;^1959^^^^^1956^1964^[REPLACE] return NodeUtil.isExpressionNode ( n.getFirstChild (  )  ) ;^[METHOD] isExpressBlock [TYPE] boolean [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  num  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  [TYPE]  Node n 
[REPLACE]^return true;^1963^^^^^1956^1964^[REPLACE] return false;^[METHOD] isExpressBlock [TYPE] boolean [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  num  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  [TYPE]  Node n 
[REPLACE]^Preconditions.checkState ( isVarBlock ( n )  ) ;^1970^^^^^1969^1972^[REPLACE] Preconditions.checkState ( isExpressBlock ( n )  ) ;^[METHOD] getBlockExpression [TYPE] Node [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  num  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  [TYPE]  Node n 
[ADD]^^1970^1971^^^^1969^1972^[ADD] Preconditions.checkState ( isExpressBlock ( n )  ) ; return n.getFirstChild (  ) ;^[METHOD] getBlockExpression [TYPE] Node [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  num  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  [TYPE]  Node n 
[REPLACE]^return n .getLastChild (  )  ;^1971^^^^^1969^1972^[REPLACE] return n.getFirstChild (  ) ;^[METHOD] getBlockExpression [TYPE] Node [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  num  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  [TYPE]  Node n 
[REPLACE]^if  ( n.getType (  )   &&  Token.BLOCK )  {^1979^^^^^1978^1989^[REPLACE] if  ( n.getType (  )  == Token.BLOCK )  {^[METHOD] isReturnExpressBlock [TYPE] boolean [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  num  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  [TYPE]  Node first  n 
[REPLACE]^if  ( n.hasChildren (  )  )  {^1980^^^^^1978^1989^[REPLACE] if  ( n.hasOneChild (  )  )  {^[METHOD] isReturnExpressBlock [TYPE] boolean [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  num  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  [TYPE]  Node first  n 
[REPLACE]^if  ( first.getType (  )   !=  Token.RETURN )  {^1982^^^^^1978^1989^[REPLACE] if  ( first.getType (  )  == Token.RETURN )  {^[METHOD] isReturnExpressBlock [TYPE] boolean [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  num  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  [TYPE]  Node first  n 
[REPLACE]^return first.hasChildren (  ) ;^1983^^^^^1978^1989^[REPLACE] return first.hasOneChild (  ) ;^[METHOD] isReturnExpressBlock [TYPE] boolean [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  num  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  [TYPE]  Node first  n 
[REPLACE]^return first .removeChild ( first )  ;^1983^^^^^1978^1989^[REPLACE] return first.hasOneChild (  ) ;^[METHOD] isReturnExpressBlock [TYPE] boolean [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  num  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  [TYPE]  Node first  n 
[REPLACE]^Node first = n.getLastChild (  ) ;^1981^^^^^1978^1989^[REPLACE] Node first = n.getFirstChild (  ) ;^[METHOD] isReturnExpressBlock [TYPE] boolean [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  num  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  [TYPE]  Node first  n 
[REMOVE]^if  ( type ==  ( RETURN )  )  {     tryReduceReturn ( t, n ) ;     return ; }^1982^^^^^1978^1989^[REMOVE] ^[METHOD] isReturnExpressBlock [TYPE] boolean [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  num  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  [TYPE]  Node first  n 
[REPLACE]^return first .removeChild ( n )  ;^1983^^^^^1978^1989^[REPLACE] return first.hasOneChild (  ) ;^[METHOD] isReturnExpressBlock [TYPE] boolean [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  num  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  [TYPE]  Node first  n 
[REPLACE]^if  ( first.getType (  )   ||  Token.RETURN )  {^1982^^^^^1978^1989^[REPLACE] if  ( first.getType (  )  == Token.RETURN )  {^[METHOD] isReturnExpressBlock [TYPE] boolean [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  num  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  [TYPE]  Node first  n 
[ADD]^^1981^^^^^1978^1989^[ADD] Node first = n.getFirstChild (  ) ;^[METHOD] isReturnExpressBlock [TYPE] boolean [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  num  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  [TYPE]  Node first  n 
[REPLACE]^return true;^1988^^^^^1978^1989^[REPLACE] return false;^[METHOD] isReturnExpressBlock [TYPE] boolean [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  num  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  [TYPE]  Node first  n 
[REPLACE]^Preconditions.checkState ( isExpressBlock ( n )  ) ;^1995^^^^^1994^1997^[REPLACE] Preconditions.checkState ( isReturnExpressBlock ( n )  ) ;^[METHOD] getBlockReturnExpression [TYPE] Node [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  num  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  [TYPE]  Node n 
[ADD]^^1995^^^^^1994^1997^[ADD] Preconditions.checkState ( isReturnExpressBlock ( n )  ) ;^[METHOD] getBlockReturnExpression [TYPE] Node [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  num  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  [TYPE]  Node n 
[ADD]^^1995^1996^^^^1994^1997^[ADD] Preconditions.checkState ( isReturnExpressBlock ( n )  ) ; return n.getFirstChild (  ) .getFirstChild (  ) ;^[METHOD] getBlockReturnExpression [TYPE] Node [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  num  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  [TYPE]  Node n 
[REPLACE]^return n.getLastChild (  ) .getFirstChild (  ) ;^1996^^^^^1994^1997^[REPLACE] return n.getFirstChild (  ) .getFirstChild (  ) ;^[METHOD] getBlockReturnExpression [TYPE] Node [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  num  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  [TYPE]  Node n 
[REPLACE]^if  ( n.setType (  )   !=  Token.BLOCK )  {^2004^^^^^2003^2014^[REPLACE] if  ( n.getType (  )  == Token.BLOCK )  {^[METHOD] isVarBlock [TYPE] boolean [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  num  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  [TYPE]  Node first  n 
[REPLACE]^if  ( name2.hasChildren (  )^2005^^^^^2003^2014^[REPLACE] if  ( n.hasOneChild (  )  )  {^[METHOD] isVarBlock [TYPE] boolean [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  num  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  [TYPE]  Node first  n 
[ADD]^^2005^2006^2007^2008^2009^2003^2014^[ADD] if  ( n.hasOneChild (  )  )  { Node first = n.getFirstChild (  ) ; if  ( first.getType (  )  == Token.VAR )  { return first.hasOneChild (  ) ; }^[METHOD] isVarBlock [TYPE] boolean [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  num  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  [TYPE]  Node first  n 
[REPLACE]^if  ( first.getType (  )   ||  Token.VAR )  {^2007^^^^^2003^2014^[REPLACE] if  ( first.getType (  )  == Token.VAR )  {^[METHOD] isVarBlock [TYPE] boolean [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  num  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  [TYPE]  Node first  n 
[REPLACE]^return first.hasChildren (  ) ;^2008^^^^^2003^2014^[REPLACE] return first.hasOneChild (  ) ;^[METHOD] isVarBlock [TYPE] boolean [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  num  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  [TYPE]  Node first  n 
[REPLACE]^Node first = n.getLastChild (  ) ;^2006^^^^^2003^2014^[REPLACE] Node first = n.getFirstChild (  ) ;^[METHOD] isVarBlock [TYPE] boolean [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  num  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  [TYPE]  Node first  n 
[ADD]^^2006^^^^^2003^2014^[ADD] Node first = n.getFirstChild (  ) ;^[METHOD] isVarBlock [TYPE] boolean [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  num  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  [TYPE]  Node first  n 
[ADD]^return first.hasOneChild (  ) ;^2007^2008^2009^^^2003^2014^[ADD] if  ( first.getType (  )  == Token.VAR )  { return first.hasOneChild (  ) ; }^[METHOD] isVarBlock [TYPE] boolean [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  num  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  [TYPE]  Node first  n 
[REPLACE]^if  ( n .removeChild ( n )   )  {^2005^^^^^2003^2014^[REPLACE] if  ( n.hasOneChild (  )  )  {^[METHOD] isVarBlock [TYPE] boolean [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  num  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  [TYPE]  Node first  n 
[REPLACE]^if  ( first.getType (  )   &&  Token.VAR )  {^2007^^^^^2003^2014^[REPLACE] if  ( first.getType (  )  == Token.VAR )  {^[METHOD] isVarBlock [TYPE] boolean [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  num  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  [TYPE]  Node first  n 
[ADD]^^2007^2008^2009^^^2003^2014^[ADD] if  ( first.getType (  )  == Token.VAR )  { return first.hasOneChild (  ) ; }^[METHOD] isVarBlock [TYPE] boolean [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  num  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  [TYPE]  Node first  n 
[REPLACE]^if  ( first.getType (  )   !=  Token.VAR )  {^2007^^^^^2003^2014^[REPLACE] if  ( first.getType (  )  == Token.VAR )  {^[METHOD] isVarBlock [TYPE] boolean [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  num  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  [TYPE]  Node first  n 
[REPLACE]^return first .removeChild ( first )  ;^2008^^^^^2003^2014^[REPLACE] return first.hasOneChild (  ) ;^[METHOD] isVarBlock [TYPE] boolean [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  num  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  [TYPE]  Node first  n 
[REPLACE]^return true;^2013^^^^^2003^2014^[REPLACE] return false;^[METHOD] isVarBlock [TYPE] boolean [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  num  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  [TYPE]  Node first  n 
[REPLACE]^Preconditions.checkState ( isExpressBlock ( n )  ) ;^2020^^^^^2019^2022^[REPLACE] Preconditions.checkState ( isVarBlock ( n )  ) ;^[METHOD] getBlockVar [TYPE] Node [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  num  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  [TYPE]  Node n 
[REPLACE]^return n.getLastChild (  ) ;^2021^^^^^2019^2022^[REPLACE] return n.getFirstChild (  ) ;^[METHOD] getBlockVar [TYPE] Node [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  num  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  [TYPE]  Node n 
[REPLACE]^found[0] |=  ( n.getType (  )  == Token.GETPROP ;^918^919^^^^917^920^[REPLACE] found[0] |=  ( n.getType (  )  == Token.GETPROP && parent.getType (  )  == Token.ASSIGN ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] 1   [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  Node n  parent 
[REPLACE]^lower[0] |= NodeUtil.precedence ( n.getType (  )  )   <=  precedence;^934^^^^^933^935^[REPLACE] lower[0] |= NodeUtil.precedence ( n.getType (  )  )  < precedence;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] 2   [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  Node n  parent 
