[REPLACE]^static final DiagnosticType DIVIDE_BY_0_ERROR  = null ;^40^41^42^^^40^42^[REPLACE] static final DiagnosticType DIVIDE_BY_0_ERROR = DiagnosticType.error ( "JSC_DIVIDE_BY_0_ERROR", "Divide by 0" ) ;^ [CLASS] FoldConstants 1 2  
[REPLACE]^static final DiagnosticType INVALID_GETELEM_INDEX_ERROR ;^44^45^46^47^^44^47^[REPLACE] static final DiagnosticType INVALID_GETELEM_INDEX_ERROR = DiagnosticType.error ( "JSC_INVALID_GETELEM_INDEX_ERROR", "Array index not integer: {0}" ) ;^ [CLASS] FoldConstants 1 2  
[REPLACE]^static final DiagnosticType INDEX_OUT_OF_BOUNDS_ERROR  = null ;^49^50^51^52^^49^52^[REPLACE] static final DiagnosticType INDEX_OUT_OF_BOUNDS_ERROR = DiagnosticType.error ( "JSC_INDEX_OUT_OF_BOUNDS_ERROR", "Array index out of bounds: {0}" ) ;^ [CLASS] FoldConstants 1 2  
[REPLACE]^static  DiagnosticType NEGATING_A_NON_NUMBER_ERROR = DiagnosticType.error ( "JSC_NEGATING_A_NON_NUMBER_ERROR", "Can't negate non-numeric value: {0}" ) ;^54^55^56^57^^54^57^[REPLACE] static final DiagnosticType NEGATING_A_NON_NUMBER_ERROR = DiagnosticType.error ( "JSC_NEGATING_A_NON_NUMBER_ERROR", "Can't negate non-numeric value: {0}" ) ;^ [CLASS] FoldConstants 1 2  
[REPLACE]^static final DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS ;^59^60^61^62^^59^62^[REPLACE] static final DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS = DiagnosticType.error ( "JSC_INVALID_REGULAR_EXPRESSION_FLAGS", "Invalid flags to RegExp constructor: {0}" ) ;^ [CLASS] FoldConstants 1 2  
[REPLACE]^static  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE = DiagnosticType.error ( "JSC_BITWISE_OPERAND_OUT_OF_RANGE", "Operand out of range, bitwise operation will lose information: {0}" ) ;^64^65^66^67^^64^67^[REPLACE] static final DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE = DiagnosticType.error ( "JSC_BITWISE_OPERAND_OUT_OF_RANGE", "Operand out of range, bitwise operation will lose information: {0}" ) ;^ [CLASS] FoldConstants 1 2  
[REPLACE]^static final DiagnosticType SHIFT_AMOUNT_OUT_OF_BOUNDS ;^69^70^71^^^69^71^[REPLACE] static final DiagnosticType SHIFT_AMOUNT_OUT_OF_BOUNDS = DiagnosticType.error ( "JSC_SHIFT_AMOUNT_OUT_OF_BOUNDS", "Shift amount out of bounds: {0}" ) ;^ [CLASS] FoldConstants 1 2  
[REPLACE]^static final DiagnosticType FRACTIONAL_BITWISE_OPERAND ;^73^74^75^^^73^75^[REPLACE] static final DiagnosticType FRACTIONAL_BITWISE_OPERAND = DiagnosticType.error ( "JSC_FRACTIONAL_BITWISE_OPERAND", "Fractional bitwise operand: {0}" ) ;^ [CLASS] FoldConstants 1 2  
[REPLACE]^private static final int AND_PRECEDENCE ;^77^^^^^^^[REPLACE] private static final int AND_PRECEDENCE = NodeUtil.precedence ( Token.AND ) ;^ [CLASS] FoldConstants 1 2  
[REPLACE]^private static final int OR_PRECEDENCE  = null ;^78^^^^^^^[REPLACE] private static final int OR_PRECEDENCE = NodeUtil.precedence ( Token.OR ) ;^ [CLASS] FoldConstants 1 2  
[REPLACE]^private  AbstractCompiler compiler;^80^^^^^^^[REPLACE] private final AbstractCompiler compiler;^ [CLASS] FoldConstants 1 2  
[REPLACE]^private  final Pattern REGEXP_FLAGS_RE = Pattern.compile ( "^[gmi]*$" ) ;^1681^^^^^^^[REPLACE] private static final Pattern REGEXP_FLAGS_RE = Pattern.compile ( "^[gmi]*$" ) ;^ [CLASS] FoldConstants 1 2  
[ADD]^^91^^^^^90^382^[ADD] int type = n.getType (  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  (intVal  !=  Token.BLOCK )  {^93^^^^^90^382^[REPLACE] if  ( type == Token.BLOCK )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^tryFoldBlock ( t, n, parent ) ;return;^93^94^95^96^^90^382^[ADD] if  ( type == Token.BLOCK )  { tryFoldBlock ( t, n, parent ) ; return; }^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^return;  ;^95^^^^^90^382^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^Node arrayNode = left.getFirstChild (  )  ;^98^^^^^90^382^[REPLACE] Node left = n.getFirstChild (  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if   (  result != null  )   {  ;^99^^^^^90^382^[REPLACE] if  ( left == null )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^return;  ;^100^^^^^90^382^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( type == Token.TYPEOF || NodeUtil.isLiteralValue ( left )  )  {^103^^^^^90^382^[REPLACE] if  ( type == Token.TYPEOF && NodeUtil.isLiteralValue ( left )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( "undefined".equals ( right.toString (  )  )  )  {^125^^^^^90^382^[REPLACE] if  ( "undefined".equals ( left.getString (  )  )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^newValue  =  newValue ;^126^^^^^90^382^[REPLACE] newValue = "undefined";^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  (className == null )  {^131^^^^^90^382^[REPLACE] if  ( newValue != null )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^^131^132^133^134^^90^382^[ADD] if  ( newValue != null )  { parent.replaceChild ( n, Node.newString ( newValue )  ) ; t.getCompiler (  ) .reportCodeChange (  ) ; }^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^parent.replaceChild ( n, newExpr ( cond )  )  ;^132^^^^^90^382^[REPLACE] parent.replaceChild ( n, Node.newString ( newValue )  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REMOVE]^newString ( result )  ;^132^^^^^90^382^[REMOVE] ^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^newString ( result )  ;^132^^^^^90^382^[REPLACE] parent.replaceChild ( n, Node.newString ( newValue )  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^^132^133^^^^90^382^[ADD] parent.replaceChild ( n, Node.newString ( newValue )  ) ; t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^compiler.reportCodeChange (  )  ;^133^^^^^90^382^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^t.getScope (  ) .reportCodeChange (  ) ;^133^^^^^90^382^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^^108^^^^^90^382^[ADD] newValue = "string";^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^^111^112^^^^90^382^[ADD] newValue = "number"; break;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^^115^116^^^^90^382^[ADD] newValue = "boolean"; break;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^newValue = "boolean"  ;^120^^^^^90^382^[REPLACE] newValue = "object";^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^return;  ;^136^^^^^90^382^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^String newValue = this;^104^^^^^90^382^[REPLACE] String newValue = null;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( "undefined".equals ( right.getString (  )  )  )  {^125^^^^^90^382^[REPLACE] if  ( "undefined".equals ( left.getString (  )  )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^parent.replaceChild ( n, Node .getString (  )   ) ;^132^^^^^90^382^[REPLACE] parent.replaceChild ( n, Node.newString ( newValue )  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^parent.replaceChild ( n, Node.newNumber ( newValue )  ) ;^132^^^^^90^382^[REPLACE] parent.replaceChild ( n, Node.newString ( newValue )  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^t .getScope (  )  .reportCodeChange (  ) ;^133^^^^^90^382^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^newValue  =  newValue ;^108^^^^^90^382^[REPLACE] newValue = "string";^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^newValue = "boolean"  ;^111^^^^^90^382^[REPLACE] newValue = "number";^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^newValue = "object"  ;^115^^^^^90^382^[REPLACE] newValue = "boolean";^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^newValue ;^126^^^^^90^382^[REPLACE] newValue = "undefined";^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^^104^^^^^90^382^[ADD] String newValue = null;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( type == Token.NOT ) {^139^140^141^^^90^382^[REPLACE] if  ( type == Token.NOT || type == Token.NEG || type == Token.BITNOT )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^} else if  ( type  !=  Token.NEW )  {^216^^^^^90^382^[REPLACE] } else if  ( type == Token.NEW )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if   (  Token.NUMBER != right.getType  (    )    )   {  ;^217^^^^^90^382^[REPLACE] if  ( Token.NAME == left.getType (  )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if   (  "Array".equals  (  className  )    )   {  ;^219^^^^^90^382^[REPLACE] if  ( "RegExp".equals ( className )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^}  else {^221^^^^^90^382^[REPLACE] } else if  ( left.getNext (  )  == null )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^}   t, n, parent, className, Token.ARRAYLIT ) ;^221^222^223^224^^90^382^[ADD] else if  ( left.getNext (  )  == null )  { if  ( "Array".equals ( className )  )  { tryFoldLiteralConstructor ( t, n, parent, className, Token.ARRAYLIT ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if   (  "RegExp".equals  (  className  )    )   {  ;^222^^^^^90^382^[REPLACE] if  ( "Array".equals ( className )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^^222^223^224^225^226^90^382^[ADD] if  ( "Array".equals ( className )  )  { tryFoldLiteralConstructor ( t, n, parent, className, Token.ARRAYLIT ) ; } else if  ( "Object".equals ( className )  )  { tryFoldLiteralConstructor (^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^} else if  ( "Object".valueOf ( className )  )  {^225^^^^^90^382^[REPLACE] } else if  ( "Object".equals ( className )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^tryFoldLiteralConstructor ( t, parent, parent, className, Token.OBJECTLIT ) ;^226^227^^^^90^382^[REPLACE] tryFoldLiteralConstructor ( t, n, parent, className, Token.OBJECTLIT ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^tryFoldLiteralConstructor ( t, parent, parent, className, Token.ARRAYLIT ) ;^223^224^^^^90^382^[REPLACE] tryFoldLiteralConstructor ( t, n, parent, className, Token.ARRAYLIT ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^}  else {^225^^^^^90^382^[REPLACE] } else if  ( "Object".equals ( className )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^tryFoldLiteralConstructor ( t, n, parent, newValue, Token.OBJECTLIT ) ;^226^227^^^^90^382^[REPLACE] tryFoldLiteralConstructor ( t, n, parent, className, Token.OBJECTLIT ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^^226^227^^^^90^382^[ADD] tryFoldLiteralConstructor ( t, n, parent, className, Token.OBJECTLIT ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( "Array".equals ( newValue )  )  {^222^^^^^90^382^[REPLACE] if  ( "Array".equals ( className )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^}  if  ( "Object".equals ( newValue )  )  {^225^^^^^90^382^[REPLACE] } else if  ( "Object".equals ( className )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^tryFoldRegularExpressionConstructor ( t, n, right ) ;^220^^^^^90^382^[REPLACE] tryFoldRegularExpressionConstructor ( t, n, parent ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^}  if  ( left.getNext (  )  != null )  {^221^^^^^90^382^[REPLACE] } else if  ( left.getNext (  )  == null )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^}   t, n, parent, className, Token.OBJECTLIT ) ;^225^226^227^228^^90^382^[ADD] else if  ( "Object".equals ( className )  )  { tryFoldLiteralConstructor ( t, n, parent, className, Token.OBJECTLIT ) ; }^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^tryFoldLiteralConstructor ( t, n, parent, newValue, Token.ARRAYLIT ) ;^223^224^^^^90^382^[REPLACE] tryFoldLiteralConstructor ( t, n, parent, className, Token.ARRAYLIT ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^}  if  ( "Object".valueOf ( className )  )  {^225^^^^^90^382^[REPLACE] } else if  ( "Object".equals ( className )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^tryFoldLiteralConstructor ( t, n, right, className, Token.OBJECTLIT ) ;^226^227^^^^90^382^[REPLACE] tryFoldLiteralConstructor ( t, n, parent, className, Token.OBJECTLIT ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^String className = left .newString ( className )  ;^218^^^^^90^382^[REPLACE] String className = left.getString (  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^}  if  ( "Object" .valueOf ( val )   )  {^225^^^^^90^382^[REPLACE] } else if  ( "Object".equals ( className )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^tryFoldLiteralConstructor ( t, n, n, className, Token.OBJECTLIT ) ;^226^227^^^^90^382^[REPLACE] tryFoldLiteralConstructor ( t, n, parent, className, Token.OBJECTLIT ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REMOVE]^tryFoldArithmetic ( t, n, left, right, parent )  ;^220^^^^^90^382^[REMOVE] ^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( "Array".valueOf ( className )  )  {^222^^^^^90^382^[REPLACE] if  ( "Array".equals ( className )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^tryFoldLiteralConstructor ( t, n, right, className, Token.ARRAYLIT ) ;^223^224^^^^90^382^[REPLACE] tryFoldLiteralConstructor ( t, n, parent, className, Token.ARRAYLIT ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^String className = right.getString (  ) ;^218^^^^^90^382^[REPLACE] String className = left.getString (  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( Token.NAME  ||  left.getType (  )  )  {^217^^^^^90^382^[REPLACE] if  ( Token.NAME == left.getType (  )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^String className = left.getString (  ) ;tryFoldRegularExpressionConstructor ( t, n, parent ) ;^217^218^219^220^^90^382^[ADD] if  ( Token.NAME == left.getType (  )  )  { String className = left.getString (  ) ; if  ( "RegExp".equals ( className )  )  { tryFoldRegularExpressionConstructor ( t, n, parent ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^tryFoldRegularExpressionConstructor ( t, n, parent ) ;^219^220^221^222^223^90^382^[ADD] if  ( "RegExp".equals ( className )  )  { tryFoldRegularExpressionConstructor ( t, n, parent ) ; } else if  ( left.getNext (  )  == null )  { if  ( "Array".equals ( className )  )  { tryFoldLiteralConstructor (^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^}  if  ( left.getNext (  )  != this )  {^221^^^^^90^382^[REPLACE] } else if  ( left.getNext (  )  == null )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REMOVE]^if  ( "Object".equals ( className )  )  {     tryFoldLiteralConstructor ( t, n, parent, className, Token.OBJECTLIT ) ; }^222^^^^^90^382^[REMOVE] ^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^}  if  ( "Object".equals ( className )  )  {^225^^^^^90^382^[REPLACE] } else if  ( "Object".equals ( className )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^}  if  ( "Object" .valueOf ( negNum )   )  {^225^^^^^90^382^[REPLACE] } else if  ( "Object".equals ( className )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( "RegExp".valueOf ( className )  )  {^219^^^^^90^382^[REPLACE] if  ( "RegExp".equals ( className )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^^223^224^^^^90^382^[ADD] tryFoldLiteralConstructor ( t, n, parent, className, Token.ARRAYLIT ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^tryFoldRegularExpressionConstructor ( t, parent, parent ) ;^220^^^^^90^382^[REPLACE] tryFoldRegularExpressionConstructor ( t, n, parent ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^} else if  ( left.getNext (  )  != null )  {^221^^^^^90^382^[REPLACE] } else if  ( left.getNext (  )  == null )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^tryFoldLiteralConstructor ( t, condition, parent, className, Token.OBJECTLIT ) ;^226^227^^^^90^382^[REPLACE] tryFoldLiteralConstructor ( t, n, parent, className, Token.OBJECTLIT ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^} else if  ( "Object" .valueOf ( val )   )  {^225^^^^^90^382^[REPLACE] } else if  ( "Object".equals ( className )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^String className = left.toString (  ) ;^218^^^^^90^382^[REPLACE] String className = left.getString (  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( NodeUtil .isAssign (  )   )  {^144^^^^^139^231^[REPLACE] if  ( NodeUtil.isExpressionNode ( parent )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^^144^145^^147^148^139^231^[ADD] if  ( NodeUtil.isExpressionNode ( parent )  )  {  parent.replaceChild ( n, n.removeFirstChild (  )  ) ; t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^return;  ;^149^^^^^139^231^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( type == Token.NOT || tryMinimizeNot ( t, n, parent )  )  {^153^^^^^139^231^[REPLACE] if  ( type == Token.NOT && tryMinimizeNot ( t, n, parent )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^return;^153^154^155^^^139^231^[ADD] if  ( type == Token.NOT && tryMinimizeNot ( t, n, parent )  )  { return; }^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^return;  ;^154^^^^^139^231^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if   (  NodeUtil.isImmutableValue  (  elem  )    )   {  ;^157^^^^^139^231^[REPLACE] if  ( !NodeUtil.isLiteralValue ( left )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^return;  ;^158^^^^^139^231^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( left.getType (  )   &&  Token.NAME )  {^171^^^^^139^231^[REPLACE] if  ( left.getType (  )  == Token.NAME )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( left.toString (  ) .equals ( "Infinity" )  )  {^172^^^^^139^231^[REPLACE] if  ( left.getString (  ) .equals ( "Infinity" )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^}  else {^175^^^^^139^231^[REPLACE] } else if  ( left.getString (  ) .equals ( "NaN" )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^}   n.removeChild ( left ) ;parent.replaceChild ( n, left ) ;t.getCompiler (  ) .reportCodeChange (  ) ;^175^176^177^178^179^139^231^[ADD] else if  ( left.getString (  ) .equals ( "NaN" )  )  {  n.removeChild ( left ) ; parent.replaceChild ( n, left ) ; t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^return;  ;^180^^^^^139^231^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^return;  ;^174^^^^^139^231^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^}  if  ( left.getString (  ) .equals ( "NaN" )  )  {^175^^^^^139^231^[REPLACE] } else if  ( left.getString (  ) .equals ( "NaN" )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^} else if   (  left.getString  (    )  .equals  (  "NaN"  )    )   {  ;^172^^^^^139^231^[REPLACE] if  ( left.getString (  ) .equals ( "Infinity" )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if   (  left.getString  (    )  .equals  (  "Infinity"  )    )   {  ;^175^^^^^139^231^[REPLACE] } else if  ( left.getString (  ) .equals ( "NaN" )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( val >= Integer.MIN_VALUE || val <= Integer.MAX_VALUE )  {^197^^^^^139^231^[REPLACE] if  ( val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^error ( t, BITWISE_OPERAND_OUT_OF_RANGE, right ) ;^206^^^^^197^207^[REPLACE] error ( t, BITWISE_OPERAND_OUT_OF_RANGE, left ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  (type  ||  val )  {^199^^^^^139^231^[REPLACE] if  ( intVal == val )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^error ( t, DIVIDE_BY_0_ERROR, right )  ;^203^^^^^199^204^[REPLACE] error ( t, FRACTIONAL_BITWISE_OPERAND, left ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^parent.replaceChild ( n, newExpr ( cond )  )  ;^200^^^^^139^231^[REPLACE] parent.replaceChild ( n, Node.newNumber ( ~intVal )  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REMOVE]^newString ( result )  ;^200^^^^^139^231^[REMOVE] ^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^newString ( result )  ;^200^^^^^139^231^[REPLACE] parent.replaceChild ( n, Node.newNumber ( ~intVal )  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^^200^^^^^139^231^[ADD] parent.replaceChild ( n, Node.newNumber ( ~intVal )  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^t.getScope (  ) .reportCodeChange (  ) ;^201^^^^^139^231^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^t.getScope (  )  ;^201^^^^^139^231^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^^201^^^^^139^231^[ADD] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^int lvalInt =  (  ( int )   ( lval )  )  ;^198^^^^^139^231^[REPLACE] int intVal =  ( int )  val;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( intVal  &&  val )  {^199^^^^^139^231^[REPLACE] if  ( intVal == val )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^parent.replaceChild ( n, Node.getType ( ~intVal )  ) ;^200^^^^^139^231^[REPLACE] parent.replaceChild ( n, Node.newNumber ( ~intVal )  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^t .getScope (  )  .reportCodeChange (  ) ;^201^^^^^139^231^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^return;^170^171^172^^174^139^231^[ADD] try { if  ( left.getType (  )  == Token.NAME )  { if  ( left.getString (  ) .equals ( "Infinity" )  )  { return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( left.getType (  )   ||  Token.NAME )  {^171^^^^^139^231^[REPLACE] if  ( left.getType (  )  == Token.NAME )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^}  if  ( right.getString (  ) .equals ( "NaN" )  )  {^175^^^^^139^231^[REPLACE] } else if  ( left.getString (  ) .equals ( "NaN" )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^double negNum = -left .getType (  )  ;^184^^^^^139^231^[REPLACE] double negNum = -left.getDouble (  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^double val = left.getDouble (  ) ;int intVal =  ( int )  val;^195^196^197^198^199^139^231^[ADD] try { double val = left.getDouble (  ) ; if  ( val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE )  { int intVal =  ( int )  val; if  ( intVal == val )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REMOVE]^if  ( intVal == val )  {     parent.replaceChild ( n, newNumber (  ( ~intVal )  )  ) ;     t.getCompiler (  ) .reportCodeChange (  ) ; }else {     error ( t, FRACTIONAL_BITWISE_OPERAND, left ) ; }^197^^^^^139^231^[REMOVE] ^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^error ( t, DIVIDE_BY_0_ERROR, right )  ;^206^^^^^197^207^[REPLACE] error ( t, BITWISE_OPERAND_OUT_OF_RANGE, left ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( intVal  !=  val )  {^199^^^^^139^231^[REPLACE] if  ( intVal == val )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^error ( t, FRACTIONAL_BITWISE_OPERAND, right ) ;^203^^^^^199^204^[REPLACE] error ( t, FRACTIONAL_BITWISE_OPERAND, left ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REMOVE]^newLinkedList (  )  ;^203^^^^^199^204^[REMOVE] ^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^parent.replaceChild ( condition, Node.newNumber ( ~intVal )  ) ;^200^^^^^139^231^[REPLACE] parent.replaceChild ( n, Node.newNumber ( ~intVal )  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^t.getCompiler (  ) .reportCodeChange (  ) ;^200^201^^^^139^231^[ADD] parent.replaceChild ( n, Node.newNumber ( ~intVal )  ) ; t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^t.getCompiler (  ) .getVar (  ) ;^201^^^^^139^231^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( intVal  ) {^199^^^^^139^231^[REPLACE] if  ( intVal == val )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^compiler.reportCodeChange (  )  ;^201^^^^^139^231^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^double rv = right.getDouble (  )  ;^196^^^^^139^231^[REPLACE] double val = left.getDouble (  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^return;  ;^215^^^^^139^231^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^^163^164^^^^139^231^[ADD] int result = NodeUtil.getBooleanValue ( left )  ? Token.FALSE : Token.TRUE;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^double rv = right.getDouble (  )  ;^184^^^^^139^231^[REPLACE] double negNum = -left.getDouble (  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^double val = right.getDouble (  ) ;^196^^^^^139^231^[REPLACE] double val = left.getDouble (  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^^187^188^189^^^139^231^[ADD] catch  ( UnsupportedOperationException ex )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( NodeUtil.isExpressionNode ( right )  )  {^144^^^^^90^382^[REPLACE] if  ( NodeUtil.isExpressionNode ( parent )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REMOVE]^if  ( ! ( areSafeFlagsToFold ( flags.getString (  )  )  )  )  {     return ; }^144^^^^^90^382^[REMOVE] ^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^return;  ;^149^^^^^90^382^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( type == Token.NOT || tryMinimizeNot ( t, n, parent )  )  {^153^^^^^90^382^[REPLACE] if  ( type == Token.NOT && tryMinimizeNot ( t, n, parent )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REMOVE]^if  ( type ==  ( RETURN )  )  {     tryReduceReturn ( t, n ) ;     return ; }^153^^^^^90^382^[REMOVE] ^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^return;  ;^154^^^^^90^382^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( !NodeUtil .isImmutableValue ( n )   )  {^157^^^^^90^382^[REPLACE] if  ( !NodeUtil.isLiteralValue ( left )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^return;  ;^158^^^^^90^382^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( left.getType (  )   ||  Token.NAME )  {^171^^^^^90^382^[REPLACE] if  ( left.getType (  )  == Token.NAME )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^} else if   (  left.getString  (    )  .equals  (  "NaN"  )    )   {  ;^172^^^^^90^382^[REPLACE] if  ( left.getString (  ) .equals ( "Infinity" )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if   (  left.getString  (    )  .equals  (  "Infinity"  )    )   {  ;^175^^^^^90^382^[REPLACE] } else if  ( left.getString (  ) .equals ( "NaN" )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^return;  ;^180^^^^^90^382^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^return;  ;^174^^^^^90^382^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^}  if  ( right.getString (  ) .equals ( "NaN" )  )  {^175^^^^^90^382^[REPLACE] } else if  ( left.getString (  ) .equals ( "NaN" )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^^172^173^174^175^^90^382^[ADD] if  ( left.getString (  ) .equals ( "Infinity" )  )  {  return; } else if  ( left.getString (  ) .equals ( "NaN" )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^}  if  ( left.getString (  ) .equals ( "NaN" )  )  {^175^^^^^90^382^[REPLACE] } else if  ( left.getString (  ) .equals ( "NaN" )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^}   n.removeChild ( left ) ;parent.replaceChild ( n, left ) ;t.getCompiler (  ) .reportCodeChange (  ) ;^175^176^177^178^179^90^382^[ADD] else if  ( left.getString (  ) .equals ( "NaN" )  )  {  n.removeChild ( left ) ; parent.replaceChild ( n, left ) ; t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( val >= Integer.MIN_VALUE ) {^197^^^^^90^382^[REPLACE] if  ( val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( intVal  !=  val )  {^199^^^^^90^382^[REPLACE] if  ( intVal == val )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^parent.replaceChild ( n, newExpr ( cond )  )  ;^200^^^^^90^382^[REPLACE] parent.replaceChild ( n, Node.newNumber ( ~intVal )  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^parent.replaceChild ( n, Node.getType ( ~intVal )  ) ;^200^^^^^90^382^[REPLACE] parent.replaceChild ( n, Node.newNumber ( ~intVal )  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^^200^^^^^90^382^[ADD] parent.replaceChild ( n, Node.newNumber ( ~intVal )  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^compiler.reportCodeChange (  )  ;^201^^^^^90^382^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^t.getScope (  ) .reportCodeChange (  ) ;^201^^^^^90^382^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^int lvalInt =  (  ( int )   ( lval )  )  ;^198^^^^^90^382^[REPLACE] int intVal =  ( int )  val;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  (  type )  {^199^^^^^90^382^[REPLACE] if  ( intVal == val )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^parent.replaceChild ( n, Node.newNumber ( ~type )  ) ;^200^^^^^90^382^[REPLACE] parent.replaceChild ( n, Node.newNumber ( ~intVal )  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REMOVE]^checkState ( isVarBlock ( n )  )  ;^200^^^^^90^382^[REMOVE] ^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^t.getCompiler (  ) .getVar (  ) ;^201^^^^^90^382^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^}  if  ( type  !=  Token.NEW )  {^216^^^^^90^382^[REPLACE] } else if  ( type == Token.NEW )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( Token.NAME  !=  left.getType (  )  )  {^217^^^^^90^382^[REPLACE] if  ( Token.NAME == left.getType (  )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^^217^218^219^220^^90^382^[ADD] if  ( Token.NAME == left.getType (  )  )  { String className = left.getString (  ) ; if  ( "RegExp".equals ( className )  )  { tryFoldRegularExpressionConstructor ( t, n, parent ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( "Array" .valueOf ( val )   )  {^222^^^^^90^382^[REPLACE] if  ( "Array".equals ( className )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^tryFoldLiteralConstructor ( t, condition, parent, className, Token.ARRAYLIT ) ;^223^224^^^^90^382^[REPLACE] tryFoldLiteralConstructor ( t, n, parent, className, Token.ARRAYLIT ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^^220^^^^^90^382^[ADD] tryFoldRegularExpressionConstructor ( t, n, parent ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( "RegExp" .valueOf ( negNum )   )  {^219^^^^^90^382^[REPLACE] if  ( "RegExp".equals ( className )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^}  if  ( right.getNext (  )  != null )  {^221^^^^^90^382^[REPLACE] } else if  ( left.getNext (  )  == null )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( "Array" .valueOf ( negNum )   )  {^222^^^^^90^382^[REPLACE] if  ( "Array".equals ( className )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if   (  n.getChildCount  (    )   < 3  )   return true;  ;^225^^^^^90^382^[REPLACE] } else if  ( "Object".equals ( className )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^checkState ( isVarBlock ( n )  )  ;^220^^^^^90^382^[REPLACE] tryFoldRegularExpressionConstructor ( t, n, parent ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^}  if  ( left.getNext (  )  != false )  {^221^^^^^90^382^[REPLACE] } else if  ( left.getNext (  )  == null )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( Token.NAME  ) {^217^^^^^90^382^[REPLACE] if  ( Token.NAME == left.getType (  )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^String s = n.getString (  )  ;^218^^^^^90^382^[REPLACE] String className = left.getString (  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^^219^220^221^222^223^90^382^[ADD] if  ( "RegExp".equals ( className )  )  { tryFoldRegularExpressionConstructor ( t, n, parent ) ; } else if  ( left.getNext (  )  == null )  { if  ( "Array".equals ( className )  )  { tryFoldLiteralConstructor (^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^} else if  ( "Object" .valueOf ( negNum )   )  {^225^^^^^90^382^[REPLACE] } else if  ( "Object".equals ( className )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^return;^170^171^172^^174^90^382^[ADD] try { if  ( left.getType (  )  == Token.NAME )  { if  ( left.getString (  ) .equals ( "Infinity" )  )  { return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^}  if  ( left .newString ( className )  .equals ( "NaN" )  )  {^175^^^^^90^382^[REPLACE] } else if  ( left.getString (  ) .equals ( "NaN" )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^double rv = right.getDouble (  )  ;^184^^^^^90^382^[REPLACE] double negNum = -left.getDouble (  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^double val = left.getDouble (  ) ;int intVal =  ( int )  val;^195^196^197^198^199^90^382^[ADD] try { double val = left.getDouble (  ) ; if  ( val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE )  { int intVal =  ( int )  val; if  ( intVal == val )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( val >= Integer.MIN_VALUE || val <= Integer.MAX_VALUE )  {^197^^^^^90^382^[REPLACE] if  ( val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^int intVal =  ( int )  val;parent.replaceChild ( n, Node.newNumber ( ~intVal )  ) ;t.getCompiler (  ) .reportCodeChange (  ) ;^197^198^199^200^201^90^382^[ADD] if  ( val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE )  { int intVal =  ( int )  val; if  ( intVal == val )  { parent.replaceChild ( n, Node.newNumber ( ~intVal )  ) ; t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( intVal  && type )  {^199^^^^^90^382^[REPLACE] if  ( intVal == val )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REMOVE]^newString ( result )  ;^200^^^^^90^382^[REMOVE] ^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^parent.replaceChild ( n, Node.getType ( ~type )  ) ;^200^^^^^90^382^[REPLACE] parent.replaceChild ( n, Node.newNumber ( ~intVal )  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^t .getScope (  )  .reportCodeChange (  ) ;^201^^^^^90^382^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^t.getScope (  )  ;^201^^^^^90^382^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^^198^^^^^90^382^[ADD] int intVal =  ( int )  val;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  (type  ||  val )  {^199^^^^^90^382^[REPLACE] if  ( intVal == val )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^^200^201^^^^90^382^[ADD] parent.replaceChild ( n, Node.newNumber ( ~intVal )  ) ; t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^^201^^^^^90^382^[ADD] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^double rv = right.getDouble (  )  ;^196^^^^^90^382^[REPLACE] double val = left.getDouble (  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^return;  ;^215^^^^^90^382^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^int result = NodeUtil.getBooleanValue ( right )  ? Token.FALSE : Token.TRUE;^163^164^^^^90^382^[REPLACE] int result = NodeUtil.getBooleanValue ( left )  ? Token.FALSE : Token.TRUE;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^double negNum = -left.newNumber (  ) ;^184^^^^^90^382^[REPLACE] double negNum = -left.getDouble (  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^double val = right.getDouble (  ) ;^196^^^^^90^382^[REPLACE] double val = left.getDouble (  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( type  ||  Token.EXPR_RESULT )  {^233^^^^^90^382^[REPLACE] if  ( type == Token.EXPR_RESULT )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^return;  ;^235^^^^^90^382^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( type  &&  Token.RETURN )  {^238^^^^^90^382^[REPLACE] if  ( type == Token.RETURN )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^return;  ;^240^^^^^90^382^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^^243^^^^^90^382^[ADD] Node right = left.getNext (  ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( right != null )  {^244^^^^^90^382^[REPLACE] if  ( right == null )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^return;  ;^245^^^^^90^382^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( type == Token.INSTANCEOF && NodeUtil.isLiteralValue ( left ) && NodeUtil.mayHaveSideEffects ( right )  )  {^250^251^252^^^90^382^[REPLACE] if  ( type == Token.INSTANCEOF && NodeUtil.isLiteralValue ( left ) && !NodeUtil.mayHaveSideEffects ( right )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REMOVE]^if  (  (  ( left.getType (  )  )  ==  ( STRING )  )  ||  (  ( right.getType (  )  )  ==  ( STRING )  )  )  {     String leftString = getStringValue ( left ) ;     String rightString = getStringValue ( right ) ;     if  (  ( leftString != null )  &&  ( rightString != null )  )  {         parent.replaceChild ( n, newString (  ( leftString + rightString )  )  ) ;         t.getCompiler (  ) .reportCodeChange (  ) ;     } }else {     tryFoldArithmetic ( t, n, left, right, parent ) ; }^250^^^^^90^382^[REMOVE] ^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if   (  NodeUtil.isImmutableValue  (  elem  )    )   {  ;^253^^^^^250^266^[REPLACE] if  ( NodeUtil.isImmutableValue ( left )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^return;  ;^257^^^^^250^266^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( right.getType (  )  == Token.NAME || "Object".equals ( right.getString (  )  )  )  {^260^261^^^^250^266^[REPLACE] if  ( right.getType (  )  == Token.NAME && "Object".equals ( right.getString (  )  )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^return;  ;^264^^^^^260^265^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^return;  ;^264^^^^^250^266^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( NodeUtil.isImmutableValue ( right )  )  {^253^^^^^90^382^[REPLACE] if  ( NodeUtil.isImmutableValue ( left )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^return;  ;^257^^^^^90^382^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( right.getType (  )  == Token.NAME ) {^260^261^^^^90^382^[REPLACE] if  ( right.getType (  )  == Token.NAME && "Object".equals ( right.getString (  )  )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^return;  ;^264^^^^^90^382^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  (  type == Token.HOOK )  {^268^^^^^90^382^[REPLACE] if  ( type == Token.IF || type == Token.HOOK )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( type == Token.IF ) {^274^^^^^90^382^[REPLACE] if  ( type == Token.IF && !changes )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^tryMinimizeIf ( t, parent, parent ) ;^275^^^^^90^382^[REPLACE] tryMinimizeIf ( t, n, parent ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^return;  ;^277^^^^^90^382^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^boolean changes = tryFoldHookIf ( t, parent, parent ) ;^270^^^^^90^382^[REPLACE] boolean changes = tryFoldHookIf ( t, n, parent ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^( tryMinimizeNot ( t, n, parent )  )  ;^275^^^^^90^382^[REPLACE] tryMinimizeIf ( t, n, parent ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  (intVal  !=  Token.DO )  {^280^^^^^90^382^[REPLACE] if  ( type == Token.DO )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^return;  ;^283^^^^^90^382^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  (   Token.WHILE )  {^286^^^^^90^382^[REPLACE] if  ( type == Token.WHILE )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^return;  ;^289^^^^^90^382^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  (intVal  &&  Token.FOR )  {^292^^^^^90^382^[REPLACE] if  ( type == Token.FOR )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  (parent == false )  {^294^^^^^90^382^[REPLACE] if  ( condition != null )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^^294^295^^297^298^90^382^[ADD] if  ( condition != null )  { tryMinimizeCondition ( t, condition, n ) ; condition = NodeUtil.getConditionExpression ( n ) ; this.tryFoldForCondition ( condition, n ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^condition =  NodeUtil.getCoparentditioparentExpressioparent ( parent ) ;^297^^^^^90^382^[REPLACE] condition = NodeUtil.getConditionExpression ( n ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^condition =  NodeUtil.getConullditionullExpressionull ( null ) ;^297^^^^^90^382^[REPLACE] condition = NodeUtil.getConditionExpression ( n ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^return;  ;^302^^^^^90^382^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^^293^^^^^90^382^[ADD] Node condition = NodeUtil.getConditionExpression ( n ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( condition == null )  {^294^^^^^90^382^[REPLACE] if  ( condition != null )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^tryMinimizeCondition ( t, condition, n ) ;condition = NodeUtil.getConditionExpression ( n ) ;this.tryFoldForCondition ( condition, n ) ;^294^295^^297^298^90^382^[ADD] if  ( condition != null )  { tryMinimizeCondition ( t, condition, n ) ; condition = NodeUtil.getConditionExpression ( n ) ; this.tryFoldForCondition ( condition, n ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^Node expr = newExpr ( hookNode )  ;^293^^^^^90^382^[REPLACE] Node condition = NodeUtil.getConditionExpression ( n ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( type == Token.AND && type == Token.OR )  {^305^306^^^^90^382^[REPLACE] if  ( type == Token.AND || type == Token.OR )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^^305^306^307^308^309^90^382^[ADD] if  ( type == Token.AND || type == Token.OR )  { tryFoldAndOr ( t, n, left, right, parent ) ; return; }^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^return;  ;^308^^^^^305^309^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^return;  ;^308^^^^^90^382^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( type == Token.BITOR ) {^311^312^^^^90^382^[REPLACE] if  ( type == Token.BITOR || type == Token.BITAND )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^^311^312^313^314^315^90^382^[ADD] if  ( type == Token.BITOR || type == Token.BITAND )  { tryFoldBitAndOr ( t, n, left, right, parent ) ; return; }^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^return;  ;^314^^^^^311^315^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^return;  ;^314^^^^^90^382^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  (  type == Token.RSH && type == Token.URSH )  {^317^318^319^^^90^382^[REPLACE] if  ( type == Token.LSH || type == Token.RSH || type == Token.URSH )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^return;  ;^321^^^^^317^322^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^return;  ;^321^^^^^90^382^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if   (  type == Token.ASSIGN  )   {  ;^324^^^^^90^382^[REPLACE] if  ( type == Token.GETPROP )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^return;  ;^326^^^^^90^382^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( type  !=  Token.CALL )  {^329^^^^^90^382^[REPLACE] if  ( type == Token.CALL )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^return;  ;^332^^^^^90^382^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  (   Token.ASSIGN )  {^335^^^^^90^382^[REPLACE] if  ( type == Token.ASSIGN )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^^335^336^337^^^90^382^[ADD] if  ( type == Token.ASSIGN )  { tryFoldAssign ( t, n, left, right ) ; }^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^tryFoldAssign ( t, parent, left, right ) ;^336^^^^^90^382^[REPLACE] tryFoldAssign ( t, n, left, right ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( NodeUtil.isLiteralValue ( left )  ) {^339^340^^^^90^382^[REPLACE] if  ( !NodeUtil.isLiteralValue ( left )  || !NodeUtil.isLiteralValue ( right )  )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( type  &&  Token.ADD ) tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^342^343^^^^339^351^[REPLACE] if  ( type == Token.ADD ) tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^^342^343^^345^^339^351^[ADD] if  ( type == Token.ADD ) tryFoldLeftChildAdd ( t, n, left, right, parent ) ; if  ( type == Token.LT ||^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( type == Token.LT ) {^345^346^^^^339^351^[REPLACE] if  ( type == Token.LT || type == Token.GT )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^^345^346^347^348^^339^351^[ADD] if  ( type == Token.LT || type == Token.GT )  { tryFoldComparison ( t, n, left, right, parent ) ; }^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^return;  ;^350^^^^^339^351^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( intVal  &&  Token.ADD ) tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^342^343^^^^90^382^[REPLACE] if  ( type == Token.ADD ) tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^tryFoldArithmetic ( t, n, left, right, parent )  ;^343^^^^^90^382^[REPLACE] tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( type == Token.LT && type == Token.GT )  {^345^346^^^^90^382^[REPLACE] if  ( type == Token.LT || type == Token.GT )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^^345^346^347^348^^90^382^[ADD] if  ( type == Token.LT || type == Token.GT )  { tryFoldComparison ( t, n, left, right, parent ) ; }^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^tryFoldComparison ( t, n, left, right, right ) ;^347^^^^^345^348^[REPLACE] tryFoldComparison ( t, n, left, right, parent ) ;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^return;  ;^350^^^^^90^382^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if   (  type == Token.ASSIGN  )   {  ;^353^^^^^90^382^[REPLACE] if  ( type == Token.ADD )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[ADD]^tryFoldAdd ( t, n, left, right, parent ) ;return;^353^354^355^356^^90^382^[ADD] if  ( type == Token.ADD )  { tryFoldAdd ( t, n, left, right, parent ) ; return; }^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^return;  ;^355^^^^^90^382^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  (  type == Token.MUL && type == Token.DIV )  {^357^358^359^^^90^382^[REPLACE] if  ( type == Token.SUB || type == Token.MUL || type == Token.DIV )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^return;  ;^361^^^^^357^362^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^return;  ;^361^^^^^90^382^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( intVal == Token.LT && type == Token.GT && type == Token.LE && type == Token.GE &&^364^365^366^367^^90^382^[REPLACE] if  ( type == Token.LT || type == Token.GT || type == Token.LE || type == Token.GE ||^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^return;  ;^373^^^^^364^374^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^return;  ;^373^^^^^90^382^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  (intVal  !=  Token.GETELEM )  {^376^^^^^90^382^[REPLACE] if  ( type == Token.GETELEM )  {^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^return;  ;^378^^^^^90^382^[REPLACE] return;^[METHOD] visit [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double negNum  val  [TYPE]  Node condition  left  n  parent  right  [TYPE]  String className  newValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  UnsupportedOperationException ex 
[REPLACE]^if  ( n.getChildCount (  )   !=  3 )  return true;^397^^^^^393^410^[REPLACE] if  ( n.getChildCount (  )  < 3 )  return true;^[METHOD] consumesDanglingElse [TYPE] boolean [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  Node n 
[ADD]^^397^398^399^400^401^393^410^[ADD] if  ( n.getChildCount (  )  < 3 )  return true;  n = n.getLastChild (  ) ; continue; case Token.WITH:^[METHOD] consumesDanglingElse [TYPE] boolean [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  Node n 
[REPLACE]^if  ( n.getChildCount (  )  < 3 )  return false;^397^^^^^393^410^[REPLACE] if  ( n.getChildCount (  )  < 3 )  return true;^[METHOD] consumesDanglingElse [TYPE] boolean [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  Node n 
[REPLACE]^n =  null.getLastChild (  ) ;^399^^^^^393^410^[REPLACE] n = n.getLastChild (  ) ;^[METHOD] consumesDanglingElse [TYPE] boolean [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  Node n 
[REPLACE]^n =  null.getLastChild (  ) ;^404^^^^^393^410^[REPLACE] n = n.getLastChild (  ) ;^[METHOD] consumesDanglingElse [TYPE] boolean [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  Node n 
[REPLACE]^return true;^407^^^^^393^410^[REPLACE] return false;^[METHOD] consumesDanglingElse [TYPE] boolean [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  [TYPE]  Node n 
[REPLACE]^Preconditions.checkArgument ( n.getType (  )   &&  Token.ASSIGN ) ;^413^^^^^412^473^[REPLACE] Preconditions.checkArgument ( n.getType (  )  == Token.ASSIGN ) ;^[METHOD] tryFoldAssign [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  leftChild  n  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^Preconditions.checkArgument ( n .setType ( result )   == Token.ASSIGN ) ;^413^^^^^412^473^[REPLACE] Preconditions.checkArgument ( n.getType (  )  == Token.ASSIGN ) ;^[METHOD] tryFoldAssign [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  leftChild  n  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^if  ( !right .detachChildren (  )   && right.getFirstChild (  ) .getNext (  )  != right.getLastChild (  )  )  {^416^417^^^^412^473^[REPLACE] if  ( !right.hasChildren (  )  || right.getFirstChild (  ) .getNext (  )  != right.getLastChild (  )  )  {^[METHOD] tryFoldAssign [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  leftChild  n  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^return;  ;^419^^^^^416^420^[REPLACE] return;^[METHOD] tryFoldAssign [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  leftChild  n  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^return;  ;^419^^^^^412^473^[REPLACE] return;^[METHOD] tryFoldAssign [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  leftChild  n  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^if  ( NodeUtil.tryMergeBlock ( right )  )  {^422^^^^^412^473^[REPLACE] if  ( NodeUtil.mayHaveSideEffects ( left )  )  {^[METHOD] tryFoldAssign [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  leftChild  n  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[ADD]^^422^423^424^^^412^473^[ADD] if  ( NodeUtil.mayHaveSideEffects ( left )  )  { return; }^[METHOD] tryFoldAssign [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  leftChild  n  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^return;  ;^423^^^^^412^473^[REPLACE] return;^[METHOD] tryFoldAssign [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  leftChild  n  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^Node arrayNode = left.getFirstChild (  )  ;^426^^^^^412^473^[REPLACE] Node leftChild = right.getFirstChild (  ) ;^[METHOD] tryFoldAssign [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  leftChild  n  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^if  ( !left .getParent (  )   )  {^427^^^^^412^473^[REPLACE] if  ( !left.checkTreeEqualsSilent ( leftChild )  )  {^[METHOD] tryFoldAssign [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  leftChild  n  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^return;  ;^428^^^^^412^473^[REPLACE] return;^[METHOD] tryFoldAssign [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  leftChild  n  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^int newType = -0;^431^^^^^412^473^[REPLACE] int newType = -1;^[METHOD] tryFoldAssign [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  leftChild  n  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[ADD]^^434^^^^^412^473^[ADD] newType = Token.ASSIGN_ADD;^[METHOD] tryFoldAssign [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  leftChild  n  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^newType = ASSIGN_BITOR  ;^437^^^^^412^473^[REPLACE] newType = Token.ASSIGN_BITAND;^[METHOD] tryFoldAssign [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  leftChild  n  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[ADD]^break;^440^441^^^^412^473^[ADD] newType = Token.ASSIGN_BITOR; break;^[METHOD] tryFoldAssign [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  leftChild  n  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^newType = ASSIGN_BITOR  ;^443^^^^^412^473^[REPLACE] newType = Token.ASSIGN_BITXOR;^[METHOD] tryFoldAssign [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  leftChild  n  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[ADD]^^446^^^^^412^473^[ADD] newType = Token.ASSIGN_DIV;^[METHOD] tryFoldAssign [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  leftChild  n  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^newType = ASSIGN_BITOR  ;^449^^^^^412^473^[REPLACE] newType = Token.ASSIGN_LSH;^[METHOD] tryFoldAssign [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  leftChild  n  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^newType = ASSIGN_BITOR  ;^452^^^^^412^473^[REPLACE] newType = Token.ASSIGN_MOD;^[METHOD] tryFoldAssign [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  leftChild  n  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^newType = ASSIGN_BITOR  ;^455^^^^^412^473^[REPLACE] newType = Token.ASSIGN_MUL;^[METHOD] tryFoldAssign [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  leftChild  n  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^newType = ASSIGN_BITOR  ;^458^^^^^412^473^[REPLACE] newType = Token.ASSIGN_RSH;^[METHOD] tryFoldAssign [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  leftChild  n  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^newType = ASSIGN_BITOR  ;^461^^^^^412^473^[REPLACE] newType = Token.ASSIGN_SUB;^[METHOD] tryFoldAssign [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  leftChild  n  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^newType = ASSIGN_BITOR  ;^464^^^^^412^473^[REPLACE] newType = Token.ASSIGN_URSH;^[METHOD] tryFoldAssign [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  leftChild  n  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^return;  ;^467^^^^^412^473^[REPLACE] return;^[METHOD] tryFoldAssign [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  leftChild  n  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^n.getParent (  ) .replaceChild ( n, new Node ( newType, leftChild.detachFromParent (  ) , right.getLastChild (  ) .detachFromParent (  )  )  ) ;^470^471^^^^412^473^[REPLACE] n.getParent (  ) .replaceChild ( n, new Node ( newType, left.detachFromParent (  ) , right.getLastChild (  ) .detachFromParent (  )  )  ) ;^[METHOD] tryFoldAssign [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  leftChild  n  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^n.getString (  ) .replaceChild ( n, new Node ( newType, left.detachFromParent (  ) , right.getLastChild (  ) .detachFromParent (  )  )  ) ;^470^471^^^^412^473^[REPLACE] n.getParent (  ) .replaceChild ( n, new Node ( newType, left.detachFromParent (  ) , right.getLastChild (  ) .detachFromParent (  )  )  ) ;^[METHOD] tryFoldAssign [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  leftChild  n  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^left.detachChildren (  ) , right.getLastChild (  ) .detachFromParent (  )  )  ) ;^471^^^^^412^473^[REPLACE] left.detachFromParent (  ) , right.getLastChild (  ) .detachFromParent (  )  )  ) ;^[METHOD] tryFoldAssign [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  leftChild  n  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^thenAssign.getLastChild (  ) .detachFromParent (  )  ;^471^^^^^412^473^[REPLACE] left.detachFromParent (  ) , right.getLastChild (  ) .detachFromParent (  )  )  ) ;^[METHOD] tryFoldAssign [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  leftChild  n  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^left.detachFromParent (  ) , right .getFirstChild (  )  .detachFromParent (  )  )  ) ;^471^^^^^412^473^[REPLACE] left.detachFromParent (  ) , right.getLastChild (  ) .detachFromParent (  )  )  ) ;^[METHOD] tryFoldAssign [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  leftChild  n  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^compiler.reportCodeChange (  )  ;^472^^^^^412^473^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryFoldAssign [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  leftChild  n  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[ADD]^^472^^^^^412^473^[ADD] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryFoldAssign [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  leftChild  n  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^t.getScope (  ) .reportCodeChange (  ) ;^472^^^^^412^473^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryFoldAssign [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  leftChild  n  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^if  ( NodeUtil.mayHaveSideEffects ( c )  )  {^482^^^^^478^497^[REPLACE] if  ( !NodeUtil.mayHaveSideEffects ( c )  )  {^[METHOD] tryFoldBlock [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node c  n  next  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^n.replaceChild ( c ) ;^483^^^^^478^497^[REPLACE] n.removeChild ( c ) ;^[METHOD] tryFoldBlock [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node c  n  next  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^t.getScope (  ) .reportCodeChange (  ) ;^484^^^^^478^497^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryFoldBlock [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node c  n  next  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^t .getScope (  )  .reportCodeChange (  ) ;^484^^^^^478^497^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryFoldBlock [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node c  n  next  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REMOVE]^ll.getNext (  )  ;^484^^^^^478^497^[REMOVE] ^[METHOD] tryFoldBlock [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node c  n  next  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^c =  parent;^486^^^^^478^497^[REPLACE] c = next;^[METHOD] tryFoldBlock [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node c  n  next  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[ADD]^^480^481^482^483^484^478^497^[ADD] for  ( Node c = n.getFirstChild (  ) ; c != null;  )  { Node next = c.getNext (  ) ; if  ( !NodeUtil.mayHaveSideEffects ( c )  )  { n.removeChild ( c ) ; t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryFoldBlock [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node c  n  next  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[ADD]^^481^^^^^478^497^[ADD] Node next = c.getNext (  ) ;^[METHOD] tryFoldBlock [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node c  n  next  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^if  ( n .hasOneChild (  )   || parent != null )  {^489^^^^^478^497^[REPLACE] if  ( n.isSyntheticBlock (  )  || parent == null )  {^[METHOD] tryFoldBlock [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node c  n  next  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REMOVE]^if  ( rvalInt != rval )  {     return ; }^489^^^^^478^497^[REMOVE] ^[METHOD] tryFoldBlock [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node c  n  next  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^return;  ;^490^^^^^478^497^[REPLACE] return;^[METHOD] tryFoldBlock [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node c  n  next  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^if  ( NodeUtil.tryMergeBlock ( parent )  )  {^494^^^^^478^497^[REPLACE] if  ( NodeUtil.tryMergeBlock ( n )  )  {^[METHOD] tryFoldBlock [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node c  n  next  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^compiler.reportCodeChange (  )  ;^495^^^^^478^497^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryFoldBlock [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node c  n  next  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^t.getScope (  ) .reportCodeChange (  ) ;^495^^^^^478^497^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryFoldBlock [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node c  n  next  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^int type = n .setType ( AND_PRECEDENCE )  ;^504^^^^^503^622^[REPLACE] int type = n.getType (  ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[ADD]^^505^506^^^^503^622^[ADD] Node cond = n.getFirstChild (  ) ; Node thenBody = cond.getNext (  ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^Node arrayNode = left.getFirstChild (  )  ;^506^^^^^503^622^[REPLACE] Node thenBody = cond.getNext (  ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^Node maybeName1 = thenAssign.getFirstChild (  )  ;^507^^^^^503^622^[REPLACE] Node elseBody = thenBody.getNext (  ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^boolean changes = true;^509^^^^^503^622^[REPLACE] boolean changes = false;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^if   (  type == Token.ASSIGN  )   {  ;^511^^^^^503^622^[REPLACE] if  ( type == Token.IF )  {^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[ADD]^^511^512^513^514^515^503^622^[ADD] if  ( type == Token.IF )  {  if  ( elseBody != null && !NodeUtil.mayHaveSideEffects ( elseBody )  )  { n.removeChild ( elseBody ) ; elseBody = null;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^if   (  n.getChildCount  (    )   < 3  )   return true;  ;^549^^^^^511^585^[REPLACE] if  ( NodeUtil.isExpressionNode ( parent )  )  {^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[ADD]^^549^550^551^^553^511^585^[ADD] if  ( NodeUtil.isExpressionNode ( parent )  )  {  if  ( !NodeUtil.mayHaveSideEffects ( thenBody )  )  { Node ifNode = new Node ( Token.IF ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^if  ( NodeUtil.mayHaveSideEffects ( thenBody )  )  {^551^^^^^511^585^[REPLACE] if  ( !NodeUtil.mayHaveSideEffects ( thenBody )  )  {^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^} else if  ( NodeUtil.mayHaveSideEffects ( elseBody )  )  {^571^^^^^511^585^[REPLACE] } else if  ( !NodeUtil.mayHaveSideEffects ( elseBody )  )  {^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[ADD]^}   Node ifNode = new Node ( Token.IF ) ;n.removeChild ( cond ) ;ifNode.addChildToBack ( cond ) ;^571^572^573^574^575^511^585^[ADD] else if  ( !NodeUtil.mayHaveSideEffects ( elseBody )  )  {  Node ifNode = new Node ( Token.IF ) ; n.removeChild ( cond ) ; ifNode.addChildToBack ( cond ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^return true;  ;^582^^^^^511^585^[REPLACE] return true;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^Node notCond = new Node ( NOT )  ;^573^^^^^511^585^[REPLACE] Node ifNode = new Node ( Token.IF ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^return false;^582^^^^^511^585^[REPLACE] return true;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[ADD]^n.removeChild ( cond ) ;ifNode.addChildToBack ( cond ) ;n.removeChild ( thenBody ) ;^573^574^575^576^^511^585^[ADD] Node ifNode = new Node ( Token.IF ) ; n.removeChild ( cond ) ; ifNode.addChildToBack ( cond ) ; n.removeChild ( thenBody ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^if  ( cond.getType (  )   !=  Token.NOT )  {^554^^^^^511^585^[REPLACE] if  ( cond.getType (  )  == Token.NOT )  {^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^Node notCond = new Node ( NOT )  ;^559^^^^^554^563^[REPLACE] Node not = new Node ( Token.NOT ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^Node expr = secondBranch.getFirstChild (  ) ;^555^^^^^511^585^[REPLACE] Node expr = cond.getFirstChild (  ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^return false;^570^^^^^511^585^[REPLACE] return true;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^Node notCond = new Node ( NOT )  ;^553^^^^^511^585^[REPLACE] Node ifNode = new Node ( Token.IF ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^Node expr = notCond.getFirstChild (  ) ;^555^^^^^511^585^[REPLACE] Node expr = cond.getFirstChild (  ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[ADD]^^559^560^^^^511^585^[ADD] Node not = new Node ( Token.NOT ) ; n.removeChild ( cond ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^if   (  first.getType  (    )   == Token.RETURN  )   {  ;^554^^^^^511^585^[REPLACE] if  ( cond.getType (  )  == Token.NOT )  {^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[ADD]^Node expr = cond.getFirstChild (  ) ;cond.removeChild ( expr ) ;ifNode.addChildToBack ( expr ) ;^554^555^556^557^^511^585^[ADD] if  ( cond.getType (  )  == Token.NOT )  { Node expr = cond.getFirstChild (  ) ; cond.removeChild ( expr ) ; ifNode.addChildToBack ( expr ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^}  else {^571^^^^^511^585^[REPLACE] } else if  ( !NodeUtil.mayHaveSideEffects ( elseBody )  )  {^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[ADD]^^555^^^^^511^585^[ADD] Node expr = cond.getFirstChild (  ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^Node notCond = new Node ( NOT )  ;^559^^^^^511^585^[REPLACE] Node not = new Node ( Token.NOT ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^if   (  NodeUtil.mayHaveSideEffects  (  left  )    )   {  ;^551^^^^^511^585^[REPLACE] if  ( !NodeUtil.mayHaveSideEffects ( thenBody )  )  {^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^if   (  NodeUtil.mayHaveSideEffects  (  left  )    )   {  ;^571^^^^^511^585^[REPLACE] } else if  ( !NodeUtil.mayHaveSideEffects ( elseBody )  )  {^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REMOVE]^if  (  ( isReturnExpressBlock ( thenBranch )  )  &&  ( isReturnExpressBlock ( elseBranch )  )  )  {     Node thenExpr = getBlockReturnExpression ( thenBranch ) ;     Node elseExpr = getBlockReturnExpression ( elseBranch ) ;     n.removeChild ( cond ) ;     thenExpr.detachFromParent (  ) ;     elseExpr.detachFromParent (  ) ;     Node hookNode = new Node ( HOOK, cond, thenExpr, elseExpr ) ;     Node returnNode = new Node ( RETURN, hookNode ) ;     parent.replaceChild ( n, returnNode ) ;     t.getCompiler (  ) .reportCodeChange (  ) ;     return ; }^571^^^^^511^585^[REMOVE] ^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[ADD]^cond.removeChild ( expr ) ;^555^556^^^^511^585^[ADD] Node expr = cond.getFirstChild (  ) ; cond.removeChild ( expr ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^return true;  ;^570^^^^^511^585^[REPLACE] return true;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[ADD]^^553^554^555^556^557^511^585^[ADD] Node ifNode = new Node ( Token.IF ) ; if  ( cond.getType (  )  == Token.NOT )  { Node expr = cond.getFirstChild (  ) ; cond.removeChild ( expr ) ; ifNode.addChildToBack ( expr ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[ADD]^^555^556^^^^511^585^[ADD] Node expr = cond.getFirstChild (  ) ; cond.removeChild ( expr ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[ADD]^^559^^^^^511^585^[ADD] Node not = new Node ( Token.NOT ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^if  ( cond.getType (  )   ) {^554^^^^^511^585^[REPLACE] if  ( cond.getType (  )  == Token.NOT )  {^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^Node expr = secondBranch .getLastChild (  )  ;^555^^^^^511^585^[REPLACE] Node expr = cond.getFirstChild (  ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^if  ( elseBody == null && !NodeUtil.mayHaveSideEffects ( elseBody )  )  {^513^^^^^503^622^[REPLACE] if  ( elseBody != null && !NodeUtil.mayHaveSideEffects ( elseBody )  )  {^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^elseBody = true;^515^^^^^503^622^[REPLACE] elseBody = null;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^changes = false;^517^^^^^503^622^[REPLACE] changes = true;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^if   (  !NodeUtil.mayHaveSideEffects  (  thenBody  )   && elseBody == null  )   {  ;^521^^^^^503^622^[REPLACE] if  ( !NodeUtil.mayHaveSideEffects ( thenBody )  && elseBody != null )  {^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[ADD]^^521^522^523^524^525^503^622^[ADD] if  ( !NodeUtil.mayHaveSideEffects ( thenBody )  && elseBody != null )  { n.removeChild ( elseBody ) ; n.replaceChild ( thenBody, elseBody ) ; Node notCond = new Node ( Token.NOT ) ; n.replaceChild ( cond, notCond ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^cond =  secondBranch;^527^^^^^503^622^[REPLACE] cond = notCond;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^thenBody =  notCond.getNext (  ) ;^528^^^^^503^622^[REPLACE] thenBody = cond.getNext (  ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^elseBody = this;^529^^^^^503^622^[REPLACE] elseBody = null;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^changes = false;^531^^^^^503^622^[REPLACE] changes = true;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[ADD]^^524^^^^^503^622^[ADD] Node notCond = new Node ( Token.NOT ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^if  ( !NodeUtil.mayHaveSideEffects ( thenBody )  ) { else {^535^^^^^503^622^[REPLACE] if  ( !NodeUtil.mayHaveSideEffects ( thenBody )  && elseBody == null )  {^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^if   (  NodeUtil.mayHaveSideEffects  (  left  )    )   {  ;^536^^^^^503^622^[REPLACE] if  ( NodeUtil.mayHaveSideEffects ( cond )  )  {^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^NodeUtil .removeChild ( ifNode )  ;^542^^^^^536^543^[REPLACE] NodeUtil.removeChild ( parent, n ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[ADD]^^542^^^^^536^543^[ADD] NodeUtil.removeChild ( parent, n ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^n.removeChild ( c )  ;^538^^^^^503^622^[REPLACE] n.removeChild ( cond ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^parent.replaceChild ( n, NodeUtil.newExpr ( thenStmt )  ) ;^539^^^^^503^622^[REPLACE] parent.replaceChild ( n, NodeUtil.newExpr ( cond )  ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^return false;^545^^^^^503^622^[REPLACE] return true;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^NodeUtil.removeChild ( parent, thenStmt ) ;^542^^^^^536^543^[REPLACE] NodeUtil.removeChild ( parent, n ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[ADD]^parent.replaceChild ( n, NodeUtil.newExpr ( cond )  ) ;^538^539^^^^503^622^[ADD] n.removeChild ( cond ) ; parent.replaceChild ( n, NodeUtil.newExpr ( cond )  ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^newExpr ( cond )  ;^539^^^^^503^622^[REPLACE] parent.replaceChild ( n, NodeUtil.newExpr ( cond )  ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^elseBody = false;^515^^^^^503^622^[REPLACE] elseBody = null;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[ADD]^^517^^^^^503^622^[ADD] changes = true;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^cond =  null;^527^^^^^503^622^[REPLACE] cond = notCond;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^thenBody =  thenStmt.getNext (  ) ;^528^^^^^503^622^[REPLACE] thenBody = cond.getNext (  ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^Node and = new Node ( AND, cond, expr.removeFirstChild (  )  )  ;^524^^^^^503^622^[REPLACE] Node notCond = new Node ( Token.NOT ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^} else if   (  !NodeUtil.mayHaveSideEffects  (  elseBody  )    )   {  ;^513^^^^^503^622^[REPLACE] if  ( elseBody != null && !NodeUtil.mayHaveSideEffects ( elseBody )  )  {^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^cond =  thenBody;^527^^^^^503^622^[REPLACE] cond = notCond;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[ADD]^^528^^^^^503^622^[ADD] thenBody = cond.getNext (  ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^elseBody = false;^529^^^^^503^622^[REPLACE] elseBody = null;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[ADD]^^531^^^^^503^622^[ADD] changes = true;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^if  ( !NodeUtil.tryMergeBlock ( thenBody )  ) {^535^^^^^503^622^[REPLACE] if  ( !NodeUtil.mayHaveSideEffects ( thenBody )  && elseBody == null )  {^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[ADD]^^535^536^^538^539^503^622^[ADD] if  ( !NodeUtil.mayHaveSideEffects ( thenBody )  && elseBody == null )  { if  ( NodeUtil.mayHaveSideEffects ( cond )  )  { n.removeChild ( cond ) ; parent.replaceChild ( n, NodeUtil.newExpr ( cond )  ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^if  ( NodeUtil .mayEffectMutableState ( elseBody )   )  {^536^^^^^503^622^[REPLACE] if  ( NodeUtil.mayHaveSideEffects ( cond )  )  {^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^parent.replaceChild ( n, NodeUtil.isGetProp ( thenStmt )  ) ;^539^^^^^503^622^[REPLACE] parent.replaceChild ( n, NodeUtil.newExpr ( cond )  ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^parent.replaceChild ( n, newExpr ( cond )  )  ;^539^^^^^503^622^[REPLACE] parent.replaceChild ( n, NodeUtil.newExpr ( cond )  ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REMOVE]^checkState ( isVarBlock ( n )  )  ;^539^^^^^503^622^[REMOVE] ^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^getStringValue ( right )  ;^542^^^^^536^543^[REPLACE] NodeUtil.removeChild ( parent, n ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^n.removeChild ( thenStmt ) ;^538^^^^^503^622^[REPLACE] n.removeChild ( cond ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[ADD]^^538^^^^^503^622^[ADD] n.removeChild ( cond ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^if   (  n.getChildCount  (    )   < 3  )   return true;  ;^549^^^^^503^622^[REPLACE] if  ( NodeUtil.isExpressionNode ( parent )  )  {^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[ADD]^^549^550^551^^553^503^622^[ADD] if  ( NodeUtil.isExpressionNode ( parent )  )  {  if  ( !NodeUtil.mayHaveSideEffects ( thenBody )  )  { Node ifNode = new Node ( Token.IF ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^if  ( NodeUtil.mayHaveSideEffects ( thenBody )  )  {^551^^^^^503^622^[REPLACE] if  ( !NodeUtil.mayHaveSideEffects ( thenBody )  )  {^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^}  if  ( NodeUtil.mayHaveSideEffects ( Body )  )  {^571^^^^^503^622^[REPLACE] } else if  ( !NodeUtil.mayHaveSideEffects ( elseBody )  )  {^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[ADD]^}   Node ifNode = new Node ( Token.IF ) ;n.removeChild ( cond ) ;ifNode.addChildToBack ( cond ) ;^571^572^573^574^575^503^622^[ADD] else if  ( !NodeUtil.mayHaveSideEffects ( elseBody )  )  {  Node ifNode = new Node ( Token.IF ) ; n.removeChild ( cond ) ; ifNode.addChildToBack ( cond ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^return false;^582^^^^^503^622^[REPLACE] return true;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^Node notCond = new Node ( NOT )  ;^573^^^^^503^622^[REPLACE] Node ifNode = new Node ( Token.IF ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^if   (  first.getType  (    )   == Token.RETURN  )   {  ;^554^^^^^503^622^[REPLACE] if  ( cond.getType (  )  == Token.NOT )  {^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^Node expr = parent.getFirstChild (  ) ;^555^^^^^503^622^[REPLACE] Node expr = cond.getFirstChild (  ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^return false;^570^^^^^503^622^[REPLACE] return true;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[ADD]^^553^554^555^556^557^503^622^[ADD] Node ifNode = new Node ( Token.IF ) ; if  ( cond.getType (  )  == Token.NOT )  { Node expr = cond.getFirstChild (  ) ; cond.removeChild ( expr ) ; ifNode.addChildToBack ( expr ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^Node arrayNode = left.getFirstChild (  )  ;^555^^^^^503^622^[REPLACE] Node expr = cond.getFirstChild (  ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[ADD]^^559^^^^^503^622^[ADD] Node not = new Node ( Token.NOT ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[ADD]^^559^^^^^554^563^[ADD] Node not = new Node ( Token.NOT ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^Node expr = thenStmt .getLastChild (  )  ;^555^^^^^503^622^[REPLACE] Node expr = cond.getFirstChild (  ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^Node notCond = new Node ( NOT )  ;^553^^^^^503^622^[REPLACE] Node ifNode = new Node ( Token.IF ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^Node notCond = new Node ( NOT )  ;^559^^^^^503^622^[REPLACE] Node not = new Node ( Token.NOT ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REMOVE]^if  (  ( thenOp.getType (  )  )  ==  ( elseOp.getType (  )  )  )  {     if  ( isAssignmentOp ( thenOp )  )  {         Node lhs = thenOp.getFirstChild (  ) ;         if  (  ( lhs.checkTreeEqualsSilent ( elseOp.getFirstChild (  )  )  )  &&  ( ! ( mayEffectMutableState ( lhs )  )  )  )  {             n.removeChild ( cond ) ;             Node assignName = thenOp.removeFirstChild (  ) ;             Node thenExpr = thenOp.removeFirstChild (  ) ;             Node elseExpr = elseOp.getLastChild (  ) ;             elseOp.removeChild ( elseExpr ) ;             Node hookNode = new Node ( HOOK, cond, thenExpr, elseExpr ) ;             Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;             Node expr = newExpr ( assign ) ;             parent.replaceChild ( n, expr ) ;             t.getCompiler (  ) .reportCodeChange (  ) ;         }     }else         if  ( isCall ( thenOp )  )  {             n.removeChild ( cond ) ;             thenOp.detachFromParent (  ) ;             elseOp.detachFromParent (  ) ;             Node hookNode = new Node ( HOOK, cond, thenOp, elseOp ) ;             Node expr = newExpr ( hookNode ) ;             parent.replaceChild ( n, expr ) ;             t.getCompiler (  ) .reportCodeChange (  ) ;         }      }^551^^^^^503^622^[REMOVE] ^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^}  if  ( !NodeUtil.mayHaveSideEffects ( Body )  )  {^571^^^^^503^622^[REPLACE] } else if  ( !NodeUtil.mayHaveSideEffects ( elseBody )  )  {^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^return true;  ;^582^^^^^503^622^[REPLACE] return true;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[ADD]^n.removeChild ( cond ) ;ifNode.addChildToBack ( cond ) ;n.removeChild ( thenBody ) ;^573^574^575^576^^503^622^[ADD] Node ifNode = new Node ( Token.IF ) ; n.removeChild ( cond ) ; ifNode.addChildToBack ( cond ) ; n.removeChild ( thenBody ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^if  ( cond .setType ( newType )    ) {^554^^^^^503^622^[REPLACE] if  ( cond.getType (  )  == Token.NOT )  {^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[ADD]^^554^555^556^557^^503^622^[ADD] if  ( cond.getType (  )  == Token.NOT )  { Node expr = cond.getFirstChild (  ) ; cond.removeChild ( expr ) ; ifNode.addChildToBack ( expr ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[ADD]^^555^^^^^503^622^[ADD] Node expr = cond.getFirstChild (  ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^Node expr = cond.getLastChild (  ) ;^555^^^^^503^622^[REPLACE] Node expr = cond.getFirstChild (  ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^if  ( cond.getType (  )   &&  Token.NOT )  {^554^^^^^503^622^[REPLACE] if  ( cond.getType (  )  == Token.NOT )  {^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^Node expr = thenStmt.getFirstChild (  ) ;^555^^^^^503^622^[REPLACE] Node expr = cond.getFirstChild (  ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^thenBody =  secondBranch.getNext (  ) ;^528^^^^^503^622^[REPLACE] thenBody = cond.getNext (  ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^elseBody = true;^529^^^^^503^622^[REPLACE] elseBody = null;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^if  ( !NodeUtil.isImmutableValue ( cond )  )  {^588^^^^^503^622^[REPLACE] if  ( !NodeUtil.isLiteralValue ( cond )  )  {^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^return true;^589^^^^^503^622^[REPLACE] return changes;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^boolean thenBodyTrue = NodeUtil.getBooleanValue ( cond ) ;^592^^^^^503^622^[REPLACE] boolean condTrue = NodeUtil.getBooleanValue ( cond ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^if   (  n.getChildCount  (    )   != 4  )   return;  ;^594^^^^^503^622^[REPLACE] if  ( n.getChildCount (  )  == 2 )  {^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^Node arrayNode = left.getFirstChild (  )  ;^612^^^^^594^620^[REPLACE] Node firstBranch = n.getFirstChild (  ) .getNext (  ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^Node secondBranch = secondBranch.getParent (  ) ;^613^^^^^594^620^[REPLACE] Node secondBranch = firstBranch.getNext (  ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^Node branch = condTrue ? notBranch : secondBranch;^614^^^^^594^620^[REPLACE] Node branch = condTrue ? firstBranch : secondBranch;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^Node notBranch = condTrue ? secondBranch : secondBranch;^615^^^^^594^620^[REPLACE] Node notBranch = condTrue ? secondBranch : firstBranch;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^if   (  n.getChildCount  (    )   < 3  )   return true;  ;^597^^^^^503^622^[REPLACE] if  ( condTrue )  {^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^NodeUtil .precedence (  )  ;^605^^^^^597^608^[REPLACE] NodeUtil.redeclareVarsInsideBranch ( n ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^NodeUtil.removeChild ( thenStmt, n ) ;^606^^^^^597^608^[REPLACE] NodeUtil.removeChild ( parent, n ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^compiler.reportCodeChange (  )  ;^607^^^^^597^608^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^t .getScope (  )  .reportCodeChange (  ) ;^607^^^^^597^608^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^Node thenStmt = n.getFirstChild (  )  .getParent (  )  ;^599^^^^^503^622^[REPLACE] Node thenStmt = n.getFirstChild (  ) .getNext (  ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^Node thenStmt = thenStmt.getFirstChild (  ) .getNext (  ) ;^599^^^^^503^622^[REPLACE] Node thenStmt = n.getFirstChild (  ) .getNext (  ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^NodeUtil.isExpressionNode ( n ) ;^605^^^^^597^608^[REPLACE] NodeUtil.redeclareVarsInsideBranch ( n ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^NodeUtil.removeChild ( thenBody, n ) ;^606^^^^^597^608^[REPLACE] NodeUtil.removeChild ( parent, n ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[ADD]^^607^^^^^597^608^[ADD] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^t.getScope (  )  ;^607^^^^^597^608^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^Node arrayNode = left.getFirstChild (  )  ;^599^^^^^503^622^[REPLACE] Node thenStmt = n.getFirstChild (  ) .getNext (  ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[ADD]^^599^^^^^503^622^[ADD] Node thenStmt = n.getFirstChild (  ) .getNext (  ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[ADD]^^612^^^^^503^622^[ADD] Node firstBranch = n.getFirstChild (  ) .getNext (  ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^Node secondBranch = thenStmt.getNext (  ) ;^613^^^^^503^622^[REPLACE] Node secondBranch = firstBranch.getNext (  ) ;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^Node branch = true ? firstBranch : secondBranch;^614^^^^^503^622^[REPLACE] Node branch = condTrue ? firstBranch : secondBranch;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^Node notBranch = true ? secondBranch : firstBranch;^615^^^^^503^622^[REPLACE] Node notBranch = condTrue ? secondBranch : firstBranch;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^return false;^621^^^^^503^622^[REPLACE] return true;^[METHOD] tryFoldHookIf [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean changes  condTrue  false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type 
[REPLACE]^Node parentotChild = n.getFirstChild (  ) ;^628^^^^^627^653^[REPLACE] Node notChild = n.getFirstChild (  ) ;^[METHOD] tryMinimizeNot [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  newOperator  notChild  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^630^^^^^627^653^[ADD] int complementOperator;^[METHOD] tryMinimizeNot [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  newOperator  notChild  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^complementOperator = EQ  ;^633^^^^^627^653^[REPLACE] complementOperator = Token.NE;^[METHOD] tryMinimizeNot [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  newOperator  notChild  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^complementOperator = NE  ;^636^^^^^627^653^[REPLACE] complementOperator = Token.EQ;^[METHOD] tryMinimizeNot [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  newOperator  notChild  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^complementOperator = NE  ;^639^^^^^627^653^[REPLACE] complementOperator = Token.SHNE;^[METHOD] tryMinimizeNot [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  newOperator  notChild  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^642^643^^^^627^653^[ADD] complementOperator = Token.SHEQ; break;^[METHOD] tryMinimizeNot [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  newOperator  notChild  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^return true;^646^^^^^627^653^[REPLACE] return false;^[METHOD] tryMinimizeNot [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  newOperator  notChild  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node parentewOperator = n .getFirstChild (  )  ;^648^^^^^627^653^[REPLACE] Node newOperator = n.removeFirstChild (  ) ;^[METHOD] tryMinimizeNot [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  newOperator  notChild  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^newOperator.setType ( type ) ;^649^^^^^627^653^[REPLACE] newOperator.setType ( complementOperator ) ;^[METHOD] tryMinimizeNot [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  newOperator  notChild  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^649^^^^^627^653^[ADD] newOperator.setType ( complementOperator ) ;^[METHOD] tryMinimizeNot [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  newOperator  notChild  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^parent.addChildAfter ( n, newOperator ) ;^650^^^^^627^653^[REPLACE] parent.replaceChild ( n, newOperator ) ;^[METHOD] tryMinimizeNot [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  newOperator  notChild  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^t.getScope (  ) .reportCodeChange (  ) ;^651^^^^^627^653^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryMinimizeNot [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  newOperator  notChild  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^t.getScope (  )  ;^651^^^^^627^653^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryMinimizeNot [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  newOperator  notChild  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^return true;  ;^652^^^^^627^653^[REPLACE] return true;^[METHOD] tryMinimizeNot [TYPE] boolean [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  newOperator  notChild  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node arrayNode = left.getFirstChild (  )  ;^659^^^^^658^832^[REPLACE] Node cond = n.getFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node thenBranch = thenOp.getNext (  ) ;^660^^^^^658^832^[REPLACE] Node thenBranch = cond.getNext (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node maybeName1 = thenAssign.getFirstChild (  )  ;^661^^^^^658^832^[REPLACE] Node elseBranch = thenBranch.getNext (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^if  ( Branch !=name1 )  {^663^^^^^658^832^[REPLACE] if  ( elseBranch == null )  {^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REMOVE]^if  (  ( thenOp.getType (  )  )  ==  ( elseOp.getType (  )  )  )  {     if  ( isAssignmentOp ( thenOp )  )  {         Node lhs = thenOp.getFirstChild (  ) ;         if  (  ( lhs.checkTreeEqualsSilent ( elseOp.getFirstChild (  )  )  )  &&  ( ! ( mayEffectMutableState ( lhs )  )  )  )  {             n.removeChild ( cond ) ;             Node assignName = thenOp.removeFirstChild (  ) ;             Node thenExpr = thenOp.removeFirstChild (  ) ;             Node elseExpr = elseOp.getLastChild (  ) ;             elseOp.removeChild ( elseExpr ) ;             Node hookNode = new Node ( HOOK, cond, thenExpr, elseExpr ) ;             Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;             Node expr = newExpr ( assign ) ;             parent.replaceChild ( n, expr ) ;             t.getCompiler (  ) .reportCodeChange (  ) ;         }     }else         if  ( isCall ( thenOp )  )  {             n.removeChild ( cond ) ;             thenOp.detachFromParent (  ) ;             elseOp.detachFromParent (  ) ;             Node hookNode = new Node ( HOOK, cond, thenOp, elseOp ) ;             Node expr = newExpr ( hookNode ) ;             parent.replaceChild ( n, expr ) ;             t.getCompiler (  ) .reportCodeChange (  ) ;         }      }^663^^^^^658^832^[REMOVE] ^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^if   (  n.getChildCount  (    )   < 3  )   return true;  ;^664^^^^^658^832^[REPLACE] if  ( isExpressBlock ( thenBranch )  )  {^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^if  ( isPropertyAssignmentInExpression ( t, var )  )  {^666^^^^^658^832^[REPLACE] if  ( isPropertyAssignmentInExpression ( t, expr )  )  {^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^return;  ;^669^^^^^658^832^[REPLACE] return;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^if  ( cond.getType (  )   &&  Token.NOT )  {^672^^^^^658^832^[REPLACE] if  ( cond.getType (  )  == Token.NOT )  {^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^if  ( isLowerPrecedenceInExpression ( t, cond,true )  || isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) ,true )  )  {^674^675^676^^^658^832^[REPLACE] if  ( isLowerPrecedenceInExpression ( t, cond, OR_PRECEDENCE )  && isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^return;  ;^678^^^^^674^679^[REPLACE] return;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^return;  ;^678^^^^^658^832^[REPLACE] return;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^return;  ;^687^^^^^658^832^[REPLACE] return;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node or = new Node ( Token.OR, cond .getFirstChild (  )  , var^681^682^^^^658^832^[REPLACE] Node or = new Node ( Token.OR, cond.removeFirstChild (  ) , expr.removeFirstChild (  )  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^683^^^^^658^832^[ADD] Node newExpr = NodeUtil.newExpr ( or ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^if  ( isLowerPrecedenceInExpression ( t, cond, OR_PRECEDENCE )  || isLowerPrecedenceInExpression ( t, expr.getLastChild (  ) , OR_PRECEDENCE )  )  {^674^675^676^^^658^832^[REPLACE] if  ( isLowerPrecedenceInExpression ( t, cond, OR_PRECEDENCE )  && isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^if  ( isLowerPrecedenceInExpression ( t, cond, AND_PRECEDENCE )  && isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , AND_PRECEDENCE )  )  {^691^692^693^^^658^832^[REPLACE] if  ( isLowerPrecedenceInExpression ( t, cond, AND_PRECEDENCE )  || isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , AND_PRECEDENCE )  )  {^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^691^692^693^^695^658^832^[ADD] if  ( isLowerPrecedenceInExpression ( t, cond, AND_PRECEDENCE )  || isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , AND_PRECEDENCE )  )  { return;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^return;  ;^695^^^^^691^696^[REPLACE] return;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^return;  ;^695^^^^^658^832^[REPLACE] return;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^665^^^^^658^832^[ADD] Node expr = getBlockExpression ( thenBranch ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node or = new Node ( Token.OR, cond.removeFirstChild (  ) , var.removeFirstChild (  )  ) ;^681^682^^^^658^832^[REPLACE] Node or = new Node ( Token.OR, cond.removeFirstChild (  ) , expr.removeFirstChild (  )  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node.isGetProp = NodeUtil.newExpr ( var ) ;^683^^^^^658^832^[REPLACE] Node newExpr = NodeUtil.newExpr ( or ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^699^700^^^^658^832^[ADD] Node and = new Node ( Token.AND, cond, expr.removeFirstChild (  )  ) ; Node newExpr = NodeUtil.newExpr ( and ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node newExpr = NodeUtil.newExpr ( thenOp ) ;^700^^^^^658^832^[REPLACE] Node newExpr = NodeUtil.newExpr ( and ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^if   (  n.getChildCount  (    )   < 3  )   return true;  ;^666^^^^^658^832^[REPLACE] if  ( isPropertyAssignmentInExpression ( t, expr )  )  {^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^666^667^^669^670^658^832^[ADD] if  ( isPropertyAssignmentInExpression ( t, expr )  )  {  return; }^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^if  ( cond.getType (  )   ) {^672^^^^^658^832^[REPLACE] if  ( cond.getType (  )  == Token.NOT )  {^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^if  ( isLowerPrecedenceInExpression ( t, cond, OR_PRECEDENCE )  ) {^674^675^676^^^658^832^[REPLACE] if  ( isLowerPrecedenceInExpression ( t, cond, OR_PRECEDENCE )  && isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node newExpr = NodeUtil.newExpr ( var ) ;^683^^^^^658^832^[REPLACE] Node newExpr = NodeUtil.newExpr ( or ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^if  ( isLowerPrecedenceInExpression ( t, cond, OR_PRECEDENCE )  || isLowerPrecedenceInExpression ( t, var.getFirstChild (  ) , OR_PRECEDENCE )  )  {^674^675^676^^^658^832^[REPLACE] if  ( isLowerPrecedenceInExpression ( t, cond, OR_PRECEDENCE )  && isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^if  (  isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , AND_PRECEDENCE )  )  {^691^692^693^^^658^832^[REPLACE] if  ( isLowerPrecedenceInExpression ( t, cond, AND_PRECEDENCE )  || isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , AND_PRECEDENCE )  )  {^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^return;  ;^705^^^^^658^832^[REPLACE] return;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node expr = getBlockExpression ( or ) ;^665^^^^^658^832^[REPLACE] Node expr = getBlockExpression ( thenBranch ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node or = new Node ( Token.OR, cond.removeFirstChild (  ) , thenOp.removeFirstChild (  )  ) ;^681^682^^^^658^832^[REPLACE] Node or = new Node ( Token.OR, cond.removeFirstChild (  ) , expr.removeFirstChild (  )  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node newExpr = NodeUtil .isGetProp ( elseExpr )  ;^683^^^^^658^832^[REPLACE] Node newExpr = NodeUtil.newExpr ( or ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node and = new Node ( Token.AND, cond, var.removeFirstChild (  )  ) ;^699^^^^^658^832^[REPLACE] Node and = new Node ( Token.AND, cond, expr.removeFirstChild (  )  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node newExpr = NodeUtil.newExpr ( thenExpr ) ;^700^^^^^658^832^[REPLACE] Node newExpr = NodeUtil.newExpr ( and ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^672^673^674^675^^658^832^[ADD] if  ( cond.getType (  )  == Token.NOT )  {  if  ( isLowerPrecedenceInExpression ( t, cond, OR_PRECEDENCE )  && isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) ,^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^674^675^676^^678^658^832^[ADD] if  ( isLowerPrecedenceInExpression ( t, cond, OR_PRECEDENCE )  && isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  { return;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node or = new Node ( Token.OR, thenOp.removeFirstChild (  ) , expr.removeFirstChild (  )  ) ;^681^682^^^^658^832^[REPLACE] Node or = new Node ( Token.OR, cond.removeFirstChild (  ) , expr.removeFirstChild (  )  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node newExpr = NodeUtil .isGetProp ( expr )  ;^683^^^^^658^832^[REPLACE] Node newExpr = NodeUtil.newExpr ( or ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^if  ( isLowerPrecedenceInExpression ( t, cond, OR_PRECEDENCE )  || isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^674^675^676^^^658^832^[REPLACE] if  ( isLowerPrecedenceInExpression ( t, cond, OR_PRECEDENCE )  && isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node elseExpr = getBlockReturnExpression ( elseBranch )  ;^665^^^^^658^832^[REPLACE] Node expr = getBlockExpression ( thenBranch ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node or = new Node ( Token.OR, cond.getFirstChild (  ) , expr.removeFirstChild (  )  ) ;^681^682^^^^658^832^[REPLACE] Node or = new Node ( Token.OR, cond.removeFirstChild (  ) , expr.removeFirstChild (  )  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node and = new Node ( Token.AND, thenOp, expr.getFirstChild (  )  ) ;^699^^^^^658^832^[REPLACE] Node and = new Node ( Token.AND, cond, expr.removeFirstChild (  )  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^700^^^^^658^832^[ADD] Node newExpr = NodeUtil.newExpr ( and ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^if  (   Token.NOT )  {^672^^^^^658^832^[REPLACE] if  ( cond.getType (  )  == Token.NOT )  {^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^if  ( isLowerPrecedenceInExpression ( t, cond,true )  || isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^674^675^676^^^658^832^[REPLACE] if  ( isLowerPrecedenceInExpression ( t, cond, OR_PRECEDENCE )  && isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node or = new Node ( Token.OR, thenOp .getFirstChild (  )  , expr^681^682^^^^658^832^[REPLACE] Node or = new Node ( Token.OR, cond.removeFirstChild (  ) , expr.removeFirstChild (  )  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node expr = newExpr ( hookNode )  ;^683^^^^^658^832^[REPLACE] Node newExpr = NodeUtil.newExpr ( or ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^if  ( isLowerPrecedenceInExpression ( t, cond,true )  && isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , AND_PRECEDENCE )  )  {^691^692^693^^^658^832^[REPLACE] if  ( isLowerPrecedenceInExpression ( t, cond, AND_PRECEDENCE )  || isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , AND_PRECEDENCE )  )  {^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node or = new Node ( Token.OR, thenOp.getFirstChild (  ) , expr.removeFirstChild (  )  ) ;^681^682^^^^658^832^[REPLACE] Node or = new Node ( Token.OR, cond.removeFirstChild (  ) , expr.removeFirstChild (  )  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node and = new Node ( Token.AND, cond, var .getFirstChild (  )   ) ;^699^^^^^658^832^[REPLACE] Node and = new Node ( Token.AND, cond, expr.removeFirstChild (  )  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^checkState ( isVarBlock ( n )  )  ;^708^^^^^658^832^[REPLACE] tryRemoveRepeatedStatements ( t, n ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^if  ( cond.setType (  )  == Token.NOT && consumesDanglingElse ( Branch )  )  {^712^^^^^658^832^[REPLACE] if  ( cond.getType (  )  == Token.NOT && !consumesDanglingElse ( elseBranch )  )  {^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^return;  ;^717^^^^^658^832^[REPLACE] return;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^if  ( isReturnExpressBlock ( thenBranch )  || isReturnExpressBlock (  else {^721^^^^^658^832^[REPLACE] if  ( isReturnExpressBlock ( thenBranch )  && isReturnExpressBlock ( elseBranch )  )  {^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^Node thenExpr = getBlockReturnExpression ( thenBranch ) ;Node elseExpr = getBlockReturnExpression ( elseBranch ) ;n.removeChild ( cond ) ;thenExpr.detachFromParent (  ) ;^721^722^723^724^725^658^832^[ADD] if  ( isReturnExpressBlock ( thenBranch )  && isReturnExpressBlock ( elseBranch )  )  { Node thenExpr = getBlockReturnExpression ( thenBranch ) ; Node elseExpr = getBlockReturnExpression ( elseBranch ) ; n.removeChild ( cond ) ; thenExpr.detachFromParent (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^return;  ;^735^^^^^658^832^[REPLACE] return;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^722^^^^^658^832^[ADD] Node thenExpr = getBlockReturnExpression ( thenBranch ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node elseExpr = getBlockReturnExpression ( var ) ;^723^^^^^658^832^[REPLACE] Node elseExpr = getBlockReturnExpression ( elseBranch ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node notCond = new Node ( NOT )  ;^731^^^^^658^832^[REPLACE] Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node notCond = new Node ( NOT )  ;^732^^^^^658^832^[REPLACE] Node returnNode = new Node ( Token.RETURN, hookNode ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node elseExpr = getBlockReturnExpression ( newExpr ) ;^723^^^^^658^832^[REPLACE] Node elseExpr = getBlockReturnExpression ( elseBranch ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node hookNode = new Node ( Token.HOOK, cond, name2, elseExpr ) ;^731^^^^^658^832^[REPLACE] Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node returnNode = new Node ( Token.RETURN, thenOp ) ;^732^^^^^658^832^[REPLACE] Node returnNode = new Node ( Token.RETURN, hookNode ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^boolean varIsExpressionBlock = isExpressBlock ( thenBranch ) ;^738^^^^^658^832^[REPLACE] boolean thenBranchIsExpressionBlock = isExpressBlock ( thenBranch ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^boolean varIsExpressionBlock = isExpressBlock ( elseBranch ) ;^739^^^^^658^832^[REPLACE] boolean elseBranchIsExpressionBlock = isExpressBlock ( elseBranch ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^if  (true ) { else {^741^^^^^658^832^[REPLACE] if  ( thenBranchIsExpressionBlock && elseBranchIsExpressionBlock )  {^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REMOVE]^if  (  ( thenOp.getType (  )  )  ==  ( elseOp.getType (  )  )  )  {     if  ( isAssignmentOp ( thenOp )  )  {         Node lhs = thenOp.getFirstChild (  ) ;         if  (  ( lhs.checkTreeEqualsSilent ( elseOp.getFirstChild (  )  )  )  &&  ( ! ( mayEffectMutableState ( lhs )  )  )  )  {             n.removeChild ( cond ) ;             Node assignName = thenOp.removeFirstChild (  ) ;             Node thenExpr = thenOp.removeFirstChild (  ) ;             Node elseExpr = elseOp.getLastChild (  ) ;             elseOp.removeChild ( elseExpr ) ;             Node hookNode = new Node ( HOOK, cond, thenExpr, elseExpr ) ;             Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;             Node expr = newExpr ( assign ) ;             parent.replaceChild ( n, expr ) ;             t.getCompiler (  ) .reportCodeChange (  ) ;         }     }else         if  ( isCall ( thenOp )  )  {             n.removeChild ( cond ) ;             thenOp.detachFromParent (  ) ;             elseOp.detachFromParent (  ) ;             Node hookNode = new Node ( HOOK, cond, thenOp, elseOp ) ;             Node expr = newExpr ( hookNode ) ;             parent.replaceChild ( n, expr ) ;             t.getCompiler (  ) .reportCodeChange (  ) ;         }      }^741^^^^^658^832^[REMOVE] ^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^if  ( thenOp.getType (  )   ||   else {^744^^^^^658^832^[REPLACE] if  ( thenOp.getType (  )  == elseOp.getType (  )  )  {^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^if   (  n.getChildCount  (    )   < 3  )   return true;  ;^746^^^^^658^832^[REPLACE] if  ( NodeUtil.isAssignmentOp ( thenOp )  )  {^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^}  else {^769^^^^^658^832^[REPLACE] } else if  ( NodeUtil.isCall ( thenOp )  )  {^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^}   n.removeChild ( cond ) ;thenOp.detachFromParent (  ) ;elseOp.detachFromParent (  ) ;^769^770^771^772^773^658^832^[ADD] else if  ( NodeUtil.isCall ( thenOp )  )  {  n.removeChild ( cond ) ; thenOp.detachFromParent (  ) ; elseOp.detachFromParent (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^Node expr = NodeUtil.newExpr ( hookNode ) ;parent.replaceChild ( n, expr ) ;t.getCompiler (  ) .reportCodeChange (  ) ;^774^775^776^777^778^658^832^[ADD] Node hookNode = new Node ( Token.HOOK, cond, thenOp, elseOp ) ; Node expr = NodeUtil.newExpr ( hookNode ) ; parent.replaceChild ( n, expr ) ; t.getCompiler (  ) .reportCodeChange (  ) ; }^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node expr = NodeUtil.isGetProp ( hookNode ) ;^775^^^^^658^832^[REPLACE] Node expr = NodeUtil.newExpr ( hookNode ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^774^775^776^777^778^658^832^[ADD] Node hookNode = new Node ( Token.HOOK, cond, thenOp, elseOp ) ; Node expr = NodeUtil.newExpr ( hookNode ) ; parent.replaceChild ( n, expr ) ; t.getCompiler (  ) .reportCodeChange (  ) ; }^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node newExpr = newExpr ( and )  ;^775^^^^^658^832^[REPLACE] Node expr = NodeUtil.newExpr ( hookNode ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^if  ( lhs.checkTreeEqualsSilent ( Op.getFirstChild (  )  )  ||^748^749^750^751^^658^832^[REPLACE] if  ( lhs.checkTreeEqualsSilent ( elseOp.getFirstChild (  )  )  &&^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node assignName = thenOp .getFirstChild (  )  ;^756^^^^^748^768^[REPLACE] Node assignName = thenOp.removeFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node thenExpr = newExpr.removeFirstChild (  ) ;^757^^^^^748^768^[REPLACE] Node thenExpr = thenOp.removeFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^elseOp.removeChild ( elseExpr ) ;elseExpr ) ;^758^759^^761^762^748^768^[ADD] Node elseExpr = elseOp.getLastChild (  ) ; elseOp.removeChild ( elseExpr ) ; Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, var ) ;^761^762^^^^748^768^[REPLACE] Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node assign = new Node ( thenOp.getNext (  ) , assignName, thenBranch ) ;^763^764^^^^748^768^[REPLACE] Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node expr = newExpr ( hookNode )  ;^765^^^^^748^768^[REPLACE] Node expr = NodeUtil.newExpr ( assign ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^747^^^^^658^832^[ADD] Node lhs = thenOp.getFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node arrayNode = left.getFirstChild (  )  ;^756^^^^^658^832^[REPLACE] Node assignName = thenOp.removeFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^757^758^^^^658^832^[ADD] Node thenExpr = thenOp.removeFirstChild (  ) ; Node elseExpr = elseOp.getLastChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node arrayNode = left.getFirstChild (  )  ;^758^^^^^658^832^[REPLACE] Node elseExpr = elseOp.getLastChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, var ) ;^761^762^^^^658^832^[REPLACE] Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node assign = new Node ( thenAssign .setType ( result )  , assignName, hookNode ) ;^763^764^^^^658^832^[REPLACE] Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node expr = newExpr ( hookNode )  ;^765^^^^^658^832^[REPLACE] Node expr = NodeUtil.newExpr ( assign ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node assignName = or.removeFirstChild (  ) ;^756^^^^^748^768^[REPLACE] Node assignName = thenOp.removeFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node thenExpr = thenExpr.removeFirstChild (  ) ;^757^^^^^748^768^[REPLACE] Node thenExpr = thenOp.removeFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node elseExpr = newExpr.getLastChild (  ) ;^758^^^^^748^768^[REPLACE] Node elseExpr = elseOp.getLastChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, or ) ;^761^762^^^^748^768^[REPLACE] Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^763^764^^^^748^768^[ADD] Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^if   (  n.getChildCount  (    )   < 3  )   return true;  ;^769^^^^^658^832^[REPLACE] } else if  ( NodeUtil.isCall ( thenOp )  )  {^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node notCond = new Node ( NOT )  ;^774^^^^^658^832^[REPLACE] Node hookNode = new Node ( Token.HOOK, cond, thenOp, elseOp ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node expr = NodeUtil.isGetProp ( thenBranch ) ;^775^^^^^658^832^[REPLACE] Node expr = NodeUtil.newExpr ( hookNode ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node thenExpr = thenOp .getFirstChild (  )  ;^757^^^^^658^832^[REPLACE] Node thenExpr = thenOp.removeFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node elseExpr = thenOp.getLastChild (  ) ;^758^^^^^658^832^[REPLACE] Node elseExpr = elseOp.getLastChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^761^762^^^^658^832^[ADD] Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node assign = new Node ( thenOp.getType (  ) , assignName, thenBranch ) ;^763^764^^^^658^832^[REPLACE] Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^765^^^^^658^832^[ADD] Node expr = NodeUtil.newExpr ( assign ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^775^^^^^658^832^[ADD] Node expr = NodeUtil.newExpr ( hookNode ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node hookNode = new Node ( Token.HOOK, cond, thenOp, newExpr ) ;^774^^^^^658^832^[REPLACE] Node hookNode = new Node ( Token.HOOK, cond, thenOp, elseOp ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node expr = NodeUtil.newExpr ( thenOp ) ;^775^^^^^658^832^[REPLACE] Node expr = NodeUtil.newExpr ( hookNode ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node hookNode = new Node ( Token.HOOK, cond, thenOp, thenExpr ) ;^774^^^^^658^832^[REPLACE] Node hookNode = new Node ( Token.HOOK, cond, thenOp, elseOp ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^748^749^^^^658^832^[ADD] if  ( lhs.checkTreeEqualsSilent ( elseOp.getFirstChild (  )  )  &&^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node arrayNode = left.getFirstChild (  )  ;^756^^^^^748^768^[REPLACE] Node assignName = thenOp.removeFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^Node elseExpr = elseOp.getLastChild (  ) ;^757^758^^^^748^768^[ADD] Node thenExpr = thenOp.removeFirstChild (  ) ; Node elseExpr = elseOp.getLastChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node elseExpr = thenOp.getLastChild (  ) ;^758^^^^^748^768^[REPLACE] Node elseExpr = elseOp.getLastChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, parent ) ;^761^762^^^^748^768^[REPLACE] Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node assign = new Node ( thenOp.getType (  ) , var, hookNode ) ;^763^764^^^^748^768^[REPLACE] Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node expr = NodeUtil.newExpr ( thenBranch ) ;^765^^^^^748^768^[REPLACE] Node expr = NodeUtil.newExpr ( assign ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node lhs = or.getFirstChild (  ) ;^747^^^^^658^832^[REPLACE] Node lhs = thenOp.getFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node assignName = or.removeFirstChild (  ) ;^756^^^^^658^832^[REPLACE] Node assignName = thenOp.removeFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node arrayNode = left.getFirstChild (  )  ;^757^^^^^658^832^[REPLACE] Node thenExpr = thenOp.removeFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node elseExpr = elseOp.getFirstChild (  ) ;^758^^^^^658^832^[REPLACE] Node elseExpr = elseOp.getLastChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node hookNode = new Node ( Token.HOOK, thenOp, thenExpr, elseExpr ) ;^761^762^^^^658^832^[REPLACE] Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node assign = new Node ( thenBranch.getType (  ) , assignName, hookNode ) ;^763^764^^^^658^832^[REPLACE] Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^756^^^^^748^768^[ADD] Node assignName = thenOp.removeFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node thenExpr = thenOp .getFirstChild (  )  ;^757^^^^^748^768^[REPLACE] Node thenExpr = thenOp.removeFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node elseExpr = returnNode.getLastChild (  ) ;^758^^^^^748^768^[REPLACE] Node elseExpr = elseOp.getLastChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^761^762^^^^748^768^[ADD] Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node assign = new Node ( thenAssign.getNext (  ) , assignName, hookNode ) ;^763^764^^^^748^768^[REPLACE] Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^765^^^^^748^768^[ADD] Node expr = NodeUtil.newExpr ( assign ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node hookNode = new Node ( Token.HOOK, thenExpr, thenOp, elseOp ) ;^774^^^^^658^832^[REPLACE] Node hookNode = new Node ( Token.HOOK, cond, thenOp, elseOp ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^return;  ;^780^^^^^658^832^[REPLACE] return;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^742^743^^^^658^832^[ADD] Node thenOp = getBlockExpression ( thenBranch ) .getFirstChild (  ) ; Node elseOp = getBlockExpression ( elseBranch ) .getFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^743^744^^746^747^658^832^[ADD] Node elseOp = getBlockExpression ( elseBranch ) .getFirstChild (  ) ; if  ( thenOp.getType (  )  == elseOp.getType (  )  )  { if  ( NodeUtil.isAssignmentOp ( thenOp )  )  { Node lhs = thenOp.getFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node lhs = n.getLastChild (  ) ;^747^^^^^658^832^[REPLACE] Node lhs = thenOp.getFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node assignName = thenOp .getFirstChild (  )  ;^756^^^^^658^832^[REPLACE] Node assignName = thenOp.removeFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^elseOp.removeChild ( elseExpr ) ;elseExpr ) ;^758^759^^761^762^658^832^[ADD] Node elseExpr = elseOp.getLastChild (  ) ; elseOp.removeChild ( elseExpr ) ; Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node assign = new Node ( thenOp.getType (  ) , assignName, thenOp ) ;^763^764^^^^658^832^[REPLACE] Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node expr = NodeUtil .isGetProp ( name2 )  ;^765^^^^^658^832^[REPLACE] Node expr = NodeUtil.newExpr ( assign ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node hookNode = new Node ( Token.HOOK, thenOp, thenOp, elseOp ) ;^774^^^^^658^832^[REPLACE] Node hookNode = new Node ( Token.HOOK, cond, thenOp, elseOp ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^if  ( thenOp.getType (  )   &&  elseOp.getType (  )  )  {^744^^^^^658^832^[REPLACE] if  ( thenOp.getType (  )  == elseOp.getType (  )  )  {^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REMOVE]^if  (  ( thenOp.getType (  )  )  ==  ( elseOp.getType (  )  )  )  {     if  ( isAssignmentOp ( thenOp )  )  {         Node lhs = thenOp.getFirstChild (  ) ;         if  (  ( lhs.checkTreeEqualsSilent ( elseOp.getFirstChild (  )  )  )  &&  ( ! ( mayEffectMutableState ( lhs )  )  )  )  {             n.removeChild ( cond ) ;             Node assignName = thenOp.removeFirstChild (  ) ;             Node thenExpr = thenOp.removeFirstChild (  ) ;             Node elseExpr = elseOp.getLastChild (  ) ;             elseOp.removeChild ( elseExpr ) ;             Node hookNode = new Node ( HOOK, cond, thenExpr, elseExpr ) ;             Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;             Node expr = newExpr ( assign ) ;             parent.replaceChild ( n, expr ) ;             t.getCompiler (  ) .reportCodeChange (  ) ;         }     }else         if  ( isCall ( thenOp )  )  {             n.removeChild ( cond ) ;             thenOp.detachFromParent (  ) ;             elseOp.detachFromParent (  ) ;             Node hookNode = new Node ( HOOK, cond, thenOp, elseOp ) ;             Node expr = newExpr ( hookNode ) ;             parent.replaceChild ( n, expr ) ;             t.getCompiler (  ) .reportCodeChange (  ) ;         }      }^746^^^^^658^832^[REMOVE] ^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^} else if  ( NodeUtil .isLiteralValue ( maybeName1 )   )  {^769^^^^^658^832^[REPLACE] } else if  ( NodeUtil.isCall ( thenOp )  )  {^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node hookNode = new Node ( Token.HOOK, cond, returnNode, elseOp ) ;^774^^^^^658^832^[REPLACE] Node hookNode = new Node ( Token.HOOK, cond, thenOp, elseOp ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node expr = NodeUtil .isGetProp ( maybeName1 )  ;^775^^^^^658^832^[REPLACE] Node expr = NodeUtil.newExpr ( hookNode ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^Node thenExpr = thenOp.removeFirstChild (  ) ;^756^757^^^^748^768^[ADD] Node assignName = thenOp.removeFirstChild (  ) ; Node thenExpr = thenOp.removeFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node hookNode = new Node ( Token.HOOK, cond, thenBranch, elseExpr ) ;^761^762^^^^748^768^[REPLACE] Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node assign = new Node ( or.getType (  ) , assignName, hookNode ) ;^763^764^^^^748^768^[REPLACE] Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^765^766^^^^748^768^[ADD] Node expr = NodeUtil.newExpr ( assign ) ; parent.replaceChild ( n, expr ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node lhs = returnNode.getLastChild (  ) ;^747^^^^^658^832^[REPLACE] Node lhs = thenOp.getFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node thenExpr = thenExpr.removeFirstChild (  ) ;^757^^^^^658^832^[REPLACE] Node thenExpr = thenOp.removeFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node elseExpr = thenExpr.getFirstChild (  ) ;^758^^^^^658^832^[REPLACE] Node elseExpr = elseOp.getLastChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node expr = NodeUtil .isGetProp ( elseBranch )  ;^765^^^^^658^832^[REPLACE] Node expr = NodeUtil.newExpr ( assign ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node arrayNode = left.getFirstChild (  )  ;^757^^^^^748^768^[REPLACE] Node thenExpr = thenOp.removeFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node hookNode = new Node ( Token.HOOK, thenExpr, thenExpr, elseExpr ) ;^761^762^^^^748^768^[REPLACE] Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node assign = new Node ( thenOp .setType ( AND_PRECEDENCE )  , assignName, hookNode ) ;^763^764^^^^748^768^[REPLACE] Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node lhs = parent.getFirstChild (  ) ;^747^^^^^658^832^[REPLACE] Node lhs = thenOp.getFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node assignName = parent.removeFirstChild (  ) ;^756^^^^^658^832^[REPLACE] Node assignName = thenOp.removeFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node elseExpr = thenBranch.getLastChild (  ) ;^758^^^^^658^832^[REPLACE] Node elseExpr = elseOp.getLastChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, returnNode ) ;^761^762^^^^658^832^[REPLACE] Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node assign = new Node ( thenOp.getNext (  ) , var, hookNode ) ;^763^764^^^^658^832^[REPLACE] Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node expr = NodeUtil.isGetProp ( thenBranch ) ;^765^^^^^658^832^[REPLACE] Node expr = NodeUtil.newExpr ( assign ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^746^747^748^^^658^832^[ADD] if  ( NodeUtil.isAssignmentOp ( thenOp )  )  { Node lhs = thenOp.getFirstChild (  ) ; if  ( lhs.checkTreeEqualsSilent ( elseOp.getFirstChild (  )  )  &&^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^if  ( lhs.checkTreeEqualsSilent ( elseOp .getLastChild (  )   )  ||^748^749^750^751^^658^832^[REPLACE] if  ( lhs.checkTreeEqualsSilent ( elseOp.getFirstChild (  )  )  &&^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REMOVE]^if  (  ( isReturnExpressBlock ( thenBranch )  )  &&  ( isReturnExpressBlock ( elseBranch )  )  )  {     Node thenExpr = getBlockReturnExpression ( thenBranch ) ;     Node elseExpr = getBlockReturnExpression ( elseBranch ) ;     n.removeChild ( cond ) ;     thenExpr.detachFromParent (  ) ;     elseExpr.detachFromParent (  ) ;     Node hookNode = new Node ( HOOK, cond, thenExpr, elseExpr ) ;     Node returnNode = new Node ( RETURN, hookNode ) ;     parent.replaceChild ( n, returnNode ) ;     t.getCompiler (  ) .reportCodeChange (  ) ;     return ; }^748^^^^^658^832^[REMOVE] ^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node thenExpr = or.removeFirstChild (  ) ;^757^^^^^748^768^[REPLACE] Node thenExpr = thenOp.removeFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node assign = new Node ( thenOp.getNext (  ) , assignName, hookNode ) ;^763^764^^^^748^768^[REPLACE] Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node expr = NodeUtil.isGetProp ( thenBranch ) ;^765^^^^^748^768^[REPLACE] Node expr = NodeUtil.newExpr ( assign ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^757^^^^^658^832^[ADD] Node thenExpr = thenOp.removeFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node elseExpr = or.getLastChild (  ) ;^758^^^^^658^832^[REPLACE] Node elseExpr = elseOp.getLastChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node assign = new Node ( thenExpr .setType ( result )  , assignName, hookNode ) ;^763^764^^^^658^832^[REPLACE] Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node expr = NodeUtil.newExpr ( thenBranch ) ;^765^^^^^658^832^[REPLACE] Node expr = NodeUtil.newExpr ( assign ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node assignName = n.removeFirstChild (  ) ;^756^^^^^748^768^[REPLACE] Node assignName = thenOp.removeFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node thenExpr = thenOp.getFirstChild (  ) ;^757^^^^^748^768^[REPLACE] Node thenExpr = thenOp.removeFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node assign = new Node ( thenOp.getType (  ) , name1, hookNode ) ;^763^764^^^^748^768^[REPLACE] Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node expr = NodeUtil.isGetProp ( assign ) ;^765^^^^^748^768^[REPLACE] Node expr = NodeUtil.newExpr ( assign ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node expr = getBlockExpression ( thenBranch )  ;^742^^^^^658^832^[REPLACE] Node thenOp = getBlockExpression ( thenBranch ) .getFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node elseOp = getBlockExpression ( name2 ) .getFirstChild (  ) ;^743^^^^^658^832^[REPLACE] Node elseOp = getBlockExpression ( elseBranch ) .getFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node lhs = returnNode.getFirstChild (  ) ;^747^^^^^658^832^[REPLACE] Node lhs = thenOp.getFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node assignName = n.removeFirstChild (  ) ;^756^^^^^658^832^[REPLACE] Node assignName = thenOp.removeFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node elseExpr = thenAssign.getLastChild (  ) ;^758^^^^^658^832^[REPLACE] Node elseExpr = elseOp.getLastChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^boolean thenBranchIsExpressionBlock = isExpressBlock ( thenBranch )  ;^783^^^^^658^832^[REPLACE] boolean thenBranchIsVar = isVarBlock ( thenBranch ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^784^785^^787^^658^832^[ADD] boolean elseBranchIsVar = isVarBlock ( elseBranch ) ;  if  ( thenBranchIsVar && elseBranchIsExpressionBlock &&^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^if  ( thenBranchIsVar || true || NodeUtil.isAssign ( getBlockExpression ( elseBranch ) .getFirstChild (  )  )  )  {^787^788^^^^658^832^[REPLACE] if  ( thenBranchIsVar && elseBranchIsExpressionBlock && NodeUtil.isAssign ( getBlockExpression ( elseBranch ) .getFirstChild (  )  )  )  {^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^787^788^^790^791^658^832^[ADD] if  ( thenBranchIsVar && elseBranchIsExpressionBlock && NodeUtil.isAssign ( getBlockExpression ( elseBranch ) .getFirstChild (  )  )  )  { Node var = getBlockVar ( thenBranch ) ; Node elseAssign = getBlockExpression ( elseBranch ) .getFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^}  else {^810^811^^^^658^832^[REPLACE] } else if  ( elseBranchIsVar && thenBranchIsExpressionBlock && NodeUtil.isAssign ( getBlockExpression ( thenBranch ) .getFirstChild (  )  )  )  {^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^}   Node var = getBlockVar ( elseBranch ) ;Node thenAssign = getBlockExpression ( thenBranch ) .getFirstChild (  ) ;^810^811^^813^814^658^832^[ADD] else if  ( elseBranchIsVar && thenBranchIsExpressionBlock && NodeUtil.isAssign ( getBlockExpression ( thenBranch ) .getFirstChild (  )  )  )  { Node var = getBlockVar ( elseBranch ) ; Node thenAssign = getBlockExpression ( thenBranch ) .getFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^if  ( name2.hasChildren (  ) || maybeName1.getType (  )  == Token.NAME || maybeName1.getString (  ) .equals ( name2.getString (  )  )  )  {^819^820^821^^^810^831^[REPLACE] if  ( name2.hasChildren (  ) && maybeName1.getType (  )  == Token.NAME && maybeName1.getString (  ) .equals ( name2.getString (  )  )  )  {^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^819^820^821^822^823^810^831^[ADD] if  ( name2.hasChildren (  ) && maybeName1.getType (  )  == Token.NAME && maybeName1.getString (  ) .equals ( name2.getString (  )  )  )  { Node thenExpr = thenAssign.getLastChild (  ) .detachFromParent (  ) ; Node elseExpr = name2.removeChildren (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^822^^^^^819^830^[ADD] Node thenExpr = thenAssign.getLastChild (  ) .detachFromParent (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node elseExpr = var.detachChildren (  ) ;^823^^^^^819^830^[REPLACE] Node elseExpr = name2.removeChildren (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node hookNode = new Node ( Token.HOOK, cond, or, elseExpr ) ;^825^^^^^819^830^[REPLACE] Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node expr = getBlockExpression ( thenBranch )  ;^813^^^^^810^831^[REPLACE] Node var = getBlockVar ( elseBranch ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node thenAssign = getBlockExpression ( name2 ) .getFirstChild (  ) ;^814^^^^^810^831^[REPLACE] Node thenAssign = getBlockExpression ( thenBranch ) .getFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node arrayNode = left.getFirstChild (  )  ;^816^^^^^810^831^[REPLACE] Node maybeName1 = thenAssign.getFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^817^^^^^810^831^[ADD] Node name2 = var.getFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node thenExpr = name2.getLastChild (  ) .detachFromParent (  ) ;^822^^^^^810^831^[REPLACE] Node thenExpr = thenAssign.getLastChild (  ) .detachFromParent (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^823^824^825^826^827^810^831^[ADD] Node elseExpr = name2.removeChildren (  ) ; cond.detachFromParent (  ) ; Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ; var.detachFromParent (  ) ; name2.addChildrenToBack ( hookNode ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node hookNode = new Node ( Token.HOOK, thenOp, thenExpr, elseExpr ) ;^825^^^^^810^831^[REPLACE] Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^if  ( name2.hasChildren (  ) || maybeName1.getType (  )  == Token.NAME || maybeName1.getString (  ) .equals ( name2.getString (  )  )  )  {^819^820^821^^^658^832^[REPLACE] if  ( name2.hasChildren (  ) && maybeName1.getType (  )  == Token.NAME && maybeName1.getString (  ) .equals ( name2.getString (  )  )  )  {^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node thenExpr = n .getFirstChild (  )  .detachFromParent (  ) ;^822^^^^^819^830^[REPLACE] Node thenExpr = thenAssign.getLastChild (  ) .detachFromParent (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node notCond = new Node ( NOT )  ;^825^^^^^819^830^[REPLACE] Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^813^814^^816^817^658^832^[ADD] Node var = getBlockVar ( elseBranch ) ; Node thenAssign = getBlockExpression ( thenBranch ) .getFirstChild (  ) ; Node maybeName1 = thenAssign.getFirstChild (  ) ; Node name2 = var.getFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^814^^^^^658^832^[ADD] Node thenAssign = getBlockExpression ( thenBranch ) .getFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node maybeName1 = newExpr.getFirstChild (  ) ;^816^^^^^658^832^[REPLACE] Node maybeName1 = thenAssign.getFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node name2 = thenAssign.getLastChild (  ) ;^817^^^^^658^832^[REPLACE] Node name2 = var.getFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^822^^^^^658^832^[ADD] Node thenExpr = thenAssign.getLastChild (  ) .detachFromParent (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node elseExpr = var.detachChildren (  ) ;^823^^^^^658^832^[REPLACE] Node elseExpr = name2.removeChildren (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, returnNode ) ;^825^^^^^658^832^[REPLACE] Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^if  (  maybeName2.getType (  )  == Token.NAME || name1.getString (  ) .equals ( maybeName2.getString (  )  )  )  {^796^797^798^^^787^831^[REPLACE] if  ( name1.hasChildren (  ) && maybeName2.getType (  )  == Token.NAME && name1.getString (  ) .equals ( maybeName2.getString (  )  )  )  {^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node left = leftParent.removeFirstChild (  )  ;^799^^^^^796^807^[REPLACE] Node thenExpr = name1.removeChildren (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node elseExpr = var.getLastChild (  ) .detachFromParent (  ) ;^800^^^^^796^807^[REPLACE] Node elseExpr = elseAssign.getLastChild (  ) .detachFromParent (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^var.detachFromParent (  ) ;name1.addChildrenToBack ( hookNode ) ;parent.replaceChild ( n, var ) ;t.getCompiler (  ) .reportCodeChange (  ) ;^802^803^804^805^806^796^807^[ADD] Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ; var.detachFromParent (  ) ; name1.addChildrenToBack ( hookNode ) ; parent.replaceChild ( n, var ) ; t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node var = getBlockVar ( parent ) ;^790^^^^^787^831^[REPLACE] Node var = getBlockVar ( thenBranch ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node elseAssign = getBlockExpression ( name1 ) .getFirstChild (  ) ;^791^^^^^787^831^[REPLACE] Node elseAssign = getBlockExpression ( elseBranch ) .getFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^793^^^^^787^831^[ADD] Node name1 = var.getFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node maybeName2 = elseAssign.getLastChild (  ) ;^794^^^^^787^831^[REPLACE] Node maybeName2 = elseAssign.getFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node thenExpr = parent.removeChildren (  ) ;^799^^^^^787^831^[REPLACE] Node thenExpr = name1.removeChildren (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node elseExpr = var.getFirstChild (  ) .detachFromParent (  ) ;^800^^^^^787^831^[REPLACE] Node elseExpr = elseAssign.getLastChild (  ) .detachFromParent (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node hookNode = new Node ( Token.HOOK, thenOp, thenExpr, elseExpr ) ;^802^^^^^787^831^[REPLACE] Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^if  ( name1.hasChildren (  ) || maybeName2.getType (  )  == Token.NAME || name1.getString (  ) .equals ( maybeName2.getString (  )  )  )  {^796^797^798^^^658^832^[REPLACE] if  ( name1.hasChildren (  ) && maybeName2.getType (  )  == Token.NAME && name1.getString (  ) .equals ( maybeName2.getString (  )  )  )  {^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node thenExpr = parent .removeChild ( thenBranch )  ;^799^^^^^796^807^[REPLACE] Node thenExpr = name1.removeChildren (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node elseExpr = thenExpr.getLastChild (  ) .detachFromParent (  ) ;^800^^^^^796^807^[REPLACE] Node elseExpr = elseAssign.getLastChild (  ) .detachFromParent (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node notCond = new Node ( NOT )  ;^802^^^^^796^807^[REPLACE] Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^}  if  ( BranchIsVar || thenBranchIsExpressionBlock || NodeUtil.isAssigthenAssign ( getBlockExpression ( thenBranch ) .getFirstChild (  )  )  )  {^810^811^^^^658^832^[REPLACE] } else if  ( elseBranchIsVar && thenBranchIsExpressionBlock && NodeUtil.isAssign ( getBlockExpression ( thenBranch ) .getFirstChild (  )  )  )  {^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node thenExpr = name2.getLastChild (  ) .detachFromParent (  ) ;^822^^^^^819^830^[REPLACE] Node thenExpr = thenAssign.getLastChild (  ) .detachFromParent (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node elseExpr = var.removeChildren (  ) ;^823^^^^^819^830^[REPLACE] Node elseExpr = name2.removeChildren (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node hookNode = new Node ( Token.HOOK, cond, var, elseExpr ) ;^825^^^^^819^830^[REPLACE] Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^813^814^^816^817^810^831^[ADD] Node var = getBlockVar ( elseBranch ) ; Node thenAssign = getBlockExpression ( thenBranch ) .getFirstChild (  ) ; Node maybeName1 = thenAssign.getFirstChild (  ) ; Node name2 = var.getFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node expr = getBlockExpression ( thenBranch )  ;^814^^^^^810^831^[REPLACE] Node thenAssign = getBlockExpression ( thenBranch ) .getFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node maybeName1 = thenBranch.getFirstChild (  ) ;^816^^^^^810^831^[REPLACE] Node maybeName1 = thenAssign.getFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node name2 = thenExpr.getFirstChild (  ) ;^817^^^^^810^831^[REPLACE] Node name2 = var.getFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^Node elseExpr = name2.removeChildren (  ) ;^822^823^^^^810^831^[ADD] Node thenExpr = thenAssign.getLastChild (  ) .detachFromParent (  ) ; Node elseExpr = name2.removeChildren (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node elseExpr = returnNode .removeChild ( lhs )  ;^823^^^^^810^831^[REPLACE] Node elseExpr = name2.removeChildren (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^825^826^827^828^829^810^831^[ADD] Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ; var.detachFromParent (  ) ; name2.addChildrenToBack ( hookNode ) ; parent.replaceChild ( n, var ) ; t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^if  ( name2.hasChildren (  ) || thenExpr.getType (  )  == Token.NAME || maybeName1.getString (  ) .equals ( name2.getString (  )  )  )  {^819^820^821^^^658^832^[REPLACE] if  ( name2.hasChildren (  ) && maybeName1.getType (  )  == Token.NAME && maybeName1.getString (  ) .equals ( name2.getString (  )  )  )  {^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node maybeName1 = thenAssign.getFirstChild (  )  ;^822^^^^^819^830^[REPLACE] Node thenExpr = thenAssign.getLastChild (  ) .detachFromParent (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node left = leftParent.removeFirstChild (  )  ;^823^^^^^819^830^[REPLACE] Node elseExpr = name2.removeChildren (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node hookNode = new Node ( Token.HOOK, thenOp, thenExpr, elseExpr ) ;^825^^^^^819^830^[REPLACE] Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node expr = getBlockExpression ( thenBranch )  ;^790^^^^^658^832^[REPLACE] Node var = getBlockVar ( thenBranch ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node expr = getBlockExpression ( thenBranch )  ;^791^^^^^658^832^[REPLACE] Node elseAssign = getBlockExpression ( elseBranch ) .getFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^793^^^^^658^832^[ADD] Node name1 = var.getFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node maybeName2 = var.getFirstChild (  ) ;^794^^^^^658^832^[REPLACE] Node maybeName2 = elseAssign.getFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node thenExpr = parent.detachChildren (  ) ;^799^^^^^658^832^[REPLACE] Node thenExpr = name1.removeChildren (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node elseExpr = var.getLastChild (  ) .detachFromParent (  ) ;^800^^^^^658^832^[REPLACE] Node elseExpr = elseAssign.getLastChild (  ) .detachFromParent (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node hookNode = new Node ( Token.HOOK, cond, thenAssign, elseExpr ) ;^802^^^^^658^832^[REPLACE] Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node expr = getBlockExpression ( thenBranch )  ;^813^^^^^658^832^[REPLACE] Node var = getBlockVar ( elseBranch ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node expr = getBlockExpression ( thenBranch )  ;^814^^^^^658^832^[REPLACE] Node thenAssign = getBlockExpression ( thenBranch ) .getFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node maybeName1 = n.getFirstChild (  ) ;^816^^^^^658^832^[REPLACE] Node maybeName1 = thenAssign.getFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node name2 = thenAssign.getFirstChild (  ) ;^817^^^^^658^832^[REPLACE] Node name2 = var.getFirstChild (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node maybeName1 = thenAssign.getFirstChild (  )  ;^822^^^^^658^832^[REPLACE] Node thenExpr = thenAssign.getLastChild (  ) .detachFromParent (  ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^cond.detachFromParent (  ) ;Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;var.detachFromParent (  ) ;name2.addChildrenToBack ( hookNode ) ;^823^824^825^826^827^658^832^[ADD] Node elseExpr = name2.removeChildren (  ) ; cond.detachFromParent (  ) ; Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ; var.detachFromParent (  ) ; name2.addChildrenToBack ( hookNode ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node hookNode = new Node ( Token.HOOK, thenOp, thenExpr, elseExpr ) ;^825^^^^^658^832^[REPLACE] Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[METHOD] tryMinimizeIf [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean elseBranchIsExpressionBlock  elseBranchIsVar  false  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^checkArgument (  (  ( n.getType (  )  )  ==  ( WHILE )  )  )  ;^857^^^^^856^884^[REPLACE] Preconditions.checkState ( n.getType (  )  == Token.IF ) ;^[METHOD] tryRemoveRepeatedStatements [TYPE] void [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node cond  falseBranch  lastFalse  lastTrue  n  parent  trueBranch  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^857^^^^^856^884^[ADD] Preconditions.checkState ( n.getType (  )  == Token.IF ) ;^[METHOD] tryRemoveRepeatedStatements [TYPE] void [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node cond  falseBranch  lastFalse  lastTrue  n  parent  trueBranch  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^( left.getType (  )  )  ;^857^^^^^856^884^[REPLACE] Preconditions.checkState ( n.getType (  )  == Token.IF ) ;^[METHOD] tryRemoveRepeatedStatements [TYPE] void [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node cond  falseBranch  lastFalse  lastTrue  n  parent  trueBranch  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^859^^^^^856^884^[ADD] Node parent = n.getParent (  ) ;^[METHOD] tryRemoveRepeatedStatements [TYPE] void [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node cond  falseBranch  lastFalse  lastTrue  n  parent  trueBranch  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^if  ( !NodeUtil.isStatementBlock ( trueBranch )  )  {^860^^^^^856^884^[REPLACE] if  ( !NodeUtil.isStatementBlock ( parent )  )  {^[METHOD] tryRemoveRepeatedStatements [TYPE] void [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node cond  falseBranch  lastFalse  lastTrue  n  parent  trueBranch  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^860^861^^863^864^856^884^[ADD] if  ( !NodeUtil.isStatementBlock ( parent )  )  {  return; }^[METHOD] tryRemoveRepeatedStatements [TYPE] void [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node cond  falseBranch  lastFalse  lastTrue  n  parent  trueBranch  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^return;  ;^863^^^^^856^884^[REPLACE] return;^[METHOD] tryRemoveRepeatedStatements [TYPE] void [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node cond  falseBranch  lastFalse  lastTrue  n  parent  trueBranch  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node arrayNode = left.getFirstChild (  )  ;^866^^^^^856^884^[REPLACE] Node cond = n.getFirstChild (  ) ;^[METHOD] tryRemoveRepeatedStatements [TYPE] void [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node cond  falseBranch  lastFalse  lastTrue  n  parent  trueBranch  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node trueBranch = trueBranch.getParent (  ) ;^867^^^^^856^884^[REPLACE] Node trueBranch = cond.getNext (  ) ;^[METHOD] tryRemoveRepeatedStatements [TYPE] void [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node cond  falseBranch  lastFalse  lastTrue  n  parent  trueBranch  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node lr = ll.getNext (  )  ;^868^^^^^856^884^[REPLACE] Node falseBranch = trueBranch.getNext (  ) ;^[METHOD] tryRemoveRepeatedStatements [TYPE] void [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node cond  falseBranch  lastFalse  lastTrue  n  parent  trueBranch  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Preconditions.checkNotNull ( lastTrue ) ;^869^^^^^856^884^[REPLACE] Preconditions.checkNotNull ( trueBranch ) ;^[METHOD] tryRemoveRepeatedStatements [TYPE] void [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node cond  falseBranch  lastFalse  lastTrue  n  parent  trueBranch  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^869^^^^^856^884^[ADD] Preconditions.checkNotNull ( trueBranch ) ;^[METHOD] tryRemoveRepeatedStatements [TYPE] void [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node cond  falseBranch  lastFalse  lastTrue  n  parent  trueBranch  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Preconditions.checkNotNull ( parent ) ;^870^^^^^856^884^[REPLACE] Preconditions.checkNotNull ( falseBranch ) ;^[METHOD] tryRemoveRepeatedStatements [TYPE] void [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node cond  falseBranch  lastFalse  lastTrue  n  parent  trueBranch  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^870^^^^^856^884^[ADD] Preconditions.checkNotNull ( falseBranch ) ;^[METHOD] tryRemoveRepeatedStatements [TYPE] void [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node cond  falseBranch  lastFalse  lastTrue  n  parent  trueBranch  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^if  ( lastTrue != null || lastFalse == null || !lastTrue.checkTreeEqualsSilent ( lastFalse )  )  {^875^876^^^^856^884^[REPLACE] if  ( lastTrue == null || lastFalse == null || !lastTrue.checkTreeEqualsSilent ( lastFalse )  )  {^[METHOD] tryRemoveRepeatedStatements [TYPE] void [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node cond  falseBranch  lastFalse  lastTrue  n  parent  trueBranch  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^875^876^877^878^^856^884^[ADD] if  ( lastTrue == null || lastFalse == null || !lastTrue.checkTreeEqualsSilent ( lastFalse )  )  { break; }^[METHOD] tryRemoveRepeatedStatements [TYPE] void [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node cond  falseBranch  lastFalse  lastTrue  n  parent  trueBranch  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node arrayNode = left.getFirstChild (  )  ;^873^^^^^856^884^[REPLACE] Node lastTrue = trueBranch.getLastChild (  ) ;^[METHOD] tryRemoveRepeatedStatements [TYPE] void [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node cond  falseBranch  lastFalse  lastTrue  n  parent  trueBranch  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^874^^^^^856^884^[ADD] Node lastFalse = falseBranch.getLastChild (  ) ;^[METHOD] tryRemoveRepeatedStatements [TYPE] void [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node cond  falseBranch  lastFalse  lastTrue  n  parent  trueBranch  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^890^^^^^889^909^[ADD] Node result = n.getFirstChild (  ) ;^[METHOD] tryReduceReturn [TYPE] void [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  operand  result  [TYPE]  String name  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^if  ( result == null )  {^891^^^^^889^909^[REPLACE] if  ( result != null )  {^[METHOD] tryReduceReturn [TYPE] void [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  operand  result  [TYPE]  String name  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^891^892^893^894^^889^909^[ADD] if  ( result != null )  { switch  ( result.getType (  )  )  { case Token.VOID: Node operand = result.getFirstChild (  ) ;^[METHOD] tryReduceReturn [TYPE] void [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  operand  result  [TYPE]  String name  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^if   (  NodeUtil.mayHaveSideEffects  (  left  )    )   {  ;^895^^^^^889^909^[REPLACE] if  ( !NodeUtil.mayHaveSideEffects ( operand )  )  {^[METHOD] tryReduceReturn [TYPE] void [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  operand  result  [TYPE]  String name  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^n.getFirstChild (  ) ;^896^^^^^889^909^[REPLACE] n.removeFirstChild (  ) ;^[METHOD] tryReduceReturn [TYPE] void [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  operand  result  [TYPE]  String name  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^896^^^^^889^909^[ADD] n.removeFirstChild (  ) ;^[METHOD] tryReduceReturn [TYPE] void [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  operand  result  [TYPE]  String name  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^t.getCompiler (  ) .getVar (  ) ;^897^^^^^889^909^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryReduceReturn [TYPE] void [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  operand  result  [TYPE]  String name  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^t.getScope (  ) .reportCodeChange (  ) ;^897^^^^^889^909^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryReduceReturn [TYPE] void [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  operand  result  [TYPE]  String name  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^897^^^^^889^909^[ADD] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryReduceReturn [TYPE] void [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  operand  result  [TYPE]  String name  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^if   (  n.getChildCount  (    )   < 3  )   return true;  ;^902^^^^^889^909^[REPLACE] if  ( name.equals ( "undefined" )  )  {^[METHOD] tryReduceReturn [TYPE] void [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  operand  result  [TYPE]  String name  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^n.removeChild ( c )  ;^903^^^^^889^909^[REPLACE] n.removeFirstChild (  ) ;^[METHOD] tryReduceReturn [TYPE] void [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  operand  result  [TYPE]  String name  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^compiler.reportCodeChange (  )  ;^904^^^^^889^909^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryReduceReturn [TYPE] void [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  operand  result  [TYPE]  String name  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^904^^^^^889^909^[ADD] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryReduceReturn [TYPE] void [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  operand  result  [TYPE]  String name  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^t.getScope (  ) .reportCodeChange (  ) ;^904^^^^^889^909^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryReduceReturn [TYPE] void [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  operand  result  [TYPE]  String name  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^return;  ;^899^^^^^889^909^[REPLACE] return;^[METHOD] tryReduceReturn [TYPE] void [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  operand  result  [TYPE]  String name  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^return;  ;^906^^^^^889^909^[REPLACE] return;^[METHOD] tryReduceReturn [TYPE] void [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  operand  result  [TYPE]  String name  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node arrayNode = left.getFirstChild (  )  ;^894^^^^^889^909^[REPLACE] Node operand = result.getFirstChild (  ) ;^[METHOD] tryReduceReturn [TYPE] void [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  operand  result  [TYPE]  String name  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[ADD]^^901^^^^^889^909^[ADD] String name = result.getString (  ) ;^[METHOD] tryReduceReturn [TYPE] void [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  operand  result  [TYPE]  String name  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^if  ( !NodeUtil.tryMergeBlock ( operand )  )  {^895^^^^^889^909^[REPLACE] if  ( !NodeUtil.mayHaveSideEffects ( operand )  )  {^[METHOD] tryReduceReturn [TYPE] void [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  operand  result  [TYPE]  String name  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^compiler.reportCodeChange (  )  ;^897^^^^^889^909^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryReduceReturn [TYPE] void [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  operand  result  [TYPE]  String name  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^t.getScope (  )  ;^897^^^^^889^909^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryReduceReturn [TYPE] void [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  operand  result  [TYPE]  String name  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^if  ( name .valueOf ( 0 )   )  {^902^^^^^889^909^[REPLACE] if  ( name.equals ( "undefined" )  )  {^[METHOD] tryReduceReturn [TYPE] void [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  operand  result  [TYPE]  String name  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^n.getFirstChild (  ) ;^903^^^^^889^909^[REPLACE] n.removeFirstChild (  ) ;^[METHOD] tryReduceReturn [TYPE] void [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  operand  result  [TYPE]  String name  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^t .getScope (  )  .reportCodeChange (  ) ;^904^^^^^889^909^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryReduceReturn [TYPE] void [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  operand  result  [TYPE]  String name  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node operand = operand .getLastChild (  )  ;^894^^^^^889^909^[REPLACE] Node operand = result.getFirstChild (  ) ;^[METHOD] tryReduceReturn [TYPE] void [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  operand  result  [TYPE]  String name  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^String name = operand.getString (  ) ;^901^^^^^889^909^[REPLACE] String name = result.getString (  ) ;^[METHOD] tryReduceReturn [TYPE] void [PARAMETER] NodeTraversal t Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  operand  result  [TYPE]  String name  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type 
[REPLACE]^Node result = false;^945^^^^^944^1003^[REPLACE] Node result = null;^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[ADD]^^947^^^^^944^1003^[ADD] int type = n.getType (  ) ;^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^if   (  NodeUtil.isImmutableValue  (  elem  )    )   {  ;^948^^^^^944^1003^[REPLACE] if  ( NodeUtil.isLiteralValue ( left )  )  {^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[ADD]^boolean lval = NodeUtil.getBooleanValue ( left ) ;^948^949^^^^944^1003^[ADD] if  ( NodeUtil.isLiteralValue ( left )  )  { boolean lval = NodeUtil.getBooleanValue ( left ) ;^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^}  if  ( NodeUtil.isLiteralValue ( right )  )  {^962^^^^^944^1003^[REPLACE] } else if  ( NodeUtil.isLiteralValue ( right )  )  {^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^if  ( pt == Token.IF && pt == Token.WHILE && pt == Token.DO && ( pt == Token.FOR && NodeUtil.isExpressionNode ( parent )  == n )  && ( pt == Token.HOOK && parent.getFirstChild (  )  == n )  )  {^972^973^974^^^944^1003^[REPLACE] if  ( pt == Token.IF || pt == Token.WHILE || pt == Token.DO || ( pt == Token.FOR && NodeUtil.getConditionExpression ( parent )  == n )  || ( pt == Token.HOOK && parent.getFirstChild (  )  == n )  )  {^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[ADD]^^972^973^974^975^^944^1003^[ADD] if  ( pt == Token.IF || pt == Token.WHILE || pt == Token.DO || ( pt == Token.FOR && NodeUtil.getConditionExpression ( parent )  == n )  || ( pt == Token.HOOK && parent.getFirstChild (  )  == n )  )  { boolean rval = NodeUtil.getBooleanValue ( right ) ;^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^if  ( type == Token.OR && rval || type == Token.AND && rval )  {^979^980^^^^972^990^[REPLACE] if  ( type == Token.OR && !rval || type == Token.AND && rval )  {^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^if  ( !NodeUtil.mayHaveSideEffects ( result )  )  {^986^^^^^979^989^[REPLACE] if  ( !NodeUtil.mayHaveSideEffects ( left )  )  {^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^result = left  ;^987^^^^^979^989^[REPLACE] result = right;^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[ADD]^^981^^^^^979^989^[ADD] result = left;^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^if  ( !NodeUtil .mayEffectMutableState ( parent )   )  {^986^^^^^972^990^[REPLACE] if  ( !NodeUtil.mayHaveSideEffects ( left )  )  {^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[ADD]^^987^^^^^972^990^[ADD] result = right;^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[ADD]^^981^^^^^972^990^[ADD] result = left;^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^result = left  ;^987^^^^^972^990^[REPLACE] result = right;^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^boolean result = getBooleanValue ( n )  ;^975^^^^^972^990^[REPLACE] boolean rval = NodeUtil.getBooleanValue ( right ) ;^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^if  ( type == Token.OR && rval || type == Token.AND && rval )  {^979^980^^^^944^1003^[REPLACE] if  ( type == Token.OR && !rval || type == Token.AND && rval )  {^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^if   (  NodeUtil.mayHaveSideEffects  (  left  )    )   {  ;^986^^^^^979^989^[REPLACE] if  ( !NodeUtil.mayHaveSideEffects ( left )  )  {^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^if   (  NodeUtil.mayHaveSideEffects  (  left  )    )   {  ;^986^^^^^944^1003^[REPLACE] if  ( !NodeUtil.mayHaveSideEffects ( left )  )  {^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^result = left  ;^987^^^^^944^1003^[REPLACE] result = right;^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[ADD]^^981^^^^^944^1003^[ADD] result = left;^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^int pt = right.getType (  ) ;^971^^^^^944^1003^[REPLACE] int pt = parent.getType (  ) ;^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^boolean rval = NodeUtil.getStringValue ( result ) ;^975^^^^^944^1003^[REPLACE] boolean rval = NodeUtil.getBooleanValue ( right ) ;^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^if  ( pt == Token.IF && pt == Token.WHILE && pt == Token.DO && ( pt == Token.FOR && NodeUtil.getConditionExpression ( parent )  == n )  && ( pt == Token.HOOK && parent.getFirstChild (  )  == n )  )  {^972^973^974^^^944^1003^[REPLACE] if  ( pt == Token.IF || pt == Token.WHILE || pt == Token.DO || ( pt == Token.FOR && NodeUtil.getConditionExpression ( parent )  == n )  || ( pt == Token.HOOK && parent.getFirstChild (  )  == n )  )  {^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^result = right  ;^981^^^^^979^989^[REPLACE] result = left;^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^if  ( !NodeUtil.mayHaveSideEffects ( result )  )  {^986^^^^^972^990^[REPLACE] if  ( !NodeUtil.mayHaveSideEffects ( left )  )  {^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^result = right  ;^981^^^^^972^990^[REPLACE] result = left;^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[ADD]^^975^^^^^972^990^[ADD] boolean rval = NodeUtil.getBooleanValue ( right ) ;^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[ADD]^^979^980^981^982^^944^1003^[ADD] if  ( type == Token.OR && !rval || type == Token.AND && rval )  { result = left; } else {^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^if  ( !NodeUtil.tryMergeBlock ( left )  )  {^986^^^^^979^989^[REPLACE] if  ( !NodeUtil.mayHaveSideEffects ( left )  )  {^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^if  ( !NodeUtil.tryMergeBlock ( left )  )  {^986^^^^^944^1003^[REPLACE] if  ( !NodeUtil.mayHaveSideEffects ( left )  )  {^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^int pt = result.getType (  ) ;^971^^^^^944^1003^[REPLACE] int pt = parent.getType (  ) ;^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[ADD]^^975^^^^^944^1003^[ADD] boolean rval = NodeUtil.getBooleanValue ( right ) ;^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^if  ( lval && type == Token.OR || lval && type == Token.AND )  {^953^954^^^^944^1003^[REPLACE] if  ( lval && type == Token.OR || !lval && type == Token.AND )  {^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[ADD]^^953^954^955^^^944^1003^[ADD] if  ( lval && type == Token.OR || !lval && type == Token.AND )  { result = left;^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^result = left  ;^960^^^^^953^961^[REPLACE] result = right;^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^result = right  ;^955^^^^^953^961^[REPLACE] result = left;^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^result = right  ;^955^^^^^944^1003^[REPLACE] result = left;^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[ADD]^^960^^^^^944^1003^[ADD] result = right;^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[ADD]^^949^^^^^944^1003^[ADD] boolean lval = NodeUtil.getBooleanValue ( left ) ;^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^}  else {^962^^^^^944^1003^[REPLACE] } else if  ( NodeUtil.isLiteralValue ( right )  )  {^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^if  (  pt == Token.WHILE && pt == Token.DO && ( pt == Token.FOR && NodeUtil.getConditionExpression ( parent )  == n )  && ( pt == Token.HOOK && parent.getFirstChild (  )  == n )  )  {^972^973^974^^^944^1003^[REPLACE] if  ( pt == Token.IF || pt == Token.WHILE || pt == Token.DO || ( pt == Token.FOR && NodeUtil.getConditionExpression ( parent )  == n )  || ( pt == Token.HOOK && parent.getFirstChild (  )  == n )  )  {^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^if  ( type == Token.OR && rval ) {^979^980^^^^972^990^[REPLACE] if  ( type == Token.OR && !rval || type == Token.AND && rval )  {^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^if  (  type == Token.AND && rval )  {^979^980^^^^944^1003^[REPLACE] if  ( type == Token.OR && !rval || type == Token.AND && rval )  {^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^if  ( !NodeUtil .mayEffectMutableState ( left )   )  {^986^^^^^944^1003^[REPLACE] if  ( !NodeUtil.mayHaveSideEffects ( left )  )  {^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[ADD]^result = right;^986^987^988^^^944^1003^[ADD] if  ( !NodeUtil.mayHaveSideEffects ( left )  )  { result = right; }^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[ADD]^^987^^^^^944^1003^[ADD] result = right;^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^int tt = right.getType (  )  ;^971^^^^^944^1003^[REPLACE] int pt = parent.getType (  ) ;^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^boolean rval = NodeUtil.getBooleanValue ( result ) ;^975^^^^^944^1003^[REPLACE] boolean rval = NodeUtil.getBooleanValue ( right ) ;^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^if  ( pt == Token.IF ) {^972^973^974^^^944^1003^[REPLACE] if  ( pt == Token.IF || pt == Token.WHILE || pt == Token.DO || ( pt == Token.FOR && NodeUtil.getConditionExpression ( parent )  == n )  || ( pt == Token.HOOK && parent.getFirstChild (  )  == n )  )  {^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^if  (  type == Token.AND && rval )  {^979^980^^^^972^990^[REPLACE] if  ( type == Token.OR && !rval || type == Token.AND && rval )  {^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^boolean rval = NodeUtil.getBooleanValue ( result ) ;^975^^^^^972^990^[REPLACE] boolean rval = NodeUtil.getBooleanValue ( right ) ;^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^if  ( NodeUtil.mayHaveSideEffects ( left )  )  {^986^^^^^979^989^[REPLACE] if  ( !NodeUtil.mayHaveSideEffects ( left )  )  {^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[ADD]^^987^^^^^979^989^[ADD] result = right;^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^if  ( !NodeUtil.mayHaveSideEffects ( result )  )  {^986^^^^^944^1003^[REPLACE] if  ( !NodeUtil.mayHaveSideEffects ( left )  )  {^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^result = left  ;^960^^^^^944^1003^[REPLACE] result = right;^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^result = right  ;^981^^^^^944^1003^[REPLACE] result = left;^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^boolean lval = NodeUtil.getBooleanValue ( right ) ;^949^^^^^944^1003^[REPLACE] boolean lval = NodeUtil.getBooleanValue ( left ) ;^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^boolean result = getBooleanValue ( n )  ;^975^^^^^944^1003^[REPLACE] boolean rval = NodeUtil.getBooleanValue ( right ) ;^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^if   (  left == null  )   {  ;^997^^^^^944^1003^[REPLACE] if  ( result != null )  {^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[ADD]^^997^998^999^1000^1001^944^1003^[ADD] if  ( result != null )  {  n.removeChild ( result ) ; parent.replaceChild ( n, result ) ; t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^n.replaceChild ( result ) ;^999^^^^^944^1003^[REPLACE] n.removeChild ( result ) ;^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^parent.replaceChild ( parent, result ) ;^1000^^^^^944^1003^[REPLACE] parent.replaceChild ( n, result ) ;^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^t.getCompiler (  )  .replaceChild ( n )  ;^1001^^^^^944^1003^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[ADD]^^1001^^^^^944^1003^[ADD] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^t.getScope (  ) .reportCodeChange (  ) ;^1001^^^^^944^1003^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryFoldAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  lval  rval  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  result  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^if  ( NodeUtil.isLiteralValue ( right )  || left.getType (  )  == Token.ADD || left.getChildCount (  )  == 2 )  {^1020^1021^1022^^^1018^1043^[REPLACE] if  ( NodeUtil.isLiteralValue ( right )  && left.getType (  )  == Token.ADD && left.getChildCount (  )  == 2 )  {^[METHOD] tryFoldLeftChildAdd [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  ll  lr  n  parent  right  [TYPE]  String leftString  result  rightString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^if  ( parent.setType (  )   ==  Token.STRING ) return;^1030^1031^^^^1020^1042^[REPLACE] if  ( lr.getType (  )  != Token.STRING ) return;^[METHOD] tryFoldLeftChildAdd [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  ll  lr  n  parent  right  [TYPE]  String leftString  result  rightString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^return;  ;^1031^^^^^1020^1042^[REPLACE] return;^[METHOD] tryFoldLeftChildAdd [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  ll  lr  n  parent  right  [TYPE]  String leftString  result  rightString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^if  ( leftString == null && rightString != null )  {^1035^^^^^1020^1042^[REPLACE] if  ( leftString != null && rightString != null )  {^[METHOD] tryFoldLeftChildAdd [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  ll  lr  n  parent  right  [TYPE]  String leftString  result  rightString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[ADD]^left.removeChild ( ll ) ;String result = leftString + rightString;n.replaceChild ( left, ll ) ;n.replaceChild ( right, Node.newString ( result )  ) ;^1035^1036^1037^1038^1039^1020^1042^[ADD] if  ( leftString != null && rightString != null )  { left.removeChild ( ll ) ; String result = leftString + rightString; n.replaceChild ( left, ll ) ; n.replaceChild ( right, Node.newString ( result )  ) ;^[METHOD] tryFoldLeftChildAdd [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  ll  lr  n  parent  right  [TYPE]  String leftString  result  rightString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[ADD]^^1037^^^^^1020^1042^[ADD] String result = leftString + rightString;^[METHOD] tryFoldLeftChildAdd [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  ll  lr  n  parent  right  [TYPE]  String leftString  result  rightString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^Node ll = right.getLastChild (  ) ;^1024^^^^^1020^1042^[REPLACE] Node ll = left.getFirstChild (  ) ;^[METHOD] tryFoldLeftChildAdd [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  ll  lr  n  parent  right  [TYPE]  String leftString  result  rightString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^Node arrayNode = left.getFirstChild (  )  ;^1025^^^^^1020^1042^[REPLACE] Node lr = ll.getNext (  ) ;^[METHOD] tryFoldLeftChildAdd [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  ll  lr  n  parent  right  [TYPE]  String leftString  result  rightString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^String leftString = NodeUtil.getStringValue ( parent ) ;^1033^^^^^1020^1042^[REPLACE] String leftString = NodeUtil.getStringValue ( lr ) ;^[METHOD] tryFoldLeftChildAdd [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  ll  lr  n  parent  right  [TYPE]  String leftString  result  rightString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[ADD]^^1034^^^^^1020^1042^[ADD] String rightString = NodeUtil.getStringValue ( right ) ;^[METHOD] tryFoldLeftChildAdd [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  ll  lr  n  parent  right  [TYPE]  String leftString  result  rightString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^String result = leftString  rightString;^1037^^^^^1020^1042^[REPLACE] String result = leftString + rightString;^[METHOD] tryFoldLeftChildAdd [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  ll  lr  n  parent  right  [TYPE]  String leftString  result  rightString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^if  ( parent .setType ( AND_PRECEDENCE )    ==  Token.STRING ) return;^1030^1031^^^^1018^1043^[REPLACE] if  ( lr.getType (  )  != Token.STRING ) return;^[METHOD] tryFoldLeftChildAdd [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  ll  lr  n  parent  right  [TYPE]  String leftString  result  rightString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[ADD]^return;String leftString = NodeUtil.getStringValue ( lr ) ;String rightString = NodeUtil.getStringValue ( right ) ;^1030^1031^^1033^1034^1018^1043^[ADD] if  ( lr.getType (  )  != Token.STRING ) return; String leftString = NodeUtil.getStringValue ( lr ) ; String rightString = NodeUtil.getStringValue ( right ) ;^[METHOD] tryFoldLeftChildAdd [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  ll  lr  n  parent  right  [TYPE]  String leftString  result  rightString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^return;  ;^1031^^^^^1018^1043^[REPLACE] return;^[METHOD] tryFoldLeftChildAdd [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  ll  lr  n  parent  right  [TYPE]  String leftString  result  rightString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^if  ( rightString == null && rightString != null )  {^1035^^^^^1018^1043^[REPLACE] if  ( leftString != null && rightString != null )  {^[METHOD] tryFoldLeftChildAdd [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  ll  lr  n  parent  right  [TYPE]  String leftString  result  rightString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^String result = leftString  rightString;^1037^^^^^1018^1043^[REPLACE] String result = leftString + rightString;^[METHOD] tryFoldLeftChildAdd [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  ll  lr  n  parent  right  [TYPE]  String leftString  result  rightString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^Node arrayNode = left.getFirstChild (  )  ;^1024^^^^^1018^1043^[REPLACE] Node ll = left.getFirstChild (  ) ;^[METHOD] tryFoldLeftChildAdd [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  ll  lr  n  parent  right  [TYPE]  String leftString  result  rightString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^Node lr = ll.getParent (  ) ;^1025^^^^^1018^1043^[REPLACE] Node lr = ll.getNext (  ) ;^[METHOD] tryFoldLeftChildAdd [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  ll  lr  n  parent  right  [TYPE]  String leftString  result  rightString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^String leftString = NodeUtil.getBooleanValue ( lr ) ;^1033^^^^^1018^1043^[REPLACE] String leftString = NodeUtil.getStringValue ( lr ) ;^[METHOD] tryFoldLeftChildAdd [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  ll  lr  n  parent  right  [TYPE]  String leftString  result  rightString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[ADD]^^1034^^^^^1018^1043^[ADD] String rightString = NodeUtil.getStringValue ( right ) ;^[METHOD] tryFoldLeftChildAdd [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  ll  lr  n  parent  right  [TYPE]  String leftString  result  rightString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[ADD]^^1037^^^^^1018^1043^[ADD] String result = leftString + rightString;^[METHOD] tryFoldLeftChildAdd [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  ll  lr  n  parent  right  [TYPE]  String leftString  result  rightString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^if  ( left.getType (  )  == Token.STRING ) {^1050^1051^^^^1049^1064^[REPLACE] if  ( left.getType (  )  == Token.STRING || right.getType (  )  == Token.STRING )  {^[METHOD] tryFoldAdd [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  right  [TYPE]  String leftString  rightString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^if  (  rightString != null )  {^1056^^^^^1049^1064^[REPLACE] if  ( leftString != null && rightString != null )  {^[METHOD] tryFoldAdd [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  right  [TYPE]  String leftString  rightString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[ADD]^^1056^1057^1058^1059^^1049^1064^[ADD] if  ( leftString != null && rightString != null )  { parent.replaceChild ( n, Node.newString ( leftString + rightString )  ) ; t.getCompiler (  ) .reportCodeChange (  ) ; }^[METHOD] tryFoldAdd [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  right  [TYPE]  String leftString  rightString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[ADD]^^1054^1055^^^^1049^1064^[ADD] String leftString = NodeUtil.getStringValue ( left ) ; String rightString = NodeUtil.getStringValue ( right ) ;^[METHOD] tryFoldAdd [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  right  [TYPE]  String leftString  rightString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^String parentString = NodeUtil.getStringValue ( right ) ;^1055^^^^^1049^1064^[REPLACE] String rightString = NodeUtil.getStringValue ( right ) ;^[METHOD] tryFoldAdd [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  n  parent  right  [TYPE]  String leftString  rightString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^if  ( left.getType (  )  == Token.NUMBER || right.getType (  )  == Token.NUMBER )  {^1072^1073^^^^1070^1106^[REPLACE] if  ( left.getType (  )  == Token.NUMBER && right.getType (  )  == Token.NUMBER )  {^[METHOD] tryFoldArithmetic [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^if  ( rval  &&  3 )  {^1089^^^^^1072^1105^[REPLACE] if  ( rval == 0 )  {^[METHOD] tryFoldArithmetic [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^return;  ;^1091^^^^^1072^1105^[REPLACE] return;^[METHOD] tryFoldArithmetic [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^if  ( String.valueOf ( result ) .length (  )  *  0.5  <= String.valueOf ( lval ) .length (  )  *  0.5  + String.valueOf ( rval ) .length (  )  *  0.5  + 0  )  {^1100^1101^^^^1072^1105^[REPLACE] if  ( String.valueOf ( result ) .length (  )  <= String.valueOf ( lval ) .length (  )  + String.valueOf ( rval ) .length (  )  + 1 )  {^[METHOD] tryFoldArithmetic [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^parent.replaceChild ( n, newExpr ( cond )  )  ;^1102^^^^^1100^1104^[REPLACE] parent.replaceChild ( n, Node.newNumber ( result )  ) ;^[METHOD] tryFoldArithmetic [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[ADD]^^1102^^^^^1100^1104^[ADD] parent.replaceChild ( n, Node.newNumber ( result )  ) ;^[METHOD] tryFoldArithmetic [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^parent.replaceChild ( n, Node.newNumber ( rval )  ) ;^1102^^^^^1100^1104^[REPLACE] parent.replaceChild ( n, Node.newNumber ( result )  ) ;^[METHOD] tryFoldArithmetic [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^t.getCompiler (  ) .getVar (  ) ;^1103^^^^^1100^1104^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryFoldArithmetic [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^t.getScope (  ) .reportCodeChange (  ) ;^1103^^^^^1100^1104^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryFoldArithmetic [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^result =result  rval;^1080^^^^^1072^1105^[REPLACE] result = lval + rval;^[METHOD] tryFoldArithmetic [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^result = lval  rval;^1083^^^^^1072^1105^[REPLACE] result = lval - rval;^[METHOD] tryFoldArithmetic [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[ADD]^^1086^^^^^1072^1105^[ADD] result = lval * rval;^[METHOD] tryFoldArithmetic [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[ADD]^^1093^^^^^1072^1105^[ADD] result = lval / rval;^[METHOD] tryFoldArithmetic [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^int tt = right.getType (  )  ;^1074^^^^^1072^1105^[REPLACE] double result;^[METHOD] tryFoldArithmetic [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[ADD]^^1075^1076^^^^1072^1105^[ADD] double lval = left.getDouble (  ) ; double rval = right.getDouble (  ) ;^[METHOD] tryFoldArithmetic [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^double rval = parent.getType (  ) ;^1076^^^^^1072^1105^[REPLACE] double rval = right.getDouble (  ) ;^[METHOD] tryFoldArithmetic [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^throw new Error ( "Unknown bitwise operator" )  ;^1096^^^^^1072^1105^[REPLACE] throw new Error ( "Unknown arithmetic operator" ) ;^[METHOD] tryFoldArithmetic [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^if  ( rval  !=  0 * 3 )  {^1089^^^^^1070^1106^[REPLACE] if  ( rval == 0 )  {^[METHOD] tryFoldArithmetic [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^return;  ;^1091^^^^^1070^1106^[REPLACE] return;^[METHOD] tryFoldArithmetic [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^if  ( String.valueOf ( result ) .length (  )  - 4 <= String.valueOf ( lval ) .length (  )  - 4 + String.valueOf ( rval ) .length (  )  - 4 + 1 )  {^1100^1101^^^^1070^1106^[REPLACE] if  ( String.valueOf ( result ) .length (  )  <= String.valueOf ( lval ) .length (  )  + String.valueOf ( rval ) .length (  )  + 1 )  {^[METHOD] tryFoldArithmetic [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[ADD]^^1103^^^^^1100^1104^[ADD] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryFoldArithmetic [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^result = lval  rval;^1080^^^^^1070^1106^[REPLACE] result = lval + rval;^[METHOD] tryFoldArithmetic [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^result = lv > rv  ;^1083^^^^^1070^1106^[REPLACE] result = lval - rval;^[METHOD] tryFoldArithmetic [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^result =result  rval;^1086^^^^^1070^1106^[REPLACE] result = lval * rval;^[METHOD] tryFoldArithmetic [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[ADD]^^1093^^^^^1070^1106^[ADD] result = lval / rval;^[METHOD] tryFoldArithmetic [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^int tt = right.getType (  )  ;^1074^^^^^1070^1106^[REPLACE] double result;^[METHOD] tryFoldArithmetic [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^double lval = left .getType (  )  ;^1075^^^^^1070^1106^[REPLACE] double lval = left.getDouble (  ) ;^[METHOD] tryFoldArithmetic [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^double rval = parent.getDouble (  ) ;^1076^^^^^1070^1106^[REPLACE] double rval = right.getDouble (  ) ;^[METHOD] tryFoldArithmetic [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^throw new Error ( "Unknown bitwise operator" )  ;^1096^^^^^1070^1106^[REPLACE] throw new Error ( "Unknown arithmetic operator" ) ;^[METHOD] tryFoldArithmetic [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type 
[REPLACE]^if  ( left.getType (  )  == Token.NUMBER || right.getType (  )  == Token.NUMBER )  {^1114^1115^^^^1112^1153^[REPLACE] if  ( left.getType (  )  == Token.NUMBER && right.getType (  )  == Token.NUMBER )  {^[METHOD] tryFoldBitAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^if  ( lval < Integer.MIN_VALUE && lval > Integer.MAX_VALUE && rval < Integer.MIN_VALUE && rval > Integer.MAX_VALUE )  {^1122^1123^^^^1114^1152^[REPLACE] if  ( lval < Integer.MIN_VALUE || lval > Integer.MAX_VALUE || rval < Integer.MIN_VALUE || rval > Integer.MAX_VALUE )  {^[METHOD] tryFoldBitAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^return;  ;^1126^^^^^1122^1127^[REPLACE] return;^[METHOD] tryFoldBitAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^if  (rvalInt  ==  lval )  {^1131^^^^^1114^1152^[REPLACE] if  ( lvalInt != lval )  {^[METHOD] tryFoldBitAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^return;  ;^1132^^^^^1114^1152^[REPLACE] return;^[METHOD] tryFoldBitAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^if   (  lvalInt != lval  )   {  ;^1136^^^^^1114^1152^[REPLACE] if  ( rvalInt != rval )  {^[METHOD] tryFoldBitAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^return;  ;^1137^^^^^1114^1152^[REPLACE] return;^[METHOD] tryFoldBitAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^result = lvalInt | rvalInt;^1142^^^^^1114^1152^[REPLACE] result = lvalInt & rvalInt;^[METHOD] tryFoldBitAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^result =result & rvalInt;^1145^^^^^1114^1152^[REPLACE] result = lvalInt | rvalInt;^[METHOD] tryFoldBitAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^return;  ;^1126^^^^^1114^1152^[REPLACE] return;^[METHOD] tryFoldBitAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^int tt = right.getType (  )  ;^1116^^^^^1114^1152^[REPLACE] double result;^[METHOD] tryFoldBitAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^double lval = right.getDouble (  ) ;^1117^^^^^1114^1152^[REPLACE] double lval = left.getDouble (  ) ;^[METHOD] tryFoldBitAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^double rval = parent.getDouble (  ) ;^1118^^^^^1114^1152^[REPLACE] double rval = right.getDouble (  ) ;^[METHOD] tryFoldBitAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[ADD]^^1130^^^^^1114^1152^[ADD] int lvalInt =  ( int )  lval;^[METHOD] tryFoldBitAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[ADD]^^1135^^^^^1114^1152^[ADD] int rvalInt =  ( int )  rval;^[METHOD] tryFoldBitAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^throw new Error ( "Unknown arithmetic operator" )  ;^1148^^^^^1114^1152^[REPLACE] throw new Error ( "Unknown bitwise operator" ) ;^[METHOD] tryFoldBitAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^if  (  lval > Integer.MAX_VALUE && rval < Integer.MIN_VALUE && rval > Integer.MAX_VALUE )  {^1122^1123^^^^1112^1153^[REPLACE] if  ( lval < Integer.MIN_VALUE || lval > Integer.MAX_VALUE || rval < Integer.MIN_VALUE || rval > Integer.MAX_VALUE )  {^[METHOD] tryFoldBitAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[ADD]^^1122^1123^^^1126^1112^1153^[ADD] if  ( lval < Integer.MIN_VALUE || lval > Integer.MAX_VALUE || rval < Integer.MIN_VALUE || rval > Integer.MAX_VALUE )  { return;^[METHOD] tryFoldBitAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^if  (rvalInt  ==  lval )  {^1131^^^^^1112^1153^[REPLACE] if  ( lvalInt != lval )  {^[METHOD] tryFoldBitAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^return;  ;^1132^^^^^1112^1153^[REPLACE] return;^[METHOD] tryFoldBitAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^if  (result  ==  rval )  {^1136^^^^^1112^1153^[REPLACE] if  ( rvalInt != rval )  {^[METHOD] tryFoldBitAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[ADD]^^1136^1137^1138^^^1112^1153^[ADD] if  ( rvalInt != rval )  { return; }^[METHOD] tryFoldBitAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^return;  ;^1137^^^^^1112^1153^[REPLACE] return;^[METHOD] tryFoldBitAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^result = lvalInt >>> rvalInt  ;^1142^^^^^1112^1153^[REPLACE] result = lvalInt & rvalInt;^[METHOD] tryFoldBitAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[ADD]^^1145^^^^^1112^1153^[ADD] result = lvalInt | rvalInt;^[METHOD] tryFoldBitAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^return;  ;^1126^^^^^1112^1153^[REPLACE] return;^[METHOD] tryFoldBitAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[ADD]^double lval = left.getDouble (  ) ;^1116^1117^^^^1112^1153^[ADD] double result; double lval = left.getDouble (  ) ;^[METHOD] tryFoldBitAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^double lval = right.getDouble (  ) ;^1117^^^^^1112^1153^[REPLACE] double lval = left.getDouble (  ) ;^[METHOD] tryFoldBitAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^double rval = parent.getType (  ) ;^1118^^^^^1112^1153^[REPLACE] double rval = right.getDouble (  ) ;^[METHOD] tryFoldBitAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^int intVal =  (  ( int )   ( val )  )  ;^1130^^^^^1112^1153^[REPLACE] int lvalInt =  ( int )  lval;^[METHOD] tryFoldBitAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^int lvalInt =  (  ( int )   ( lval )  )  ;^1135^^^^^1112^1153^[REPLACE] int rvalInt =  ( int )  rval;^[METHOD] tryFoldBitAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^return ;^1148^^^^^1112^1153^[REPLACE] throw new Error ( "Unknown bitwise operator" ) ;^[METHOD] tryFoldBitAndOr [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^if  ( left.getType (  )  == Token.NUMBER ) {^1161^1162^^^^1159^1212^[REPLACE] if  ( left.getType (  )  == Token.NUMBER && right.getType (  )  == Token.NUMBER )  {^[METHOD] tryFoldShift [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^if  (  ( lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE )  )  {^1170^^^^^1161^1211^[REPLACE] if  ( ! ( lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE )  )  {^[METHOD] tryFoldShift [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^return;  ;^1172^^^^^1161^1211^[REPLACE] return;^[METHOD] tryFoldShift [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^if  (  ( rval >= 0 &&false )  )  {^1177^^^^^1161^1211^[REPLACE] if  ( ! ( rval >= 0 && rval < 32 )  )  {^[METHOD] tryFoldShift [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^return;  ;^1179^^^^^1161^1211^[REPLACE] return;^[METHOD] tryFoldShift [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^if   (  rvalInt != rval  )   {  ;^1184^^^^^1161^1211^[REPLACE] if  ( lvalInt != lval )  {^[METHOD] tryFoldShift [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^return;  ;^1186^^^^^1161^1211^[REPLACE] return;^[METHOD] tryFoldShift [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^if   (  lvalInt != lval  )   {  ;^1190^^^^^1161^1211^[REPLACE] if  ( rvalInt != rval )  {^[METHOD] tryFoldShift [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[ADD]^^1190^1191^1192^1193^^1161^1211^[ADD] if  ( rvalInt != rval )  { error ( t, FRACTIONAL_BITWISE_OPERAND, right ) ; return; }^[METHOD] tryFoldShift [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^return;  ;^1192^^^^^1161^1211^[REPLACE] return;^[METHOD] tryFoldShift [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^result = lvalInt >>> rvalInt  ;^1197^^^^^1161^1211^[REPLACE] result = lvalInt << rvalInt;^[METHOD] tryFoldShift [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^result = lvalInt >>> rvalInt  ;^1200^^^^^1161^1211^[REPLACE] result = lvalInt >> rvalInt;^[METHOD] tryFoldShift [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^result = lvalInt  <=  rvalInt;^1203^^^^^1161^1211^[REPLACE] result = lvalInt >>> rvalInt;^[METHOD] tryFoldShift [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^int tt = right.getType (  )  ;^1164^^^^^1161^1211^[REPLACE] double result;^[METHOD] tryFoldShift [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^double rv = right.getDouble (  )  ;^1165^^^^^1161^1211^[REPLACE] double lval = left.getDouble (  ) ;^[METHOD] tryFoldShift [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^double rval = parent.getDouble (  ) ;^1166^^^^^1161^1211^[REPLACE] double rval = right.getDouble (  ) ;^[METHOD] tryFoldShift [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^int intVal =  (  ( int )   ( val )  )  ;^1183^^^^^1161^1211^[REPLACE] int lvalInt =  ( int )  lval;^[METHOD] tryFoldShift [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[ADD]^^1189^^^^^1161^1211^[ADD] int rvalInt =  ( int )  rval;^[METHOD] tryFoldShift [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^return ;^1206^1207^^^^1161^1211^[REPLACE] throw new AssertionError ( "Unknown shift operator: " + Node.tokenToName ( n.getType (  )  )  ) ;^[METHOD] tryFoldShift [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^if  (  ( lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE )  )  {^1170^^^^^1159^1212^[REPLACE] if  ( ! ( lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE )  )  {^[METHOD] tryFoldShift [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^return;  ;^1172^^^^^1159^1212^[REPLACE] return;^[METHOD] tryFoldShift [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^if  (  ( false ) {^1177^^^^^1159^1212^[REPLACE] if  ( ! ( rval >= 0 && rval < 32 )  )  {^[METHOD] tryFoldShift [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^return;  ;^1179^^^^^1159^1212^[REPLACE] return;^[METHOD] tryFoldShift [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^if  ( rvalInt  ==  lval )  {^1184^^^^^1159^1212^[REPLACE] if  ( lvalInt != lval )  {^[METHOD] tryFoldShift [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^return;  ;^1186^^^^^1159^1212^[REPLACE] return;^[METHOD] tryFoldShift [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^if   (  lvalInt != lval  )   {  ;^1190^^^^^1159^1212^[REPLACE] if  ( rvalInt != rval )  {^[METHOD] tryFoldShift [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^return;  ;^1192^^^^^1159^1212^[REPLACE] return;^[METHOD] tryFoldShift [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^result = lvalInt >>> rvalInt  ;^1197^^^^^1159^1212^[REPLACE] result = lvalInt << rvalInt;^[METHOD] tryFoldShift [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[ADD]^^1200^^^^^1159^1212^[ADD] result = lvalInt >> rvalInt;^[METHOD] tryFoldShift [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[ADD]^^1203^1204^^^^1159^1212^[ADD] result = lvalInt >>> rvalInt; break;^[METHOD] tryFoldShift [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^int tt = right.getType (  )  ;^1164^^^^^1159^1212^[REPLACE] double result;^[METHOD] tryFoldShift [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^double lval = left.getType (  ) ;^1165^^^^^1159^1212^[REPLACE] double lval = left.getDouble (  ) ;^[METHOD] tryFoldShift [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[ADD]^^1166^^^^^1159^1212^[ADD] double rval = right.getDouble (  ) ;^[METHOD] tryFoldShift [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^int intVal =  (  ( int )   ( val )  )  ;^1183^^^^^1159^1212^[REPLACE] int lvalInt =  ( int )  lval;^[METHOD] tryFoldShift [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^int lvalInt =  (  ( int )   ( lval )  )  ;^1189^^^^^1159^1212^[REPLACE] int rvalInt =  ( int )  rval;^[METHOD] tryFoldShift [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^return ;^1206^1207^^^^1159^1212^[REPLACE] throw new AssertionError ( "Unknown shift operator: " + Node.tokenToName ( n.getType (  )  )  ) ;^[METHOD] tryFoldShift [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lval  result  rval  [TYPE]  Node left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type 
[REPLACE]^int op = parent.getType (  ) ;^1221^^^^^1219^1408^[REPLACE] int op = n.getType (  ) ;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1222^^^^^1219^1408^[ADD] boolean result;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^boolean parentLiteral = NodeUtil .isImmutableValue ( n )  ;^1226^^^^^1219^1408^[REPLACE] boolean rightLiteral = NodeUtil.isLiteralValue ( right ) ;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^boolean undefinedRight =  (  ( Token.NAME == right.getType (  ) ;^1227^1228^1229^1230^^1219^1408^[REPLACE] boolean undefinedRight =  (  ( Token.NAME == right.getType (  ) && right.getString (  ) .equals ( "undefined" )  ) ||  ( Token.VOID == right.getType (  ) && NodeUtil.isLiteralValue ( right.getFirstChild (  )  )  )  ) ;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( NodeUtil.isLiteralValue ( left.getFirstChild (  )  )  )  {^1234^^^^^1219^1408^[REPLACE] if  ( !NodeUtil.isLiteralValue ( left.getFirstChild (  )  )  )  {^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^}  if  ( rightLiteral )  {^1236^^^^^1219^1408^[REPLACE] } else if  ( !rightLiteral )  {^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[ADD]^}   return;boolean nullRight =  ( Token.NULL == right.getType (  )  ) ;boolean equivalent = undefinedRight || nullRight;^1236^1237^1238^1239^1240^1219^1408^[ADD] else if  ( !rightLiteral )  { return; } else { boolean nullRight =  ( Token.NULL == right.getType (  )  ) ; boolean equivalent = undefinedRight || nullRight;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^result = !equivalent  ;^1244^^^^^1236^1264^[REPLACE] result = equivalent;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^result = equivalent  ;^1247^^^^^1236^1264^[REPLACE] result = !equivalent;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^result = !undefinedRight  ;^1250^^^^^1236^1264^[REPLACE] result = undefinedRight;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^result = undefinedRight  ;^1253^^^^^1236^1264^[REPLACE] result = !undefinedRight;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^result = true;^1259^^^^^1236^1264^[REPLACE] result = false;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return;  ;^1262^^^^^1236^1264^[REPLACE] return;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1239^1240^^^^1236^1264^[ADD] boolean nullRight =  ( Token.NULL == right.getType (  )  ) ; boolean equivalent = undefinedRight || nullRight;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^boolean equivalent = undefinedRight  >=  nullRight;^1240^^^^^1236^1264^[REPLACE] boolean equivalent = undefinedRight || nullRight;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return;  ;^1237^^^^^1219^1408^[REPLACE] return;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^result = !equivalent  ;^1244^^^^^1219^1408^[REPLACE] result = equivalent;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^result = equivalent  ;^1247^^^^^1219^1408^[REPLACE] result = !equivalent;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^result = !undefinedRight  ;^1250^^^^^1219^1408^[REPLACE] result = undefinedRight;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^result = undefinedRight  ;^1253^^^^^1219^1408^[REPLACE] result = !undefinedRight;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^result = true;^1259^^^^^1219^1408^[REPLACE] result = false;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return;  ;^1262^^^^^1219^1408^[REPLACE] return;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1239^^^^^1219^1408^[ADD] boolean nullRight =  ( Token.NULL == right.getType (  )  ) ;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1240^^^^^1219^1408^[ADD] boolean equivalent = undefinedRight || nullRight;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return;  ;^1235^^^^^1219^1408^[REPLACE] return;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^}  else {^1236^^^^^1219^1408^[REPLACE] } else if  ( !rightLiteral )  {^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1239^^^^^1236^1264^[ADD] boolean nullRight =  ( Token.NULL == right.getType (  )  ) ;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^boolean equivalent = undefinedRight  ==  nullRight;^1240^^^^^1236^1264^[REPLACE] boolean equivalent = undefinedRight || nullRight;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if   (  undefinedLeft  )   {  ;^1268^^^^^1219^1408^[REPLACE] if  ( undefinedRight )  {^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^result =  ( type  !=  Token.EQ ) ;^1269^^^^^1219^1408^[REPLACE] result =  ( op == Token.EQ ) ;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( undefinedLeft )  {^1275^^^^^1219^1408^[REPLACE] if  ( undefinedRight )  {^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^result = true;^1276^^^^^1219^1408^[REPLACE] result = false;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( tt != Token.THIS || tt != Token.TRUE || tt != Token.FALSE || tt != Token.NULL )^1282^1283^1284^1285^^1219^1408^[REPLACE] if  ( tt != Token.THIS && tt != Token.TRUE && tt != Token.FALSE && tt != Token.NULL )^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1282^1283^1284^1285^1286^1219^1408^[ADD] if  ( tt != Token.THIS && tt != Token.TRUE && tt != Token.FALSE && tt != Token.NULL ) return;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return;  ;^1286^^^^^1219^1408^[REPLACE] return;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( undefinedLeft )  {^1302^^^^^1219^1408^[REPLACE] if  ( undefinedRight )  {^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1303^^^^^1219^1408^[ADD] result = false;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( Token.STRING  ==  right.setType (  )  )  {^1306^^^^^1219^1408^[REPLACE] if  ( Token.STRING != right.getType (  )  )  {^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return;  ;^1307^^^^^1219^1408^[REPLACE] return;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( undefinedLeft )  {^1324^^^^^1219^1408^[REPLACE] if  ( undefinedRight )  {^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^result = true;^1325^^^^^1219^1408^[REPLACE] result = false;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( Token.NUMBER  == 1 (  )  )  {^1328^^^^^1219^1408^[REPLACE] if  ( Token.NUMBER != right.getType (  )  )  {^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return;  ;^1329^^^^^1219^1408^[REPLACE] return;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if   (  n.getChildCount  (    )   < 3  )   return true;  ;^1347^^^^^1219^1408^[REPLACE] if  ( rightLiteral )  {^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if   (  undefinedRight  )   {  ;^1349^^^^^1219^1408^[REPLACE] if  ( undefinedLeft )  {^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1349^1350^1351^1352^1353^1219^1408^[ADD] if  ( undefinedLeft )  { boolean nullRight =  ( Token.NULL == right.getType (  )  ) ; boolean equivalent = undefinedRight || nullRight; switch  ( op )  { case Token.EQ:^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^result = !equivalent  ;^1355^^^^^1219^1408^[REPLACE] result = equivalent;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^result = equivalent  ;^1358^^^^^1219^1408^[REPLACE] result = !equivalent;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^result = !undefinedRight  ;^1361^^^^^1219^1408^[REPLACE] result = undefinedRight;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^result = undefinedRight  ;^1364^^^^^1219^1408^[REPLACE] result = !undefinedRight;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^result = true;^1370^^^^^1219^1408^[REPLACE] result = false;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return;  ;^1373^^^^^1219^1408^[REPLACE] return;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^boolean nullRight =  ( Token.NULL != parent.getType (  )  ) ;^1350^^^^^1219^1408^[REPLACE] boolean nullRight =  ( Token.NULL == right.getType (  )  ) ;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^boolean equivalent = undefinedRight  >=  nullRight;^1351^^^^^1219^1408^[REPLACE] boolean equivalent = undefinedRight || nullRight;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1358^^^^^1219^1408^[ADD] result = !equivalent;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^boolean undefinedLeft =  ( right.getString (  ) .equals ( "undefined" )  ) ;^1348^^^^^1219^1408^[REPLACE] boolean undefinedLeft =  ( left.getString (  ) .equals ( "undefined" )  ) ;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1350^^^^^1219^1408^[ADD] boolean nullRight =  ( Token.NULL == right.getType (  )  ) ;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^boolean equivalent = undefinedRight && undefinedLeft;^1351^^^^^1219^1408^[REPLACE] boolean equivalent = undefinedRight || nullRight;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1361^^^^^1219^1408^[ADD] result = undefinedRight;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^boolean nullRight =  ( Token.NULL != right.getType (  )  ) ;^1350^^^^^1219^1408^[REPLACE] boolean nullRight =  ( Token.NULL == right.getType (  )  ) ;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^boolean equivalent = undefinedLeft ;^1351^^^^^1219^1408^[REPLACE] boolean equivalent = undefinedRight || nullRight;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( Token.NAME  ==  right.getType (  )  )  {^1379^^^^^1219^1408^[REPLACE] if  ( Token.NAME != right.getType (  )  )  {^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1379^1380^1381^^^1219^1408^[ADD] if  ( Token.NAME != right.getType (  )  )  { return; }^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return;  ;^1380^^^^^1219^1408^[REPLACE] return;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( !ln .valueOf ( rv )   )  {^1384^^^^^1219^1408^[REPLACE] if  ( !ln.equals ( rn )  )  {^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return;  ;^1385^^^^^1219^1408^[REPLACE] return;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^result =  ( op  !=  Token.EQ ) ;^1269^^^^^1219^1408^[REPLACE] result =  ( op == Token.EQ ) ;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^result =  ( left.getType (  )  )  !=  ( right.getType (  )  )  ;^1289^^^^^1219^1408^[REPLACE] result = left.getType (  )  == right.getType (  ) ;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^result = left.getType (  )   ==  right.getType (  ) ;^1293^^^^^1219^1408^[REPLACE] result = left.getType (  )  != right.getType (  ) ;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^result = ! ( left.getString (  ) .equals ( right.getString (  )  )  )  ;^1311^^^^^1219^1408^[REPLACE] result = left.getString (  ) .equals ( right.getString (  )  ) ;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^result = left.getString (  ) .equals ( right.getString (  )  )  ;^1315^^^^^1219^1408^[REPLACE] result = !left.getString (  ) .equals ( right.getString (  )  ) ;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1325^^^^^1219^1408^[ADD] result = false;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1335^^^^^1219^1408^[ADD] case Token.EQ: result = lv == rv; break;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^case Token.NE: result = lv  ==  rv; break;^1336^^^^^1219^1408^[REPLACE] case Token.NE: result = lv != rv; break;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^case Token.LE: result = lv  !=  rv; break;^1337^^^^^1219^1408^[REPLACE] case Token.LE: result = lv <= rv; break;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^case Token.LT: result = lv  !=   rv; break;^1338^^^^^1219^1408^[REPLACE] case Token.LT: result = lv <  rv; break;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^result = lv > rv  ;^1339^^^^^1219^1408^[REPLACE] case Token.GE: result = lv >= rv; break;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1340^^^^^1219^1408^[ADD] case Token.GT: result = lv >  rv; break;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1364^^^^^1219^1408^[ADD] result = !undefinedRight;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^result = true;^1393^^^^^1219^1408^[REPLACE] result = false;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return;  ;^1297^^^^^1219^1408^[REPLACE] return;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return;  ;^1319^^^^^1219^1408^[REPLACE] return;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return;  ;^1342^^^^^1219^1408^[REPLACE] return;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return;  ;^1396^^^^^1219^1408^[REPLACE] return;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return;  ;^1402^^^^^1219^1408^[REPLACE] return;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^int type = n.getType (  )  ;^1281^^^^^1219^1408^[REPLACE] int tt = right.getType (  ) ;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^double lv = right.getType (  ) ;^1331^^^^^1219^1408^[REPLACE] double lv = left.getDouble (  ) ;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1332^^^^^1219^1408^[ADD] double rv = right.getDouble (  ) ;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1348^^^^^1219^1408^[ADD] boolean undefinedLeft =  ( left.getString (  ) .equals ( "undefined" )  ) ;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^boolean equivalent = undefinedRight  &  nullRight;^1351^^^^^1219^1408^[REPLACE] boolean equivalent = undefinedRight || nullRight;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^String ln = right .newString ( ln )  ;^1382^^^^^1219^1408^[REPLACE] String ln = left.getString (  ) ;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^String rn = parent.toString (  ) ;^1383^^^^^1219^1408^[REPLACE] String rn = right.getString (  ) ;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^parent.replaceChild ( n, new Node ( undefinedRight ? Token.TRUE : Token.FALSE )  ) ;^1405^1406^^^^1219^1408^[REPLACE] parent.replaceChild ( n, new Node ( result ? Token.TRUE : Token.FALSE )  ) ;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^compiler.reportCodeChange (  )  ;^1407^^^^^1219^1408^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^t.getScope (  ) .reportCodeChange (  ) ;^1407^^^^^1219^1408^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryFoldComparison [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean equivalent  false  nullRight  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double lv  rv  [TYPE]  Node left  n  parent  right  [TYPE]  String ln  rn  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  (  !NodeUtil.isImmutableValue ( right )  )  {^1417^^^^^1416^1455^[REPLACE] if  ( !NodeUtil.isGetProp ( left )  || !NodeUtil.isImmutableValue ( right )  )  {^[METHOD] tryFoldStringIndexOf [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  isIndexOf  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  [TYPE]  String lstring  searchValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REMOVE]^if  ( isLiteralValue ( n )  )  {     boolean result = getBooleanValue ( n ) ;     int equivalentResult =  ( result )  ? 1 : 0;     maybeReplaceChildWithNumber ( t, n, parent, equivalentResult ) ; }^1417^^^^^1416^1455^[REMOVE] ^[METHOD] tryFoldStringIndexOf [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  isIndexOf  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  [TYPE]  String lstring  searchValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return;  ;^1418^^^^^1416^1455^[REPLACE] return;^[METHOD] tryFoldStringIndexOf [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  isIndexOf  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  [TYPE]  String lstring  searchValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^Node lstringNode = secondArg.getFirstChild (  ) ;^1421^^^^^1416^1455^[REPLACE] Node lstringNode = left.getFirstChild (  ) ;^[METHOD] tryFoldStringIndexOf [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  isIndexOf  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  [TYPE]  String lstring  searchValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1422^^^^^1416^1455^[ADD] Node functionName = lstringNode.getNext (  ) ;^[METHOD] tryFoldStringIndexOf [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  isIndexOf  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  [TYPE]  String lstring  searchValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  (  ( lstringNode.getType (  )  != Token.STRING )  && ( !functionName.getString (  ) .equals ( "indexOf" )  && !functionName.getString (  ) .equals ( "lastIndexOf" )  )  )  {^1424^1425^1426^^^1416^1455^[REPLACE] if  (  ( lstringNode.getType (  )  != Token.STRING )  || ( !functionName.getString (  ) .equals ( "indexOf" )  && !functionName.getString (  ) .equals ( "lastIndexOf" )  )  )  {^[METHOD] tryFoldStringIndexOf [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  isIndexOf  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  [TYPE]  String lstring  searchValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REMOVE]^if  (  (  ( arrayNode.getType (  )  )  !=  ( ARRAYLIT )  )  ||  ( ! ( functionName.getString (  ) .equals ( "join" )  )  )  )  {     return ; }^1424^^^^^1416^1455^[REMOVE] ^[METHOD] tryFoldStringIndexOf [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  isIndexOf  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  [TYPE]  String lstring  searchValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return;  ;^1427^^^^^1424^1428^[REPLACE] return;^[METHOD] tryFoldStringIndexOf [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  isIndexOf  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  [TYPE]  String lstring  searchValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return;  ;^1427^^^^^1416^1455^[REPLACE] return;^[METHOD] tryFoldStringIndexOf [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  isIndexOf  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  [TYPE]  String lstring  searchValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^String lstring = NodeUtil .getBooleanValue ( right )  ;^1430^^^^^1416^1455^[REPLACE] String lstring = NodeUtil.getStringValue ( lstringNode ) ;^[METHOD] tryFoldStringIndexOf [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  isIndexOf  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  [TYPE]  String lstring  searchValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1431^^^^^1416^1455^[ADD] boolean isIndexOf = functionName.getString (  ) .equals ( "indexOf" ) ;^[METHOD] tryFoldStringIndexOf [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  isIndexOf  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  [TYPE]  String lstring  searchValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^Node firstArg = parent;^1432^^^^^1416^1455^[REPLACE] Node firstArg = right;^[METHOD] tryFoldStringIndexOf [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  isIndexOf  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  [TYPE]  String lstring  searchValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[ADD]^String searchValue = NodeUtil.getStringValue ( firstArg ) ;^1433^1434^^^^1416^1455^[ADD] Node secondArg = right.getNext (  ) ; String searchValue = NodeUtil.getStringValue ( firstArg ) ;^[METHOD] tryFoldStringIndexOf [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  isIndexOf  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  [TYPE]  String lstring  searchValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1434^^^^^1416^1455^[ADD] String searchValue = NodeUtil.getStringValue ( firstArg ) ;^[METHOD] tryFoldStringIndexOf [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  isIndexOf  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  [TYPE]  String lstring  searchValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( searchValue != null )  {^1436^^^^^1416^1455^[REPLACE] if  ( searchValue == null )  {^[METHOD] tryFoldStringIndexOf [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  isIndexOf  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  [TYPE]  String lstring  searchValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return;  ;^1437^^^^^1416^1455^[REPLACE] return;^[METHOD] tryFoldStringIndexOf [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  isIndexOf  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  [TYPE]  String lstring  searchValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^int fromIndex = isIndexOf ? 0  : lstring.length (  ) ;^1439^^^^^1416^1455^[REPLACE] int fromIndex = isIndexOf ? 0 : lstring.length (  ) ;^[METHOD] tryFoldStringIndexOf [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  isIndexOf  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  [TYPE]  String lstring  searchValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  (parent == null )  {^1440^^^^^1416^1455^[REPLACE] if  ( secondArg != null )  {^[METHOD] tryFoldStringIndexOf [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  isIndexOf  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  [TYPE]  String lstring  searchValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  (  ( secondArg.getNext (  )  == null )  || ( secondArg.getType (  )  != Token.NUMBER )  )  {^1442^1443^^^^1416^1455^[REPLACE] if  (  ( secondArg.getNext (  )  != null )  || ( secondArg.getType (  )  != Token.NUMBER )  )  {^[METHOD] tryFoldStringIndexOf [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  isIndexOf  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  [TYPE]  String lstring  searchValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^fromIndex =   ( int )  null.getDouble (  ) ;^1446^^^^^1442^1447^[REPLACE] fromIndex =  ( int )  secondArg.getDouble (  ) ;^[METHOD] tryFoldStringIndexOf [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  isIndexOf  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  [TYPE]  String lstring  searchValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return;  ;^1444^^^^^1442^1447^[REPLACE] return;^[METHOD] tryFoldStringIndexOf [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  isIndexOf  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  [TYPE]  String lstring  searchValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^fromIndex =   ( int )  newNode.getDouble (  ) ;^1446^^^^^1416^1455^[REPLACE] fromIndex =  ( int )  secondArg.getDouble (  ) ;^[METHOD] tryFoldStringIndexOf [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  isIndexOf  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  [TYPE]  String lstring  searchValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return;  ;^1444^^^^^1416^1455^[REPLACE] return;^[METHOD] tryFoldStringIndexOf [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  isIndexOf  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  [TYPE]  String lstring  searchValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  (  ( secondArg.getType (  )  != Token.NUMBER )  )  {^1442^1443^^^^1416^1455^[REPLACE] if  (  ( secondArg.getNext (  )  != null )  || ( secondArg.getType (  )  != Token.NUMBER )  )  {^[METHOD] tryFoldStringIndexOf [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  isIndexOf  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  [TYPE]  String lstring  searchValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1442^1443^1444^1445^1446^1416^1455^[ADD] if  (  ( secondArg.getNext (  )  != null )  || ( secondArg.getType (  )  != Token.NUMBER )  )  { return; } else { fromIndex =  ( int )  secondArg.getDouble (  ) ;^[METHOD] tryFoldStringIndexOf [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  isIndexOf  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  [TYPE]  String lstring  searchValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1446^^^^^1416^1455^[ADD] fromIndex =  ( int )  secondArg.getDouble (  ) ;^[METHOD] tryFoldStringIndexOf [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  isIndexOf  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  [TYPE]  String lstring  searchValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^int indexVal = isIndexOf ? lstring.indexOf ( searchValue, op ) : lstring.lastIndexOf ( searchValue, fromIndex ) ;^1449^1450^^^^1416^1455^[REPLACE] int indexVal = isIndexOf ? lstring.indexOf ( searchValue, fromIndex ) : lstring.lastIndexOf ( searchValue, fromIndex ) ;^[METHOD] tryFoldStringIndexOf [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  isIndexOf  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  [TYPE]  String lstring  searchValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^Node notCond = new Node ( NOT )  ;^1451^^^^^1416^1455^[REPLACE] Node newNode = Node.newNumber ( indexVal ) ;^[METHOD] tryFoldStringIndexOf [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  isIndexOf  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  [TYPE]  String lstring  searchValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^parent.addChildAfter ( n, secondArg ) ;^1452^^^^^1416^1455^[REPLACE] parent.replaceChild ( n, newNode ) ;^[METHOD] tryFoldStringIndexOf [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  isIndexOf  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  [TYPE]  String lstring  searchValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^t.getScope (  ) .reportCodeChange (  ) ;^1454^^^^^1416^1455^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryFoldStringIndexOf [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  isIndexOf  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  [TYPE]  String lstring  searchValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1454^^^^^1416^1455^[ADD] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryFoldStringIndexOf [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  isIndexOf  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  [TYPE]  String lstring  searchValue  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( NodeUtil.isGetProp ( left )  || !NodeUtil.isImmutableValue ( right )  )  {^1463^^^^^1462^1549^[REPLACE] if  ( !NodeUtil.isGetProp ( left )  || !NodeUtil.isImmutableValue ( right )  )  {^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return;  ;^1464^^^^^1462^1549^[REPLACE] return;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^Node maybeName1 = thenAssign.getFirstChild (  )  ;^1467^^^^^1462^1549^[REPLACE] Node arrayNode = left.getFirstChild (  ) ;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^Node functionName = right.getNext (  ) ;^1468^^^^^1462^1549^[REPLACE] Node functionName = arrayNode.getNext (  ) ;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  (  ( replacement.getType (  )  != Token.ARRAYLIT )  && !functionName.getString (  ) .equals ( "join" )  )  {^1470^1471^^^^1462^1549^[REPLACE] if  (  ( arrayNode.getType (  )  != Token.ARRAYLIT )  || !functionName.getString (  ) .equals ( "join" )  )  {^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return;  ;^1472^^^^^1470^1473^[REPLACE] return;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return;  ;^1472^^^^^1462^1549^[REPLACE] return;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1475^^^^^1462^1549^[ADD] String joinString = NodeUtil.getStringValue ( right ) ;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^int tt = right.getType (  )  ;^1476^^^^^1462^1549^[REPLACE] List<Node> arrayFoldedChildren = Lists.newLinkedList (  ) ;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1477^^^^^1462^1549^[ADD] StringBuilder sb = new StringBuilder (  ) ;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^int foldedSize = 1;^1478^^^^^1462^1549^[REPLACE] int foldedSize = 0;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^Node elem = replacement.getFirstChild (  ) ;^1479^^^^^1462^1549^[REPLACE] Node elem = arrayNode.getFirstChild (  ) ;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if   (  !NodeUtil.isLiteralValue  (  left  )    )   {  ;^1482^^^^^1462^1549^[REPLACE] if  ( NodeUtil.isImmutableValue ( elem )  )  {^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( sb.length (  )  + 1 > 0 )  {^1488^^^^^1482^1496^[REPLACE] if  ( sb.length (  )  > 0 )  {^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^foldedSize += sb.length (  )  + 3 + 2;^1490^^^^^1482^1496^[REPLACE] foldedSize += sb.length (  )  + 2;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^sb  =  sb ;^1492^^^^^1482^1496^[REPLACE] sb = new StringBuilder (  ) ;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^foldedSize += getCost ( right )  ;^1494^^^^^1482^1496^[REPLACE] foldedSize += InlineCostEstimator.getCost ( elem ) ;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( sb.length (  )  *  2 > 0 )  {^1483^^^^^1462^1549^[REPLACE] if  ( sb.length (  )  > 0 )  {^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^checkState ( isVarBlock ( n )  )  ;^1484^^^^^1462^1549^[REPLACE] sb.append ( joinString ) ;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( sb.length (  )  /  2 > 0 )  {^1483^^^^^1462^1549^[REPLACE] if  ( sb.length (  )  > 0 )  {^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[ADD]^sb.append ( joinString ) ;^1483^1484^1485^^^1462^1549^[ADD] if  ( sb.length (  )  > 0 )  { sb.append ( joinString ) ; }^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^sb .append ( null , OR_PRECEDENCE , pt )  ;^1484^^^^^1462^1549^[REPLACE] sb.append ( joinString ) ;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( sb.length (  )  %  0.5  > 0 )  {^1488^^^^^1462^1549^[REPLACE] if  ( sb.length (  )  > 0 )  {^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1490^^^^^1462^1549^[ADD] foldedSize += sb.length (  )  + 2;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^sb  =  sb ;^1492^^^^^1462^1549^[REPLACE] sb = new StringBuilder (  ) ;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^foldedSize += sb.length (  )  *  2 + 2;^1490^^^^^1462^1549^[REPLACE] foldedSize += sb.length (  )  + 2;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1492^^^^^1462^1549^[ADD] sb = new StringBuilder (  ) ;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^foldedSize += getCost ( right )  ;^1494^^^^^1462^1549^[REPLACE] foldedSize += InlineCostEstimator.getCost ( elem ) ;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^elem =  replacement.getNext (  ) ;^1497^^^^^1462^1549^[REPLACE] elem = elem.getNext (  ) ;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( sb.length (  )  %  0 .5  > 0  )  {^1500^^^^^1462^1549^[REPLACE] if  ( sb.length (  )  > 0 )  {^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^foldedSize += sb.length (  )  + 5 + 2;^1502^^^^^1462^1549^[REPLACE] foldedSize += sb.length (  )  + 2;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^foldedSize += sb.length (  )  + 4 + 2;^1502^^^^^1462^1549^[REPLACE] foldedSize += sb.length (  )  + 2;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^foldedSize += arrayFoldedChildren.size (  )  + 4 - 1;^1506^^^^^1462^1549^[REPLACE] foldedSize += arrayFoldedChildren.size (  )  - 1;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^int originalSize = InlineCostEstimator.getCost ( replacement ) ;^1508^^^^^1462^1549^[REPLACE] int originalSize = InlineCostEstimator.getCost ( n ) ;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  (type  >=  originalSize )  {^1517^^^^^1462^1549^[REPLACE] if  ( foldedSize > originalSize )  {^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return;  ;^1518^^^^^1462^1549^[REPLACE] return;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( foldedStringNode.getType (  )   ==  Token.STRING )  {^1521^^^^^1462^1549^[REPLACE] if  ( foldedStringNode.getType (  )  != Token.STRING )  {^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^foldedStringNode =  right;^1526^^^^^1462^1549^[REPLACE] foldedStringNode = replacement;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^Node replacement = new Node ( Token.ADD, Node.newString ( "" ) , parent ) ;^1524^1525^^^^1462^1549^[REPLACE] Node replacement = new Node ( Token.ADD, Node.newString ( "" ) , foldedStringNode ) ;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( arrayFoldedChildren.size (  )  *  0.5  == right.setType (  )  )  {^1533^^^^^1462^1549^[REPLACE] if  ( arrayFoldedChildren.size (  )  == arrayNode.getChildCount (  )  )  {^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1533^1534^1535^^^1462^1549^[ADD] if  ( arrayFoldedChildren.size (  )  == arrayNode.getChildCount (  )  )  { return; }^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return;  ;^1534^^^^^1462^1549^[REPLACE] return;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( precedence  ==  type )  {^1539^^^^^1462^1549^[REPLACE] if  ( foldedSize > originalSize )  {^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[ADD]^return;^1539^1540^1541^^^1462^1549^[ADD] if  ( foldedSize > originalSize )  { return; }^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return;  ;^1540^^^^^1462^1549^[REPLACE] return;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^for  ( Node node : false )  {^1543^^^^^^^[REPLACE] for  ( Node node : arrayFoldedChildren )  {^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^foldedStringNode =  right;^1526^^^^^^^[REPLACE] foldedStringNode = replacement;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^foldedSize +=  rvalInt;^1537^^^^^^^[REPLACE] foldedSize += kJoinOverhead;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^foldedSize += getCost ( elem )  ;^1538^^^^^^^[REPLACE] foldedSize += InlineCostEstimator.getCost ( right ) ;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return;  ;^1518^^^^^^^[REPLACE] return;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return;  ;^1534^^^^^^^[REPLACE] return;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return;  ;^1540^^^^^^^[REPLACE] return;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^Node emptyStringNode = Node .getString (  )  ;^1511^^^^^^^[REPLACE] Node emptyStringNode = Node.newString ( "" ) ;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^Node foldedStringNode = arrayFoldedChildren.remove ( 0 * 0 ) ;^1516^^^^^^^[REPLACE] Node foldedStringNode = arrayFoldedChildren.remove ( 0 ) ;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^Node replacement = new Node ( Token.ADD, Node.newString ( "" ) , right ) ;^1524^1525^^^^^^[REPLACE] Node replacement = new Node ( Token.ADD, Node.newString ( "" ) , foldedStringNode ) ;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^int kJoinOverhead = "[].join (  ) ".valueOf (  ) ;^1536^^^^^^^[REPLACE] int kJoinOverhead = "[].join (  ) ".length (  ) ;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^Node lr = ll.getNext (  )  ;^1543^^^^^^^[REPLACE] for  ( Node node : arrayFoldedChildren )  {^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^t .getScope (  )  .reportCodeChange (  ) ;^1548^^^^^1462^1549^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^t.getScope (  )  ;^1548^^^^^1462^1549^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryFoldStringJoin [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List arrayFoldedChildren  [TYPE]  String joinString  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( left.getType (  )   ) {^1556^^^^^1555^1594^[REPLACE] if  ( left.getType (  )  == Token.ARRAYLIT )  {^[METHOD] tryFoldGetElem [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double index  [TYPE]  Node elem  left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( right.getType (  )   ==  Token.NUMBER )  {^1558^^^^^1555^1594^[REPLACE] if  ( right.getType (  )  != Token.NUMBER )  {^[METHOD] tryFoldGetElem [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double index  [TYPE]  Node elem  left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1558^1559^^1561^1562^1555^1594^[ADD] if  ( right.getType (  )  != Token.NUMBER )  {  return; }^[METHOD] tryFoldGetElem [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double index  [TYPE]  Node elem  left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return;  ;^1561^^^^^1555^1594^[REPLACE] return;^[METHOD] tryFoldGetElem [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double index  [TYPE]  Node elem  left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( intIndex  ==  index )  {^1566^^^^^1555^1594^[REPLACE] if  ( intIndex != index )  {^[METHOD] tryFoldGetElem [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double index  [TYPE]  Node elem  left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return;  ;^1569^^^^^1555^1594^[REPLACE] return;^[METHOD] tryFoldGetElem [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double index  [TYPE]  Node elem  left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( intIndex  ==  0 )  {^1572^^^^^1555^1594^[REPLACE] if  ( intIndex < 0 )  {^[METHOD] tryFoldGetElem [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double index  [TYPE]  Node elem  left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return;  ;^1575^^^^^1555^1594^[REPLACE] return;^[METHOD] tryFoldGetElem [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double index  [TYPE]  Node elem  left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( elem != null )  {^1583^^^^^1555^1594^[REPLACE] if  ( elem == null )  {^[METHOD] tryFoldGetElem [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double index  [TYPE]  Node elem  left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return;  ;^1586^^^^^1555^1594^[REPLACE] return;^[METHOD] tryFoldGetElem [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double index  [TYPE]  Node elem  left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1580^^^^^1555^1594^[ADD] elem = elem.getNext (  ) ;^[METHOD] tryFoldGetElem [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double index  [TYPE]  Node elem  left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^double index = parent.getDouble (  ) ;^1564^^^^^1555^1594^[REPLACE] double index = right.getDouble (  ) ;^[METHOD] tryFoldGetElem [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double index  [TYPE]  Node elem  left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^int intVal =  (  ( int )   ( val )  )  ;^1565^^^^^1555^1594^[REPLACE] int intIndex =  ( int )  index;^[METHOD] tryFoldGetElem [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double index  [TYPE]  Node elem  left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^Node elem = left.getLastChild (  ) ;^1578^^^^^1555^1594^[REPLACE] Node elem = left.getFirstChild (  ) ;^[METHOD] tryFoldGetElem [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double index  [TYPE]  Node elem  left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1579^1580^1581^^^1555^1594^[ADD] for  ( int i = 0; elem != null && i < intIndex; i++ )  { elem = elem.getNext (  ) ; }^[METHOD] tryFoldGetElem [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double index  [TYPE]  Node elem  left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1566^1567^1568^1569^1570^1555^1594^[ADD] if  ( intIndex != index )  { t.getCompiler (  ) .report ( JSError.make ( t, right, INVALID_GETELEM_INDEX_ERROR, String.valueOf ( index )  )  ) ; return; }^[METHOD] tryFoldGetElem [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double index  [TYPE]  Node elem  left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( precedence  > type )  {^1572^^^^^1555^1594^[REPLACE] if  ( intIndex < 0 )  {^[METHOD] tryFoldGetElem [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double index  [TYPE]  Node elem  left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1572^1573^1574^1575^1576^1555^1594^[ADD] if  ( intIndex < 0 )  { t.getCompiler (  ) .report ( JSError.make ( t, n, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf ( intIndex )  )  ) ; return; }^[METHOD] tryFoldGetElem [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double index  [TYPE]  Node elem  left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( elem !=parent )  {^1583^^^^^1555^1594^[REPLACE] if  ( elem == null )  {^[METHOD] tryFoldGetElem [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double index  [TYPE]  Node elem  left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^elem =  parent.getNext (  ) ;^1580^^^^^1555^1594^[REPLACE] elem = elem.getNext (  ) ;^[METHOD] tryFoldGetElem [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double index  [TYPE]  Node elem  left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1564^1565^^^^1555^1594^[ADD] double index = right.getDouble (  ) ; int intIndex =  ( int )  index;^[METHOD] tryFoldGetElem [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double index  [TYPE]  Node elem  left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^Node arrayNode = left.getFirstChild (  )  ;^1578^^^^^1555^1594^[REPLACE] Node elem = left.getFirstChild (  ) ;^[METHOD] tryFoldGetElem [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double index  [TYPE]  Node elem  left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^for  ( int i = 0 << 0; elem != null && i < intIndex; i++ )  {^1579^^^^^1555^1594^[REPLACE] for  ( int i = 0; elem != null && i < intIndex; i++ )  {^[METHOD] tryFoldGetElem [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  double index  [TYPE]  Node elem  left  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( right.getType (  )  == Token.STRING && right.getString (  ) .equals ( "length %  0.5 " )  )  {^1601^1602^^^^1600^1625^[REPLACE] if  ( right.getType (  )  == Token.STRING && right.getString (  ) .equals ( "length" )  )  {^[METHOD] tryFoldGetProp [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  lengthNode  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( NodeUtil.mayHaveSideEffects ( right )  )  {^1606^^^^^1601^1624^[REPLACE] if  ( NodeUtil.mayHaveSideEffects ( left )  )  {^[METHOD] tryFoldGetProp [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  lengthNode  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return;  ;^1608^^^^^1601^1624^[REPLACE] return;^[METHOD] tryFoldGetProp [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  lengthNode  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1610^^^^^1601^1624^[ADD] knownLength = left.getChildCount (  ) ;^[METHOD] tryFoldGetProp [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  lengthNode  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^knownLength =  right.getString (  ) .length (  ) ;^1613^^^^^1601^1624^[REPLACE] knownLength = left.getString (  ) .length (  ) ;^[METHOD] tryFoldGetProp [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  lengthNode  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return;  ;^1617^^^^^1601^1624^[REPLACE] return;^[METHOD] tryFoldGetProp [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  lengthNode  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^int knownLength = -3;^1603^^^^^1601^1624^[REPLACE] int knownLength = -1;^[METHOD] tryFoldGetProp [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  lengthNode  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1621^^^^^1601^1624^[ADD] Node lengthNode = Node.newNumber ( knownLength ) ;^[METHOD] tryFoldGetProp [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  lengthNode  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if   (  !NodeUtil.mayHaveSideEffects  (  c  )    )   {  ;^1606^^^^^1600^1625^[REPLACE] if  ( NodeUtil.mayHaveSideEffects ( left )  )  {^[METHOD] tryFoldGetProp [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  lengthNode  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return;  ;^1608^^^^^1600^1625^[REPLACE] return;^[METHOD] tryFoldGetProp [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  lengthNode  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^knownLength =  right.getChildCount (  ) ;^1610^^^^^1600^1625^[REPLACE] knownLength = left.getChildCount (  ) ;^[METHOD] tryFoldGetProp [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  lengthNode  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^knownLength =  right.getString (  ) .length (  ) ;^1613^^^^^1600^1625^[REPLACE] knownLength = left.getString (  ) .length (  ) ;^[METHOD] tryFoldGetProp [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  lengthNode  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return;  ;^1617^^^^^1600^1625^[REPLACE] return;^[METHOD] tryFoldGetProp [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  lengthNode  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^int knownLength = -4;^1603^^^^^1600^1625^[REPLACE] int knownLength = -1;^[METHOD] tryFoldGetProp [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  lengthNode  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^Node lengthNode = Node.newNumber ( type ) ;^1621^^^^^1600^1625^[REPLACE] Node lengthNode = Node.newNumber ( knownLength ) ;^[METHOD] tryFoldGetProp [TYPE] void [PARAMETER] NodeTraversal t Node n Node left Node right Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node left  lengthNode  n  parent  right  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^Node constructor = pattern .getLastChild (  )  ;^1632^^^^^1631^1679^[REPLACE] Node constructor = n.getFirstChild (  ) ;^[METHOD] tryFoldRegularExpressionConstructor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node constructor  flags  n  parent  pattern  regexLiteral  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^Node pattern = regexLiteral.getNext (  ) ;^1633^^^^^1631^1679^[REPLACE] Node pattern = constructor.getNext (  ) ;^[METHOD] tryFoldRegularExpressionConstructor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node constructor  flags  n  parent  pattern  regexLiteral  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1634^^^^^1631^1679^[ADD] Node flags = null != pattern ? pattern.getNext (  )  : null;^[METHOD] tryFoldRegularExpressionConstructor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node constructor  flags  n  parent  pattern  regexLiteral  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( null != pattern ||  ( null != flags && null != flags.setType (  )  )  )  {^1636^^^^^1631^1679^[REPLACE] if  ( null == pattern ||  ( null != flags && null != flags.getNext (  )  )  )  {^[METHOD] tryFoldRegularExpressionConstructor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node constructor  flags  n  parent  pattern  regexLiteral  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return;  ;^1638^^^^^1631^1679^[REPLACE] return;^[METHOD] tryFoldRegularExpressionConstructor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node constructor  flags  n  parent  pattern  regexLiteral  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( pattern.getType (  )  == Token.STRING  && "".equals ( pattern.toString (  )  )^1641^1642^1643^1644^^1631^1679^[REPLACE] if  ( pattern.getType (  )  == Token.STRING  && !"".equals ( pattern.getString (  )  )^[METHOD] tryFoldRegularExpressionConstructor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node constructor  flags  n  parent  pattern  regexLiteral  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1641^1642^^1644^^1631^1679^[ADD] if  ( pattern.getType (  )  == Token.STRING && !"".equals ( pattern.getString (  )  )^[METHOD] tryFoldRegularExpressionConstructor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node constructor  flags  n  parent  pattern  regexLiteral  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  (  "".equals ( flags.toString (  )  )  )  {^1660^^^^^1641^1678^[REPLACE] if  ( null == flags || "".equals ( flags.getString (  )  )  )  {^[METHOD] tryFoldRegularExpressionConstructor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node constructor  flags  n  parent  pattern  regexLiteral  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if   (  !areSafeFlagsToFold  (  flags.getString  (    )    )    )   {  ;^1665^^^^^1660^1674^[REPLACE] if  ( !areValidRegexpFlags ( flags.getString (  )  )  )  {^[METHOD] tryFoldRegularExpressionConstructor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node constructor  flags  n  parent  pattern  regexLiteral  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1665^1666^1667^1668^^1660^1674^[ADD] if  ( !areValidRegexpFlags ( flags.getString (  )  )  )  { error ( t, INVALID_REGULAR_EXPRESSION_FLAGS, flags ) ; return; }^[METHOD] tryFoldRegularExpressionConstructor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node constructor  flags  n  parent  pattern  regexLiteral  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if   (  !areValidRegexpFlags  (  flags.getString  (    )    )    )   {  ;^1669^^^^^1660^1674^[REPLACE] if  ( !areSafeFlagsToFold ( flags.getString (  )  )  )  {^[METHOD] tryFoldRegularExpressionConstructor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node constructor  flags  n  parent  pattern  regexLiteral  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^regexLiteral = new Node ( REGEXP, pattern )  ;^1673^^^^^1660^1674^[REPLACE] regexLiteral = new Node ( Token.REGEXP, pattern, flags ) ;^[METHOD] tryFoldRegularExpressionConstructor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node constructor  flags  n  parent  pattern  regexLiteral  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return;  ;^1667^^^^^1660^1674^[REPLACE] return;^[METHOD] tryFoldRegularExpressionConstructor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node constructor  flags  n  parent  pattern  regexLiteral  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return;  ;^1670^^^^^1660^1674^[REPLACE] return;^[METHOD] tryFoldRegularExpressionConstructor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node constructor  flags  n  parent  pattern  regexLiteral  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1662^^^^^1641^1678^[ADD] regexLiteral = new Node ( Token.REGEXP, pattern ) ;^[METHOD] tryFoldRegularExpressionConstructor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node constructor  flags  n  parent  pattern  regexLiteral  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( !areValidRegexpFlags ( regexLiteral.getString (  )  )  )  {^1665^^^^^1641^1678^[REPLACE] if  ( !areValidRegexpFlags ( flags.getString (  )  )  )  {^[METHOD] tryFoldRegularExpressionConstructor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node constructor  flags  n  parent  pattern  regexLiteral  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return;  ;^1667^^^^^1641^1678^[REPLACE] return;^[METHOD] tryFoldRegularExpressionConstructor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node constructor  flags  n  parent  pattern  regexLiteral  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( areSafeFlagsToFold ( flags.getString (  )  )  )  {^1669^^^^^1641^1678^[REPLACE] if  ( !areSafeFlagsToFold ( flags.getString (  )  )  )  {^[METHOD] tryFoldRegularExpressionConstructor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node constructor  flags  n  parent  pattern  regexLiteral  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1669^1670^1671^^^1641^1678^[ADD] if  ( !areSafeFlagsToFold ( flags.getString (  )  )  )  { return; }^[METHOD] tryFoldRegularExpressionConstructor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node constructor  flags  n  parent  pattern  regexLiteral  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return;  ;^1670^^^^^1641^1678^[REPLACE] return;^[METHOD] tryFoldRegularExpressionConstructor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node constructor  flags  n  parent  pattern  regexLiteral  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1657^^^^^1641^1678^[ADD] pattern = makeForwardSlashBracketSafe ( pattern ) ;^[METHOD] tryFoldRegularExpressionConstructor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node constructor  flags  n  parent  pattern  regexLiteral  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^regexLiteral = new Node ( REGEXP, pattern, flags )  ;^1662^^^^^1641^1678^[REPLACE] regexLiteral = new Node ( Token.REGEXP, pattern ) ;^[METHOD] tryFoldRegularExpressionConstructor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node constructor  flags  n  parent  pattern  regexLiteral  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^regexLiteral = new Node ( REGEXP, pattern )  ;^1673^^^^^1641^1678^[REPLACE] regexLiteral = new Node ( Token.REGEXP, pattern, flags ) ;^[METHOD] tryFoldRegularExpressionConstructor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node constructor  flags  n  parent  pattern  regexLiteral  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1659^^^^^1641^1678^[ADD] Node regexLiteral;^[METHOD] tryFoldRegularExpressionConstructor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node constructor  flags  n  parent  pattern  regexLiteral  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( false != flags || "".equals ( flags.getString (  )  )  )  {^1660^^^^^1631^1679^[REPLACE] if  ( null == flags || "".equals ( flags.getString (  )  )  )  {^[METHOD] tryFoldRegularExpressionConstructor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node constructor  flags  n  parent  pattern  regexLiteral  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1660^1661^1662^1663^^1631^1679^[ADD] if  ( null == flags || "".equals ( flags.getString (  )  )  )  {  regexLiteral = new Node ( Token.REGEXP, pattern ) ; } else {^[METHOD] tryFoldRegularExpressionConstructor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node constructor  flags  n  parent  pattern  regexLiteral  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( !areSafeFlagsToFold ( regexLiteral.getString (  )  )  )  {^1669^^^^^1660^1674^[REPLACE] if  ( !areSafeFlagsToFold ( flags.getString (  )  )  )  {^[METHOD] tryFoldRegularExpressionConstructor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node constructor  flags  n  parent  pattern  regexLiteral  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[ADD]^return;^1669^1670^1671^^^1660^1674^[ADD] if  ( !areSafeFlagsToFold ( flags.getString (  )  )  )  { return; }^[METHOD] tryFoldRegularExpressionConstructor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node constructor  flags  n  parent  pattern  regexLiteral  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^regexLiteral = new Node ( REGEXP, pattern, flags )  ;^1662^^^^^1631^1679^[REPLACE] regexLiteral = new Node ( Token.REGEXP, pattern ) ;^[METHOD] tryFoldRegularExpressionConstructor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node constructor  flags  n  parent  pattern  regexLiteral  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if   (  !areSafeFlagsToFold  (  flags.getString  (    )    )    )   {  ;^1665^^^^^1631^1679^[REPLACE] if  ( !areValidRegexpFlags ( flags.getString (  )  )  )  {^[METHOD] tryFoldRegularExpressionConstructor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node constructor  flags  n  parent  pattern  regexLiteral  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1665^1666^1667^1668^^1631^1679^[ADD] if  ( !areValidRegexpFlags ( flags.getString (  )  )  )  { error ( t, INVALID_REGULAR_EXPRESSION_FLAGS, flags ) ; return; }^[METHOD] tryFoldRegularExpressionConstructor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node constructor  flags  n  parent  pattern  regexLiteral  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return;  ;^1667^^^^^1631^1679^[REPLACE] return;^[METHOD] tryFoldRegularExpressionConstructor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node constructor  flags  n  parent  pattern  regexLiteral  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( !areSafeFlagsToFold ( regexLiteral.getString (  )  )  )  {^1669^^^^^1631^1679^[REPLACE] if  ( !areSafeFlagsToFold ( flags.getString (  )  )  )  {^[METHOD] tryFoldRegularExpressionConstructor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node constructor  flags  n  parent  pattern  regexLiteral  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return;  ;^1670^^^^^1631^1679^[REPLACE] return;^[METHOD] tryFoldRegularExpressionConstructor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node constructor  flags  n  parent  pattern  regexLiteral  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^pattern =  makeForwardSlashBracketSafe ( regexLiteral ) ;^1657^^^^^1631^1679^[REPLACE] pattern = makeForwardSlashBracketSafe ( pattern ) ;^[METHOD] tryFoldRegularExpressionConstructor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node constructor  flags  n  parent  pattern  regexLiteral  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1673^^^^^1631^1679^[ADD] regexLiteral = new Node ( Token.REGEXP, pattern, flags ) ;^[METHOD] tryFoldRegularExpressionConstructor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node constructor  flags  n  parent  pattern  regexLiteral  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^Node lr = ll.getNext (  )  ;^1659^^^^^1631^1679^[REPLACE] Node regexLiteral;^[METHOD] tryFoldRegularExpressionConstructor [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node constructor  flags  n  parent  pattern  regexLiteral  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^String s = n .newString ( s )  ;^1710^^^^^1709^1732^[REPLACE] String s = n.getString (  ) ;^[METHOD] makeForwardSlashBracketSafe [TYPE] Node [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  [TYPE]  String s  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1712^^^^^1709^1732^[ADD] StringBuilder sb = null;^[METHOD] makeForwardSlashBracketSafe [TYPE] Node [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  [TYPE]  String s  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^int pos = 4;^1713^^^^^1709^1732^[REPLACE] int pos = 0;^[METHOD] makeForwardSlashBracketSafe [TYPE] Node [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  [TYPE]  String s  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( null == sb )  { sb = new StringBuilder ( s.length (  )  + 2 + 16 ) ; }^1720^^^^^1709^1732^[REPLACE] if  ( null == sb )  { sb = new StringBuilder ( s.length (  )  + 16 ) ; }^[METHOD] makeForwardSlashBracketSafe [TYPE] Node [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  [TYPE]  String s  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[ADD]^sb.append ( s, pos, i ) .append ( '\\' ) ;pos = i;break;^1720^1721^1722^1723^1724^1709^1732^[ADD] if  ( null == sb )  { sb = new StringBuilder ( s.length (  )  + 16 ) ; } sb.append ( s, pos, i ) .append ( '\\' ) ; pos = i; break; }^[METHOD] makeForwardSlashBracketSafe [TYPE] Node [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  [TYPE]  String s  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( null == sb )  { sb = new StringBuilder ( s.length (  )  - 2 + 0  ) ; }^1720^^^^^1709^1732^[REPLACE] if  ( null == sb )  { sb = new StringBuilder ( s.length (  )  + 16 ) ; }^[METHOD] makeForwardSlashBracketSafe [TYPE] Node [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  [TYPE]  String s  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^pos =  rvalInt;^1722^^^^^1709^1732^[REPLACE] pos = i;^[METHOD] makeForwardSlashBracketSafe [TYPE] Node [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  [TYPE]  String s  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1714^1715^1716^1717^1718^1709^1732^[ADD] for  ( int i = 0; i < s.length (  ) ; ++i )  { switch  ( s.charAt ( i )  )  { case '\\': ++i; break;^[METHOD] makeForwardSlashBracketSafe [TYPE] Node [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  [TYPE]  String s  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( null != sb )  { return n.cloneTree (  ) ; }^1728^^^^^1709^1732^[REPLACE] if  ( null == sb )  { return n.cloneTree (  ) ; }^[METHOD] makeForwardSlashBracketSafe [TYPE] Node [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  [TYPE]  String s  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( null == sb )  { return n.getType (  ) ; }^1728^^^^^1709^1732^[REPLACE] if  ( null == sb )  { return n.cloneTree (  ) ; }^[METHOD] makeForwardSlashBracketSafe [TYPE] Node [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  [TYPE]  String s  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^sb.append ( s, pos, i )  ;^1730^^^^^1709^1732^[REPLACE] sb.append ( s, pos, s.length (  )  ) ;^[METHOD] makeForwardSlashBracketSafe [TYPE] Node [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  [TYPE]  String s  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^( s.length (  )  )  ;^1730^^^^^1709^1732^[REPLACE] sb.append ( s, pos, s.length (  )  ) ;^[METHOD] makeForwardSlashBracketSafe [TYPE] Node [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  [TYPE]  String s  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return Node .getString (  )  ;^1731^^^^^1709^1732^[REPLACE] return Node.newString ( sb.toString (  )  ) ;^[METHOD] makeForwardSlashBracketSafe [TYPE] Node [PARAMETER] Node n [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  StringBuilder sb  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node n  [TYPE]  String s  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^Preconditions.checkState ( n.getType (  )   !=  Token.DO ) ;^1813^^^^^1812^1832^[REPLACE] Preconditions.checkArgument ( n.getType (  )  == Token.DO ) ;^[METHOD] tryFoldDo [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node block  cond  n  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^( left.getType (  )  )  ;^1813^^^^^1812^1832^[REPLACE] Preconditions.checkArgument ( n.getType (  )  == Token.DO ) ;^[METHOD] tryFoldDo [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node block  cond  n  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^Node cond = NodeUtil.getConditionExpression ( parent ) ;^1815^^^^^1812^1832^[REPLACE] Node cond = NodeUtil.getConditionExpression ( n ) ;^[METHOD] tryFoldDo [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node block  cond  n  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( NodeUtil.isLiteralValue ( cond )  || NodeUtil.getStringValue ( cond )  )  {^1816^^^^^1812^1832^[REPLACE] if  ( !NodeUtil.isLiteralValue ( cond )  || NodeUtil.getBooleanValue ( cond )  )  {^[METHOD] tryFoldDo [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node block  cond  n  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return;  ;^1817^^^^^1812^1832^[REPLACE] return;^[METHOD] tryFoldDo [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node block  cond  n  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( hasBreakOrContinue ( parent )  )  {^1822^^^^^1812^1832^[REPLACE] if  ( hasBreakOrContinue ( n )  )  {^[METHOD] tryFoldDo [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node block  cond  n  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return;  ;^1823^^^^^1812^1832^[REPLACE] return;^[METHOD] tryFoldDo [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node block  cond  n  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^Preconditions.checkState ( NodeUtil.isControlStructureCodeBlock ( parent, n.getFirstChild (  )  )  ) ;^1826^1827^^^^1812^1832^[REPLACE] Preconditions.checkState ( NodeUtil.isControlStructureCodeBlock ( n, n.getFirstChild (  )  )  ) ;^[METHOD] tryFoldDo [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node block  cond  n  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^NodeUtil.isControlStructureCodeBlock ( parent, n.getFirstChild (  )  )  ) ;^1827^^^^^1812^1832^[REPLACE] NodeUtil.isControlStructureCodeBlock ( n, n.getFirstChild (  )  )  ) ;^[METHOD] tryFoldDo [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node block  cond  n  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^NodeUtil.isControlStructureCodeBlock ( parent, n.getLastChild (  )  )  ) ;^1827^^^^^1812^1832^[REPLACE] NodeUtil.isControlStructureCodeBlock ( n, n.getFirstChild (  )  )  ) ;^[METHOD] tryFoldDo [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node block  cond  n  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[ADD]^Node block = n.removeFirstChild (  ) ;^1827^1828^^^^1812^1832^[ADD] NodeUtil.isControlStructureCodeBlock ( n, n.getFirstChild (  )  )  ) ; Node block = n.removeFirstChild (  ) ;^[METHOD] tryFoldDo [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node block  cond  n  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^Node arrayNode = left.getFirstChild (  )  ;^1828^^^^^1812^1832^[REPLACE] Node block = n.removeFirstChild (  ) ;^[METHOD] tryFoldDo [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node block  cond  n  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^parent.replaceChild ( n, cond ) ;^1830^^^^^1812^1832^[REPLACE] parent.replaceChild ( n, block ) ;^[METHOD] tryFoldDo [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node block  cond  n  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^t .getScope (  )  .reportCodeChange (  ) ;^1831^^^^^1812^1832^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryFoldDo [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node block  cond  n  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^t.getScope (  ) .reportCodeChange (  ) ;^1831^^^^^1812^1832^[REPLACE] t.getCompiler (  ) .reportCodeChange (  ) ;^[METHOD] tryFoldDo [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node block  cond  n  parent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if  ( leftParent.getType (  )  != Token.NOT && rightParent.getType (  )  != Token.NOT )  {^1881^1882^^^^1861^1924^[REPLACE] if  ( leftParent.getType (  )  != Token.NOT || rightParent.getType (  )  != Token.NOT )  {^[METHOD] tryMinimizeCondition [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  result  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1881^1882^^1884^1885^1861^1924^[ADD] if  ( leftParent.getType (  )  != Token.NOT || rightParent.getType (  )  != Token.NOT )  { break; }^[METHOD] tryMinimizeCondition [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  result  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^if   (  NodeUtil.isImmutableValue  (  elem  )    )   {  ;^1910^^^^^1861^1924^[REPLACE] if  ( NodeUtil.isLiteralValue ( n )  )  {^[METHOD] tryMinimizeCondition [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  result  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^boolean rval = getBooleanValue ( right )  ;^1911^^^^^1861^1924^[REPLACE] boolean result = NodeUtil.getBooleanValue ( n ) ;^[METHOD] tryMinimizeCondition [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  result  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^int equivalentResult = result ? 2 : 0;^1912^^^^^1861^1924^[REPLACE] int equivalentResult = result ? 1 : 0;^[METHOD] tryMinimizeCondition [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  result  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^n =  rightParent;^1870^^^^^1861^1924^[REPLACE] n = newRoot;^[METHOD] tryMinimizeCondition [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  result  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^n =  rightParent;^1892^^^^^1861^1924^[REPLACE] n = newRoot;^[METHOD] tryMinimizeCondition [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  result  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return;  ;^1875^^^^^1861^1924^[REPLACE] return;^[METHOD] tryMinimizeCondition [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  result  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^return;  ;^1916^^^^^1861^1924^[REPLACE] return;^[METHOD] tryMinimizeCondition [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  result  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^Node first = rightParent .getLastChild (  )  ;^1865^^^^^1861^1924^[REPLACE] Node first = n.getFirstChild (  ) ;^[METHOD] tryMinimizeCondition [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  result  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1868^^^^^1861^1924^[ADD] Node newRoot = first.removeFirstChild (  ) ;^[METHOD] tryMinimizeCondition [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  result  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^Node arrayNode = left.getFirstChild (  )  ;^1879^^^^^1861^1924^[REPLACE] Node leftParent = first.getFirstChild (  ) ;^[METHOD] tryMinimizeCondition [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  result  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1880^^^^^1861^1924^[ADD] Node rightParent = first.getLastChild (  ) ;^[METHOD] tryMinimizeCondition [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  result  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^Node arrayNode = left.getFirstChild (  )  ;^1886^^^^^1861^1924^[REPLACE] Node left = leftParent.removeFirstChild (  ) ;^[METHOD] tryMinimizeCondition [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  result  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^Node right = next.removeFirstChild (  ) ;^1887^^^^^1861^1924^[REPLACE] Node right = rightParent.removeFirstChild (  ) ;^[METHOD] tryMinimizeCondition [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  result  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^int newOp  =  Token.OR ;^1889^^^^^1861^1924^[REPLACE] int newOp =  ( first.getType (  )  == Token.AND )  ? Token.OR : Token.AND;^[METHOD] tryMinimizeCondition [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  result  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^Node notCond = new Node ( NOT )  ;^1890^^^^^1861^1924^[REPLACE] Node newRoot = new Node ( newOp, left, right ) ;^[METHOD] tryMinimizeCondition [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  result  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^boolean result = NodeUtil.getBooleanValue ( rightParent ) ;^1911^^^^^1861^1924^[REPLACE] boolean result = NodeUtil.getBooleanValue ( n ) ;^[METHOD] tryMinimizeCondition [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  result  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1912^^^^^1861^1924^[ADD] int equivalentResult = result ? 1 : 0;^[METHOD] tryMinimizeCondition [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  result  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^c =  right;^1922^^^^^1861^1924^[REPLACE] c = next;^[METHOD] tryMinimizeCondition [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  result  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[ADD]^^1919^1920^1921^1922^1923^1861^1924^[ADD] for  ( Node c = n.getFirstChild (  ) ; c != null;  )  { Node next = c.getNext (  ) ; tryMinimizeCondition ( t, c, n ) ; c = next; }^[METHOD] tryMinimizeCondition [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  result  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
[REPLACE]^Node next = c .getParent (  )  ;^1920^^^^^1861^1924^[REPLACE] Node next = c.getNext (  ) ;^[METHOD] tryMinimizeCondition [TYPE] void [PARAMETER] NodeTraversal t Node n Node parent [CLASS] FoldConstants 1 2   [TYPE]  Pattern REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean false  result  true  [TYPE]  NodeTraversal t  [TYPE]  DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  [TYPE]  Node c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  [TYPE]  int AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type 
