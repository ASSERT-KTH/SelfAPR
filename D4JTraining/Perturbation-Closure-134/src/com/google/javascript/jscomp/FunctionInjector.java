[REPLACE]^private  AbstractCompiler compiler;^38^^^^^^^[REPLACE] private final AbstractCompiler compiler;^ [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult  
[REPLACE]^private  boolean allowDecomposition;^40^^^^^^^[REPLACE] private final boolean allowDecomposition;^ [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult  
[REPLACE]^private Set<String> knownConstants ;^41^^^^^^^[REPLACE] private Set<String> knownConstants = Sets.newHashSet (  ) ;^ [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult  
[REPLACE]^Node callNode;^76^^^^^^^[REPLACE] final Node callNode;^ [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult  
[REPLACE]^JSModule module;^77^^^^^^^[REPLACE] final JSModule module;^ [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult  
[REPLACE]^InliningMode mode;^78^^^^^^^[REPLACE] final InliningMode mode;^ [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult  
[REPLACE]^private static  int NAME_COST_ESTIMATE = InlineCostEstimator.ESTIMATED_IDENTIFIER_COST;^93^94^^^^93^94^[REPLACE] private static final int NAME_COST_ESTIMATE = InlineCostEstimator.ESTIMATED_IDENTIFIER_COST;^ [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult  
[REPLACE]^private static final int COMMA_COST ;^97^^^^^^^[REPLACE] private static final int COMMA_COST = 1;^ [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult  
[REPLACE]^private static  int PAREN_COST = 2;^100^^^^^^^[REPLACE] private static final int PAREN_COST = 2;^ [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult  
[ADD]^^113^^^^^112^141^[ADD] Node block = NodeUtil.getFunctionBody ( fnNode ) ;^[METHOD] doesFunctionMeetMinimumRequirements [TYPE] boolean [PARAMETER] String fnName Node fnNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  true  [TYPE]  Set knownConstants  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  fnNode  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String fnName  fnRecursionName  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^if  ( NodeUtil .isNodeTypeReferenced (  )   )  {^117^^^^^112^141^[REPLACE] if  ( NodeUtil.isNameReferenced ( block, fnName )  )  {^[METHOD] doesFunctionMeetMinimumRequirements [TYPE] boolean [PARAMETER] String fnName Node fnNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  true  [TYPE]  Set knownConstants  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  fnNode  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String fnName  fnRecursionName  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^return true;^118^^^^^112^141^[REPLACE] return false;^[METHOD] doesFunctionMeetMinimumRequirements [TYPE] boolean [PARAMETER] String fnName Node fnNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  true  [TYPE]  Set knownConstants  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  fnNode  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String fnName  fnRecursionName  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^String fnRecursionName = callNode .getLastChild (  )  .getString (  ) ;^121^^^^^112^141^[REPLACE] String fnRecursionName = fnNode.getFirstChild (  ) .getString (  ) ;^[METHOD] doesFunctionMeetMinimumRequirements [TYPE] boolean [PARAMETER] String fnName Node fnNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  true  [TYPE]  Set knownConstants  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  fnNode  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String fnName  fnRecursionName  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^if  (  !fnRecursionName.isEmpty (  ) && !fnRecursionName.equals ( fnName ) && NodeUtil.isNameReferenced ( block, fnRecursionName )  )  {^122^123^124^125^^112^141^[REPLACE] if  ( fnRecursionName != null && !fnRecursionName.isEmpty (  ) && !fnRecursionName.equals ( fnName ) && NodeUtil.isNameReferenced ( block, fnRecursionName )  )  {^[METHOD] doesFunctionMeetMinimumRequirements [TYPE] boolean [PARAMETER] String fnName Node fnNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  true  [TYPE]  Set knownConstants  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  fnNode  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String fnName  fnRecursionName  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^return true;^126^^^^^122^127^[REPLACE] return false;^[METHOD] doesFunctionMeetMinimumRequirements [TYPE] boolean [PARAMETER] String fnName Node fnNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  true  [TYPE]  Set knownConstants  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  fnNode  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String fnName  fnRecursionName  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^return true;^126^^^^^112^141^[REPLACE] return false;^[METHOD] doesFunctionMeetMinimumRequirements [TYPE] boolean [PARAMETER] String fnName Node fnNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  true  [TYPE]  Set knownConstants  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  fnNode  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String fnName  fnRecursionName  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^if  ( NodeUtil.isLhs ( fnNode, "arguments" )  )  {^130^^^^^112^141^[REPLACE] if  ( NodeUtil.isNameReferenced ( block, "arguments" )  )  {^[METHOD] doesFunctionMeetMinimumRequirements [TYPE] boolean [PARAMETER] String fnName Node fnNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  true  [TYPE]  Set knownConstants  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  fnNode  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String fnName  fnRecursionName  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[ADD]^return false;^130^131^132^^^112^141^[ADD] if  ( NodeUtil.isNameReferenced ( block, "arguments" )  )  { return false; }^[METHOD] doesFunctionMeetMinimumRequirements [TYPE] boolean [PARAMETER] String fnName Node fnNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  true  [TYPE]  Set knownConstants  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  fnNode  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String fnName  fnRecursionName  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^return false;  ;^131^^^^^112^141^[REPLACE] return false;^[METHOD] doesFunctionMeetMinimumRequirements [TYPE] boolean [PARAMETER] String fnName Node fnNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  true  [TYPE]  Set knownConstants  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  fnNode  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String fnName  fnRecursionName  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^if  ( NodeUtil.isFunctionObjectCall ( fnNode )  )  {^136^^^^^112^141^[REPLACE] if  ( NodeUtil.containsFunctionDeclaration ( block )  )  {^[METHOD] doesFunctionMeetMinimumRequirements [TYPE] boolean [PARAMETER] String fnName Node fnNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  true  [TYPE]  Set knownConstants  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  fnNode  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String fnName  fnRecursionName  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[ADD]^return false;^136^137^138^^^112^141^[ADD] if  ( NodeUtil.containsFunctionDeclaration ( block )  )  { return false; }^[METHOD] doesFunctionMeetMinimumRequirements [TYPE] boolean [PARAMETER] String fnName Node fnNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  true  [TYPE]  Set knownConstants  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  fnNode  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String fnName  fnRecursionName  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^return true;^137^^^^^112^141^[REPLACE] return false;^[METHOD] doesFunctionMeetMinimumRequirements [TYPE] boolean [PARAMETER] String fnName Node fnNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  true  [TYPE]  Set knownConstants  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  fnNode  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String fnName  fnRecursionName  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^return false;^140^^^^^112^141^[REPLACE] return true;^[METHOD] doesFunctionMeetMinimumRequirements [TYPE] boolean [PARAMETER] String fnName Node fnNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  true  [TYPE]  Set knownConstants  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  fnNode  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String fnName  fnRecursionName  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^if  ( !isSupportedCallType ( fnNode )  )  {^157^^^^^154^174^[REPLACE] if  ( !isSupportedCallType ( callNode )  )  {^[METHOD] canInlineReferenceToFunction [TYPE] FunctionInjector$CanInlineResult [PARAMETER] NodeTraversal t Node callNode Node fnNode String> needAliases InliningMode mode boolean referencesThis [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  NodeTraversal t  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  fnNode  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^return newBlock;  ;^158^^^^^154^174^[REPLACE] return CanInlineResult.NO;^[METHOD] canInlineReferenceToFunction [TYPE] FunctionInjector$CanInlineResult [PARAMETER] NodeTraversal t Node callNode Node fnNode String> needAliases InliningMode mode boolean referencesThis [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  NodeTraversal t  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  fnNode  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^if  (  NodeUtil.isFunctionObjectApply ( callNode )  )  {^162^^^^^154^174^[REPLACE] if  ( referencesThis && !NodeUtil.isFunctionObjectCall ( callNode )  )  {^[METHOD] canInlineReferenceToFunction [TYPE] FunctionInjector$CanInlineResult [PARAMETER] NodeTraversal t Node callNode Node fnNode String> needAliases InliningMode mode boolean referencesThis [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  NodeTraversal t  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  fnNode  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^return newBlock;  ;^165^^^^^154^174^[REPLACE] return CanInlineResult.NO;^[METHOD] canInlineReferenceToFunction [TYPE] FunctionInjector$CanInlineResult [PARAMETER] NodeTraversal t Node callNode Node fnNode String> needAliases InliningMode mode boolean referencesThis [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  NodeTraversal t  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  fnNode  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^if  ( mode  !=  InliningMode.DIRECT )  {^168^^^^^154^174^[REPLACE] if  ( mode == InliningMode.DIRECT )  {^[METHOD] canInlineReferenceToFunction [TYPE] FunctionInjector$CanInlineResult [PARAMETER] NodeTraversal t Node callNode Node fnNode String> needAliases InliningMode mode boolean referencesThis [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  NodeTraversal t  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  fnNode  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[ADD]^return canInlineReferenceDirectly ( callNode, fnNode ) ;t, callNode, fnNode, needAliases ) ;^168^169^170^171^172^154^174^[ADD] if  ( mode == InliningMode.DIRECT )  { return canInlineReferenceDirectly ( callNode, fnNode ) ; } else { return canInlineReferenceAsStatementBlock ( t, callNode, fnNode, needAliases ) ;^[METHOD] canInlineReferenceToFunction [TYPE] FunctionInjector$CanInlineResult [PARAMETER] NodeTraversal t Node callNode Node fnNode String> needAliases InliningMode mode boolean referencesThis [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  NodeTraversal t  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  fnNode  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^return canInlineReferenceAsStatementBlock ( t, callNode, fnNode, this ) ;^171^172^^^^168^173^[REPLACE] return canInlineReferenceAsStatementBlock ( t, callNode, fnNode, needAliases ) ;^[METHOD] canInlineReferenceToFunction [TYPE] FunctionInjector$CanInlineResult [PARAMETER] NodeTraversal t Node callNode Node fnNode String> needAliases InliningMode mode boolean referencesThis [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  NodeTraversal t  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  fnNode  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^return canInlineReferenceDirectly  (  callNode, fnNode  )  ;  ;^169^^^^^154^174^[REPLACE] return canInlineReferenceDirectly ( callNode, fnNode ) ;^[METHOD] canInlineReferenceToFunction [TYPE] FunctionInjector$CanInlineResult [PARAMETER] NodeTraversal t Node callNode Node fnNode String> needAliases InliningMode mode boolean referencesThis [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  NodeTraversal t  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  fnNode  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^return canInlineReferenceAsStatementBlock  (  t, callNode, fnNode, needAliases  )  ;  ;^171^172^^^^154^174^[REPLACE] return canInlineReferenceAsStatementBlock ( t, callNode, fnNode, needAliases ) ;^[METHOD] canInlineReferenceToFunction [TYPE] FunctionInjector$CanInlineResult [PARAMETER] NodeTraversal t Node callNode Node fnNode String> needAliases InliningMode mode boolean referencesThis [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  NodeTraversal t  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  fnNode  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[ADD]^^217^218^^^^216^246^[ADD] Node block = fnNode.getLastChild (  ) ; Node callParentNode = callNode.getParent (  ) ;^[METHOD] inlineReturnValue [TYPE] Node [PARAMETER] Node callNode Node fnNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  fnNode  inlineResult  newExpression  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  Map argMap  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^Node callParentNode = safeReturnNode.getString (  ) ;^218^^^^^216^246^[REPLACE] Node callParentNode = callNode.getParent (  ) ;^[METHOD] inlineReturnValue [TYPE] Node [PARAMETER] Node callNode Node fnNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  fnNode  inlineResult  newExpression  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  Map argMap  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^Map<String, Node> argMap = FunctionArgumentInjector.getFunctionCallParameterMap ( thisValue, callNode, this.safeNameIdSupplier ) ;^225^226^227^^^216^246^[REPLACE] Map<String, Node> argMap = FunctionArgumentInjector.getFunctionCallParameterMap ( fnNode, callNode, this.safeNameIdSupplier ) ;^[METHOD] inlineReturnValue [TYPE] Node [PARAMETER] Node callNode Node fnNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  fnNode  inlineResult  newExpression  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  Map argMap  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^Node parent  ;^229^^^^^216^246^[REPLACE] Node newExpression;^[METHOD] inlineReturnValue [TYPE] Node [PARAMETER] Node callNode Node fnNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  fnNode  inlineResult  newExpression  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  Map argMap  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^if  ( block.hasChildren (  )  )  {^230^^^^^216^246^[REPLACE] if  ( !block.hasChildren (  )  )  {^[METHOD] inlineReturnValue [TYPE] Node [PARAMETER] Node callNode Node fnNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  fnNode  inlineResult  newExpression  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  Map argMap  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[ADD]^newExpression = NodeUtil.newUndefinedNode (  ) ;Node returnNode = block.getFirstChild (  ) ;Preconditions.checkArgument ( returnNode.getType (  )  == Token.RETURN ) ;^230^231^232^233^234^216^246^[ADD] if  ( !block.hasChildren (  )  )  { newExpression = NodeUtil.newUndefinedNode (  ) ; } else { Node returnNode = block.getFirstChild (  ) ; Preconditions.checkArgument ( returnNode.getType (  )  == Token.RETURN ) ;^[METHOD] inlineReturnValue [TYPE] Node [PARAMETER] Node callNode Node fnNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  fnNode  inlineResult  newExpression  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  Map argMap  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^newExpression =  thisValue.removeFirstChild (  ) ;^241^^^^^230^242^[REPLACE] newExpression = safeReturnNode.removeFirstChild (  ) ;^[METHOD] inlineReturnValue [TYPE] Node [PARAMETER] Node callNode Node fnNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  fnNode  inlineResult  newExpression  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  Map argMap  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^Node block = fnNode.getLastChild (  )  ;^233^^^^^230^242^[REPLACE] Node returnNode = block.getFirstChild (  ) ;^[METHOD] inlineReturnValue [TYPE] Node [PARAMETER] Node callNode Node fnNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  fnNode  inlineResult  newExpression  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  Map argMap  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^Node safeReturnNode = thisValue.cloneTree (  ) ;^237^^^^^230^242^[REPLACE] Node safeReturnNode = returnNode.cloneTree (  ) ;^[METHOD] inlineReturnValue [TYPE] Node [PARAMETER] Node callNode Node fnNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  fnNode  inlineResult  newExpression  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  Map argMap  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^Node inlineResult = FunctionArgumentInjector.inject ( inlineResult, true, argMap ) ;^238^239^^^^230^242^[REPLACE] Node inlineResult = FunctionArgumentInjector.inject ( safeReturnNode, null, argMap ) ;^[METHOD] inlineReturnValue [TYPE] Node [PARAMETER] Node callNode Node fnNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  fnNode  inlineResult  newExpression  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  Map argMap  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[ADD]^^231^^^^^216^246^[ADD] newExpression = NodeUtil.newUndefinedNode (  ) ;^[METHOD] inlineReturnValue [TYPE] Node [PARAMETER] Node callNode Node fnNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  fnNode  inlineResult  newExpression  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  Map argMap  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^newExpression  =  newExpression ;^231^^^^^216^246^[REPLACE] newExpression = NodeUtil.newUndefinedNode (  ) ;^[METHOD] inlineReturnValue [TYPE] Node [PARAMETER] Node callNode Node fnNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  fnNode  inlineResult  newExpression  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  Map argMap  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^newExpression =  thisValue.removeFirstChild (  ) ;^241^^^^^216^246^[REPLACE] newExpression = safeReturnNode.removeFirstChild (  ) ;^[METHOD] inlineReturnValue [TYPE] Node [PARAMETER] Node callNode Node fnNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  fnNode  inlineResult  newExpression  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  Map argMap  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^Node returnNode = returnNode.getLastChild (  ) ;^233^^^^^216^246^[REPLACE] Node returnNode = block.getFirstChild (  ) ;^[METHOD] inlineReturnValue [TYPE] Node [PARAMETER] Node callNode Node fnNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  fnNode  inlineResult  newExpression  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  Map argMap  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^Node safeReturnNode = thisValue .addChildBefore ( block , callNode )  ;^237^^^^^216^246^[REPLACE] Node safeReturnNode = returnNode.cloneTree (  ) ;^[METHOD] inlineReturnValue [TYPE] Node [PARAMETER] Node callNode Node fnNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  fnNode  inlineResult  newExpression  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  Map argMap  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^Node inlineResult = FunctionArgumentInjector.inject ( safeReturnNode, false, null ) ;^238^239^^^^216^246^[REPLACE] Node inlineResult = FunctionArgumentInjector.inject ( safeReturnNode, null, argMap ) ;^[METHOD] inlineReturnValue [TYPE] Node [PARAMETER] Node callNode Node fnNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  fnNode  inlineResult  newExpression  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  Map argMap  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^callParentNode.replaceChild ( callNode, safeReturnNode ) ;^244^^^^^216^246^[REPLACE] callParentNode.replaceChild ( callNode, newExpression ) ;^[METHOD] inlineReturnValue [TYPE] Node [PARAMETER] Node callNode Node fnNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  fnNode  inlineResult  newExpression  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  Map argMap  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^return newExpression;  ;^245^^^^^216^246^[REPLACE] return newExpression;^[METHOD] inlineReturnValue [TYPE] Node [PARAMETER] Node callNode Node fnNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  fnNode  inlineResult  newExpression  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  Map argMap  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^Node parent = newExpression.getString (  ) ;^314^^^^^313^353^[REPLACE] Node parent = callNode.getParent (  ) ;^[METHOD] classifyCallSite [TYPE] FunctionInjector$CallSiteType [PARAMETER] Node callNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  DecompositionType type  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  inlineResult  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  ExpressionDecomposer decomposer  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^Node grandParent = safeReturnNode.getParent (  ) ;^315^^^^^313^353^[REPLACE] Node grandParent = parent.getParent (  ) ;^[METHOD] classifyCallSite [TYPE] FunctionInjector$CallSiteType [PARAMETER] Node callNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  DecompositionType type  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  inlineResult  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  ExpressionDecomposer decomposer  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^if   (  NodeUtil.isLoopStructure  (  parent  )    )   {  ;^318^^^^^313^353^[REPLACE] if  ( NodeUtil.isExprCall ( parent )  )  {^[METHOD] classifyCallSite [TYPE] FunctionInjector$CallSiteType [PARAMETER] Node callNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  DecompositionType type  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  inlineResult  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  ExpressionDecomposer decomposer  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^}  else {^321^322^323^324^^313^353^[REPLACE] } else if  ( NodeUtil.isExprAssign ( grandParent ) && !NodeUtil.isLhs ( callNode, parent ) && parent.getFirstChild (  ) .getType (  )  == Token.NAME && !NodeUtil.isConstantName ( parent.getFirstChild (  )  )  )  {^[METHOD] classifyCallSite [TYPE] FunctionInjector$CallSiteType [PARAMETER] Node callNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  DecompositionType type  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  inlineResult  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  ExpressionDecomposer decomposer  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^}  else {^327^328^329^330^^313^353^[REPLACE] } else if  ( parent.getType (  )  == Token.NAME && !NodeUtil.isConstantName ( parent ) && grandParent.getType (  )  == Token.VAR && grandParent.hasOneChild (  )  )  {^[METHOD] classifyCallSite [TYPE] FunctionInjector$CallSiteType [PARAMETER] Node callNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  DecompositionType type  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  inlineResult  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  ExpressionDecomposer decomposer  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^if  ( expressionRoot == false )  {^337^^^^^327^350^[REPLACE] if  ( expressionRoot != null )  {^[METHOD] classifyCallSite [TYPE] FunctionInjector$CallSiteType [PARAMETER] Node callNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  DecompositionType type  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  inlineResult  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  ExpressionDecomposer decomposer  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^if  ( type  !=  DecompositionType.MOVABLE )  {^342^^^^^327^350^[REPLACE] if  ( type == DecompositionType.MOVABLE )  {^[METHOD] classifyCallSite [TYPE] FunctionInjector$CallSiteType [PARAMETER] Node callNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  DecompositionType type  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  inlineResult  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  ExpressionDecomposer decomposer  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[ADD]^return CallSiteType.EXPRESSION;return CallSiteType.DECOMPOSABLE_EXPRESSION;^342^343^344^345^^327^350^[ADD] if  ( type == DecompositionType.MOVABLE )  { return CallSiteType.EXPRESSION; } else if  ( type == DecompositionType.DECOMPOSABLE )  { return CallSiteType.DECOMPOSABLE_EXPRESSION;^[METHOD] classifyCallSite [TYPE] FunctionInjector$CallSiteType [PARAMETER] Node callNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  DecompositionType type  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  inlineResult  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  ExpressionDecomposer decomposer  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^}  if  ( type  ||  DecompositionType.DECOMPOSABLE )  {^344^^^^^327^350^[REPLACE] } else if  ( type == DecompositionType.DECOMPOSABLE )  {^[METHOD] classifyCallSite [TYPE] FunctionInjector$CallSiteType [PARAMETER] Node callNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  DecompositionType type  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  inlineResult  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  ExpressionDecomposer decomposer  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^checkArgument (  ( callSiteType !=  ( UNSUPPORTED )  )  )  ;^347^^^^^344^348^[REPLACE] Preconditions.checkState ( type == DecompositionType.UNDECOMPOSABLE ) ;^[METHOD] classifyCallSite [TYPE] FunctionInjector$CallSiteType [PARAMETER] Node callNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  DecompositionType type  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  inlineResult  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  ExpressionDecomposer decomposer  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REMOVE]^checkState ( isExpressionNode ( grandParent )  )  ;^347^^^^^344^348^[REMOVE] ^[METHOD] classifyCallSite [TYPE] FunctionInjector$CallSiteType [PARAMETER] Node callNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  DecompositionType type  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  inlineResult  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  ExpressionDecomposer decomposer  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^return newBlock;  ;^345^^^^^327^350^[REPLACE] return CallSiteType.DECOMPOSABLE_EXPRESSION;^[METHOD] classifyCallSite [TYPE] FunctionInjector$CallSiteType [PARAMETER] Node callNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  DecompositionType type  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  inlineResult  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  ExpressionDecomposer decomposer  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^return newBlock;  ;^343^^^^^327^350^[REPLACE] return CallSiteType.EXPRESSION;^[METHOD] classifyCallSite [TYPE] FunctionInjector$CallSiteType [PARAMETER] Node callNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  DecompositionType type  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  inlineResult  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  ExpressionDecomposer decomposer  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^}  else {^344^^^^^327^350^[REPLACE] } else if  ( type == DecompositionType.DECOMPOSABLE )  {^[METHOD] classifyCallSite [TYPE] FunctionInjector$CallSiteType [PARAMETER] Node callNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  DecompositionType type  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  inlineResult  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  ExpressionDecomposer decomposer  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^Preconditions.checkState ( type  &&  DecompositionType.UNDECOMPOSABLE ) ;^347^^^^^344^348^[REPLACE] Preconditions.checkState ( type == DecompositionType.UNDECOMPOSABLE ) ;^[METHOD] classifyCallSite [TYPE] FunctionInjector$CallSiteType [PARAMETER] Node callNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  DecompositionType type  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  inlineResult  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  ExpressionDecomposer decomposer  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[ADD]^^347^^^^^344^348^[ADD] Preconditions.checkState ( type == DecompositionType.UNDECOMPOSABLE ) ;^[METHOD] classifyCallSite [TYPE] FunctionInjector$CallSiteType [PARAMETER] Node callNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  DecompositionType type  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  inlineResult  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  ExpressionDecomposer decomposer  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[ADD]^^338^339^^^^327^350^[ADD] ExpressionDecomposer decomposer = new ExpressionDecomposer ( compiler, safeNameIdSupplier, knownConstants ) ;^[METHOD] classifyCallSite [TYPE] FunctionInjector$CallSiteType [PARAMETER] Node callNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  DecompositionType type  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  inlineResult  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  ExpressionDecomposer decomposer  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^DecompositionType type = decomposer.findExpressionRoot ( callNode ) ;^340^341^^^^327^350^[REPLACE] DecompositionType type = decomposer.canExposeExpression ( callNode ) ;^[METHOD] classifyCallSite [TYPE] FunctionInjector$CallSiteType [PARAMETER] Node callNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  DecompositionType type  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  inlineResult  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  ExpressionDecomposer decomposer  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^if  ( type  &&  DecompositionType.MOVABLE )  {^342^^^^^327^350^[REPLACE] if  ( type == DecompositionType.MOVABLE )  {^[METHOD] classifyCallSite [TYPE] FunctionInjector$CallSiteType [PARAMETER] Node callNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  DecompositionType type  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  inlineResult  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  ExpressionDecomposer decomposer  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[ADD]^^342^343^344^345^^327^350^[ADD] if  ( type == DecompositionType.MOVABLE )  { return CallSiteType.EXPRESSION; } else if  ( type == DecompositionType.DECOMPOSABLE )  { return CallSiteType.DECOMPOSABLE_EXPRESSION;^[METHOD] classifyCallSite [TYPE] FunctionInjector$CallSiteType [PARAMETER] Node callNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  DecompositionType type  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  inlineResult  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  ExpressionDecomposer decomposer  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^if   (  type == DecompositionType.MOVABLE  )   {  ;^344^^^^^327^350^[REPLACE] } else if  ( type == DecompositionType.DECOMPOSABLE )  {^[METHOD] classifyCallSite [TYPE] FunctionInjector$CallSiteType [PARAMETER] Node callNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  DecompositionType type  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  inlineResult  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  ExpressionDecomposer decomposer  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[ADD]^}   Preconditions.checkState ( type == DecompositionType.UNDECOMPOSABLE ) ;^344^345^346^347^348^327^350^[ADD] else if  ( type == DecompositionType.DECOMPOSABLE )  { return CallSiteType.DECOMPOSABLE_EXPRESSION; } else { Preconditions.checkState ( type == DecompositionType.UNDECOMPOSABLE ) ; }^[METHOD] classifyCallSite [TYPE] FunctionInjector$CallSiteType [PARAMETER] Node callNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  DecompositionType type  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  inlineResult  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  ExpressionDecomposer decomposer  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^Preconditions .checkState (  )  ;^347^^^^^344^348^[REPLACE] Preconditions.checkState ( type == DecompositionType.UNDECOMPOSABLE ) ;^[METHOD] classifyCallSite [TYPE] FunctionInjector$CallSiteType [PARAMETER] Node callNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  DecompositionType type  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  inlineResult  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  ExpressionDecomposer decomposer  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^Node injectionPoint = findInjectionPoint ( callNode )  ;^336^^^^^327^350^[REPLACE] Node expressionRoot = ExpressionDecomposer.findExpressionRoot ( callNode ) ;^[METHOD] classifyCallSite [TYPE] FunctionInjector$CallSiteType [PARAMETER] Node callNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  DecompositionType type  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  inlineResult  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  ExpressionDecomposer decomposer  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[ADD]^^340^341^^^^327^350^[ADD] DecompositionType type = decomposer.canExposeExpression ( callNode ) ;^[METHOD] classifyCallSite [TYPE] FunctionInjector$CallSiteType [PARAMETER] Node callNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  DecompositionType type  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  inlineResult  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  ExpressionDecomposer decomposer  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^return newBlock;  ;^334^^^^^327^350^[REPLACE] return CallSiteType.VAR_DECL_SIMPLE_ASSIGNMENT;^[METHOD] classifyCallSite [TYPE] FunctionInjector$CallSiteType [PARAMETER] Node callNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  DecompositionType type  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  inlineResult  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  ExpressionDecomposer decomposer  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^if  ( thisValue == null )  {^337^^^^^313^353^[REPLACE] if  ( expressionRoot != null )  {^[METHOD] classifyCallSite [TYPE] FunctionInjector$CallSiteType [PARAMETER] Node callNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  DecompositionType type  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  inlineResult  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  ExpressionDecomposer decomposer  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[ADD]^^337^338^339^340^341^313^353^[ADD] if  ( expressionRoot != null )  { ExpressionDecomposer decomposer = new ExpressionDecomposer ( compiler, safeNameIdSupplier, knownConstants ) ; DecompositionType type = decomposer.canExposeExpression ( callNode ) ;^[METHOD] classifyCallSite [TYPE] FunctionInjector$CallSiteType [PARAMETER] Node callNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  DecompositionType type  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  inlineResult  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  ExpressionDecomposer decomposer  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^if  ( type  !=  DecompositionType.MOVABLE )  {^342^^^^^313^353^[REPLACE] if  ( type == DecompositionType.MOVABLE )  {^[METHOD] classifyCallSite [TYPE] FunctionInjector$CallSiteType [PARAMETER] Node callNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  DecompositionType type  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  inlineResult  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  ExpressionDecomposer decomposer  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^if   (  type == DecompositionType.MOVABLE  )   {  ;^344^^^^^313^353^[REPLACE] } else if  ( type == DecompositionType.DECOMPOSABLE )  {^[METHOD] classifyCallSite [TYPE] FunctionInjector$CallSiteType [PARAMETER] Node callNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  DecompositionType type  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  inlineResult  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  ExpressionDecomposer decomposer  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[ADD]^}   Preconditions.checkState ( type == DecompositionType.UNDECOMPOSABLE ) ;^344^345^346^347^348^313^353^[ADD] else if  ( type == DecompositionType.DECOMPOSABLE )  { return CallSiteType.DECOMPOSABLE_EXPRESSION; } else { Preconditions.checkState ( type == DecompositionType.UNDECOMPOSABLE ) ; }^[METHOD] classifyCallSite [TYPE] FunctionInjector$CallSiteType [PARAMETER] Node callNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  DecompositionType type  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  inlineResult  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  ExpressionDecomposer decomposer  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^return newBlock;  ;^345^^^^^313^353^[REPLACE] return CallSiteType.DECOMPOSABLE_EXPRESSION;^[METHOD] classifyCallSite [TYPE] FunctionInjector$CallSiteType [PARAMETER] Node callNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  DecompositionType type  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  inlineResult  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  ExpressionDecomposer decomposer  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^return newBlock;  ;^343^^^^^313^353^[REPLACE] return CallSiteType.EXPRESSION;^[METHOD] classifyCallSite [TYPE] FunctionInjector$CallSiteType [PARAMETER] Node callNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  DecompositionType type  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  inlineResult  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  ExpressionDecomposer decomposer  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^}  else {^344^^^^^313^353^[REPLACE] } else if  ( type == DecompositionType.DECOMPOSABLE )  {^[METHOD] classifyCallSite [TYPE] FunctionInjector$CallSiteType [PARAMETER] Node callNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  DecompositionType type  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  inlineResult  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  ExpressionDecomposer decomposer  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^DecompositionType type = decomposer .findExpressionRoot ( returnNode )  ;^340^341^^^^313^353^[REPLACE] DecompositionType type = decomposer.canExposeExpression ( callNode ) ;^[METHOD] classifyCallSite [TYPE] FunctionInjector$CallSiteType [PARAMETER] Node callNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  DecompositionType type  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  inlineResult  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  ExpressionDecomposer decomposer  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^} else if   (  type == DecompositionType.DECOMPOSABLE  )   {  ;^342^^^^^313^353^[REPLACE] if  ( type == DecompositionType.MOVABLE )  {^[METHOD] classifyCallSite [TYPE] FunctionInjector$CallSiteType [PARAMETER] Node callNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  DecompositionType type  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  inlineResult  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  ExpressionDecomposer decomposer  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^}  if  ( type  ) {^344^^^^^313^353^[REPLACE] } else if  ( type == DecompositionType.DECOMPOSABLE )  {^[METHOD] classifyCallSite [TYPE] FunctionInjector$CallSiteType [PARAMETER] Node callNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  DecompositionType type  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  inlineResult  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  ExpressionDecomposer decomposer  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^Preconditions.checkArgument ( type  &&  DecompositionType.UNDECOMPOSABLE ) ;^347^^^^^344^348^[REPLACE] Preconditions.checkState ( type == DecompositionType.UNDECOMPOSABLE ) ;^[METHOD] classifyCallSite [TYPE] FunctionInjector$CallSiteType [PARAMETER] Node callNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  DecompositionType type  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  inlineResult  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  ExpressionDecomposer decomposer  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^Preconditions.checkArgument ( type  !=  DecompositionType.UNDECOMPOSABLE ) ;^347^^^^^344^348^[REPLACE] Preconditions.checkState ( type == DecompositionType.UNDECOMPOSABLE ) ;^[METHOD] classifyCallSite [TYPE] FunctionInjector$CallSiteType [PARAMETER] Node callNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  DecompositionType type  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  inlineResult  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  ExpressionDecomposer decomposer  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^return newBlock;  ;^334^^^^^313^353^[REPLACE] return CallSiteType.VAR_DECL_SIMPLE_ASSIGNMENT;^[METHOD] classifyCallSite [TYPE] FunctionInjector$CallSiteType [PARAMETER] Node callNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  DecompositionType type  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  inlineResult  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  ExpressionDecomposer decomposer  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[ADD]^^336^^^^^313^353^[ADD] Node expressionRoot = ExpressionDecomposer.findExpressionRoot ( callNode ) ;^[METHOD] classifyCallSite [TYPE] FunctionInjector$CallSiteType [PARAMETER] Node callNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  DecompositionType type  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  inlineResult  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  ExpressionDecomposer decomposer  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[ADD]^^338^339^^^^313^353^[ADD] ExpressionDecomposer decomposer = new ExpressionDecomposer ( compiler, safeNameIdSupplier, knownConstants ) ;^[METHOD] classifyCallSite [TYPE] FunctionInjector$CallSiteType [PARAMETER] Node callNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  DecompositionType type  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  inlineResult  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  ExpressionDecomposer decomposer  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^DecompositionType type = decomposer .findExpressionRoot ( block )  ;^340^341^^^^313^353^[REPLACE] DecompositionType type = decomposer.canExposeExpression ( callNode ) ;^[METHOD] classifyCallSite [TYPE] FunctionInjector$CallSiteType [PARAMETER] Node callNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  DecompositionType type  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  inlineResult  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  ExpressionDecomposer decomposer  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^return newBlock;  ;^326^^^^^321^350^[REPLACE] return CallSiteType.SIMPLE_ASSIGNMENT;^[METHOD] classifyCallSite [TYPE] FunctionInjector$CallSiteType [PARAMETER] Node callNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  DecompositionType type  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  inlineResult  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  ExpressionDecomposer decomposer  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^}  if  ( parent.getType (  )  == Token.NAME && NodeUtil.isConstantName ( parent ) && grandParent.getType (  )  == Token.VAR && grandParent.hasOneChild (  )  )  {^327^328^329^330^^313^353^[REPLACE] } else if  ( parent.getType (  )  == Token.NAME && !NodeUtil.isConstantName ( parent ) && grandParent.getType (  )  == Token.VAR && grandParent.hasOneChild (  )  )  {^[METHOD] classifyCallSite [TYPE] FunctionInjector$CallSiteType [PARAMETER] Node callNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  DecompositionType type  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  inlineResult  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  ExpressionDecomposer decomposer  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^if  (safeReturnNode == null )  {^337^^^^^327^350^[REPLACE] if  ( expressionRoot != null )  {^[METHOD] classifyCallSite [TYPE] FunctionInjector$CallSiteType [PARAMETER] Node callNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  DecompositionType type  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  inlineResult  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  ExpressionDecomposer decomposer  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^} else if  ( type  !=  DecompositionType.DECOMPOSABLE )  {^344^^^^^327^350^[REPLACE] } else if  ( type == DecompositionType.DECOMPOSABLE )  {^[METHOD] classifyCallSite [TYPE] FunctionInjector$CallSiteType [PARAMETER] Node callNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  DecompositionType type  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  inlineResult  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  ExpressionDecomposer decomposer  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^if  (   DecompositionType.MOVABLE )  {^342^^^^^327^350^[REPLACE] if  ( type == DecompositionType.MOVABLE )  {^[METHOD] classifyCallSite [TYPE] FunctionInjector$CallSiteType [PARAMETER] Node callNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  DecompositionType type  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  inlineResult  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  ExpressionDecomposer decomposer  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^}  if  ( type  !=  DecompositionType.DECOMPOSABLE )  {^344^^^^^327^350^[REPLACE] } else if  ( type == DecompositionType.DECOMPOSABLE )  {^[METHOD] classifyCallSite [TYPE] FunctionInjector$CallSiteType [PARAMETER] Node callNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  DecompositionType type  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  inlineResult  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  ExpressionDecomposer decomposer  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[ADD]^}   return CallSiteType.DECOMPOSABLE_EXPRESSION;Preconditions.checkState ( type == DecompositionType.UNDECOMPOSABLE ) ;^344^345^346^347^348^327^350^[ADD] else if  ( type == DecompositionType.DECOMPOSABLE )  { return CallSiteType.DECOMPOSABLE_EXPRESSION; } else { Preconditions.checkState ( type == DecompositionType.UNDECOMPOSABLE ) ; }^[METHOD] classifyCallSite [TYPE] FunctionInjector$CallSiteType [PARAMETER] Node callNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  DecompositionType type  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  inlineResult  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  ExpressionDecomposer decomposer  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^Preconditions.checkState ( type  ||  DecompositionType.UNDECOMPOSABLE ) ;^347^^^^^344^348^[REPLACE] Preconditions.checkState ( type == DecompositionType.UNDECOMPOSABLE ) ;^[METHOD] classifyCallSite [TYPE] FunctionInjector$CallSiteType [PARAMETER] Node callNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  DecompositionType type  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  inlineResult  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  ExpressionDecomposer decomposer  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^Node expressionRoot = ExpressionDecomposer.findExpressionRoot ( thisValue ) ;^336^^^^^327^350^[REPLACE] Node expressionRoot = ExpressionDecomposer.findExpressionRoot ( callNode ) ;^[METHOD] classifyCallSite [TYPE] FunctionInjector$CallSiteType [PARAMETER] Node callNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  DecompositionType type  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  inlineResult  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  ExpressionDecomposer decomposer  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^if  ( expressionRoot == null )  {^337^^^^^313^353^[REPLACE] if  ( expressionRoot != null )  {^[METHOD] classifyCallSite [TYPE] FunctionInjector$CallSiteType [PARAMETER] Node callNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  DecompositionType type  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  inlineResult  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  ExpressionDecomposer decomposer  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^if  ( type  &&  DecompositionType.MOVABLE )  {^342^^^^^313^353^[REPLACE] if  ( type == DecompositionType.MOVABLE )  {^[METHOD] classifyCallSite [TYPE] FunctionInjector$CallSiteType [PARAMETER] Node callNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  DecompositionType type  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  inlineResult  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  ExpressionDecomposer decomposer  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^}  if  ( type  ||  DecompositionType.DECOMPOSABLE )  {^344^^^^^313^353^[REPLACE] } else if  ( type == DecompositionType.DECOMPOSABLE )  {^[METHOD] classifyCallSite [TYPE] FunctionInjector$CallSiteType [PARAMETER] Node callNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  DecompositionType type  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  inlineResult  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  ExpressionDecomposer decomposer  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[ADD]^}   return CallSiteType.DECOMPOSABLE_EXPRESSION;Preconditions.checkState ( type == DecompositionType.UNDECOMPOSABLE ) ;^344^345^346^347^348^313^353^[ADD] else if  ( type == DecompositionType.DECOMPOSABLE )  { return CallSiteType.DECOMPOSABLE_EXPRESSION; } else { Preconditions.checkState ( type == DecompositionType.UNDECOMPOSABLE ) ; }^[METHOD] classifyCallSite [TYPE] FunctionInjector$CallSiteType [PARAMETER] Node callNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  DecompositionType type  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  inlineResult  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  ExpressionDecomposer decomposer  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^DecompositionType type = decomposer.findExpressionRoot ( callNode ) ;^340^341^^^^313^353^[REPLACE] DecompositionType type = decomposer.canExposeExpression ( callNode ) ;^[METHOD] classifyCallSite [TYPE] FunctionInjector$CallSiteType [PARAMETER] Node callNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  DecompositionType type  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  inlineResult  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  ExpressionDecomposer decomposer  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^if  ( type  ||  DecompositionType.MOVABLE )  {^342^^^^^313^353^[REPLACE] if  ( type == DecompositionType.MOVABLE )  {^[METHOD] classifyCallSite [TYPE] FunctionInjector$CallSiteType [PARAMETER] Node callNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  DecompositionType type  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  inlineResult  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  ExpressionDecomposer decomposer  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^}  if  ( type  !=  DecompositionType.DECOMPOSABLE )  {^344^^^^^313^353^[REPLACE] } else if  ( type == DecompositionType.DECOMPOSABLE )  {^[METHOD] classifyCallSite [TYPE] FunctionInjector$CallSiteType [PARAMETER] Node callNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  DecompositionType type  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  inlineResult  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  ExpressionDecomposer decomposer  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^return newBlock;  ;^326^^^^^313^353^[REPLACE] return CallSiteType.SIMPLE_ASSIGNMENT;^[METHOD] classifyCallSite [TYPE] FunctionInjector$CallSiteType [PARAMETER] Node callNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  DecompositionType type  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  inlineResult  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  ExpressionDecomposer decomposer  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^DecompositionType type = decomposer.canExposeExpression ( thisValue ) ;^340^341^^^^313^353^[REPLACE] DecompositionType type = decomposer.canExposeExpression ( callNode ) ;^[METHOD] classifyCallSite [TYPE] FunctionInjector$CallSiteType [PARAMETER] Node callNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  DecompositionType type  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  inlineResult  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  ExpressionDecomposer decomposer  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^return newBlock;  ;^320^^^^^313^353^[REPLACE] return CallSiteType.SIMPLE_CALL;^[METHOD] classifyCallSite [TYPE] FunctionInjector$CallSiteType [PARAMETER] Node callNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  DecompositionType type  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  inlineResult  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  ExpressionDecomposer decomposer  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^}  if  ( NodeUtil.isExprAssign ( grandParent ) ) {^321^322^323^324^^313^353^[REPLACE] } else if  ( NodeUtil.isExprAssign ( grandParent ) && !NodeUtil.isLhs ( callNode, parent ) && parent.getFirstChild (  ) .getType (  )  == Token.NAME && !NodeUtil.isConstantName ( parent.getFirstChild (  )  )  )  {^[METHOD] classifyCallSite [TYPE] FunctionInjector$CallSiteType [PARAMETER] Node callNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  DecompositionType type  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  inlineResult  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  ExpressionDecomposer decomposer  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[ADD]^}^321^322^323^324^^313^353^[ADD] else if  ( NodeUtil.isExprAssign ( grandParent ) && !NodeUtil.isLhs ( callNode, parent ) && parent.getFirstChild (  ) .getType (  )  == Token.NAME && !NodeUtil.isConstantName ( parent.getFirstChild (  )  )  )  {^[METHOD] classifyCallSite [TYPE] FunctionInjector$CallSiteType [PARAMETER] Node callNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  DecompositionType type  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  inlineResult  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  ExpressionDecomposer decomposer  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^if  ( expressionRoot == null )  {^337^^^^^327^350^[REPLACE] if  ( expressionRoot != null )  {^[METHOD] classifyCallSite [TYPE] FunctionInjector$CallSiteType [PARAMETER] Node callNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  DecompositionType type  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  inlineResult  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  ExpressionDecomposer decomposer  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^if  ( type  ) {^342^^^^^327^350^[REPLACE] if  ( type == DecompositionType.MOVABLE )  {^[METHOD] classifyCallSite [TYPE] FunctionInjector$CallSiteType [PARAMETER] Node callNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  DecompositionType type  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  inlineResult  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  ExpressionDecomposer decomposer  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^} else if  (   DecompositionType.DECOMPOSABLE )  {^344^^^^^327^350^[REPLACE] } else if  ( type == DecompositionType.DECOMPOSABLE )  {^[METHOD] classifyCallSite [TYPE] FunctionInjector$CallSiteType [PARAMETER] Node callNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  DecompositionType type  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  inlineResult  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  ExpressionDecomposer decomposer  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^Preconditions.checkState ( type  !=  DecompositionType.UNDECOMPOSABLE ) ;^347^^^^^344^348^[REPLACE] Preconditions.checkState ( type == DecompositionType.UNDECOMPOSABLE ) ;^[METHOD] classifyCallSite [TYPE] FunctionInjector$CallSiteType [PARAMETER] Node callNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  DecompositionType type  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  inlineResult  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  ExpressionDecomposer decomposer  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^}  if  ( type  &&  DecompositionType.DECOMPOSABLE )  {^344^^^^^327^350^[REPLACE] } else if  ( type == DecompositionType.DECOMPOSABLE )  {^[METHOD] classifyCallSite [TYPE] FunctionInjector$CallSiteType [PARAMETER] Node callNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  DecompositionType type  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  inlineResult  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  ExpressionDecomposer decomposer  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^DecompositionType type = decomposer .findExpressionRoot ( callNode )  ;^340^341^^^^327^350^[REPLACE] DecompositionType type = decomposer.canExposeExpression ( callNode ) ;^[METHOD] classifyCallSite [TYPE] FunctionInjector$CallSiteType [PARAMETER] Node callNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  DecompositionType type  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  inlineResult  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  ExpressionDecomposer decomposer  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[ADD]^^342^343^344^345^^313^353^[ADD] if  ( type == DecompositionType.MOVABLE )  { return CallSiteType.EXPRESSION; } else if  ( type == DecompositionType.DECOMPOSABLE )  { return CallSiteType.DECOMPOSABLE_EXPRESSION;^[METHOD] classifyCallSite [TYPE] FunctionInjector$CallSiteType [PARAMETER] Node callNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  DecompositionType type  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  inlineResult  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  ExpressionDecomposer decomposer  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^} else if  ( type  ||  DecompositionType.DECOMPOSABLE )  {^344^^^^^313^353^[REPLACE] } else if  ( type == DecompositionType.DECOMPOSABLE )  {^[METHOD] classifyCallSite [TYPE] FunctionInjector$CallSiteType [PARAMETER] Node callNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  DecompositionType type  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  inlineResult  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  ExpressionDecomposer decomposer  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^Node expressionRoot = ExpressionDecomposer .findInjectionPoint ( thisValue )  ;^336^^^^^313^353^[REPLACE] Node expressionRoot = ExpressionDecomposer.findExpressionRoot ( callNode ) ;^[METHOD] classifyCallSite [TYPE] FunctionInjector$CallSiteType [PARAMETER] Node callNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  DecompositionType type  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  inlineResult  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  ExpressionDecomposer decomposer  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^if  ( parent == null )  {^337^^^^^327^350^[REPLACE] if  ( expressionRoot != null )  {^[METHOD] classifyCallSite [TYPE] FunctionInjector$CallSiteType [PARAMETER] Node callNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  DecompositionType type  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  inlineResult  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  ExpressionDecomposer decomposer  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[ADD]^^337^338^339^340^341^327^350^[ADD] if  ( expressionRoot != null )  { ExpressionDecomposer decomposer = new ExpressionDecomposer ( compiler, safeNameIdSupplier, knownConstants ) ; DecompositionType type = decomposer.canExposeExpression ( callNode ) ;^[METHOD] classifyCallSite [TYPE] FunctionInjector$CallSiteType [PARAMETER] Node callNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  DecompositionType type  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  inlineResult  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  ExpressionDecomposer decomposer  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^if  ( type  ||  DecompositionType.MOVABLE )  {^342^^^^^327^350^[REPLACE] if  ( type == DecompositionType.MOVABLE )  {^[METHOD] classifyCallSite [TYPE] FunctionInjector$CallSiteType [PARAMETER] Node callNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  DecompositionType type  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  inlineResult  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  ExpressionDecomposer decomposer  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^DecompositionType type = decomposer .findExpressionRoot ( inlineResult )  ;^340^341^^^^327^350^[REPLACE] DecompositionType type = decomposer.canExposeExpression ( callNode ) ;^[METHOD] classifyCallSite [TYPE] FunctionInjector$CallSiteType [PARAMETER] Node callNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  DecompositionType type  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  inlineResult  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  ExpressionDecomposer decomposer  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^} else if   (  type == DecompositionType.DECOMPOSABLE  )   {  ;^342^^^^^327^350^[REPLACE] if  ( type == DecompositionType.MOVABLE )  {^[METHOD] classifyCallSite [TYPE] FunctionInjector$CallSiteType [PARAMETER] Node callNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  DecompositionType type  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  inlineResult  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  ExpressionDecomposer decomposer  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^} else if  ( type  &&  DecompositionType.DECOMPOSABLE )  {^344^^^^^327^350^[REPLACE] } else if  ( type == DecompositionType.DECOMPOSABLE )  {^[METHOD] classifyCallSite [TYPE] FunctionInjector$CallSiteType [PARAMETER] Node callNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  DecompositionType type  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  inlineResult  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  ExpressionDecomposer decomposer  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^if  ( type  ) {^342^^^^^313^353^[REPLACE] if  ( type == DecompositionType.MOVABLE )  {^[METHOD] classifyCallSite [TYPE] FunctionInjector$CallSiteType [PARAMETER] Node callNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  DecompositionType type  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  inlineResult  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  ExpressionDecomposer decomposer  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^} else if  ( type  &&  DecompositionType.DECOMPOSABLE )  {^344^^^^^313^353^[REPLACE] } else if  ( type == DecompositionType.DECOMPOSABLE )  {^[METHOD] classifyCallSite [TYPE] FunctionInjector$CallSiteType [PARAMETER] Node callNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  DecompositionType type  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  inlineResult  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  ExpressionDecomposer decomposer  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^Node expressionRoot = ExpressionDecomposer.findExpressionRoot ( newExpression ) ;^336^^^^^313^353^[REPLACE] Node expressionRoot = ExpressionDecomposer.findExpressionRoot ( callNode ) ;^[METHOD] classifyCallSite [TYPE] FunctionInjector$CallSiteType [PARAMETER] Node callNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  DecompositionType type  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  inlineResult  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  ExpressionDecomposer decomposer  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^DecompositionType type = decomposer .findExpressionRoot ( callParentNode )  ;^340^341^^^^313^353^[REPLACE] DecompositionType type = decomposer.canExposeExpression ( callNode ) ;^[METHOD] classifyCallSite [TYPE] FunctionInjector$CallSiteType [PARAMETER] Node callNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  DecompositionType type  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  inlineResult  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  ExpressionDecomposer decomposer  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^return newBlock;  ;^352^^^^^313^353^[REPLACE] return CallSiteType.UNSUPPORTED;^[METHOD] classifyCallSite [TYPE] FunctionInjector$CallSiteType [PARAMETER] Node callNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  DecompositionType type  [TYPE]  boolean allowDecomposition  false  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  inlineResult  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  ExpressionDecomposer decomposer  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^Node parent = thisValue.getParent (  ) ;^362^^^^^361^465^[REPLACE] Node parent = callNode.getParent (  ) ;^[METHOD] inlineFunction [TYPE] Node [PARAMETER] Node callNode Node fnNode String fnName [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String fnName  resultName  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST  [TYPE]  FunctionToBlockMutator mutator 
[REPLACE]^Node grandParent = safeReturnNode .getString (  )  ;^363^^^^^361^465^[REPLACE] Node grandParent = parent.getParent (  ) ;^[METHOD] inlineFunction [TYPE] Node [PARAMETER] Node callNode Node fnNode String fnName [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String fnName  resultName  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST  [TYPE]  FunctionToBlockMutator mutator 
[REPLACE]^int costDelta =  ( directInlines * costDeltaDirect )  +  ( blockInlines * costDeltaBlock )  ;^367^^^^^361^465^[REPLACE] CallSiteType callSiteType = classifyCallSite ( callNode ) ;^[METHOD] inlineFunction [TYPE] Node [PARAMETER] Node callNode Node fnNode String fnName [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String fnName  resultName  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST  [TYPE]  FunctionToBlockMutator mutator 
[REPLACE]^Preconditions.checkArgument (VAR_DECL_SIMPLE_ASSIGNMENT  ==  CallSiteType.UNSUPPORTED ) ;^368^^^^^361^465^[REPLACE] Preconditions.checkArgument ( callSiteType != CallSiteType.UNSUPPORTED ) ;^[METHOD] inlineFunction [TYPE] Node [PARAMETER] Node callNode Node fnNode String fnName [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String fnName  resultName  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST  [TYPE]  FunctionToBlockMutator mutator 
[ADD]^^373^374^^^^361^465^[ADD] String resultName = null; boolean needsDefaultReturnResult = true;^[METHOD] inlineFunction [TYPE] Node [PARAMETER] Node callNode Node fnNode String fnName [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String fnName  resultName  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST  [TYPE]  FunctionToBlockMutator mutator 
[REPLACE]^boolean needsDefaultReturnResult = false;^374^^^^^361^465^[REPLACE] boolean needsDefaultReturnResult = true;^[METHOD] inlineFunction [TYPE] Node [PARAMETER] Node callNode Node fnNode String fnName [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String fnName  resultName  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST  [TYPE]  FunctionToBlockMutator mutator 
[ADD]^^377^378^^^^361^465^[ADD] resultName = parent.getFirstChild (  ) .getString (  ) ; break;^[METHOD] inlineFunction [TYPE] Node [PARAMETER] Node callNode Node fnNode String fnName [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String fnName  resultName  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST  [TYPE]  FunctionToBlockMutator mutator 
[REPLACE]^resultName = parent.getFirstChild (  ) .getString (  )  ;^381^^^^^361^465^[REPLACE] resultName = parent.getString (  ) ;^[METHOD] inlineFunction [TYPE] Node [PARAMETER] Node callNode Node fnNode String fnName [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String fnName  resultName  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST  [TYPE]  FunctionToBlockMutator mutator 
[REPLACE]^resultName = true;^385^^^^^361^465^[REPLACE] resultName = null;^[METHOD] inlineFunction [TYPE] Node [PARAMETER] Node callNode Node fnNode String fnName [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String fnName  resultName  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST  [TYPE]  FunctionToBlockMutator mutator 
[REPLACE]^needsDefaultReturnResult = true;^386^^^^^361^465^[REPLACE] needsDefaultReturnResult = false;^[METHOD] inlineFunction [TYPE] Node [PARAMETER] Node callNode Node fnNode String fnName [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String fnName  resultName  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST  [TYPE]  FunctionToBlockMutator mutator 
[ADD]^^390^^^^^361^465^[ADD] resultName = getUniqueResultName (  ) ;^[METHOD] inlineFunction [TYPE] Node [PARAMETER] Node callNode Node fnNode String fnName [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String fnName  resultName  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST  [TYPE]  FunctionToBlockMutator mutator 
[ADD]^^391^^^^^361^465^[ADD] needsDefaultReturnResult = false;^[METHOD] inlineFunction [TYPE] Node [PARAMETER] Node callNode Node fnNode String fnName [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String fnName  resultName  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST  [TYPE]  FunctionToBlockMutator mutator 
[REPLACE]^throw new IllegalStateException ( "Unexpected call site type." )  ;^396^397^^^^361^465^[REPLACE] throw new IllegalStateException ( "Decomposable expressions must decomposed before inlining." ) ;^[METHOD] inlineFunction [TYPE] Node [PARAMETER] Node callNode Node fnNode String fnName [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String fnName  resultName  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST  [TYPE]  FunctionToBlockMutator mutator 
[REPLACE]^throw new IllegalStateException ( "Decomposable expressions must decomposed before inlining." )  ;^400^^^^^361^465^[REPLACE] throw new IllegalStateException  (" ")  ;^[METHOD] inlineFunction [TYPE] Node [PARAMETER] Node callNode Node fnNode String fnName [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String fnName  resultName  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST  [TYPE]  FunctionToBlockMutator mutator 
[ADD]^^403^^^^^361^465^[ADD] boolean isCallInLoop = isCallWithinLoop ( callNode ) ;^[METHOD] inlineFunction [TYPE] Node [PARAMETER] Node callNode Node fnNode String fnName [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String fnName  resultName  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST  [TYPE]  FunctionToBlockMutator mutator 
[REPLACE]^Node newBlock = mutator.mutate ( fnName, thisValue, callNode, resultName, needsDefaultReturnResult, isCallInLoop ) ;^408^409^410^^^361^465^[REPLACE] Node newBlock = mutator.mutate ( fnName, fnNode, callNode, resultName, needsDefaultReturnResult, isCallInLoop ) ;^[METHOD] inlineFunction [TYPE] Node [PARAMETER] Node callNode Node fnNode String fnName [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String fnName  resultName  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST  [TYPE]  FunctionToBlockMutator mutator 
[ADD]^^415^^^^^361^465^[ADD] Node greatGrandParent = grandParent.getParent (  ) ;^[METHOD] inlineFunction [TYPE] Node [PARAMETER] Node callNode Node fnNode String fnName [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String fnName  resultName  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST  [TYPE]  FunctionToBlockMutator mutator 
[ADD]^^443^444^^^^361^465^[ADD] Node injectionPoint = ExpressionDecomposer.findInjectionPoint ( callNode ) ; Preconditions.checkNotNull ( injectionPoint ) ;^[METHOD] inlineFunction [TYPE] Node [PARAMETER] Node callNode Node fnNode String fnName [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String fnName  resultName  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST  [TYPE]  FunctionToBlockMutator mutator 
[REPLACE]^Node thisValueParent = injectionPoint.getParent (  ) ;^445^^^^^361^465^[REPLACE] Node injectionPointParent = injectionPoint.getParent (  ) ;^[METHOD] inlineFunction [TYPE] Node [PARAMETER] Node callNode Node fnNode String fnName [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String fnName  resultName  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST  [TYPE]  FunctionToBlockMutator mutator 
[REPLACE]^throw new IllegalStateException ( "Decomposable expressions must decomposed before inlining." )  ;^461^^^^^361^465^[REPLACE] throw new IllegalStateException  (" ")  ;^[METHOD] inlineFunction [TYPE] Node [PARAMETER] Node callNode Node fnNode String fnName [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String fnName  resultName  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST  [TYPE]  FunctionToBlockMutator mutator 
[REPLACE]^return newBlock;  ;^464^^^^^361^465^[REPLACE] return newBlock;^[METHOD] inlineFunction [TYPE] Node [PARAMETER] Node callNode Node fnNode String fnName [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  String fnName  resultName  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST  [TYPE]  FunctionToBlockMutator mutator 
[REPLACE]^Node block = NodeUtil.getFunctionBody ( thisValue ) ;^491^^^^^489^507^[REPLACE] Node block = NodeUtil.getFunctionBody ( fnNode ) ;^[METHOD] isDirectCallNodeReplacementPossible [TYPE] boolean [PARAMETER] Node fnNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^if  ( block.hasChildren (  )  )  {^495^^^^^489^507^[REPLACE] if  ( !block.hasChildren (  )  )  {^[METHOD] isDirectCallNodeReplacementPossible [TYPE] boolean [PARAMETER] Node fnNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^}  else {^498^^^^^489^507^[REPLACE] } else if  ( block.hasOneChild (  )  )  {^[METHOD] isDirectCallNodeReplacementPossible [TYPE] boolean [PARAMETER] Node fnNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[ADD]^}   return true;^498^499^500^501^502^489^507^[ADD] else if  ( block.hasOneChild (  )  )  {  if  ( block.getFirstChild (  ) .getType (  )  == Token.RETURN && block.getFirstChild (  ) .getFirstChild (  )  != null )  { return true;^[METHOD] isDirectCallNodeReplacementPossible [TYPE] boolean [PARAMETER] Node fnNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^if  ( block.getFirstChild (  ) .getType (  )  != Token.RETURN && block.getFirstChild (  ) .getFirstChild (  )  != null )  {^500^501^^^^489^507^[REPLACE] if  ( block.getFirstChild (  ) .getType (  )  == Token.RETURN && block.getFirstChild (  ) .getFirstChild (  )  != null )  {^[METHOD] isDirectCallNodeReplacementPossible [TYPE] boolean [PARAMETER] Node fnNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^return false;^502^^^^^500^503^[REPLACE] return true;^[METHOD] isDirectCallNodeReplacementPossible [TYPE] boolean [PARAMETER] Node fnNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^return false;^502^^^^^489^507^[REPLACE] return true;^[METHOD] isDirectCallNodeReplacementPossible [TYPE] boolean [PARAMETER] Node fnNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^if  ( block.getFirstChild (  ) .getType (  )  != Token.RETURN ) {^500^501^^^^489^507^[REPLACE] if  ( block.getFirstChild (  ) .getType (  )  == Token.RETURN && block.getFirstChild (  ) .getFirstChild (  )  != null )  {^[METHOD] isDirectCallNodeReplacementPossible [TYPE] boolean [PARAMETER] Node fnNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[ADD]^^500^501^502^503^^489^507^[ADD] if  ( block.getFirstChild (  ) .getType (  )  == Token.RETURN && block.getFirstChild (  ) .getFirstChild (  )  != null )  { return true; }^[METHOD] isDirectCallNodeReplacementPossible [TYPE] boolean [PARAMETER] Node fnNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^return true;  ;^502^^^^^489^507^[REPLACE] return true;^[METHOD] isDirectCallNodeReplacementPossible [TYPE] boolean [PARAMETER] Node fnNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^return false;^497^^^^^489^507^[REPLACE] return true;^[METHOD] isDirectCallNodeReplacementPossible [TYPE] boolean [PARAMETER] Node fnNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^if  (  block.getFirstChild (  ) .getFirstChild (  )  != null )  {^500^501^^^^489^507^[REPLACE] if  ( block.getFirstChild (  ) .getType (  )  == Token.RETURN && block.getFirstChild (  ) .getFirstChild (  )  != null )  {^[METHOD] isDirectCallNodeReplacementPossible [TYPE] boolean [PARAMETER] Node fnNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^if  ( safeReturnNode .getLastChild (  )  .getType (  )  != Token.RETURN && block^500^501^^^^489^507^[REPLACE] if  ( block.getFirstChild (  ) .getType (  )  == Token.RETURN && block.getFirstChild (  ) .getFirstChild (  )  != null )  {^[METHOD] isDirectCallNodeReplacementPossible [TYPE] boolean [PARAMETER] Node fnNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^return true;^506^^^^^489^507^[REPLACE] return false;^[METHOD] isDirectCallNodeReplacementPossible [TYPE] boolean [PARAMETER] Node fnNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set knownConstants  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^CallSiteType callSiteType = classifyCallSite ( returnNode ) ;^528^^^^^527^548^[REPLACE] CallSiteType callSiteType = classifyCallSite ( callNode ) ;^[METHOD] canInlineReferenceAsStatementBlock [TYPE] FunctionInjector$CanInlineResult [PARAMETER] NodeTraversal t Node callNode Node fnNode String> namesToAlias [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set knownConstants  namesToAlias  needAliases  [TYPE]  NodeTraversal t  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^if  (   CallSiteType.UNSUPPORTED )  {^529^^^^^527^548^[REPLACE] if  ( callSiteType == CallSiteType.UNSUPPORTED )  {^[METHOD] canInlineReferenceAsStatementBlock [TYPE] FunctionInjector$CanInlineResult [PARAMETER] NodeTraversal t Node callNode Node fnNode String> namesToAlias [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set knownConstants  namesToAlias  needAliases  [TYPE]  NodeTraversal t  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^return newBlock;  ;^530^^^^^527^548^[REPLACE] return CanInlineResult.NO;^[METHOD] canInlineReferenceAsStatementBlock [TYPE] FunctionInjector$CanInlineResult [PARAMETER] NodeTraversal t Node callNode Node fnNode String> namesToAlias [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set knownConstants  namesToAlias  needAliases  [TYPE]  NodeTraversal t  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^if  (  callSiteType == CallSiteType.DECOMPOSABLE_EXPRESSION )  {^533^534^^^^527^548^[REPLACE] if  ( !allowDecomposition && callSiteType == CallSiteType.DECOMPOSABLE_EXPRESSION )  {^[METHOD] canInlineReferenceAsStatementBlock [TYPE] FunctionInjector$CanInlineResult [PARAMETER] NodeTraversal t Node callNode Node fnNode String> namesToAlias [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set knownConstants  namesToAlias  needAliases  [TYPE]  NodeTraversal t  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^return newBlock;  ;^535^^^^^533^536^[REPLACE] return CanInlineResult.NO;^[METHOD] canInlineReferenceAsStatementBlock [TYPE] FunctionInjector$CanInlineResult [PARAMETER] NodeTraversal t Node callNode Node fnNode String> namesToAlias [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set knownConstants  namesToAlias  needAliases  [TYPE]  NodeTraversal t  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^return newBlock;  ;^535^^^^^527^548^[REPLACE] return CanInlineResult.NO;^[METHOD] canInlineReferenceAsStatementBlock [TYPE] FunctionInjector$CanInlineResult [PARAMETER] NodeTraversal t Node callNode Node fnNode String> namesToAlias [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set knownConstants  namesToAlias  needAliases  [TYPE]  NodeTraversal t  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^} else if   (  parent.getType  (    )   == Token.NAME && !NodeUtil.isConstantName  (  parent  )  ;^538^539^^^^527^548^[REPLACE] if  ( !callMeetsBlockInliningRequirements ( t, callNode, fnNode, namesToAlias )  )  {^[METHOD] canInlineReferenceAsStatementBlock [TYPE] FunctionInjector$CanInlineResult [PARAMETER] NodeTraversal t Node callNode Node fnNode String> namesToAlias [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set knownConstants  namesToAlias  needAliases  [TYPE]  NodeTraversal t  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^return newBlock;  ;^540^^^^^538^541^[REPLACE] return CanInlineResult.NO;^[METHOD] canInlineReferenceAsStatementBlock [TYPE] FunctionInjector$CanInlineResult [PARAMETER] NodeTraversal t Node callNode Node fnNode String> namesToAlias [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set knownConstants  namesToAlias  needAliases  [TYPE]  NodeTraversal t  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^return newBlock;  ;^540^^^^^527^548^[REPLACE] return CanInlineResult.NO;^[METHOD] canInlineReferenceAsStatementBlock [TYPE] FunctionInjector$CanInlineResult [PARAMETER] NodeTraversal t Node callNode Node fnNode String> namesToAlias [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set knownConstants  namesToAlias  needAliases  [TYPE]  NodeTraversal t  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^if  (VAR_DECL_SIMPLE_ASSIGNMENT  !=  CallSiteType.DECOMPOSABLE_EXPRESSION )   {^543^^^^^527^548^[REPLACE] if  ( callSiteType == CallSiteType.DECOMPOSABLE_EXPRESSION )   {^[METHOD] canInlineReferenceAsStatementBlock [TYPE] FunctionInjector$CanInlineResult [PARAMETER] NodeTraversal t Node callNode Node fnNode String> namesToAlias [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set knownConstants  namesToAlias  needAliases  [TYPE]  NodeTraversal t  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^return newBlock;  ;^546^^^^^543^547^[REPLACE] return CanInlineResult.YES;^[METHOD] canInlineReferenceAsStatementBlock [TYPE] FunctionInjector$CanInlineResult [PARAMETER] NodeTraversal t Node callNode Node fnNode String> namesToAlias [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set knownConstants  namesToAlias  needAliases  [TYPE]  NodeTraversal t  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^return newBlock;  ;^544^^^^^527^548^[REPLACE] return CanInlineResult.AFTER_DECOMPOSITION;^[METHOD] canInlineReferenceAsStatementBlock [TYPE] FunctionInjector$CanInlineResult [PARAMETER] NodeTraversal t Node callNode Node fnNode String> namesToAlias [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set knownConstants  namesToAlias  needAliases  [TYPE]  NodeTraversal t  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^return newBlock;  ;^546^^^^^527^548^[REPLACE] return CanInlineResult.YES;^[METHOD] canInlineReferenceAsStatementBlock [TYPE] FunctionInjector$CanInlineResult [PARAMETER] NodeTraversal t Node callNode Node fnNode String> namesToAlias [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  false  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set knownConstants  namesToAlias  needAliases  [TYPE]  NodeTraversal t  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnNode  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^boolean fnContainsVars = NodeUtil.isNodeTypeReferenced ( NodeUtil.isFunction ( newExpression ) , Token.VAR ) ;^567^568^^^^556^601^[REPLACE] boolean fnContainsVars = NodeUtil.isNodeTypeReferenced ( NodeUtil.getFunctionBody ( fnNode ) , Token.VAR ) ;^[METHOD] callMeetsBlockInliningRequirements [TYPE] boolean [PARAMETER] NodeTraversal t Node callNode Node fnNode String> namesToAlias [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  false  fnContainsVars  hasArgs  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  NodeTraversal t  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  Map args  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[ADD]^^569^^^^^556^601^[ADD] boolean callerContainsFunction = false;^[METHOD] callMeetsBlockInliningRequirements [TYPE] boolean [PARAMETER] NodeTraversal t Node callNode Node fnNode String> namesToAlias [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  false  fnContainsVars  hasArgs  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  NodeTraversal t  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  Map args  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^if  ( t.inGlobalScope (  )  )  {^570^^^^^556^601^[REPLACE] if  ( !t.inGlobalScope (  )  )  {^[METHOD] callMeetsBlockInliningRequirements [TYPE] boolean [PARAMETER] NodeTraversal t Node callNode Node fnNode String> namesToAlias [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  false  fnContainsVars  hasArgs  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  NodeTraversal t  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  Map args  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[ADD]^^574^575^^^^556^601^[ADD] callerContainsFunction = NodeUtil.containsFunctionDeclaration ( fnCallerBody ) ;^[METHOD] callMeetsBlockInliningRequirements [TYPE] boolean [PARAMETER] NodeTraversal t Node callNode Node fnNode String> namesToAlias [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  false  fnContainsVars  hasArgs  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  NodeTraversal t  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  Map args  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^Node parent = callNode.getParent (  )  ;^571^^^^^556^601^[REPLACE] Node fnCaller = t.getScopeRoot (  ) ;^[METHOD] callMeetsBlockInliningRequirements [TYPE] boolean [PARAMETER] NodeTraversal t Node callNode Node fnNode String> namesToAlias [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  false  fnContainsVars  hasArgs  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  NodeTraversal t  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  Map args  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[ADD]^^572^^^^^556^601^[ADD] Node fnCallerBody = fnCaller.getLastChild (  ) ;^[METHOD] callMeetsBlockInliningRequirements [TYPE] boolean [PARAMETER] NodeTraversal t Node callNode Node fnNode String> namesToAlias [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  false  fnContainsVars  hasArgs  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  NodeTraversal t  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  Map args  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^callerContainsFunction =  NodeUtil.containsFunctionDeclaration ( injectionPointParent ) ;^574^575^^^^556^601^[REPLACE] callerContainsFunction = NodeUtil.containsFunctionDeclaration ( fnCallerBody ) ;^[METHOD] callMeetsBlockInliningRequirements [TYPE] boolean [PARAMETER] NodeTraversal t Node callNode Node fnNode String> namesToAlias [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  false  fnContainsVars  hasArgs  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  NodeTraversal t  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  Map args  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[ADD]^^571^^^^^556^601^[ADD] Node fnCaller = t.getScopeRoot (  ) ;^[METHOD] callMeetsBlockInliningRequirements [TYPE] boolean [PARAMETER] NodeTraversal t Node callNode Node fnNode String> namesToAlias [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  false  fnContainsVars  hasArgs  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  NodeTraversal t  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  Map args  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^Node fnCallerBody = fnCaller.getFirstChild (  ) ;^572^^^^^556^601^[REPLACE] Node fnCallerBody = fnCaller.getLastChild (  ) ;^[METHOD] callMeetsBlockInliningRequirements [TYPE] boolean [PARAMETER] NodeTraversal t Node callNode Node fnNode String> namesToAlias [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  false  fnContainsVars  hasArgs  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  NodeTraversal t  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  Map args  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^if  ( fnContainsVars ) {^578^^^^^556^601^[REPLACE] if  ( fnContainsVars && callerContainsFunction )  {^[METHOD] callMeetsBlockInliningRequirements [TYPE] boolean [PARAMETER] NodeTraversal t Node callNode Node fnNode String> namesToAlias [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  false  fnContainsVars  hasArgs  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  NodeTraversal t  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  Map args  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^return true;^579^^^^^556^601^[REPLACE] return false;^[METHOD] callMeetsBlockInliningRequirements [TYPE] boolean [PARAMETER] NodeTraversal t Node callNode Node fnNode String> namesToAlias [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  false  fnContainsVars  hasArgs  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  NodeTraversal t  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  Map args  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^return false;  ;^579^^^^^556^601^[REPLACE] return false;^[METHOD] callMeetsBlockInliningRequirements [TYPE] boolean [PARAMETER] NodeTraversal t Node callNode Node fnNode String> namesToAlias [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  false  fnContainsVars  hasArgs  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  NodeTraversal t  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  Map args  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^} else if   (  parent.getType  (    )   == Token.NAME && !NodeUtil.isConstantName  (  parent  )  ;^584^^^^^556^601^[REPLACE] if  ( callerContainsFunction )  {^[METHOD] callMeetsBlockInliningRequirements [TYPE] boolean [PARAMETER] NodeTraversal t Node callNode Node fnNode String> namesToAlias [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  false  fnContainsVars  hasArgs  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  NodeTraversal t  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  Map args  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^} else if   (  parent.getType  (    )   == Token.NAME && !NodeUtil.isConstantName  (  parent  )  ;^589^^^^^556^601^[REPLACE] if  ( hasArgs )  {^[METHOD] callMeetsBlockInliningRequirements [TYPE] boolean [PARAMETER] NodeTraversal t Node callNode Node fnNode String> namesToAlias [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  false  fnContainsVars  hasArgs  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  NodeTraversal t  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  Map args  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^} else if   (  parent.getType  (    )   == Token.NAME && !NodeUtil.isConstantName  (  parent  )  ;^594^^^^^556^601^[REPLACE] if  ( !allNamesToAlias.isEmpty (  )  )  {^[METHOD] callMeetsBlockInliningRequirements [TYPE] boolean [PARAMETER] NodeTraversal t Node callNode Node fnNode String> namesToAlias [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  false  fnContainsVars  hasArgs  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  NodeTraversal t  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  Map args  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^return true;^595^^^^^556^601^[REPLACE] return false;^[METHOD] callMeetsBlockInliningRequirements [TYPE] boolean [PARAMETER] NodeTraversal t Node callNode Node fnNode String> namesToAlias [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  false  fnContainsVars  hasArgs  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  NodeTraversal t  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  Map args  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^Set<String> allNamesToAlias = Sets.newHashSet ( this ) ;^591^^^^^556^601^[REPLACE] Set<String> allNamesToAlias = Sets.newHashSet ( namesToAlias ) ;^[METHOD] callMeetsBlockInliningRequirements [TYPE] boolean [PARAMETER] NodeTraversal t Node callNode Node fnNode String> namesToAlias [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  false  fnContainsVars  hasArgs  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  NodeTraversal t  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  Map args  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^if  ( allNamesToAlias.isEmpty (  )  )  {^594^^^^^556^601^[REPLACE] if  ( !allNamesToAlias.isEmpty (  )  )  {^[METHOD] callMeetsBlockInliningRequirements [TYPE] boolean [PARAMETER] NodeTraversal t Node callNode Node fnNode String> namesToAlias [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  false  fnContainsVars  hasArgs  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  NodeTraversal t  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  Map args  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^Map<String, Node> args = FunctionArgumentInjector.maybeAddTempsForCallArguments ( fnNode, thisValue, this.safeNameIdSupplier ) ;^585^586^587^^^556^601^[REPLACE] Map<String, Node> args = FunctionArgumentInjector.getFunctionCallParameterMap ( fnNode, callNode, this.safeNameIdSupplier ) ;^[METHOD] callMeetsBlockInliningRequirements [TYPE] boolean [PARAMETER] NodeTraversal t Node callNode Node fnNode String> namesToAlias [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  false  fnContainsVars  hasArgs  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  NodeTraversal t  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  Map args  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[ADD]^^588^^^^^556^601^[ADD] boolean hasArgs = !args.isEmpty (  ) ;^[METHOD] callMeetsBlockInliningRequirements [TYPE] boolean [PARAMETER] NodeTraversal t Node callNode Node fnNode String> namesToAlias [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  false  fnContainsVars  hasArgs  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  NodeTraversal t  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  Map args  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REMOVE]^if  ( callerContainsFunction )  {     String, Node> args = getFunctionCallParameterMap ( fnNode, callNode, this.safeNameIdSupplier ) ;     boolean hasArgs = ! ( args.isEmpty (  )  ) ;     if  ( hasArgs )  {         String> allNamesToAlias = newHashSet ( namesToAlias ) ;         maybeAddTempsForCallArguments ( fnNode, args, allNamesToAlias, compiler.getCodingConvention (  )  ) ;         if  ( ! ( allNamesToAlias.isEmpty (  )  )  )  {             return false;         }     } }^589^^^^^556^601^[REMOVE] ^[METHOD] callMeetsBlockInliningRequirements [TYPE] boolean [PARAMETER] NodeTraversal t Node callNode Node fnNode String> namesToAlias [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  false  fnContainsVars  hasArgs  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  NodeTraversal t  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  Map args  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^return false;  ;^595^^^^^556^601^[REPLACE] return false;^[METHOD] callMeetsBlockInliningRequirements [TYPE] boolean [PARAMETER] NodeTraversal t Node callNode Node fnNode String> namesToAlias [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  false  fnContainsVars  hasArgs  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  NodeTraversal t  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  Map args  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^Set<String> allNamesToAlias = Sets.newHashSet ( null ) ;^591^^^^^556^601^[REPLACE] Set<String> allNamesToAlias = Sets.newHashSet ( namesToAlias ) ;^[METHOD] callMeetsBlockInliningRequirements [TYPE] boolean [PARAMETER] NodeTraversal t Node callNode Node fnNode String> namesToAlias [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  false  fnContainsVars  hasArgs  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  NodeTraversal t  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  Map args  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REMOVE]^if  (  ( blockInlines > 0 )  &&  ( costDeltaBlock > 0 )  )  {     return false; }^594^^^^^556^601^[REMOVE] ^[METHOD] callMeetsBlockInliningRequirements [TYPE] boolean [PARAMETER] NodeTraversal t Node callNode Node fnNode String> namesToAlias [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  false  fnContainsVars  hasArgs  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  NodeTraversal t  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  Map args  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^Map<String, Node> args = FunctionArgumentInjector.getFunctionCallParameterMap ( inlineResult, callNode, this.safeNameIdSupplier ) ;^585^586^587^^^556^601^[REPLACE] Map<String, Node> args = FunctionArgumentInjector.getFunctionCallParameterMap ( fnNode, callNode, this.safeNameIdSupplier ) ;^[METHOD] callMeetsBlockInliningRequirements [TYPE] boolean [PARAMETER] NodeTraversal t Node callNode Node fnNode String> namesToAlias [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  false  fnContainsVars  hasArgs  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  NodeTraversal t  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  Map args  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^return false;^600^^^^^556^601^[REPLACE] return true;^[METHOD] callMeetsBlockInliningRequirements [TYPE] boolean [PARAMETER] NodeTraversal t Node callNode Node fnNode String> namesToAlias [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  false  fnContainsVars  hasArgs  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  NodeTraversal t  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  Map args  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^if  ( !isDirectCallNodeReplacementPossible ( thisValue )  )  {^617^^^^^616^672^[REPLACE] if  ( !isDirectCallNodeReplacementPossible ( fnNode )  )  {^[METHOD] canInlineReferenceDirectly [TYPE] FunctionInjector$CanInlineResult [PARAMETER] Node callNode Node fnNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  false  fnContainsVars  hasArgs  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^return newBlock;  ;^618^^^^^616^672^[REPLACE] return CanInlineResult.NO;^[METHOD] canInlineReferenceDirectly [TYPE] FunctionInjector$CanInlineResult [PARAMETER] Node callNode Node fnNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  false  fnContainsVars  hasArgs  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^Node block = newBlock.getFirstChild (  ) ;^621^^^^^616^672^[REPLACE] Node block = fnNode.getLastChild (  ) ;^[METHOD] canInlineReferenceDirectly [TYPE] FunctionInjector$CanInlineResult [PARAMETER] Node callNode Node fnNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  false  fnContainsVars  hasArgs  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^Node cArg = newBlock.getFirstChild (  ) .getNext (  ) ;^624^^^^^616^672^[REPLACE] Node cArg = callNode.getFirstChild (  ) .getNext (  ) ;^[METHOD] canInlineReferenceDirectly [TYPE] FunctionInjector$CanInlineResult [PARAMETER] Node callNode Node fnNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  false  fnContainsVars  hasArgs  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^if  ( callNode.getFirstChild (  ) .getType (  )   ==  Token.NAME )  {^629^^^^^616^672^[REPLACE] if  ( callNode.getFirstChild (  ) .getType (  )  != Token.NAME )  {^[METHOD] canInlineReferenceDirectly [TYPE] FunctionInjector$CanInlineResult [PARAMETER] Node callNode Node fnNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  false  fnContainsVars  hasArgs  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^} else if   (  NodeUtil.isFunctionObjectApply  (  callNode  )    )   {  ;^630^^^^^616^672^[REPLACE] if  ( NodeUtil.isFunctionObjectCall ( callNode )  )  {^[METHOD] canInlineReferenceDirectly [TYPE] FunctionInjector$CanInlineResult [PARAMETER] Node callNode Node fnNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  false  fnContainsVars  hasArgs  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[ADD]^^630^631^632^633^634^616^672^[ADD] if  ( NodeUtil.isFunctionObjectCall ( callNode )  )  {  Preconditions.checkNotNull ( cArg ) ; Preconditions.checkState ( cArg.getType (  )  == Token.THIS ) ; cArg = cArg.getNext (  ) ;^[METHOD] canInlineReferenceDirectly [TYPE] FunctionInjector$CanInlineResult [PARAMETER] Node callNode Node fnNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  false  fnContainsVars  hasArgs  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^Preconditions.checkArgument ( !NodeUtil.isFunctionObjectApply ( newBlock )  ) ;^637^^^^^630^638^[REPLACE] Preconditions.checkState ( !NodeUtil.isFunctionObjectApply ( callNode )  ) ;^[METHOD] canInlineReferenceDirectly [TYPE] FunctionInjector$CanInlineResult [PARAMETER] Node callNode Node fnNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  false  fnContainsVars  hasArgs  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REMOVE]^checkState ( isExpressionNode ( grandParent )  )  ;^637^^^^^630^638^[REMOVE] ^[METHOD] canInlineReferenceDirectly [TYPE] FunctionInjector$CanInlineResult [PARAMETER] Node callNode Node fnNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  false  fnContainsVars  hasArgs  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^Preconditions.checkState ( !NodeUtil.isFunctionObjectApply ( thisValue )  ) ;^637^^^^^630^638^[REPLACE] Preconditions.checkState ( !NodeUtil.isFunctionObjectApply ( callNode )  ) ;^[METHOD] canInlineReferenceDirectly [TYPE] FunctionInjector$CanInlineResult [PARAMETER] Node callNode Node fnNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  false  fnContainsVars  hasArgs  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[ADD]^^634^^^^^616^672^[ADD] cArg = cArg.getNext (  ) ;^[METHOD] canInlineReferenceDirectly [TYPE] FunctionInjector$CanInlineResult [PARAMETER] Node callNode Node fnNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  false  fnContainsVars  hasArgs  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^cArg =  thisValue.getNext (  ) ;^634^^^^^616^672^[REPLACE] cArg = cArg.getNext (  ) ;^[METHOD] canInlineReferenceDirectly [TYPE] FunctionInjector$CanInlineResult [PARAMETER] Node callNode Node fnNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  false  fnContainsVars  hasArgs  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^Preconditions.checkState ( !NodeUtil.isFunctionObjectCall ( callNode )  ) ;^637^^^^^630^638^[REPLACE] Preconditions.checkState ( !NodeUtil.isFunctionObjectApply ( callNode )  ) ;^[METHOD] canInlineReferenceDirectly [TYPE] FunctionInjector$CanInlineResult [PARAMETER] Node callNode Node fnNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  false  fnContainsVars  hasArgs  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[ADD]^^637^^^^^630^638^[ADD] Preconditions.checkState ( !NodeUtil.isFunctionObjectApply ( callNode )  ) ;^[METHOD] canInlineReferenceDirectly [TYPE] FunctionInjector$CanInlineResult [PARAMETER] Node callNode Node fnNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  false  fnContainsVars  hasArgs  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^Node argsNode = getFnParameters ( fnNode )  ;^642^^^^^616^672^[REPLACE] Node fnParam = NodeUtil.getFnParameters ( fnNode ) .getFirstChild (  ) ;^[METHOD] canInlineReferenceDirectly [TYPE] FunctionInjector$CanInlineResult [PARAMETER] Node callNode Node fnNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  false  fnContainsVars  hasArgs  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^if  ( fnParam == true )  {^645^^^^^616^672^[REPLACE] if  ( fnParam != null )  {^[METHOD] canInlineReferenceDirectly [TYPE] FunctionInjector$CanInlineResult [PARAMETER] Node callNode Node fnNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  false  fnContainsVars  hasArgs  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^if  (safeReturnNode == null )  {^646^^^^^616^672^[REPLACE] if  ( cArg != null )  {^[METHOD] canInlineReferenceDirectly [TYPE] FunctionInjector$CanInlineResult [PARAMETER] Node callNode Node fnNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  false  fnContainsVars  hasArgs  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^if  ( NodeUtil.mayEffectMutableState ( cArg ) || NodeUtil.getNameReferenceCount ( block, fnParam.getString (  )  )  > 1 )  {^650^651^652^^^616^672^[REPLACE] if  ( NodeUtil.mayEffectMutableState ( cArg ) && NodeUtil.getNameReferenceCount ( block, fnParam.getString (  )  )  > 1 )  {^[METHOD] canInlineReferenceDirectly [TYPE] FunctionInjector$CanInlineResult [PARAMETER] Node callNode Node fnNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  false  fnContainsVars  hasArgs  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^return newBlock;  ;^653^^^^^650^654^[REPLACE] return CanInlineResult.NO;^[METHOD] canInlineReferenceDirectly [TYPE] FunctionInjector$CanInlineResult [PARAMETER] Node callNode Node fnNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  false  fnContainsVars  hasArgs  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^return newBlock;  ;^653^^^^^616^672^[REPLACE] return CanInlineResult.NO;^[METHOD] canInlineReferenceDirectly [TYPE] FunctionInjector$CanInlineResult [PARAMETER] Node callNode Node fnNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  false  fnContainsVars  hasArgs  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^if  ( NodeUtil.mayEffectMutableState ( cArg ) ) {^650^651^652^^^616^672^[REPLACE] if  ( NodeUtil.mayEffectMutableState ( cArg ) && NodeUtil.getNameReferenceCount ( block, fnParam.getString (  )  )  > 1 )  {^[METHOD] canInlineReferenceDirectly [TYPE] FunctionInjector$CanInlineResult [PARAMETER] Node callNode Node fnNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  false  fnContainsVars  hasArgs  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^fnParam =  thisValue.getNext (  ) ;^658^^^^^616^672^[REPLACE] fnParam = fnParam.getNext (  ) ;^[METHOD] canInlineReferenceDirectly [TYPE] FunctionInjector$CanInlineResult [PARAMETER] Node callNode Node fnNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  false  fnContainsVars  hasArgs  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^if  (returnNode == null )  {^646^^^^^616^672^[REPLACE] if  ( cArg != null )  {^[METHOD] canInlineReferenceDirectly [TYPE] FunctionInjector$CanInlineResult [PARAMETER] Node callNode Node fnNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  false  fnContainsVars  hasArgs  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[ADD]^^646^647^^^650^616^672^[ADD] if  ( cArg != null )  {  if  ( NodeUtil.mayEffectMutableState ( cArg )^[METHOD] canInlineReferenceDirectly [TYPE] FunctionInjector$CanInlineResult [PARAMETER] Node callNode Node fnNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  false  fnContainsVars  hasArgs  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^if  ( NodeUtil.mayEffectMutableState ( cArg ) || NodeUtil.getNameReferenceCount ( safeReturnNode, fnParam.getString (  )  )  > 1 >> 0 )  {^650^651^652^^^616^672^[REPLACE] if  ( NodeUtil.mayEffectMutableState ( cArg ) && NodeUtil.getNameReferenceCount ( block, fnParam.getString (  )  )  > 1 )  {^[METHOD] canInlineReferenceDirectly [TYPE] FunctionInjector$CanInlineResult [PARAMETER] Node callNode Node fnNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  false  fnContainsVars  hasArgs  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^if  ( NodeUtil.mayEffectMutableState ( returnNode ) || NodeUtil.getNameReferenceCount ( block, fnParam.getString (  )  )  > 1 )  {^650^651^652^^^616^672^[REPLACE] if  ( NodeUtil.mayEffectMutableState ( cArg ) && NodeUtil.getNameReferenceCount ( block, fnParam.getString (  )  )  > 1 )  {^[METHOD] canInlineReferenceDirectly [TYPE] FunctionInjector$CanInlineResult [PARAMETER] Node callNode Node fnNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  false  fnContainsVars  hasArgs  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^if   (  fnParam != null  )   {  ;^663^^^^^616^672^[REPLACE] if  ( cArg != null )  {^[METHOD] canInlineReferenceDirectly [TYPE] FunctionInjector$CanInlineResult [PARAMETER] Node callNode Node fnNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  false  fnContainsVars  hasArgs  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^if  ( NodeUtil.mayHaveSideEffects ( inlineResult )  )  {^664^^^^^616^672^[REPLACE] if  ( NodeUtil.mayHaveSideEffects ( cArg )  )  {^[METHOD] canInlineReferenceDirectly [TYPE] FunctionInjector$CanInlineResult [PARAMETER] Node callNode Node fnNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  false  fnContainsVars  hasArgs  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^return newBlock;  ;^665^^^^^616^672^[REPLACE] return CanInlineResult.NO;^[METHOD] canInlineReferenceDirectly [TYPE] FunctionInjector$CanInlineResult [PARAMETER] Node callNode Node fnNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  false  fnContainsVars  hasArgs  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[ADD]^^667^^^^^616^672^[ADD] cArg = cArg.getNext (  ) ;^[METHOD] canInlineReferenceDirectly [TYPE] FunctionInjector$CanInlineResult [PARAMETER] Node callNode Node fnNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  false  fnContainsVars  hasArgs  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^if  ( NodeUtil .mayEffectMutableState ( cArg )   )  {^664^^^^^616^672^[REPLACE] if  ( NodeUtil.mayHaveSideEffects ( cArg )  )  {^[METHOD] canInlineReferenceDirectly [TYPE] FunctionInjector$CanInlineResult [PARAMETER] Node callNode Node fnNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  false  fnContainsVars  hasArgs  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[ADD]^return CanInlineResult.NO;^664^665^666^^^616^672^[ADD] if  ( NodeUtil.mayHaveSideEffects ( cArg )  )  { return CanInlineResult.NO; }^[METHOD] canInlineReferenceDirectly [TYPE] FunctionInjector$CanInlineResult [PARAMETER] Node callNode Node fnNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  false  fnContainsVars  hasArgs  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^cArg =  null.getNext (  ) ;^667^^^^^616^672^[REPLACE] cArg = cArg.getNext (  ) ;^[METHOD] canInlineReferenceDirectly [TYPE] FunctionInjector$CanInlineResult [PARAMETER] Node callNode Node fnNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  false  fnContainsVars  hasArgs  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^return newBlock;  ;^671^^^^^616^672^[REPLACE] return CanInlineResult.YES;^[METHOD] canInlineReferenceDirectly [TYPE] FunctionInjector$CanInlineResult [PARAMETER] Node callNode Node fnNode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  false  fnContainsVars  hasArgs  isCallInLoop  needsDefaultReturnResult  referencesThis  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST 
[REPLACE]^int referenceCount = this.size (  ) ;^688^^^^^687^741^[REPLACE] int referenceCount = refs.size (  ) ;^[METHOD] inliningLowersCost [TYPE] boolean [PARAMETER] JSModule fnModule Node fnNode Reference> refs String> namesToAlias boolean isRemovable boolean referencesThis [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Reference ref  [TYPE]  Node block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST  callCost  costDeltaBlock  costDeltaDirect  overallCallCost  referenceCount  referencesUsingBlockInlining  referencesUsingDirectInlining  [TYPE]  JSModuleGraph moduleGraph  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  checkModules  false  fnContainsVars  hasArgs  isCallInLoop  isRemovable  needsDefaultReturnResult  referencesThis  true  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  JSModule fnModule  module  [TYPE]  Collection refs  [TYPE]  Supplier safeNameIdSupplier 
[REPLACE]^if  ( referencesUsingDirectInlining  != costDeltaDirect )  {^689^^^^^687^741^[REPLACE] if  ( referenceCount == 0 )  {^[METHOD] inliningLowersCost [TYPE] boolean [PARAMETER] JSModule fnModule Node fnNode Reference> refs String> namesToAlias boolean isRemovable boolean referencesThis [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Reference ref  [TYPE]  Node block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST  callCost  costDeltaBlock  costDeltaDirect  overallCallCost  referenceCount  referencesUsingBlockInlining  referencesUsingDirectInlining  [TYPE]  JSModuleGraph moduleGraph  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  checkModules  false  fnContainsVars  hasArgs  isCallInLoop  isRemovable  needsDefaultReturnResult  referencesThis  true  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  JSModule fnModule  module  [TYPE]  Collection refs  [TYPE]  Supplier safeNameIdSupplier 
[REPLACE]^return false;^690^^^^^687^741^[REPLACE] return true;^[METHOD] inliningLowersCost [TYPE] boolean [PARAMETER] JSModule fnModule Node fnNode Reference> refs String> namesToAlias boolean isRemovable boolean referencesThis [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Reference ref  [TYPE]  Node block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST  callCost  costDeltaBlock  costDeltaDirect  overallCallCost  referenceCount  referencesUsingBlockInlining  referencesUsingDirectInlining  [TYPE]  JSModuleGraph moduleGraph  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  checkModules  false  fnContainsVars  hasArgs  isCallInLoop  isRemovable  needsDefaultReturnResult  referencesThis  true  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  JSModule fnModule  module  [TYPE]  Collection refs  [TYPE]  Supplier safeNameIdSupplier 
[REPLACE]^int referencesUsingBlockInlining = 2;^693^^^^^687^741^[REPLACE] int referencesUsingBlockInlining = 0;^[METHOD] inliningLowersCost [TYPE] boolean [PARAMETER] JSModule fnModule Node fnNode Reference> refs String> namesToAlias boolean isRemovable boolean referencesThis [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Reference ref  [TYPE]  Node block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST  callCost  costDeltaBlock  costDeltaDirect  overallCallCost  referenceCount  referencesUsingBlockInlining  referencesUsingDirectInlining  [TYPE]  JSModuleGraph moduleGraph  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  checkModules  false  fnContainsVars  hasArgs  isCallInLoop  isRemovable  needsDefaultReturnResult  referencesThis  true  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  JSModule fnModule  module  [TYPE]  Collection refs  [TYPE]  Supplier safeNameIdSupplier 
[REPLACE]^boolean checkModules = isRemovable  ||  fnModule != null;^695^^^^^687^741^[REPLACE] boolean checkModules = isRemovable && fnModule != null;^[METHOD] inliningLowersCost [TYPE] boolean [PARAMETER] JSModule fnModule Node fnNode Reference> refs String> namesToAlias boolean isRemovable boolean referencesThis [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Reference ref  [TYPE]  Node block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST  callCost  costDeltaBlock  costDeltaDirect  overallCallCost  referenceCount  referencesUsingBlockInlining  referencesUsingDirectInlining  [TYPE]  JSModuleGraph moduleGraph  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  checkModules  false  fnContainsVars  hasArgs  isCallInLoop  isRemovable  needsDefaultReturnResult  referencesThis  true  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  JSModule fnModule  module  [TYPE]  Collection refs  [TYPE]  Supplier safeNameIdSupplier 
[REPLACE]^JSModuleGraph moduleGraph = compiler .getCodingConvention (  )  ;^696^^^^^687^741^[REPLACE] JSModuleGraph moduleGraph = compiler.getModuleGraph (  ) ;^[METHOD] inliningLowersCost [TYPE] boolean [PARAMETER] JSModule fnModule Node fnNode Reference> refs String> namesToAlias boolean isRemovable boolean referencesThis [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Reference ref  [TYPE]  Node block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST  callCost  costDeltaBlock  costDeltaDirect  overallCallCost  referenceCount  referencesUsingBlockInlining  referencesUsingDirectInlining  [TYPE]  JSModuleGraph moduleGraph  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  checkModules  false  fnContainsVars  hasArgs  isCallInLoop  isRemovable  needsDefaultReturnResult  referencesThis  true  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  JSModule fnModule  module  [TYPE]  Collection refs  [TYPE]  Supplier safeNameIdSupplier 
[REPLACE]^if  (   InliningMode.BLOCK )  {^699^^^^^687^741^[REPLACE] if  ( ref.mode == InliningMode.BLOCK )  {^[METHOD] inliningLowersCost [TYPE] boolean [PARAMETER] JSModule fnModule Node fnNode Reference> refs String> namesToAlias boolean isRemovable boolean referencesThis [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Reference ref  [TYPE]  Node block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST  callCost  costDeltaBlock  costDeltaDirect  overallCallCost  referenceCount  referencesUsingBlockInlining  referencesUsingDirectInlining  [TYPE]  JSModuleGraph moduleGraph  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  checkModules  false  fnContainsVars  hasArgs  isCallInLoop  isRemovable  needsDefaultReturnResult  referencesThis  true  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  JSModule fnModule  module  [TYPE]  Collection refs  [TYPE]  Supplier safeNameIdSupplier 
[REPLACE]^if  ( checkModules ) {^704^^^^^687^741^[REPLACE] if  ( checkModules && ref.module != null )  {^[METHOD] inliningLowersCost [TYPE] boolean [PARAMETER] JSModule fnModule Node fnNode Reference> refs String> namesToAlias boolean isRemovable boolean referencesThis [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Reference ref  [TYPE]  Node block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST  callCost  costDeltaBlock  costDeltaDirect  overallCallCost  referenceCount  referencesUsingBlockInlining  referencesUsingDirectInlining  [TYPE]  JSModuleGraph moduleGraph  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  checkModules  false  fnContainsVars  hasArgs  isCallInLoop  isRemovable  needsDefaultReturnResult  referencesThis  true  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  JSModule fnModule  module  [TYPE]  Collection refs  [TYPE]  Supplier safeNameIdSupplier 
[REPLACE]^if  ( ref.module != module || !moduleGraph.dependsOn ( ref.module, fnModule )  )  {^705^706^^^^687^741^[REPLACE] if  ( ref.module != fnModule && !moduleGraph.dependsOn ( ref.module, fnModule )  )  {^[METHOD] inliningLowersCost [TYPE] boolean [PARAMETER] JSModule fnModule Node fnNode Reference> refs String> namesToAlias boolean isRemovable boolean referencesThis [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Reference ref  [TYPE]  Node block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST  callCost  costDeltaBlock  costDeltaDirect  overallCallCost  referenceCount  referencesUsingBlockInlining  referencesUsingDirectInlining  [TYPE]  JSModuleGraph moduleGraph  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  checkModules  false  fnContainsVars  hasArgs  isCallInLoop  isRemovable  needsDefaultReturnResult  referencesThis  true  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  JSModule fnModule  module  [TYPE]  Collection refs  [TYPE]  Supplier safeNameIdSupplier 
[ADD]^^709^^^^^705^711^[ADD] isRemovable = false;^[METHOD] inliningLowersCost [TYPE] boolean [PARAMETER] JSModule fnModule Node fnNode Reference> refs String> namesToAlias boolean isRemovable boolean referencesThis [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Reference ref  [TYPE]  Node block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST  callCost  costDeltaBlock  costDeltaDirect  overallCallCost  referenceCount  referencesUsingBlockInlining  referencesUsingDirectInlining  [TYPE]  JSModuleGraph moduleGraph  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  checkModules  false  fnContainsVars  hasArgs  isCallInLoop  isRemovable  needsDefaultReturnResult  referencesThis  true  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  JSModule fnModule  module  [TYPE]  Collection refs  [TYPE]  Supplier safeNameIdSupplier 
[REPLACE]^checkModules = true;^710^^^^^705^711^[REPLACE] checkModules = false;^[METHOD] inliningLowersCost [TYPE] boolean [PARAMETER] JSModule fnModule Node fnNode Reference> refs String> namesToAlias boolean isRemovable boolean referencesThis [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Reference ref  [TYPE]  Node block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST  callCost  costDeltaBlock  costDeltaDirect  overallCallCost  referenceCount  referencesUsingBlockInlining  referencesUsingDirectInlining  [TYPE]  JSModuleGraph moduleGraph  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  checkModules  false  fnContainsVars  hasArgs  isCallInLoop  isRemovable  needsDefaultReturnResult  referencesThis  true  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  JSModule fnModule  module  [TYPE]  Collection refs  [TYPE]  Supplier safeNameIdSupplier 
[REPLACE]^isRemovable = true;^709^^^^^687^741^[REPLACE] isRemovable = false;^[METHOD] inliningLowersCost [TYPE] boolean [PARAMETER] JSModule fnModule Node fnNode Reference> refs String> namesToAlias boolean isRemovable boolean referencesThis [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Reference ref  [TYPE]  Node block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST  callCost  costDeltaBlock  costDeltaDirect  overallCallCost  referenceCount  referencesUsingBlockInlining  referencesUsingDirectInlining  [TYPE]  JSModuleGraph moduleGraph  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  checkModules  false  fnContainsVars  hasArgs  isCallInLoop  isRemovable  needsDefaultReturnResult  referencesThis  true  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  JSModule fnModule  module  [TYPE]  Collection refs  [TYPE]  Supplier safeNameIdSupplier 
[REPLACE]^checkModules = true;^710^^^^^687^741^[REPLACE] checkModules = false;^[METHOD] inliningLowersCost [TYPE] boolean [PARAMETER] JSModule fnModule Node fnNode Reference> refs String> namesToAlias boolean isRemovable boolean referencesThis [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Reference ref  [TYPE]  Node block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST  callCost  costDeltaBlock  costDeltaDirect  overallCallCost  referenceCount  referencesUsingBlockInlining  referencesUsingDirectInlining  [TYPE]  JSModuleGraph moduleGraph  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  checkModules  false  fnContainsVars  hasArgs  isCallInLoop  isRemovable  needsDefaultReturnResult  referencesThis  true  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  JSModule fnModule  module  [TYPE]  Collection refs  [TYPE]  Supplier safeNameIdSupplier 
[REPLACE]^if  ( ref.module != fnModule || !moduleGraph.dependsOn ( ref.module, fnModule )  )  {^705^706^^^^687^741^[REPLACE] if  ( ref.module != fnModule && !moduleGraph.dependsOn ( ref.module, fnModule )  )  {^[METHOD] inliningLowersCost [TYPE] boolean [PARAMETER] JSModule fnModule Node fnNode Reference> refs String> namesToAlias boolean isRemovable boolean referencesThis [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Reference ref  [TYPE]  Node block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST  callCost  costDeltaBlock  costDeltaDirect  overallCallCost  referenceCount  referencesUsingBlockInlining  referencesUsingDirectInlining  [TYPE]  JSModuleGraph moduleGraph  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  checkModules  false  fnContainsVars  hasArgs  isCallInLoop  isRemovable  needsDefaultReturnResult  referencesThis  true  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  JSModule fnModule  module  [TYPE]  Collection refs  [TYPE]  Supplier safeNameIdSupplier 
[ADD]^^705^706^^^709^687^741^[ADD] if  ( ref.module != fnModule && !moduleGraph.dependsOn ( ref.module, fnModule )  )  { isRemovable = false;^[METHOD] inliningLowersCost [TYPE] boolean [PARAMETER] JSModule fnModule Node fnNode Reference> refs String> namesToAlias boolean isRemovable boolean referencesThis [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Reference ref  [TYPE]  Node block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST  callCost  costDeltaBlock  costDeltaDirect  overallCallCost  referenceCount  referencesUsingBlockInlining  referencesUsingDirectInlining  [TYPE]  JSModuleGraph moduleGraph  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  checkModules  false  fnContainsVars  hasArgs  isCallInLoop  isRemovable  needsDefaultReturnResult  referencesThis  true  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  JSModule fnModule  module  [TYPE]  Collection refs  [TYPE]  Supplier safeNameIdSupplier 
[REPLACE]^isRemovable = true;^709^^^^^705^711^[REPLACE] isRemovable = false;^[METHOD] inliningLowersCost [TYPE] boolean [PARAMETER] JSModule fnModule Node fnNode Reference> refs String> namesToAlias boolean isRemovable boolean referencesThis [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Reference ref  [TYPE]  Node block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST  callCost  costDeltaBlock  costDeltaDirect  overallCallCost  referenceCount  referencesUsingBlockInlining  referencesUsingDirectInlining  [TYPE]  JSModuleGraph moduleGraph  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  checkModules  false  fnContainsVars  hasArgs  isCallInLoop  isRemovable  needsDefaultReturnResult  referencesThis  true  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  JSModule fnModule  module  [TYPE]  Collection refs  [TYPE]  Supplier safeNameIdSupplier 
[REPLACE]^if  ( ref.mode  !=  InliningMode.BLOCK )  {^699^^^^^687^741^[REPLACE] if  ( ref.mode == InliningMode.BLOCK )  {^[METHOD] inliningLowersCost [TYPE] boolean [PARAMETER] JSModule fnModule Node fnNode Reference> refs String> namesToAlias boolean isRemovable boolean referencesThis [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Reference ref  [TYPE]  Node block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST  callCost  costDeltaBlock  costDeltaDirect  overallCallCost  referenceCount  referencesUsingBlockInlining  referencesUsingDirectInlining  [TYPE]  JSModuleGraph moduleGraph  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  checkModules  false  fnContainsVars  hasArgs  isCallInLoop  isRemovable  needsDefaultReturnResult  referencesThis  true  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  JSModule fnModule  module  [TYPE]  Collection refs  [TYPE]  Supplier safeNameIdSupplier 
[REPLACE]^if  ( isRemovable ) {^704^^^^^687^741^[REPLACE] if  ( checkModules && ref.module != null )  {^[METHOD] inliningLowersCost [TYPE] boolean [PARAMETER] JSModule fnModule Node fnNode Reference> refs String> namesToAlias boolean isRemovable boolean referencesThis [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Reference ref  [TYPE]  Node block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST  callCost  costDeltaBlock  costDeltaDirect  overallCallCost  referenceCount  referencesUsingBlockInlining  referencesUsingDirectInlining  [TYPE]  JSModuleGraph moduleGraph  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  checkModules  false  fnContainsVars  hasArgs  isCallInLoop  isRemovable  needsDefaultReturnResult  referencesThis  true  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  JSModule fnModule  module  [TYPE]  Collection refs  [TYPE]  Supplier safeNameIdSupplier 
[REPLACE]^if  ( ref.module != fnModule ) {^705^706^^^^687^741^[REPLACE] if  ( ref.module != fnModule && !moduleGraph.dependsOn ( ref.module, fnModule )  )  {^[METHOD] inliningLowersCost [TYPE] boolean [PARAMETER] JSModule fnModule Node fnNode Reference> refs String> namesToAlias boolean isRemovable boolean referencesThis [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Reference ref  [TYPE]  Node block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST  callCost  costDeltaBlock  costDeltaDirect  overallCallCost  referenceCount  referencesUsingBlockInlining  referencesUsingDirectInlining  [TYPE]  JSModuleGraph moduleGraph  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  checkModules  false  fnContainsVars  hasArgs  isCallInLoop  isRemovable  needsDefaultReturnResult  referencesThis  true  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  JSModule fnModule  module  [TYPE]  Collection refs  [TYPE]  Supplier safeNameIdSupplier 
[REPLACE]^int costDelta =  ( directInlines * costDeltaDirect )  +  ( blockInlines * costDeltaBlock )  ;^698^^^^^687^741^[REPLACE] for  ( Reference ref : refs )  {^[METHOD] inliningLowersCost [TYPE] boolean [PARAMETER] JSModule fnModule Node fnNode Reference> refs String> namesToAlias boolean isRemovable boolean referencesThis [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Reference ref  [TYPE]  Node block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST  callCost  costDeltaBlock  costDeltaDirect  overallCallCost  referenceCount  referencesUsingBlockInlining  referencesUsingDirectInlining  [TYPE]  JSModuleGraph moduleGraph  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  checkModules  false  fnContainsVars  hasArgs  isCallInLoop  isRemovable  needsDefaultReturnResult  referencesThis  true  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  JSModule fnModule  module  [TYPE]  Collection refs  [TYPE]  Supplier safeNameIdSupplier 
[REPLACE]^int referencesUsingDirectInlining = referenceCount  referencesUsingBlockInlining;^715^716^^^^687^741^[REPLACE] int referencesUsingDirectInlining = referenceCount - referencesUsingBlockInlining;^[METHOD] inliningLowersCost [TYPE] boolean [PARAMETER] JSModule fnModule Node fnNode Reference> refs String> namesToAlias boolean isRemovable boolean referencesThis [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Reference ref  [TYPE]  Node block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST  callCost  costDeltaBlock  costDeltaDirect  overallCallCost  referenceCount  referencesUsingBlockInlining  referencesUsingDirectInlining  [TYPE]  JSModuleGraph moduleGraph  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  checkModules  false  fnContainsVars  hasArgs  isCallInLoop  isRemovable  needsDefaultReturnResult  referencesThis  true  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  JSModule fnModule  module  [TYPE]  Collection refs  [TYPE]  Supplier safeNameIdSupplier 
[REPLACE]^if  ( overallCallCost == 3 || isRemovable || referencesUsingDirectInlining == 3 )  {^724^725^^^^687^741^[REPLACE] if  ( referenceCount == 1 && isRemovable && referencesUsingDirectInlining == 1 )  {^[METHOD] inliningLowersCost [TYPE] boolean [PARAMETER] JSModule fnModule Node fnNode Reference> refs String> namesToAlias boolean isRemovable boolean referencesThis [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Reference ref  [TYPE]  Node block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST  callCost  costDeltaBlock  costDeltaDirect  overallCallCost  referenceCount  referencesUsingBlockInlining  referencesUsingDirectInlining  [TYPE]  JSModuleGraph moduleGraph  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  checkModules  false  fnContainsVars  hasArgs  isCallInLoop  isRemovable  needsDefaultReturnResult  referencesThis  true  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  JSModule fnModule  module  [TYPE]  Collection refs  [TYPE]  Supplier safeNameIdSupplier 
[REPLACE]^return false;^726^^^^^724^727^[REPLACE] return true;^[METHOD] inliningLowersCost [TYPE] boolean [PARAMETER] JSModule fnModule Node fnNode Reference> refs String> namesToAlias boolean isRemovable boolean referencesThis [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Reference ref  [TYPE]  Node block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST  callCost  costDeltaBlock  costDeltaDirect  overallCallCost  referenceCount  referencesUsingBlockInlining  referencesUsingDirectInlining  [TYPE]  JSModuleGraph moduleGraph  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  checkModules  false  fnContainsVars  hasArgs  isCallInLoop  isRemovable  needsDefaultReturnResult  referencesThis  true  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  JSModule fnModule  module  [TYPE]  Collection refs  [TYPE]  Supplier safeNameIdSupplier 
[REPLACE]^return false;^726^^^^^687^741^[REPLACE] return true;^[METHOD] inliningLowersCost [TYPE] boolean [PARAMETER] JSModule fnModule Node fnNode Reference> refs String> namesToAlias boolean isRemovable boolean referencesThis [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Reference ref  [TYPE]  Node block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST  callCost  costDeltaBlock  costDeltaDirect  overallCallCost  referenceCount  referencesUsingBlockInlining  referencesUsingDirectInlining  [TYPE]  JSModuleGraph moduleGraph  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  checkModules  false  fnContainsVars  hasArgs  isCallInLoop  isRemovable  needsDefaultReturnResult  referencesThis  true  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  JSModule fnModule  module  [TYPE]  Collection refs  [TYPE]  Supplier safeNameIdSupplier 
[REPLACE]^int callCost = estimateCallCost ( fnNode, true ) ;^729^^^^^687^741^[REPLACE] int callCost = estimateCallCost ( fnNode, referencesThis ) ;^[METHOD] inliningLowersCost [TYPE] boolean [PARAMETER] JSModule fnModule Node fnNode Reference> refs String> namesToAlias boolean isRemovable boolean referencesThis [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Reference ref  [TYPE]  Node block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST  callCost  costDeltaBlock  costDeltaDirect  overallCallCost  referenceCount  referencesUsingBlockInlining  referencesUsingDirectInlining  [TYPE]  JSModuleGraph moduleGraph  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  checkModules  false  fnContainsVars  hasArgs  isCallInLoop  isRemovable  needsDefaultReturnResult  referencesThis  true  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  JSModule fnModule  module  [TYPE]  Collection refs  [TYPE]  Supplier safeNameIdSupplier 
[REPLACE]^int overallCallCost = callCost referencesUsingDirectInlining;^730^^^^^687^741^[REPLACE] int overallCallCost = callCost * referenceCount;^[METHOD] inliningLowersCost [TYPE] boolean [PARAMETER] JSModule fnModule Node fnNode Reference> refs String> namesToAlias boolean isRemovable boolean referencesThis [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Reference ref  [TYPE]  Node block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST  callCost  costDeltaBlock  costDeltaDirect  overallCallCost  referenceCount  referencesUsingBlockInlining  referencesUsingDirectInlining  [TYPE]  JSModuleGraph moduleGraph  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  checkModules  false  fnContainsVars  hasArgs  isCallInLoop  isRemovable  needsDefaultReturnResult  referencesThis  true  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  JSModule fnModule  module  [TYPE]  Collection refs  [TYPE]  Supplier safeNameIdSupplier 
[REPLACE]^int costDeltaDirect = inlineCostDelta ( thisValue, namesToAlias, InliningMode.DIRECT ) ;^732^733^^^^687^741^[REPLACE] int costDeltaDirect = inlineCostDelta ( fnNode, namesToAlias, InliningMode.DIRECT ) ;^[METHOD] inliningLowersCost [TYPE] boolean [PARAMETER] JSModule fnModule Node fnNode Reference> refs String> namesToAlias boolean isRemovable boolean referencesThis [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Reference ref  [TYPE]  Node block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST  callCost  costDeltaBlock  costDeltaDirect  overallCallCost  referenceCount  referencesUsingBlockInlining  referencesUsingDirectInlining  [TYPE]  JSModuleGraph moduleGraph  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  checkModules  false  fnContainsVars  hasArgs  isCallInLoop  isRemovable  needsDefaultReturnResult  referencesThis  true  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  JSModule fnModule  module  [TYPE]  Collection refs  [TYPE]  Supplier safeNameIdSupplier 
[REPLACE]^int costDeltaBlock = inlineCostDelta ( fnNode, this, InliningMode.BLOCK ) ;^734^735^^^^687^741^[REPLACE] int costDeltaBlock = inlineCostDelta ( fnNode, namesToAlias, InliningMode.BLOCK ) ;^[METHOD] inliningLowersCost [TYPE] boolean [PARAMETER] JSModule fnModule Node fnNode Reference> refs String> namesToAlias boolean isRemovable boolean referencesThis [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Reference ref  [TYPE]  Node block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST  callCost  costDeltaBlock  costDeltaDirect  overallCallCost  referenceCount  referencesUsingBlockInlining  referencesUsingDirectInlining  [TYPE]  JSModuleGraph moduleGraph  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  checkModules  false  fnContainsVars  hasArgs  isCallInLoop  isRemovable  needsDefaultReturnResult  referencesThis  true  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  JSModule fnModule  module  [TYPE]  Collection refs  [TYPE]  Supplier safeNameIdSupplier 
[REPLACE]^return doesLowerCost ( fnNode, overallCallCost, referencesUsingDirectInlining, costDeltaDirect, referencesUsingDirectInlining, costDeltaBlock, isRemovable ) ;^737^738^739^740^^687^741^[REPLACE] return doesLowerCost ( fnNode, overallCallCost, referencesUsingDirectInlining, costDeltaDirect, referencesUsingBlockInlining, costDeltaBlock, isRemovable ) ;^[METHOD] inliningLowersCost [TYPE] boolean [PARAMETER] JSModule fnModule Node fnNode Reference> refs String> namesToAlias boolean isRemovable boolean referencesThis [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Reference ref  [TYPE]  Node block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST  callCost  costDeltaBlock  costDeltaDirect  overallCallCost  referenceCount  referencesUsingBlockInlining  referencesUsingDirectInlining  [TYPE]  JSModuleGraph moduleGraph  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  checkModules  false  fnContainsVars  hasArgs  isCallInLoop  isRemovable  needsDefaultReturnResult  referencesThis  true  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  JSModule fnModule  module  [TYPE]  Collection refs  [TYPE]  Supplier safeNameIdSupplier 
[REPLACE]^int fnInstanceCount = directInlines + blockInlines   ( removable ? 1 : 0 ) ;^757^^^^^750^774^[REPLACE] int fnInstanceCount = directInlines + blockInlines -  ( removable ? 1 : 0 ) ;^[METHOD] doesLowerCost [TYPE] boolean [PARAMETER] Node fnNode int callCost int directInlines int costDeltaDirect int blockInlines int costDeltaBlock boolean removable [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  checkModules  false  fnContainsVars  hasArgs  isCallInLoop  isRemovable  needsDefaultReturnResult  referencesThis  removable  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule fnModule  module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST  blockInlines  callCost  costDelta  costDeltaBlock  costDeltaDirect  directInlines  fnInstanceCount  overallCallCost  referenceCount  referencesUsingBlockInlining  referencesUsingDirectInlining  threshold 
[REPLACE]^if  ( fnInstanceCount  && directInlines )  {^759^^^^^750^774^[REPLACE] if  ( fnInstanceCount == 0 )  {^[METHOD] doesLowerCost [TYPE] boolean [PARAMETER] Node fnNode int callCost int directInlines int costDeltaDirect int blockInlines int costDeltaBlock boolean removable [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  checkModules  false  fnContainsVars  hasArgs  isCallInLoop  isRemovable  needsDefaultReturnResult  referencesThis  removable  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule fnModule  module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST  blockInlines  callCost  costDelta  costDeltaBlock  costDeltaDirect  directInlines  fnInstanceCount  overallCallCost  referenceCount  referencesUsingBlockInlining  referencesUsingDirectInlining  threshold 
[ADD]^^759^760^^^^750^774^[ADD] if  ( fnInstanceCount == 0 )  {^[METHOD] doesLowerCost [TYPE] boolean [PARAMETER] Node fnNode int callCost int directInlines int costDeltaDirect int blockInlines int costDeltaBlock boolean removable [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  checkModules  false  fnContainsVars  hasArgs  isCallInLoop  isRemovable  needsDefaultReturnResult  referencesThis  removable  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule fnModule  module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST  blockInlines  callCost  costDelta  costDeltaBlock  costDeltaDirect  directInlines  fnInstanceCount  overallCallCost  referenceCount  referencesUsingBlockInlining  referencesUsingDirectInlining  threshold 
[REPLACE]^if  ( blockInlines > 0 / 4 || costDeltaBlock > 0 / 4 )  {^763^^^^^750^774^[REPLACE] if  ( blockInlines > 0 && costDeltaBlock > 0 )  {^[METHOD] doesLowerCost [TYPE] boolean [PARAMETER] Node fnNode int callCost int directInlines int costDeltaDirect int blockInlines int costDeltaBlock boolean removable [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  checkModules  false  fnContainsVars  hasArgs  isCallInLoop  isRemovable  needsDefaultReturnResult  referencesThis  removable  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule fnModule  module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST  blockInlines  callCost  costDelta  costDeltaBlock  costDeltaDirect  directInlines  fnInstanceCount  overallCallCost  referenceCount  referencesUsingBlockInlining  referencesUsingDirectInlining  threshold 
[REPLACE]^return true;^764^^^^^750^774^[REPLACE] return false;^[METHOD] doesLowerCost [TYPE] boolean [PARAMETER] Node fnNode int callCost int directInlines int costDeltaDirect int blockInlines int costDeltaBlock boolean removable [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  checkModules  false  fnContainsVars  hasArgs  isCallInLoop  isRemovable  needsDefaultReturnResult  referencesThis  removable  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule fnModule  module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST  blockInlines  callCost  costDelta  costDeltaBlock  costDeltaDirect  directInlines  fnInstanceCount  overallCallCost  referenceCount  referencesUsingBlockInlining  referencesUsingDirectInlining  threshold 
[REPLACE]^return false;^766^^^^^750^774^[REPLACE] return true;^[METHOD] doesLowerCost [TYPE] boolean [PARAMETER] Node fnNode int callCost int directInlines int costDeltaDirect int blockInlines int costDeltaBlock boolean removable [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  checkModules  false  fnContainsVars  hasArgs  isCallInLoop  isRemovable  needsDefaultReturnResult  referencesThis  removable  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule fnModule  module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST  blockInlines  callCost  costDelta  costDeltaBlock  costDeltaDirect  directInlines  fnInstanceCount  overallCallCost  referenceCount  referencesUsingBlockInlining  referencesUsingDirectInlining  threshold 
[REPLACE]^if  ( overallCallCost > 0 || costDeltaBlock > 0 )  {^763^^^^^750^774^[REPLACE] if  ( blockInlines > 0 && costDeltaBlock > 0 )  {^[METHOD] doesLowerCost [TYPE] boolean [PARAMETER] Node fnNode int callCost int directInlines int costDeltaDirect int blockInlines int costDeltaBlock boolean removable [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  checkModules  false  fnContainsVars  hasArgs  isCallInLoop  isRemovable  needsDefaultReturnResult  referencesThis  removable  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule fnModule  module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST  blockInlines  callCost  costDelta  costDeltaBlock  costDeltaDirect  directInlines  fnInstanceCount  overallCallCost  referenceCount  referencesUsingBlockInlining  referencesUsingDirectInlining  threshold 
[ADD]^^769^770^^^^750^774^[ADD] int costDelta =  ( directInlines * costDeltaDirect )  + ( blockInlines * costDeltaBlock ) ;^[METHOD] doesLowerCost [TYPE] boolean [PARAMETER] Node fnNode int callCost int directInlines int costDeltaDirect int blockInlines int costDeltaBlock boolean removable [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  checkModules  false  fnContainsVars  hasArgs  isCallInLoop  isRemovable  needsDefaultReturnResult  referencesThis  removable  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule fnModule  module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST  blockInlines  callCost  costDelta  costDeltaBlock  costDeltaDirect  directInlines  fnInstanceCount  overallCallCost  referenceCount  referencesUsingBlockInlining  referencesUsingDirectInlining  threshold 
[REPLACE]^int threshold =  (costDeltaDirect )   threshold;^771^^^^^750^774^[REPLACE] int threshold =  ( callCost - costDelta )  / fnInstanceCount;^[METHOD] doesLowerCost [TYPE] boolean [PARAMETER] Node fnNode int callCost int directInlines int costDeltaDirect int blockInlines int costDeltaBlock boolean removable [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  checkModules  false  fnContainsVars  hasArgs  isCallInLoop  isRemovable  needsDefaultReturnResult  referencesThis  removable  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule fnModule  module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST  blockInlines  callCost  costDelta  costDeltaBlock  costDeltaDirect  directInlines  fnInstanceCount  overallCallCost  referenceCount  referencesUsingBlockInlining  referencesUsingDirectInlining  threshold 
[REPLACE]^return false ;^773^^^^^750^774^[REPLACE] return InlineCostEstimator.getCost ( fnNode, threshold + 1 )  <= threshold;^[METHOD] doesLowerCost [TYPE] boolean [PARAMETER] Node fnNode int callCost int directInlines int costDeltaDirect int blockInlines int costDeltaBlock boolean removable [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  checkModules  false  fnContainsVars  hasArgs  isCallInLoop  isRemovable  needsDefaultReturnResult  referencesThis  removable  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule fnModule  module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST  blockInlines  callCost  costDelta  costDeltaBlock  costDeltaDirect  directInlines  fnInstanceCount  overallCallCost  referenceCount  referencesUsingBlockInlining  referencesUsingDirectInlining  threshold 
[REPLACE]^Node block = getFunctionBody ( fnNode )  ;^782^^^^^781^799^[REPLACE] Node argsNode = NodeUtil.getFnParameters ( fnNode ) ;^[METHOD] estimateCallCost [TYPE] int [PARAMETER] Node fnNode boolean referencesThis [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  checkModules  false  fnContainsVars  hasArgs  isCallInLoop  isRemovable  needsDefaultReturnResult  referencesThis  removable  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node argsNode  block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule fnModule  module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST  blockInlines  callCost  costDelta  costDeltaBlock  costDeltaDirect  directInlines  fnInstanceCount  numArgs  overallCallCost  referenceCount  referencesUsingBlockInlining  referencesUsingDirectInlining  threshold 
[REPLACE]^int numArgs = newBlock.getChildCount (  ) ;^783^^^^^781^799^[REPLACE] int numArgs = argsNode.getChildCount (  ) ;^[METHOD] estimateCallCost [TYPE] int [PARAMETER] Node fnNode boolean referencesThis [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  checkModules  false  fnContainsVars  hasArgs  isCallInLoop  isRemovable  needsDefaultReturnResult  referencesThis  removable  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node argsNode  block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule fnModule  module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST  blockInlines  callCost  costDelta  costDeltaBlock  costDeltaDirect  directInlines  fnInstanceCount  numArgs  overallCallCost  referenceCount  referencesUsingBlockInlining  referencesUsingDirectInlining  threshold 
[REPLACE]^int costDeltaBlock = inlineCostDelta ( fnNode, namesToAlias, BLOCK )  ;^785^^^^^781^799^[REPLACE] int callCost = NAME_COST_ESTIMATE + PAREN_COST;^[METHOD] estimateCallCost [TYPE] int [PARAMETER] Node fnNode boolean referencesThis [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  checkModules  false  fnContainsVars  hasArgs  isCallInLoop  isRemovable  needsDefaultReturnResult  referencesThis  removable  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node argsNode  block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule fnModule  module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST  blockInlines  callCost  costDelta  costDeltaBlock  costDeltaDirect  directInlines  fnInstanceCount  numArgs  overallCallCost  referenceCount  referencesUsingBlockInlining  referencesUsingDirectInlining  threshold 
[REPLACE]^if  ( numArgs  <=  0 * 1 )  {^786^^^^^781^799^[REPLACE] if  ( numArgs > 0 )  {^[METHOD] estimateCallCost [TYPE] int [PARAMETER] Node fnNode boolean referencesThis [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  checkModules  false  fnContainsVars  hasArgs  isCallInLoop  isRemovable  needsDefaultReturnResult  referencesThis  removable  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node argsNode  block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule fnModule  module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST  blockInlines  callCost  costDelta  costDeltaBlock  costDeltaDirect  directInlines  fnInstanceCount  numArgs  overallCallCost  referenceCount  referencesUsingBlockInlining  referencesUsingDirectInlining  threshold 
[REPLACE]^callCost =  ( numArgs * NAME_COST_ESTIMATE )    (  ( numArgs - 1 )  * COMMA_COST ) ;^787^^^^^781^799^[REPLACE] callCost +=  ( numArgs * NAME_COST_ESTIMATE )  +  (  ( numArgs - 1 )  * COMMA_COST ) ;^[METHOD] estimateCallCost [TYPE] int [PARAMETER] Node fnNode boolean referencesThis [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  checkModules  false  fnContainsVars  hasArgs  isCallInLoop  isRemovable  needsDefaultReturnResult  referencesThis  removable  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node argsNode  block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule fnModule  module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST  blockInlines  callCost  costDelta  costDeltaBlock  costDeltaDirect  directInlines  fnInstanceCount  numArgs  overallCallCost  referenceCount  referencesUsingBlockInlining  referencesUsingDirectInlining  threshold 
[REPLACE]^callCost =  ( numArgs *referenceCount )    (  ( numArgs - 1 / 4 )  * COMMA_COST ) ;^787^^^^^781^799^[REPLACE] callCost +=  ( numArgs * NAME_COST_ESTIMATE )  +  (  ( numArgs - 1 )  * COMMA_COST ) ;^[METHOD] estimateCallCost [TYPE] int [PARAMETER] Node fnNode boolean referencesThis [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  checkModules  false  fnContainsVars  hasArgs  isCallInLoop  isRemovable  needsDefaultReturnResult  referencesThis  removable  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node argsNode  block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule fnModule  module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST  blockInlines  callCost  costDelta  costDeltaBlock  costDeltaDirect  directInlines  fnInstanceCount  numArgs  overallCallCost  referenceCount  referencesUsingBlockInlining  referencesUsingDirectInlining  threshold 
[REPLACE]^} else if   (  parent.getType  (    )   == Token.NAME && !NodeUtil.isConstantName  (  parent  )  ;^790^^^^^781^799^[REPLACE] if  ( referencesThis )  {^[METHOD] estimateCallCost [TYPE] int [PARAMETER] Node fnNode boolean referencesThis [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  checkModules  false  fnContainsVars  hasArgs  isCallInLoop  isRemovable  needsDefaultReturnResult  referencesThis  removable  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node argsNode  block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule fnModule  module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST  blockInlines  callCost  costDelta  costDeltaBlock  costDeltaDirect  directInlines  fnInstanceCount  numArgs  overallCallCost  referenceCount  referencesUsingBlockInlining  referencesUsingDirectInlining  threshold 
[ADD]^^790^791^^^^781^799^[ADD] if  ( referencesThis )  {^[METHOD] estimateCallCost [TYPE] int [PARAMETER] Node fnNode boolean referencesThis [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  checkModules  false  fnContainsVars  hasArgs  isCallInLoop  isRemovable  needsDefaultReturnResult  referencesThis  removable  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node argsNode  block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule fnModule  module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST  blockInlines  callCost  costDelta  costDeltaBlock  costDeltaDirect  directInlines  fnInstanceCount  numArgs  overallCallCost  referenceCount  referencesUsingBlockInlining  referencesUsingDirectInlining  threshold 
[REPLACE]^callCost = 5 % 4  5 % 4;^795^^^^^781^799^[REPLACE] callCost += 5 + 5;^[METHOD] estimateCallCost [TYPE] int [PARAMETER] Node fnNode boolean referencesThis [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  checkModules  false  fnContainsVars  hasArgs  isCallInLoop  isRemovable  needsDefaultReturnResult  referencesThis  removable  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node argsNode  block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule fnModule  module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST  blockInlines  callCost  costDelta  costDeltaBlock  costDeltaDirect  directInlines  fnInstanceCount  numArgs  overallCallCost  referenceCount  referencesUsingBlockInlining  referencesUsingDirectInlining  threshold 
[REPLACE]^callCost = 5L  5L;^795^^^^^781^799^[REPLACE] callCost += 5 + 5;^[METHOD] estimateCallCost [TYPE] int [PARAMETER] Node fnNode boolean referencesThis [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  checkModules  false  fnContainsVars  hasArgs  isCallInLoop  isRemovable  needsDefaultReturnResult  referencesThis  removable  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node argsNode  block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule fnModule  module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST  blockInlines  callCost  costDelta  costDeltaBlock  costDeltaDirect  directInlines  fnInstanceCount  numArgs  overallCallCost  referenceCount  referencesUsingBlockInlining  referencesUsingDirectInlining  threshold 
[REPLACE]^return overallCallCost;^798^^^^^781^799^[REPLACE] return callCost;^[METHOD] estimateCallCost [TYPE] int [PARAMETER] Node fnNode boolean referencesThis [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  checkModules  false  fnContainsVars  hasArgs  isCallInLoop  isRemovable  needsDefaultReturnResult  referencesThis  removable  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node argsNode  block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule fnModule  module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST  blockInlines  callCost  costDelta  costDeltaBlock  costDeltaDirect  directInlines  fnInstanceCount  numArgs  overallCallCost  referenceCount  referencesUsingBlockInlining  referencesUsingDirectInlining  threshold 
[REPLACE]^int paramCount = NodeUtil.getFnParameters ( thisValue ) .getChildCount (  ) ;^809^^^^^806^855^[REPLACE] int paramCount = NodeUtil.getFnParameters ( fnNode ) .getChildCount (  ) ;^[METHOD] inlineCostDelta [TYPE] int [PARAMETER] Node fnNode String> namesToAlias InliningMode mode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  checkModules  false  fnContainsVars  hasArgs  isCallInLoop  isRemovable  needsDefaultReturnResult  referencesThis  removable  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node argsNode  block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule fnModule  module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  INLINE_BLOCK_OVERHEAD  NAME_COST_ESTIMATE  PAREN_COST  PER_ALIAS_OVERHEAD  PER_RETURN_OVERHEAD  PER_RETURN_RESULT_OVERHEAD  aliasCount  baseOverhead  blockInlines  callCost  commaCount  costDelta  costDeltaBlock  costDeltaDirect  costDeltaFunctionOverhead  directInlines  fnInstanceCount  numArgs  overallCallCost  overhead  paramCount  referenceCount  referencesUsingBlockInlining  referencesUsingDirectInlining  resultCount  returnCount  threshold 
[REPLACE]^int commaCount  =  0;^810^^^^^806^855^[REPLACE] int commaCount =  ( paramCount > 1 )  ? paramCount - 1 : 0;^[METHOD] inlineCostDelta [TYPE] int [PARAMETER] Node fnNode String> namesToAlias InliningMode mode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  checkModules  false  fnContainsVars  hasArgs  isCallInLoop  isRemovable  needsDefaultReturnResult  referencesThis  removable  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node argsNode  block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule fnModule  module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  INLINE_BLOCK_OVERHEAD  NAME_COST_ESTIMATE  PAREN_COST  PER_ALIAS_OVERHEAD  PER_RETURN_OVERHEAD  PER_RETURN_RESULT_OVERHEAD  aliasCount  baseOverhead  blockInlines  callCost  commaCount  costDelta  costDeltaBlock  costDeltaDirect  costDeltaFunctionOverhead  directInlines  fnInstanceCount  numArgs  overallCallCost  overhead  paramCount  referenceCount  referencesUsingBlockInlining  referencesUsingDirectInlining  resultCount  returnCount  threshold 
[REPLACE]^int costDeltaFunctionOverhead = 15  commaCount  ( paramCount * InlineCostEstimator.ESTIMATED_IDENTIFIER_COST ) ;^811^812^^^^806^855^[REPLACE] int costDeltaFunctionOverhead = 15 + commaCount + ( paramCount * InlineCostEstimator.ESTIMATED_IDENTIFIER_COST ) ;^[METHOD] inlineCostDelta [TYPE] int [PARAMETER] Node fnNode String> namesToAlias InliningMode mode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  checkModules  false  fnContainsVars  hasArgs  isCallInLoop  isRemovable  needsDefaultReturnResult  referencesThis  removable  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node argsNode  block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule fnModule  module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  INLINE_BLOCK_OVERHEAD  NAME_COST_ESTIMATE  PAREN_COST  PER_ALIAS_OVERHEAD  PER_RETURN_OVERHEAD  PER_RETURN_RESULT_OVERHEAD  aliasCount  baseOverhead  blockInlines  callCost  commaCount  costDelta  costDeltaBlock  costDeltaDirect  costDeltaFunctionOverhead  directInlines  fnInstanceCount  numArgs  overallCallCost  overhead  paramCount  referenceCount  referencesUsingBlockInlining  referencesUsingDirectInlining  resultCount  returnCount  threshold 
[REPLACE]^Node callParentNode = callNode.getParent (  )  ;^814^^^^^806^855^[REPLACE] Node block = fnNode.getLastChild (  ) ;^[METHOD] inlineCostDelta [TYPE] int [PARAMETER] Node fnNode String> namesToAlias InliningMode mode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  checkModules  false  fnContainsVars  hasArgs  isCallInLoop  isRemovable  needsDefaultReturnResult  referencesThis  removable  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node argsNode  block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule fnModule  module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  INLINE_BLOCK_OVERHEAD  NAME_COST_ESTIMATE  PAREN_COST  PER_ALIAS_OVERHEAD  PER_RETURN_OVERHEAD  PER_RETURN_RESULT_OVERHEAD  aliasCount  baseOverhead  blockInlines  callCost  commaCount  costDelta  costDeltaBlock  costDeltaDirect  costDeltaFunctionOverhead  directInlines  fnInstanceCount  numArgs  overallCallCost  overhead  paramCount  referenceCount  referencesUsingBlockInlining  referencesUsingDirectInlining  resultCount  returnCount  threshold 
[REPLACE]^if  ( !block.newString (  )  )  {^815^^^^^806^855^[REPLACE] if  ( !block.hasChildren (  )  )  {^[METHOD] inlineCostDelta [TYPE] int [PARAMETER] Node fnNode String> namesToAlias InliningMode mode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  checkModules  false  fnContainsVars  hasArgs  isCallInLoop  isRemovable  needsDefaultReturnResult  referencesThis  removable  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node argsNode  block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule fnModule  module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  INLINE_BLOCK_OVERHEAD  NAME_COST_ESTIMATE  PAREN_COST  PER_ALIAS_OVERHEAD  PER_RETURN_OVERHEAD  PER_RETURN_RESULT_OVERHEAD  aliasCount  baseOverhead  blockInlines  callCost  commaCount  costDelta  costDeltaBlock  costDeltaDirect  costDeltaFunctionOverhead  directInlines  fnInstanceCount  numArgs  overallCallCost  overhead  paramCount  referenceCount  referencesUsingBlockInlining  referencesUsingDirectInlining  resultCount  returnCount  threshold 
[REPLACE]^return -  (  costDeltaFunctionOverhead + 7  )  ;  ;^817^^^^^806^855^[REPLACE] return -costDeltaFunctionOverhead;^[METHOD] inlineCostDelta [TYPE] int [PARAMETER] Node fnNode String> namesToAlias InliningMode mode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  checkModules  false  fnContainsVars  hasArgs  isCallInLoop  isRemovable  needsDefaultReturnResult  referencesThis  removable  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node argsNode  block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule fnModule  module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  INLINE_BLOCK_OVERHEAD  NAME_COST_ESTIMATE  PAREN_COST  PER_ALIAS_OVERHEAD  PER_RETURN_OVERHEAD  PER_RETURN_RESULT_OVERHEAD  aliasCount  baseOverhead  blockInlines  callCost  commaCount  costDelta  costDeltaBlock  costDeltaDirect  costDeltaFunctionOverhead  directInlines  fnInstanceCount  numArgs  overallCallCost  overhead  paramCount  referenceCount  referencesUsingBlockInlining  referencesUsingDirectInlining  resultCount  returnCount  threshold 
[REPLACE]^if  ( BLOCK  ||  InliningMode.DIRECT )  {^820^^^^^806^855^[REPLACE] if  ( mode == InliningMode.DIRECT )  {^[METHOD] inlineCostDelta [TYPE] int [PARAMETER] Node fnNode String> namesToAlias InliningMode mode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  checkModules  false  fnContainsVars  hasArgs  isCallInLoop  isRemovable  needsDefaultReturnResult  referencesThis  removable  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node argsNode  block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule fnModule  module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  INLINE_BLOCK_OVERHEAD  NAME_COST_ESTIMATE  PAREN_COST  PER_ALIAS_OVERHEAD  PER_RETURN_OVERHEAD  PER_RETURN_RESULT_OVERHEAD  aliasCount  baseOverhead  blockInlines  callCost  commaCount  costDelta  costDeltaBlock  costDeltaDirect  costDeltaFunctionOverhead  directInlines  fnInstanceCount  numArgs  overallCallCost  overhead  paramCount  referenceCount  referencesUsingBlockInlining  referencesUsingDirectInlining  resultCount  returnCount  threshold 
[REPLACE]^return  ( overhead  costDeltaFunctionOverhead ) ;^853^^^^^820^854^[REPLACE] return  ( overhead - costDeltaFunctionOverhead ) ;^[METHOD] inlineCostDelta [TYPE] int [PARAMETER] Node fnNode String> namesToAlias InliningMode mode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  checkModules  false  fnContainsVars  hasArgs  isCallInLoop  isRemovable  needsDefaultReturnResult  referencesThis  removable  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node argsNode  block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule fnModule  module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  INLINE_BLOCK_OVERHEAD  NAME_COST_ESTIMATE  PAREN_COST  PER_ALIAS_OVERHEAD  PER_RETURN_OVERHEAD  PER_RETURN_RESULT_OVERHEAD  aliasCount  baseOverhead  blockInlines  callCost  commaCount  costDelta  costDeltaBlock  costDeltaDirect  costDeltaFunctionOverhead  directInlines  fnInstanceCount  numArgs  overallCallCost  overhead  paramCount  referenceCount  referencesUsingBlockInlining  referencesUsingDirectInlining  resultCount  returnCount  threshold 
[REPLACE]^int aliasCount = this.size (  ) ;^825^^^^^820^854^[REPLACE] int aliasCount = namesToAlias.size (  ) ;^[METHOD] inlineCostDelta [TYPE] int [PARAMETER] Node fnNode String> namesToAlias InliningMode mode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  checkModules  false  fnContainsVars  hasArgs  isCallInLoop  isRemovable  needsDefaultReturnResult  referencesThis  removable  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node argsNode  block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule fnModule  module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  INLINE_BLOCK_OVERHEAD  NAME_COST_ESTIMATE  PAREN_COST  PER_ALIAS_OVERHEAD  PER_RETURN_OVERHEAD  PER_RETURN_RESULT_OVERHEAD  aliasCount  baseOverhead  blockInlines  callCost  commaCount  costDelta  costDeltaBlock  costDeltaDirect  costDeltaFunctionOverhead  directInlines  fnInstanceCount  numArgs  overallCallCost  overhead  paramCount  referenceCount  referencesUsingBlockInlining  referencesUsingDirectInlining  resultCount  returnCount  threshold 
[REPLACE]^final int INLINE_BLOCK_OVERHEAD = 0;^836^^^^^820^854^[REPLACE] final int INLINE_BLOCK_OVERHEAD = 4;^[METHOD] inlineCostDelta [TYPE] int [PARAMETER] Node fnNode String> namesToAlias InliningMode mode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  checkModules  false  fnContainsVars  hasArgs  isCallInLoop  isRemovable  needsDefaultReturnResult  referencesThis  removable  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node argsNode  block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule fnModule  module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  INLINE_BLOCK_OVERHEAD  NAME_COST_ESTIMATE  PAREN_COST  PER_ALIAS_OVERHEAD  PER_RETURN_OVERHEAD  PER_RETURN_RESULT_OVERHEAD  aliasCount  baseOverhead  blockInlines  callCost  commaCount  costDelta  costDeltaBlock  costDeltaDirect  costDeltaFunctionOverhead  directInlines  fnInstanceCount  numArgs  overallCallCost  overhead  paramCount  referenceCount  referencesUsingBlockInlining  referencesUsingDirectInlining  resultCount  returnCount  threshold 
[REPLACE]^final int PER_RETURN_OVERHEAD = 4;^837^^^^^820^854^[REPLACE] final int PER_RETURN_OVERHEAD = 2;^[METHOD] inlineCostDelta [TYPE] int [PARAMETER] Node fnNode String> namesToAlias InliningMode mode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  checkModules  false  fnContainsVars  hasArgs  isCallInLoop  isRemovable  needsDefaultReturnResult  referencesThis  removable  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node argsNode  block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule fnModule  module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  INLINE_BLOCK_OVERHEAD  NAME_COST_ESTIMATE  PAREN_COST  PER_ALIAS_OVERHEAD  PER_RETURN_OVERHEAD  PER_RETURN_RESULT_OVERHEAD  aliasCount  baseOverhead  blockInlines  callCost  commaCount  costDelta  costDeltaBlock  costDeltaDirect  costDeltaFunctionOverhead  directInlines  fnInstanceCount  numArgs  overallCallCost  overhead  paramCount  referenceCount  referencesUsingBlockInlining  referencesUsingDirectInlining  resultCount  returnCount  threshold 
[ADD]^^838^839^^^^820^854^[ADD] final int PER_RETURN_RESULT_OVERHEAD = 3; final int PER_ALIAS_OVERHEAD = 3;^[METHOD] inlineCostDelta [TYPE] int [PARAMETER] Node fnNode String> namesToAlias InliningMode mode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  checkModules  false  fnContainsVars  hasArgs  isCallInLoop  isRemovable  needsDefaultReturnResult  referencesThis  removable  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node argsNode  block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule fnModule  module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  INLINE_BLOCK_OVERHEAD  NAME_COST_ESTIMATE  PAREN_COST  PER_ALIAS_OVERHEAD  PER_RETURN_OVERHEAD  PER_RETURN_RESULT_OVERHEAD  aliasCount  baseOverhead  blockInlines  callCost  commaCount  costDelta  costDeltaBlock  costDeltaDirect  costDeltaFunctionOverhead  directInlines  fnInstanceCount  numArgs  overallCallCost  overhead  paramCount  referenceCount  referencesUsingBlockInlining  referencesUsingDirectInlining  resultCount  returnCount  threshold 
[REPLACE]^final int INLINE_BLOCK_OVERHEAD = 4  ;^839^^^^^820^854^[REPLACE] final int PER_ALIAS_OVERHEAD = 3;^[METHOD] inlineCostDelta [TYPE] int [PARAMETER] Node fnNode String> namesToAlias InliningMode mode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  checkModules  false  fnContainsVars  hasArgs  isCallInLoop  isRemovable  needsDefaultReturnResult  referencesThis  removable  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node argsNode  block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule fnModule  module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  INLINE_BLOCK_OVERHEAD  NAME_COST_ESTIMATE  PAREN_COST  PER_ALIAS_OVERHEAD  PER_RETURN_OVERHEAD  PER_RETURN_RESULT_OVERHEAD  aliasCount  baseOverhead  blockInlines  callCost  commaCount  costDelta  costDeltaBlock  costDeltaDirect  costDeltaFunctionOverhead  directInlines  fnInstanceCount  numArgs  overallCallCost  overhead  paramCount  referenceCount  referencesUsingBlockInlining  referencesUsingDirectInlining  resultCount  returnCount  threshold 
[REPLACE]^int returnCount = NodeUtil.getNodeTypeReferenceCount ( safeReturnNode, Token.RETURN ) ;^844^^^^^820^854^[REPLACE] int returnCount = NodeUtil.getNodeTypeReferenceCount ( block, Token.RETURN ) ;^[METHOD] inlineCostDelta [TYPE] int [PARAMETER] Node fnNode String> namesToAlias InliningMode mode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  checkModules  false  fnContainsVars  hasArgs  isCallInLoop  isRemovable  needsDefaultReturnResult  referencesThis  removable  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node argsNode  block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule fnModule  module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  INLINE_BLOCK_OVERHEAD  NAME_COST_ESTIMATE  PAREN_COST  PER_ALIAS_OVERHEAD  PER_RETURN_OVERHEAD  PER_RETURN_RESULT_OVERHEAD  aliasCount  baseOverhead  blockInlines  callCost  commaCount  costDelta  costDeltaBlock  costDeltaDirect  costDeltaFunctionOverhead  directInlines  fnInstanceCount  numArgs  overallCallCost  overhead  paramCount  referenceCount  referencesUsingBlockInlining  referencesUsingDirectInlining  resultCount  returnCount  threshold 
[ADD]^^845^^^^^820^854^[ADD] int resultCount =  ( returnCount > 0 )  ? returnCount - 1 : 0;^[METHOD] inlineCostDelta [TYPE] int [PARAMETER] Node fnNode String> namesToAlias InliningMode mode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  checkModules  false  fnContainsVars  hasArgs  isCallInLoop  isRemovable  needsDefaultReturnResult  referencesThis  removable  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node argsNode  block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule fnModule  module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  INLINE_BLOCK_OVERHEAD  NAME_COST_ESTIMATE  PAREN_COST  PER_ALIAS_OVERHEAD  PER_RETURN_OVERHEAD  PER_RETURN_RESULT_OVERHEAD  aliasCount  baseOverhead  blockInlines  callCost  commaCount  costDelta  costDeltaBlock  costDeltaDirect  costDeltaFunctionOverhead  directInlines  fnInstanceCount  numArgs  overallCallCost  overhead  paramCount  referenceCount  referencesUsingBlockInlining  referencesUsingDirectInlining  resultCount  returnCount  threshold 
[REPLACE]^int baseOverhead  =  INLINE_BLOCK_OVERHEAD ;^846^^^^^820^854^[REPLACE] int baseOverhead =  ( returnCount > 0 )  ? INLINE_BLOCK_OVERHEAD : 0;^[METHOD] inlineCostDelta [TYPE] int [PARAMETER] Node fnNode String> namesToAlias InliningMode mode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  checkModules  false  fnContainsVars  hasArgs  isCallInLoop  isRemovable  needsDefaultReturnResult  referencesThis  removable  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node argsNode  block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule fnModule  module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  INLINE_BLOCK_OVERHEAD  NAME_COST_ESTIMATE  PAREN_COST  PER_ALIAS_OVERHEAD  PER_RETURN_OVERHEAD  PER_RETURN_RESULT_OVERHEAD  aliasCount  baseOverhead  blockInlines  callCost  commaCount  costDelta  costDeltaBlock  costDeltaDirect  costDeltaFunctionOverhead  directInlines  fnInstanceCount  numArgs  overallCallCost  overhead  paramCount  referenceCount  referencesUsingBlockInlining  referencesUsingDirectInlining  resultCount  returnCount  threshold 
[ADD]^^848^849^850^^^820^854^[ADD] int overhead = baseOverhead + returnCount * PER_RETURN_OVERHEAD + resultCount * PER_RETURN_RESULT_OVERHEAD^[METHOD] inlineCostDelta [TYPE] int [PARAMETER] Node fnNode String> namesToAlias InliningMode mode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  checkModules  false  fnContainsVars  hasArgs  isCallInLoop  isRemovable  needsDefaultReturnResult  referencesThis  removable  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node argsNode  block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule fnModule  module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  INLINE_BLOCK_OVERHEAD  NAME_COST_ESTIMATE  PAREN_COST  PER_ALIAS_OVERHEAD  PER_RETURN_OVERHEAD  PER_RETURN_RESULT_OVERHEAD  aliasCount  baseOverhead  blockInlines  callCost  commaCount  costDelta  costDeltaBlock  costDeltaDirect  costDeltaFunctionOverhead  directInlines  fnInstanceCount  numArgs  overallCallCost  overhead  paramCount  referenceCount  referencesUsingBlockInlining  referencesUsingDirectInlining  resultCount  returnCount  threshold 
[REPLACE]^return -  (  costDeltaFunctionOverhead + 7  )  ;  ;^823^^^^^806^855^[REPLACE] return - ( costDeltaFunctionOverhead + 7 ) ;^[METHOD] inlineCostDelta [TYPE] int [PARAMETER] Node fnNode String> namesToAlias InliningMode mode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  checkModules  false  fnContainsVars  hasArgs  isCallInLoop  isRemovable  needsDefaultReturnResult  referencesThis  removable  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node argsNode  block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule fnModule  module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  INLINE_BLOCK_OVERHEAD  NAME_COST_ESTIMATE  PAREN_COST  PER_ALIAS_OVERHEAD  PER_RETURN_OVERHEAD  PER_RETURN_RESULT_OVERHEAD  aliasCount  baseOverhead  blockInlines  callCost  commaCount  costDelta  costDeltaBlock  costDeltaDirect  costDeltaFunctionOverhead  directInlines  fnInstanceCount  numArgs  overallCallCost  overhead  paramCount  referenceCount  referencesUsingBlockInlining  referencesUsingDirectInlining  resultCount  returnCount  threshold 
[REPLACE]^return - (threshold  7 ) ;^823^^^^^806^855^[REPLACE] return - ( costDeltaFunctionOverhead + 7 ) ;^[METHOD] inlineCostDelta [TYPE] int [PARAMETER] Node fnNode String> namesToAlias InliningMode mode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  checkModules  false  fnContainsVars  hasArgs  isCallInLoop  isRemovable  needsDefaultReturnResult  referencesThis  removable  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node argsNode  block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule fnModule  module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  INLINE_BLOCK_OVERHEAD  NAME_COST_ESTIMATE  PAREN_COST  PER_ALIAS_OVERHEAD  PER_RETURN_OVERHEAD  PER_RETURN_RESULT_OVERHEAD  aliasCount  baseOverhead  blockInlines  callCost  commaCount  costDelta  costDeltaBlock  costDeltaDirect  costDeltaFunctionOverhead  directInlines  fnInstanceCount  numArgs  overallCallCost  overhead  paramCount  referenceCount  referencesUsingBlockInlining  referencesUsingDirectInlining  resultCount  returnCount  threshold 
[REPLACE]^return  ( overhead  overallCallCost ) ;^853^^^^^806^855^[REPLACE] return  ( overhead - costDeltaFunctionOverhead ) ;^[METHOD] inlineCostDelta [TYPE] int [PARAMETER] Node fnNode String> namesToAlias InliningMode mode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  checkModules  false  fnContainsVars  hasArgs  isCallInLoop  isRemovable  needsDefaultReturnResult  referencesThis  removable  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node argsNode  block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule fnModule  module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  INLINE_BLOCK_OVERHEAD  NAME_COST_ESTIMATE  PAREN_COST  PER_ALIAS_OVERHEAD  PER_RETURN_OVERHEAD  PER_RETURN_RESULT_OVERHEAD  aliasCount  baseOverhead  blockInlines  callCost  commaCount  costDelta  costDeltaBlock  costDeltaDirect  costDeltaFunctionOverhead  directInlines  fnInstanceCount  numArgs  overallCallCost  overhead  paramCount  referenceCount  referencesUsingBlockInlining  referencesUsingDirectInlining  resultCount  returnCount  threshold 
[REPLACE]^int aliasCount = null.size (  ) ;^825^^^^^806^855^[REPLACE] int aliasCount = namesToAlias.size (  ) ;^[METHOD] inlineCostDelta [TYPE] int [PARAMETER] Node fnNode String> namesToAlias InliningMode mode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  checkModules  false  fnContainsVars  hasArgs  isCallInLoop  isRemovable  needsDefaultReturnResult  referencesThis  removable  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node argsNode  block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule fnModule  module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  INLINE_BLOCK_OVERHEAD  NAME_COST_ESTIMATE  PAREN_COST  PER_ALIAS_OVERHEAD  PER_RETURN_OVERHEAD  PER_RETURN_RESULT_OVERHEAD  aliasCount  baseOverhead  blockInlines  callCost  commaCount  costDelta  costDeltaBlock  costDeltaDirect  costDeltaFunctionOverhead  directInlines  fnInstanceCount  numArgs  overallCallCost  overhead  paramCount  referenceCount  referencesUsingBlockInlining  referencesUsingDirectInlining  resultCount  returnCount  threshold 
[REPLACE]^final int PER_ALIAS_OVERHEAD = 3  ;^836^^^^^806^855^[REPLACE] final int INLINE_BLOCK_OVERHEAD = 4;^[METHOD] inlineCostDelta [TYPE] int [PARAMETER] Node fnNode String> namesToAlias InliningMode mode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  checkModules  false  fnContainsVars  hasArgs  isCallInLoop  isRemovable  needsDefaultReturnResult  referencesThis  removable  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node argsNode  block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule fnModule  module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  INLINE_BLOCK_OVERHEAD  NAME_COST_ESTIMATE  PAREN_COST  PER_ALIAS_OVERHEAD  PER_RETURN_OVERHEAD  PER_RETURN_RESULT_OVERHEAD  aliasCount  baseOverhead  blockInlines  callCost  commaCount  costDelta  costDeltaBlock  costDeltaDirect  costDeltaFunctionOverhead  directInlines  fnInstanceCount  numArgs  overallCallCost  overhead  paramCount  referenceCount  referencesUsingBlockInlining  referencesUsingDirectInlining  resultCount  returnCount  threshold 
[REPLACE]^final int PER_ALIAS_OVERHEAD = 3  ;^837^^^^^806^855^[REPLACE] final int PER_RETURN_OVERHEAD = 2;^[METHOD] inlineCostDelta [TYPE] int [PARAMETER] Node fnNode String> namesToAlias InliningMode mode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  checkModules  false  fnContainsVars  hasArgs  isCallInLoop  isRemovable  needsDefaultReturnResult  referencesThis  removable  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node argsNode  block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule fnModule  module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  INLINE_BLOCK_OVERHEAD  NAME_COST_ESTIMATE  PAREN_COST  PER_ALIAS_OVERHEAD  PER_RETURN_OVERHEAD  PER_RETURN_RESULT_OVERHEAD  aliasCount  baseOverhead  blockInlines  callCost  commaCount  costDelta  costDeltaBlock  costDeltaDirect  costDeltaFunctionOverhead  directInlines  fnInstanceCount  numArgs  overallCallCost  overhead  paramCount  referenceCount  referencesUsingBlockInlining  referencesUsingDirectInlining  resultCount  returnCount  threshold 
[REPLACE]^final int PER_ALIAS_OVERHEAD = 3  ;^838^^^^^806^855^[REPLACE] final int PER_RETURN_RESULT_OVERHEAD = 3;^[METHOD] inlineCostDelta [TYPE] int [PARAMETER] Node fnNode String> namesToAlias InliningMode mode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  checkModules  false  fnContainsVars  hasArgs  isCallInLoop  isRemovable  needsDefaultReturnResult  referencesThis  removable  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node argsNode  block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule fnModule  module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  INLINE_BLOCK_OVERHEAD  NAME_COST_ESTIMATE  PAREN_COST  PER_ALIAS_OVERHEAD  PER_RETURN_OVERHEAD  PER_RETURN_RESULT_OVERHEAD  aliasCount  baseOverhead  blockInlines  callCost  commaCount  costDelta  costDeltaBlock  costDeltaDirect  costDeltaFunctionOverhead  directInlines  fnInstanceCount  numArgs  overallCallCost  overhead  paramCount  referenceCount  referencesUsingBlockInlining  referencesUsingDirectInlining  resultCount  returnCount  threshold 
[REPLACE]^final int INLINE_BLOCK_OVERHEAD = 4  ;^839^^^^^806^855^[REPLACE] final int PER_ALIAS_OVERHEAD = 3;^[METHOD] inlineCostDelta [TYPE] int [PARAMETER] Node fnNode String> namesToAlias InliningMode mode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  checkModules  false  fnContainsVars  hasArgs  isCallInLoop  isRemovable  needsDefaultReturnResult  referencesThis  removable  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node argsNode  block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule fnModule  module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  INLINE_BLOCK_OVERHEAD  NAME_COST_ESTIMATE  PAREN_COST  PER_ALIAS_OVERHEAD  PER_RETURN_OVERHEAD  PER_RETURN_RESULT_OVERHEAD  aliasCount  baseOverhead  blockInlines  callCost  commaCount  costDelta  costDeltaBlock  costDeltaDirect  costDeltaFunctionOverhead  directInlines  fnInstanceCount  numArgs  overallCallCost  overhead  paramCount  referenceCount  referencesUsingBlockInlining  referencesUsingDirectInlining  resultCount  returnCount  threshold 
[REPLACE]^int returnCount = NodeUtil.getNodeTypeReferenceCount ( safeReturnNode, Token.RETURN ) ;^844^^^^^806^855^[REPLACE] int returnCount = NodeUtil.getNodeTypeReferenceCount ( block, Token.RETURN ) ;^[METHOD] inlineCostDelta [TYPE] int [PARAMETER] Node fnNode String> namesToAlias InliningMode mode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  checkModules  false  fnContainsVars  hasArgs  isCallInLoop  isRemovable  needsDefaultReturnResult  referencesThis  removable  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node argsNode  block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule fnModule  module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  INLINE_BLOCK_OVERHEAD  NAME_COST_ESTIMATE  PAREN_COST  PER_ALIAS_OVERHEAD  PER_RETURN_OVERHEAD  PER_RETURN_RESULT_OVERHEAD  aliasCount  baseOverhead  blockInlines  callCost  commaCount  costDelta  costDeltaBlock  costDeltaDirect  costDeltaFunctionOverhead  directInlines  fnInstanceCount  numArgs  overallCallCost  overhead  paramCount  referenceCount  referencesUsingBlockInlining  referencesUsingDirectInlining  resultCount  returnCount  threshold 
[REPLACE]^int resultCount  = threshold - 1 ;^845^^^^^806^855^[REPLACE] int resultCount =  ( returnCount > 0 )  ? returnCount - 1 : 0;^[METHOD] inlineCostDelta [TYPE] int [PARAMETER] Node fnNode String> namesToAlias InliningMode mode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  checkModules  false  fnContainsVars  hasArgs  isCallInLoop  isRemovable  needsDefaultReturnResult  referencesThis  removable  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node argsNode  block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule fnModule  module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  INLINE_BLOCK_OVERHEAD  NAME_COST_ESTIMATE  PAREN_COST  PER_ALIAS_OVERHEAD  PER_RETURN_OVERHEAD  PER_RETURN_RESULT_OVERHEAD  aliasCount  baseOverhead  blockInlines  callCost  commaCount  costDelta  costDeltaBlock  costDeltaDirect  costDeltaFunctionOverhead  directInlines  fnInstanceCount  numArgs  overallCallCost  overhead  paramCount  referenceCount  referencesUsingBlockInlining  referencesUsingDirectInlining  resultCount  returnCount  threshold 
[REPLACE]^int baseOverhead  =  INLINE_BLOCK_OVERHEAD ;^846^^^^^806^855^[REPLACE] int baseOverhead =  ( returnCount > 0 )  ? INLINE_BLOCK_OVERHEAD : 0;^[METHOD] inlineCostDelta [TYPE] int [PARAMETER] Node fnNode String> namesToAlias InliningMode mode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  checkModules  false  fnContainsVars  hasArgs  isCallInLoop  isRemovable  needsDefaultReturnResult  referencesThis  removable  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node argsNode  block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule fnModule  module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  INLINE_BLOCK_OVERHEAD  NAME_COST_ESTIMATE  PAREN_COST  PER_ALIAS_OVERHEAD  PER_RETURN_OVERHEAD  PER_RETURN_RESULT_OVERHEAD  aliasCount  baseOverhead  blockInlines  callCost  commaCount  costDelta  costDeltaBlock  costDeltaDirect  costDeltaFunctionOverhead  directInlines  fnInstanceCount  numArgs  overallCallCost  overhead  paramCount  referenceCount  referencesUsingBlockInlining  referencesUsingDirectInlining  resultCount  returnCount  threshold 
[REPLACE]^int overhead = baseOverhead  returnCount * PER_RETURN_OVERHEAD  resultCount * PER_RETURN_RESULT_OVERHEAD  aliasCount * PER_ALIAS_OVERHEAD;^848^849^850^851^^806^855^[REPLACE] int overhead = baseOverhead + returnCount * PER_RETURN_OVERHEAD + resultCount * PER_RETURN_RESULT_OVERHEAD + aliasCount * PER_ALIAS_OVERHEAD;^[METHOD] inlineCostDelta [TYPE] int [PARAMETER] Node fnNode String> namesToAlias InliningMode mode [CLASS] FunctionInjector InliningMode Reference CallSiteType CanInlineResult   [TYPE]  CanInlineResult AFTER_DECOMPOSITION  NO  YES  [TYPE]  AbstractCompiler compiler  [TYPE]  boolean allowDecomposition  callerContainsFunction  checkModules  false  fnContainsVars  hasArgs  isCallInLoop  isRemovable  needsDefaultReturnResult  referencesThis  removable  true  [TYPE]  Set allNamesToAlias  knownConstants  namesToAlias  needAliases  [TYPE]  InliningMode BLOCK  DIRECT  mode  [TYPE]  CallSiteType DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  callSiteType  [TYPE]  Node argsNode  block  cArg  callNode  callParentNode  expressionRoot  fnCaller  fnCallerBody  fnNode  fnParam  grandParent  greatGrandParent  injectionPoint  injectionPointParent  inlineResult  newBlock  newExpression  parent  returnNode  safeReturnNode  thisValue  [TYPE]  JSModule fnModule  module  [TYPE]  Supplier safeNameIdSupplier  [TYPE]  int COMMA_COST  INLINE_BLOCK_OVERHEAD  NAME_COST_ESTIMATE  PAREN_COST  PER_ALIAS_OVERHEAD  PER_RETURN_OVERHEAD  PER_RETURN_RESULT_OVERHEAD  aliasCount  baseOverhead  blockInlines  callCost  commaCount  costDelta  costDeltaBlock  costDeltaDirect  costDeltaFunctionOverhead  directInlines  fnInstanceCount  numArgs  overallCallCost  overhead  paramCount  referenceCount  referencesUsingBlockInlining  referencesUsingDirectInlining  resultCount  returnCount  threshold 
[REPLACE]^Node callNode;^76^^^^^^^[REPLACE] final Node callNode;^[METHOD] <init> [TYPE] FunctionInjector$InliningMode() [PARAMETER] [CLASS] Reference   [TYPE]  InliningMode BLOCK  DIRECT  [TYPE]  boolean false  true 
[REPLACE]^InliningMode mode;^78^^^^^^^[REPLACE] final InliningMode mode;^[METHOD] <init> [TYPE] FunctionInjector$InliningMode() [PARAMETER] [CLASS] Reference   [TYPE]  InliningMode BLOCK  DIRECT  [TYPE]  boolean false  true 
