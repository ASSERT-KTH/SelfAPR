InputStream  inStream  =  new  FileInputStream  (  in  )  ;	[BUGGY]  InputStream  inStream  =  new  BufferedInputStream(  conn.getInputStream(  ));InputStream  inStream  =  new  FileInputStream(  in);  [CONTEXT]        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      File  in  String  charsetName  [VARIABLES]  boolean    InputStream    inStream    String    charsetName    data    File    in    
String  data  =  readInputStream  (  inStream,  charsetName  )  ;	[BUGGY]  char  data  =  readInputStream(  inStream,  charsetName);  [CONTEXT]  static  String  load(File  in,  String  charsetName)  throws  IOException  {  InputStream  inStream  =  new  FileInputStream(in);  [BUGGY]  char  data  =  readInputStream  (  inStream,  charsetName  )  ;  inStream.close();  return  data;  }        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      File  in  String  charsetName  [VARIABLES]  boolean    InputStream    inStream    String    charsetName    data    File    in    
String  data  =  readInputStream  (  inStream,  charsetName  )  ;	[BUGGY]  String  data  =  readInputStream(  charsetName,  inStream);  [CONTEXT]  static  String  load(File  in,  String  charsetName)  throws  IOException  {  InputStream  inStream  =  new  FileInputStream(in);  [BUGGY]  String  data  =  readInputStream  (  charsetName,  inStream  )  ;  inStream.close();  return  data;  }        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      File  in  String  charsetName  [VARIABLES]  boolean    InputStream    inStream    String    charsetName    data    File    in    
String  data  =  readInputStream  (  inStream,  charsetName  )  ;	[BUGGY]  String  data  =  readInputStream(    charsetName);  [CONTEXT]  static  String  load(File  in,  String  charsetName)  throws  IOException  {  InputStream  inStream  =  new  FileInputStream(in);  [BUGGY]  String  data  =  readInputStream  (charsetName  )  ;  inStream.close();  return  data;  }        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      File  in  String  charsetName  [VARIABLES]  boolean    InputStream    inStream    String    charsetName    data    File    in    
String  data  =  readInputStream  (  inStream,  charsetName  )  ;	[BUGGY]  String  data  =  readInputStream(  inStream);  [CONTEXT]  static  String  load(File  in,  String  charsetName)  throws  IOException  {  InputStream  inStream  =  new  FileInputStream(in);  [BUGGY]  String  data  =  readInputStream  (  inStream  )  ;  inStream.close();  return  data;  }        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      File  in  String  charsetName  [VARIABLES]  boolean    InputStream    inStream    String    charsetName    data    File    in    
String  data  =  readInputStream  (  inStream,  charsetName  )  ;	[BUGGY]  String  data  =  load(  inStream,  charsetName);  [CONTEXT]  static  String  load(File  in,  String  charsetName)  throws  IOException  {  InputStream  inStream  =  new  FileInputStream(in);  [BUGGY]  String  data  =  load  (  inStream,  charsetName  )  ;  inStream.close();  return  data;  }        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      File  in  String  charsetName  [VARIABLES]  boolean    InputStream    inStream    String    charsetName    data    File    in    
String  data  =  readInputStream  (  inStream,  charsetName  )  ;	[BUGGY]  Reader  inReader  =  new  InputStreamReader(  inStream,  charsetName);String  data  =  readInputStream(  inStream,  charsetName);  [CONTEXT]        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      File  in  String  charsetName  [VARIABLES]  boolean    InputStream    inStream    String    charsetName    data    File    in    
String  data  =  readInputStream  (  inStream,  charsetName  )  ;	[BUGGY]  String  data  =  readInputStream(  inStream,  charSet);String  data  =  readInputStream(  inStream,  charsetName);  [CONTEXT]        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      File  in  String  charsetName  [VARIABLES]  boolean    InputStream    inStream    String    charsetName    data    File    in    
String  data  =  readInputStream  (  inStream,  charsetName  )  ;	[BUGGY]  String  data  =  readInputStream(  inStream,  data);  [CONTEXT]  static  String  load(File  in,  String  charsetName)  throws  IOException  {  InputStream  inStream  =  new  FileInputStream(in);  [BUGGY]  String  data  =  readInputStream  (  inStream,  data  )  ;  inStream.close();  return  data;  }        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      File  in  String  charsetName  [VARIABLES]  boolean    InputStream    inStream    String    charsetName    data    File    in    
String  data  =  readInputStream  (  inStream,  charsetName  )  ;	[BUGGY]  String  data  =  load(  inStream,  data);  [CONTEXT]  static  String  load(File  in,  String  charsetName)  throws  IOException  {  InputStream  inStream  =  new  FileInputStream(in);  [BUGGY]  String  data  =  load  (  inStream,  data  )  ;  inStream.close();  return  data;  }        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      File  in  String  charsetName  [VARIABLES]  boolean    InputStream    inStream    String    charsetName    data    File    in    
String  data  =  readInputStream  (  inStream,  charsetName  )  ;  inStream.close  (  )  ;	[BUGGY]    [CONTEXT]  static  String  load(File  in,  String  charsetName)  throws  IOException  {  InputStream  inStream  =  new  FileInputStream(in);  [BUGGY]  String  data  =  readInputStream(inStream,  charsetName);      return  data;        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      File  in  String  charsetName  [VARIABLES]  boolean    InputStream    inStream    String    charsetName    data    File    in    
inStream.close  (  )  ;  return  data;	[BUGGY]    [CONTEXT]  static  String  load(File  in,  String  charsetName)  throws  IOException  {  InputStream  inStream  =  new  FileInputStream(in);  String  data  =  readInputStream(inStream,  charsetName);  [BUGGY]  inStream.close();            [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      File  in  String  charsetName  [VARIABLES]  boolean    InputStream    inStream    String    charsetName    data    File    in    
return  data;	[BUGGY]  return  charsetName;  [CONTEXT]  static  String  load(File  in,  String  charsetName)  throws  IOException  {  InputStream  inStream  =  new  FileInputStream(in);  String  data  =  readInputStream(inStream,  charsetName);  inStream.close();  [BUGGY]  return  charsetName;  }        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      File  in  String  charsetName  [VARIABLES]  boolean    InputStream    inStream    String    charsetName    data    File    in    
String  protocol  =  url.getProtocol  (  )  ;	[BUGGY]  char  protocol  =  url.getProtocol(  );  [CONTEXT]  static  String  load(URL  url,  int  timeoutMillis)  throws  IOException  {  [BUGGY]  char  protocol  =  url.getProtocol  ()  ;  Validate.isTrue(protocol.equals( "http ")  ||  protocol.equals( "https "),   "Only  http  &  https  protocols  supported ");    HttpURLConnection  conn  =  (HttpURLConnection)  url.openConnection();  conn.setInstanceFollowRedirects(true);  conn.setConnectTimeout(timeoutMillis);  conn.setReadTimeout(timeoutMillis);  conn.connect();    int  res  =  conn.getResponseCode();  if  (res  !=  HttpURLConnection.HTTP_OK)  throw  new  IOException(res  +   "  error  loading  URL   "  +  url.toString());    String  contentType  =  conn.getContentType();  if  (contentType  ==  null  ||  !contentType.startsWith( "text/ "))  throw  new  IOException(String.format( "Unhandled  content  type  \ "%s\ "  on  URL  %s.  Must  be  text/* ",  contentType,  url.toString()));    InputStream  inStream  =  new  BufferedInputStream(conn.getInputStream());  String  charSet  =   "UTF-8 ";  //  todo[must]:  get  from  content-encoding,  or  http-equiv  (two-pass?)    String  data  =  readInputStream(inStream,  charSet);  inStream.close();  return  data;  }        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      URL  url  int  timeoutMillis  [VARIABLES]  HttpURLConnection    conn    boolean    InputStream    inStream    String    charSet    contentType    data    protocol    URL    url    int    res    timeoutMillis    
String  protocol  =  url.getProtocol  (  )  ;	[BUGGY]  String  protocol  =  url  .openConnection(  )  ;  [CONTEXT]  static  String  load(URL  url,  int  timeoutMillis)  throws  IOException  {  [BUGGY]  String  protocol  =  url  .openConnection  ();  Validate.isTrue(protocol.equals( "http ")  ||  protocol.equals( "https "),   "Only  http  &  https  protocols  supported ");    HttpURLConnection  conn  =  (HttpURLConnection)  url.openConnection();  conn.setInstanceFollowRedirects(true);  conn.setConnectTimeout(timeoutMillis);  conn.setReadTimeout(timeoutMillis);  conn.connect();    int  res  =  conn.getResponseCode();  if  (res  !=  HttpURLConnection.HTTP_OK)  throw  new  IOException(res  +   "  error  loading  URL   "  +  url.toString());    String  contentType  =  conn.getContentType();  if  (contentType  ==  null  ||  !contentType.startsWith( "text/ "))  throw  new  IOException(String.format( "Unhandled  content  type  \ "%s\ "  on  URL  %s.  Must  be  text/* ",  contentType,  url.toString()));    InputStream  inStream  =  new  BufferedInputStream(conn.getInputStream());  String  charSet  =   "UTF-8 ";  //  todo[must]:  get  from  content-encoding,  or  http-equiv  (two-pass?)    String  data  =  readInputStream(inStream,  charSet);  inStream.close();  return  data;  }        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      URL  url  int  timeoutMillis  [VARIABLES]  HttpURLConnection    conn    boolean    InputStream    inStream    String    charSet    contentType    data    protocol    URL    url    int    res    timeoutMillis    
String  protocol  =  url.getProtocol  (  )  ;  Validate.isTrue  (  protocol.equals  (   "http "  )  ||  protocol.equals  (   "https "  )  ,   "Only  http  &  https  protocols  supported "  )  ;	[BUGGY]    [CONTEXT]  static  String  load(URL  url,  int  timeoutMillis)  throws  IOException  {  [BUGGY]  String  protocol  =  url.getProtocol();        HttpURLConnection  conn  =  (HttpURLConnection)  url.openConnection();  conn.setInstanceFollowRedirects(true);  conn.setConnectTimeout(timeoutMillis);  conn.setReadTimeout(timeoutMillis);  conn.connect();    int  res  =  conn.getResponseCode();  if  (res  !=  HttpURLConnection.HTTP_OK)  throw  new  IOException(res  +   "  error  loading  URL   "  +  url.toString());    String  contentType  =  conn.getContentType();  if  (contentType  ==  null  ||  !contentType.startsWith( "text/ "))  throw  new  IOException(String.format( "Unhandled  content  type  \ "%s\ "  on  URL  %s.  Must  be  text/* ",  contentType,  url.toString()));    InputStream  inStream  =  new  BufferedInputStream(conn.getInputStream());  String  charSet  =   "UTF-8 ";  //  todo[must]:  get  from  content-encoding,  or  http-equiv  (two-pass?)    String  data  =  readInputStream(inStream,  charSet);  inStream.close();  return  data;        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      URL  url  int  timeoutMillis  [VARIABLES]  HttpURLConnection    conn    boolean    InputStream    inStream    String    charSet    contentType    data    protocol    URL    url    int    res    timeoutMillis    
String  protocol  =  url.getProtocol  (  )  ;  Validate.isTrue  (  protocol.equals  (   "http "  )  ||  protocol.equals  (   "https "  )  ,   "Only  http  &  https  protocols  supported "  )  ;	[BUGGY]  Validate.isTrue(  protocol.equals(   "http ")  ||  protocol.equals(   "https "),   "Only  http  &  https  protocols  supported ");  String  protocol  =  url.getProtocol(  );  [CONTEXT]        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      URL  url  int  timeoutMillis  [VARIABLES]  HttpURLConnection    conn    boolean    InputStream    inStream    String    charSet    contentType    data    protocol    URL    url    int    res    timeoutMillis    
String  protocol  =  url.getProtocol  (  )  ;  Validate.isTrue  (  protocol.equals  (   "http "  )  ||  protocol.equals  (   "https "  )  ,   "Only  http  &  https  protocols  supported "  )  ;	[BUGGY]  Validate.isTrue(  protocol.equals(   "http ")  ||  protocol.equals(   "https "),   "Only  http  &  https  protocols  supported ");String  protocol  =  url.getProtocol(  );  Validate.isTrue(  protocol.equals(   "http ")  ||  protocol.equals(   "https "),   "Only  http  &  https  protocols  supported ");  [CONTEXT]        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      URL  url  int  timeoutMillis  [VARIABLES]  HttpURLConnection    conn    boolean    InputStream    inStream    String    charSet    contentType    data    protocol    URL    url    int    res    timeoutMillis    
Validate.isTrue  (  protocol.equals  (   "http "  )  ||  protocol.equals  (   "https "  )  ,   "Only  http  &  https  protocols  supported "  )  ;	[BUGGY]  Validate.isTrue(  protocol.equals(   "http ")  &&  protocol.equals(   "https "),   "Only  http  &  https  protocols  supported ");  [CONTEXT]  static  String  load(URL  url,  int  timeoutMillis)  throws  IOException  {  String  protocol  =  url.getProtocol();  [BUGGY]  Validate.isTrue  (  protocol.equals  (   "http "  )&&  protocol.equals  (   "https "  )  ,   "Only  http  &  https  protocols  supported "  )  ;    HttpURLConnection  conn  =  (HttpURLConnection)  url.openConnection();  conn.setInstanceFollowRedirects(true);  conn.setConnectTimeout(timeoutMillis);  conn.setReadTimeout(timeoutMillis);  conn.connect();    int  res  =  conn.getResponseCode();  if  (res  !=  HttpURLConnection.HTTP_OK)  throw  new  IOException(res  +   "  error  loading  URL   "  +  url.toString());    String  contentType  =  conn.getContentType();  if  (contentType  ==  null  ||  !contentType.startsWith( "text/ "))  throw  new  IOException(String.format( "Unhandled  content  type  \ "%s\ "  on  URL  %s.  Must  be  text/* ",  contentType,  url.toString()));    InputStream  inStream  =  new  BufferedInputStream(conn.getInputStream());  String  charSet  =   "UTF-8 ";  //  todo[must]:  get  from  content-encoding,  or  http-equiv  (two-pass?)    String  data  =  readInputStream(inStream,  charSet);  inStream.close();  return  data;  }        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      URL  url  int  timeoutMillis  [VARIABLES]  HttpURLConnection    conn    boolean    InputStream    inStream    String    charSet    contentType    data    protocol    URL    url    int    res    timeoutMillis    
Validate.isTrue  (  protocol.equals  (   "http "  )  ||  protocol.equals  (   "https "  )  ,   "Only  http  &  https  protocols  supported "  )  ;	[BUGGY]  Validate.isTrue(  protocol.equals(   "httttp ")  ||  protocol.equals(   "https "),   "Only  http  &  https  protocols  supported ");  [CONTEXT]  static  String  load(URL  url,  int  timeoutMillis)  throws  IOException  {  String  protocol  =  url.getProtocol();  [BUGGY]  Validate.isTrue  (  protocol.equals  (   "httttp "  )||  protocol.equals  (   "https "  )  ,   "Only  http  &  https  protocols  supported "  )  ;    HttpURLConnection  conn  =  (HttpURLConnection)  url.openConnection();  conn.setInstanceFollowRedirects(true);  conn.setConnectTimeout(timeoutMillis);  conn.setReadTimeout(timeoutMillis);  conn.connect();    int  res  =  conn.getResponseCode();  if  (res  !=  HttpURLConnection.HTTP_OK)  throw  new  IOException(res  +   "  error  loading  URL   "  +  url.toString());    String  contentType  =  conn.getContentType();  if  (contentType  ==  null  ||  !contentType.startsWith( "text/ "))  throw  new  IOException(String.format( "Unhandled  content  type  \ "%s\ "  on  URL  %s.  Must  be  text/* ",  contentType,  url.toString()));    InputStream  inStream  =  new  BufferedInputStream(conn.getInputStream());  String  charSet  =   "UTF-8 ";  //  todo[must]:  get  from  content-encoding,  or  http-equiv  (two-pass?)    String  data  =  readInputStream(inStream,  charSet);  inStream.close();  return  data;  }        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      URL  url  int  timeoutMillis  [VARIABLES]  HttpURLConnection    conn    boolean    InputStream    inStream    String    charSet    contentType    data    protocol    URL    url    int    res    timeoutMillis    
Validate.isTrue  (  protocol.equals  (   "http "  )  ||  protocol.equals  (   "https "  )  ,   "Only  http  &  https  protocols  supported "  )  ;	[BUGGY]  Validate.isTrue(  protocol.equals(   "http ")  ||  protocol.equals(   "httpsh "),   "Only  http  &  https  protocols  supported ");  [CONTEXT]  static  String  load(URL  url,  int  timeoutMillis)  throws  IOException  {  String  protocol  =  url.getProtocol();  [BUGGY]  Validate.isTrue  (  protocol.equals  (   "http "  )||  protocol.equals  (   "httpsh "  )  ,   "Only  http  &  https  protocols  supported "  )  ;    HttpURLConnection  conn  =  (HttpURLConnection)  url.openConnection();  conn.setInstanceFollowRedirects(true);  conn.setConnectTimeout(timeoutMillis);  conn.setReadTimeout(timeoutMillis);  conn.connect();    int  res  =  conn.getResponseCode();  if  (res  !=  HttpURLConnection.HTTP_OK)  throw  new  IOException(res  +   "  error  loading  URL   "  +  url.toString());    String  contentType  =  conn.getContentType();  if  (contentType  ==  null  ||  !contentType.startsWith( "text/ "))  throw  new  IOException(String.format( "Unhandled  content  type  \ "%s\ "  on  URL  %s.  Must  be  text/* ",  contentType,  url.toString()));    InputStream  inStream  =  new  BufferedInputStream(conn.getInputStream());  String  charSet  =   "UTF-8 ";  //  todo[must]:  get  from  content-encoding,  or  http-equiv  (two-pass?)    String  data  =  readInputStream(inStream,  charSet);  inStream.close();  return  data;  }        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      URL  url  int  timeoutMillis  [VARIABLES]  HttpURLConnection    conn    boolean    InputStream    inStream    String    charSet    contentType    data    protocol    URL    url    int    res    timeoutMillis    
Validate.isTrue  (  protocol.equals  (   "http "  )  ||  protocol.equals  (   "https "  )  ,   "Only  http  &  https  protocols  supported "  )  ;	[BUGGY]  Validate.isTrue(  protocol.equals(   "http ")  ||  protocol.equals(   "https "),   "ttps  protocols  supportnly  http  &  https  protocols  supported ");  [CONTEXT]  static  String  load(URL  url,  int  timeoutMillis)  throws  IOException  {  String  protocol  =  url.getProtocol();  [BUGGY]  Validate.isTrue  (  protocol.equals  (   "http "  )||  protocol.equals  (   "https "  )  ,   "ttps  protocols  supportnly  http  &  https  protocols  supported "  )  ;    HttpURLConnection  conn  =  (HttpURLConnection)  url.openConnection();  conn.setInstanceFollowRedirects(true);  conn.setConnectTimeout(timeoutMillis);  conn.setReadTimeout(timeoutMillis);  conn.connect();    int  res  =  conn.getResponseCode();  if  (res  !=  HttpURLConnection.HTTP_OK)  throw  new  IOException(res  +   "  error  loading  URL   "  +  url.toString());    String  contentType  =  conn.getContentType();  if  (contentType  ==  null  ||  !contentType.startsWith( "text/ "))  throw  new  IOException(String.format( "Unhandled  content  type  \ "%s\ "  on  URL  %s.  Must  be  text/* ",  contentType,  url.toString()));    InputStream  inStream  =  new  BufferedInputStream(conn.getInputStream());  String  charSet  =   "UTF-8 ";  //  todo[must]:  get  from  content-encoding,  or  http-equiv  (two-pass?)    String  data  =  readInputStream(inStream,  charSet);  inStream.close();  return  data;  }        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      URL  url  int  timeoutMillis  [VARIABLES]  HttpURLConnection    conn    boolean    InputStream    inStream    String    charSet    contentType    data    protocol    URL    url    int    res    timeoutMillis    
Validate.isTrue  (  protocol.equals  (   "http "  )  ||  protocol.equals  (   "https "  )  ,   "Only  http  &  https  protocols  supported "  )  ;	[BUGGY]  Validate.isTrue(  data.equals(   "http ")  ||  protocol.equals(   "https "),   "Only  http  &  https  protocols  supported ");  [CONTEXT]  static  String  load(URL  url,  int  timeoutMillis)  throws  IOException  {  String  protocol  =  url.getProtocol();  [BUGGY]  Validate.isTrue  (  data.equals  (   "http "  )||  protocol.equals  (   "https "  )  ,   "Only  http  &  https  protocols  supported "  )  ;    HttpURLConnection  conn  =  (HttpURLConnection)  url.openConnection();  conn.setInstanceFollowRedirects(true);  conn.setConnectTimeout(timeoutMillis);  conn.setReadTimeout(timeoutMillis);  conn.connect();    int  res  =  conn.getResponseCode();  if  (res  !=  HttpURLConnection.HTTP_OK)  throw  new  IOException(res  +   "  error  loading  URL   "  +  url.toString());    String  contentType  =  conn.getContentType();  if  (contentType  ==  null  ||  !contentType.startsWith( "text/ "))  throw  new  IOException(String.format( "Unhandled  content  type  \ "%s\ "  on  URL  %s.  Must  be  text/* ",  contentType,  url.toString()));    InputStream  inStream  =  new  BufferedInputStream(conn.getInputStream());  String  charSet  =   "UTF-8 ";  //  todo[must]:  get  from  content-encoding,  or  http-equiv  (two-pass?)    String  data  =  readInputStream(inStream,  charSet);  inStream.close();  return  data;  }        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      URL  url  int  timeoutMillis  [VARIABLES]  HttpURLConnection    conn    boolean    InputStream    inStream    String    charSet    contentType    data    protocol    URL    url    int    res    timeoutMillis    
Validate.isTrue  (  protocol.equals  (   "http "  )  ||  protocol.equals  (   "https "  )  ,   "Only  http  &  https  protocols  supported "  )  ;	[BUGGY]    [CONTEXT]  static  String  load(URL  url,  int  timeoutMillis)  throws  IOException  {  String  protocol  =  url.getProtocol();  [BUGGY]  Validate.isTrue(protocol.equals( "http ")  ||  protocol.equals( "https "),   "Only  http  &  https  protocols  supported ");      HttpURLConnection  conn  =  (HttpURLConnection)  url.openConnection();  conn.setInstanceFollowRedirects(true);  conn.setConnectTimeout(timeoutMillis);  conn.setReadTimeout(timeoutMillis);  conn.connect();    int  res  =  conn.getResponseCode();  if  (res  !=  HttpURLConnection.HTTP_OK)  throw  new  IOException(res  +   "  error  loading  URL   "  +  url.toString());    String  contentType  =  conn.getContentType();  if  (contentType  ==  null  ||  !contentType.startsWith( "text/ "))  throw  new  IOException(String.format( "Unhandled  content  type  \ "%s\ "  on  URL  %s.  Must  be  text/* ",  contentType,  url.toString()));    InputStream  inStream  =  new  BufferedInputStream(conn.getInputStream());  String  charSet  =   "UTF-8 ";  //  todo[must]:  get  from  content-encoding,  or  http-equiv  (two-pass?)    String  data  =  readInputStream(inStream,  charSet);  inStream.close();  return  data;        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      URL  url  int  timeoutMillis  [VARIABLES]  HttpURLConnection    conn    boolean    InputStream    inStream    String    charSet    contentType    data    protocol    URL    url    int    res    timeoutMillis    
Validate.isTrue  (  protocol.equals  (   "http "  )  ||  protocol.equals  (   "https "  )  ,   "Only  http  &  https  protocols  supported "  )  ;	[BUGGY]  Validate.isTrue(  protocol.equals(   "htttp ")  ||  protocol.equals(   "https "),   "Only  http  &  https  protocols  supported ");  [CONTEXT]  static  String  load(URL  url,  int  timeoutMillis)  throws  IOException  {  String  protocol  =  url.getProtocol();  [BUGGY]  Validate.isTrue  (  protocol.equals  (   "htttp "  )||  protocol.equals  (   "https "  )  ,   "Only  http  &  https  protocols  supported "  )  ;    HttpURLConnection  conn  =  (HttpURLConnection)  url.openConnection();  conn.setInstanceFollowRedirects(true);  conn.setConnectTimeout(timeoutMillis);  conn.setReadTimeout(timeoutMillis);  conn.connect();    int  res  =  conn.getResponseCode();  if  (res  !=  HttpURLConnection.HTTP_OK)  throw  new  IOException(res  +   "  error  loading  URL   "  +  url.toString());    String  contentType  =  conn.getContentType();  if  (contentType  ==  null  ||  !contentType.startsWith( "text/ "))  throw  new  IOException(String.format( "Unhandled  content  type  \ "%s\ "  on  URL  %s.  Must  be  text/* ",  contentType,  url.toString()));    InputStream  inStream  =  new  BufferedInputStream(conn.getInputStream());  String  charSet  =   "UTF-8 ";  //  todo[must]:  get  from  content-encoding,  or  http-equiv  (two-pass?)    String  data  =  readInputStream(inStream,  charSet);  inStream.close();  return  data;  }        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      URL  url  int  timeoutMillis  [VARIABLES]  HttpURLConnection    conn    boolean    InputStream    inStream    String    charSet    contentType    data    protocol    URL    url    int    res    timeoutMillis    
Validate.isTrue  (  protocol.equals  (   "http "  )  ||  protocol.equals  (   "https "  )  ,   "Only  http  &  https  protocols  supported "  )  ;	[BUGGY]  Validate.isTrue(  protocol.equals(   "http ")  ||  protocol.equals(   "httttps "),   "Only  http  &  https  protocols  supported ");  [CONTEXT]  static  String  load(URL  url,  int  timeoutMillis)  throws  IOException  {  String  protocol  =  url.getProtocol();  [BUGGY]  Validate.isTrue  (  protocol.equals  (   "http "  )||  protocol.equals  (   "httttps "  )  ,   "Only  http  &  https  protocols  supported "  )  ;    HttpURLConnection  conn  =  (HttpURLConnection)  url.openConnection();  conn.setInstanceFollowRedirects(true);  conn.setConnectTimeout(timeoutMillis);  conn.setReadTimeout(timeoutMillis);  conn.connect();    int  res  =  conn.getResponseCode();  if  (res  !=  HttpURLConnection.HTTP_OK)  throw  new  IOException(res  +   "  error  loading  URL   "  +  url.toString());    String  contentType  =  conn.getContentType();  if  (contentType  ==  null  ||  !contentType.startsWith( "text/ "))  throw  new  IOException(String.format( "Unhandled  content  type  \ "%s\ "  on  URL  %s.  Must  be  text/* ",  contentType,  url.toString()));    InputStream  inStream  =  new  BufferedInputStream(conn.getInputStream());  String  charSet  =   "UTF-8 ";  //  todo[must]:  get  from  content-encoding,  or  http-equiv  (two-pass?)    String  data  =  readInputStream(inStream,  charSet);  inStream.close();  return  data;  }        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      URL  url  int  timeoutMillis  [VARIABLES]  HttpURLConnection    conn    boolean    InputStream    inStream    String    charSet    contentType    data    protocol    URL    url    int    res    timeoutMillis    
HttpURLConnection  conn  =  (  HttpURLConnection  )  url.openConnection  (  )  ;  conn.setInstanceFollowRedirects  (  true  )  ;	[BUGGY]  conn.setInstanceFollowRedirects(  true);  HttpURLConnection  conn  =  (  HttpURLConnection)  url.openConnection(  );  [CONTEXT]        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      URL  url  int  timeoutMillis  [VARIABLES]  HttpURLConnection    conn    boolean    InputStream    inStream    String    charSet    contentType    data    protocol    URL    url    int    res    timeoutMillis    
HttpURLConnection  conn  =  (  HttpURLConnection  )  url.openConnection  (  )  ;  conn.setInstanceFollowRedirects  (  true  )  ;	[BUGGY]  HttpURLConnection  conn  =  (  HttpURLConnection)  url.openConnection(  );HttpURLConnection  conn  =  (  HttpURLConnection)  url.openConnection(  );  conn.setInstanceFollowRedirects(  true);  [CONTEXT]        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      URL  url  int  timeoutMillis  [VARIABLES]  HttpURLConnection    conn    boolean    InputStream    inStream    String    charSet    contentType    data    protocol    URL    url    int    res    timeoutMillis    
HttpURLConnection  conn  =  (  HttpURLConnection  )  url.openConnection  (  )  ;	[BUGGY]  HttpURLConnection  conn  =  (  HttpURLConnection)  url  .getProtocol(  )  ;  [CONTEXT]  static  String  load(URL  url,  int  timeoutMillis)  throws  IOException  {  String  protocol  =  url.getProtocol();  Validate.isTrue(protocol.equals( "http ")  ||  protocol.equals( "https "),   "Only  http  &  https  protocols  supported ");    [BUGGY]  HttpURLConnection  conn  =(  HttpURLConnection  )url  .getProtocol  ();  conn.setInstanceFollowRedirects(true);  conn.setConnectTimeout(timeoutMillis);  conn.setReadTimeout(timeoutMillis);  conn.connect();    int  res  =  conn.getResponseCode();  if  (res  !=  HttpURLConnection.HTTP_OK)  throw  new  IOException(res  +   "  error  loading  URL   "  +  url.toString());    String  contentType  =  conn.getContentType();  if  (contentType  ==  null  ||  !contentType.startsWith( "text/ "))  throw  new  IOException(String.format( "Unhandled  content  type  \ "%s\ "  on  URL  %s.  Must  be  text/* ",  contentType,  url.toString()));    InputStream  inStream  =  new  BufferedInputStream(conn.getInputStream());  String  charSet  =   "UTF-8 ";  //  todo[must]:  get  from  content-encoding,  or  http-equiv  (two-pass?)    String  data  =  readInputStream(inStream,  charSet);  inStream.close();  return  data;  }        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      URL  url  int  timeoutMillis  [VARIABLES]  HttpURLConnection    conn    boolean    InputStream    inStream    String    charSet    contentType    data    protocol    URL    url    int    res    timeoutMillis    
HttpURLConnection  conn  =  (  HttpURLConnection  )  url.openConnection  (  )  ;	[BUGGY]    [CONTEXT]  static  String  load(URL  url,  int  timeoutMillis)  throws  IOException  {  String  protocol  =  url.getProtocol();  Validate.isTrue(protocol.equals( "http ")  ||  protocol.equals( "https "),   "Only  http  &  https  protocols  supported ");    [BUGGY]  HttpURLConnection  conn  =  (HttpURLConnection)  url.openConnection();    conn.setInstanceFollowRedirects(true);  conn.setConnectTimeout(timeoutMillis);  conn.setReadTimeout(timeoutMillis);  conn.connect();    int  res  =  conn.getResponseCode();  if  (res  !=  HttpURLConnection.HTTP_OK)  throw  new  IOException(res  +   "  error  loading  URL   "  +  url.toString());    String  contentType  =  conn.getContentType();  if  (contentType  ==  null  ||  !contentType.startsWith( "text/ "))  throw  new  IOException(String.format( "Unhandled  content  type  \ "%s\ "  on  URL  %s.  Must  be  text/* ",  contentType,  url.toString()));    InputStream  inStream  =  new  BufferedInputStream(conn.getInputStream());  String  charSet  =   "UTF-8 ";  //  todo[must]:  get  from  content-encoding,  or  http-equiv  (two-pass?)    String  data  =  readInputStream(inStream,  charSet);  inStream.close();  return  data;        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      URL  url  int  timeoutMillis  [VARIABLES]  HttpURLConnection    conn    boolean    InputStream    inStream    String    charSet    contentType    data    protocol    URL    url    int    res    timeoutMillis    
conn.setInstanceFollowRedirects  (  true  )  ;	[BUGGY]  conn.setInstanceFollowRedirects(  false);  [CONTEXT]  static  String  load(URL  url,  int  timeoutMillis)  throws  IOException  {  String  protocol  =  url.getProtocol();  Validate.isTrue(protocol.equals( "http ")  ||  protocol.equals( "https "),   "Only  http  &  https  protocols  supported ");    HttpURLConnection  conn  =  (HttpURLConnection)  url.openConnection();  [BUGGY]  conn.setInstanceFollowRedirects  (  false  )  ;  conn.setConnectTimeout(timeoutMillis);  conn.setReadTimeout(timeoutMillis);  conn.connect();    int  res  =  conn.getResponseCode();  if  (res  !=  HttpURLConnection.HTTP_OK)  throw  new  IOException(res  +   "  error  loading  URL   "  +  url.toString());    String  contentType  =  conn.getContentType();  if  (contentType  ==  null  ||  !contentType.startsWith( "text/ "))  throw  new  IOException(String.format( "Unhandled  content  type  \ "%s\ "  on  URL  %s.  Must  be  text/* ",  contentType,  url.toString()));    InputStream  inStream  =  new  BufferedInputStream(conn.getInputStream());  String  charSet  =   "UTF-8 ";  //  todo[must]:  get  from  content-encoding,  or  http-equiv  (two-pass?)    String  data  =  readInputStream(inStream,  charSet);  inStream.close();  return  data;  }        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      URL  url  int  timeoutMillis  [VARIABLES]  HttpURLConnection    conn    boolean    InputStream    inStream    String    charSet    contentType    data    protocol    URL    url    int    res    timeoutMillis    
conn.setInstanceFollowRedirects  (  true  )  ;	[BUGGY]  conn  .getResponseCode(  )  ;  [CONTEXT]  static  String  load(URL  url,  int  timeoutMillis)  throws  IOException  {  String  protocol  =  url.getProtocol();  Validate.isTrue(protocol.equals( "http ")  ||  protocol.equals( "https "),   "Only  http  &  https  protocols  supported ");    HttpURLConnection  conn  =  (HttpURLConnection)  url.openConnection();  [BUGGY]  conn  .getResponseCode  ();  conn.setConnectTimeout(timeoutMillis);  conn.setReadTimeout(timeoutMillis);  conn.connect();    int  res  =  conn.getResponseCode();  if  (res  !=  HttpURLConnection.HTTP_OK)  throw  new  IOException(res  +   "  error  loading  URL   "  +  url.toString());    String  contentType  =  conn.getContentType();  if  (contentType  ==  null  ||  !contentType.startsWith( "text/ "))  throw  new  IOException(String.format( "Unhandled  content  type  \ "%s\ "  on  URL  %s.  Must  be  text/* ",  contentType,  url.toString()));    InputStream  inStream  =  new  BufferedInputStream(conn.getInputStream());  String  charSet  =   "UTF-8 ";  //  todo[must]:  get  from  content-encoding,  or  http-equiv  (two-pass?)    String  data  =  readInputStream(inStream,  charSet);  inStream.close();  return  data;  }        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      URL  url  int  timeoutMillis  [VARIABLES]  HttpURLConnection    conn    boolean    InputStream    inStream    String    charSet    contentType    data    protocol    URL    url    int    res    timeoutMillis    
conn.setInstanceFollowRedirects  (  true  )  ;  conn.setConnectTimeout  (  timeoutMillis  )  ;	[BUGGY]    [CONTEXT]  static  String  load(URL  url,  int  timeoutMillis)  throws  IOException  {  String  protocol  =  url.getProtocol();  Validate.isTrue(protocol.equals( "http ")  ||  protocol.equals( "https "),   "Only  http  &  https  protocols  supported ");    HttpURLConnection  conn  =  (HttpURLConnection)  url.openConnection();  [BUGGY]  conn.setInstanceFollowRedirects(true);      conn.setReadTimeout(timeoutMillis);  conn.connect();    int  res  =  conn.getResponseCode();  if  (res  !=  HttpURLConnection.HTTP_OK)  throw  new  IOException(res  +   "  error  loading  URL   "  +  url.toString());    String  contentType  =  conn.getContentType();  if  (contentType  ==  null  ||  !contentType.startsWith( "text/ "))  throw  new  IOException(String.format( "Unhandled  content  type  \ "%s\ "  on  URL  %s.  Must  be  text/* ",  contentType,  url.toString()));    InputStream  inStream  =  new  BufferedInputStream(conn.getInputStream());  String  charSet  =   "UTF-8 ";  //  todo[must]:  get  from  content-encoding,  or  http-equiv  (two-pass?)    String  data  =  readInputStream(inStream,  charSet);  inStream.close();  return  data;        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      URL  url  int  timeoutMillis  [VARIABLES]  HttpURLConnection    conn    boolean    InputStream    inStream    String    charSet    contentType    data    protocol    URL    url    int    res    timeoutMillis    
conn.setConnectTimeout  (  timeoutMillis  )  ;	[BUGGY]  conn.setConnectTimeout(  res);  [CONTEXT]  static  String  load(URL  url,  int  timeoutMillis)  throws  IOException  {  String  protocol  =  url.getProtocol();  Validate.isTrue(protocol.equals( "http ")  ||  protocol.equals( "https "),   "Only  http  &  https  protocols  supported ");    HttpURLConnection  conn  =  (HttpURLConnection)  url.openConnection();  conn.setInstanceFollowRedirects(true);  [BUGGY]  conn.setConnectTimeout  (  res  )  ;  conn.setReadTimeout(timeoutMillis);  conn.connect();    int  res  =  conn.getResponseCode();  if  (res  !=  HttpURLConnection.HTTP_OK)  throw  new  IOException(res  +   "  error  loading  URL   "  +  url.toString());    String  contentType  =  conn.getContentType();  if  (contentType  ==  null  ||  !contentType.startsWith( "text/ "))  throw  new  IOException(String.format( "Unhandled  content  type  \ "%s\ "  on  URL  %s.  Must  be  text/* ",  contentType,  url.toString()));    InputStream  inStream  =  new  BufferedInputStream(conn.getInputStream());  String  charSet  =   "UTF-8 ";  //  todo[must]:  get  from  content-encoding,  or  http-equiv  (two-pass?)    String  data  =  readInputStream(inStream,  charSet);  inStream.close();  return  data;  }        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      URL  url  int  timeoutMillis  [VARIABLES]  HttpURLConnection    conn    boolean    InputStream    inStream    String    charSet    contentType    data    protocol    URL    url    int    res    timeoutMillis    
conn.setConnectTimeout  (  timeoutMillis  )  ;	[BUGGY]    [CONTEXT]  static  String  load(URL  url,  int  timeoutMillis)  throws  IOException  {  String  protocol  =  url.getProtocol();  Validate.isTrue(protocol.equals( "http ")  ||  protocol.equals( "https "),   "Only  http  &  https  protocols  supported ");    HttpURLConnection  conn  =  (HttpURLConnection)  url.openConnection();  conn.setInstanceFollowRedirects(true);  [BUGGY]  conn.setConnectTimeout(timeoutMillis);    conn.setReadTimeout(timeoutMillis);  conn.connect();    int  res  =  conn.getResponseCode();  if  (res  !=  HttpURLConnection.HTTP_OK)  throw  new  IOException(res  +   "  error  loading  URL   "  +  url.toString());    String  contentType  =  conn.getContentType();  if  (contentType  ==  null  ||  !contentType.startsWith( "text/ "))  throw  new  IOException(String.format( "Unhandled  content  type  \ "%s\ "  on  URL  %s.  Must  be  text/* ",  contentType,  url.toString()));    InputStream  inStream  =  new  BufferedInputStream(conn.getInputStream());  String  charSet  =   "UTF-8 ";  //  todo[must]:  get  from  content-encoding,  or  http-equiv  (two-pass?)    String  data  =  readInputStream(inStream,  charSet);  inStream.close();  return  data;        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      URL  url  int  timeoutMillis  [VARIABLES]  HttpURLConnection    conn    boolean    InputStream    inStream    String    charSet    contentType    data    protocol    URL    url    int    res    timeoutMillis    
conn.setConnectTimeout  (  timeoutMillis  )  ;	[BUGGY]  conn.setReadTimeout(  timeoutMillis);conn.setConnectTimeout(  timeoutMillis);  [CONTEXT]        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      URL  url  int  timeoutMillis  [VARIABLES]  HttpURLConnection    conn    boolean    InputStream    inStream    String    charSet    contentType    data    protocol    URL    url    int    res    timeoutMillis    
conn.setReadTimeout  (  timeoutMillis  )  ;	[BUGGY]  conn.setReadTimeout(  res);  [CONTEXT]  static  String  load(URL  url,  int  timeoutMillis)  throws  IOException  {  String  protocol  =  url.getProtocol();  Validate.isTrue(protocol.equals( "http ")  ||  protocol.equals( "https "),   "Only  http  &  https  protocols  supported ");    HttpURLConnection  conn  =  (HttpURLConnection)  url.openConnection();  conn.setInstanceFollowRedirects(true);  conn.setConnectTimeout(timeoutMillis);  [BUGGY]  conn.setReadTimeout  (  res  )  ;  conn.connect();    int  res  =  conn.getResponseCode();  if  (res  !=  HttpURLConnection.HTTP_OK)  throw  new  IOException(res  +   "  error  loading  URL   "  +  url.toString());    String  contentType  =  conn.getContentType();  if  (contentType  ==  null  ||  !contentType.startsWith( "text/ "))  throw  new  IOException(String.format( "Unhandled  content  type  \ "%s\ "  on  URL  %s.  Must  be  text/* ",  contentType,  url.toString()));    InputStream  inStream  =  new  BufferedInputStream(conn.getInputStream());  String  charSet  =   "UTF-8 ";  //  todo[must]:  get  from  content-encoding,  or  http-equiv  (two-pass?)    String  data  =  readInputStream(inStream,  charSet);  inStream.close();  return  data;  }        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      URL  url  int  timeoutMillis  [VARIABLES]  HttpURLConnection    conn    boolean    InputStream    inStream    String    charSet    contentType    data    protocol    URL    url    int    res    timeoutMillis    
conn.setReadTimeout  (  timeoutMillis  )  ;	[BUGGY]  conn  .setConnectTimeout(  timeoutMillis)  ;  [CONTEXT]  static  String  load(URL  url,  int  timeoutMillis)  throws  IOException  {  String  protocol  =  url.getProtocol();  Validate.isTrue(protocol.equals( "http ")  ||  protocol.equals( "https "),   "Only  http  &  https  protocols  supported ");    HttpURLConnection  conn  =  (HttpURLConnection)  url.openConnection();  conn.setInstanceFollowRedirects(true);  conn.setConnectTimeout(timeoutMillis);  [BUGGY]  conn  .setConnectTimeout  (  timeoutMillis  );  conn.connect();    int  res  =  conn.getResponseCode();  if  (res  !=  HttpURLConnection.HTTP_OK)  throw  new  IOException(res  +   "  error  loading  URL   "  +  url.toString());    String  contentType  =  conn.getContentType();  if  (contentType  ==  null  ||  !contentType.startsWith( "text/ "))  throw  new  IOException(String.format( "Unhandled  content  type  \ "%s\ "  on  URL  %s.  Must  be  text/* ",  contentType,  url.toString()));    InputStream  inStream  =  new  BufferedInputStream(conn.getInputStream());  String  charSet  =   "UTF-8 ";  //  todo[must]:  get  from  content-encoding,  or  http-equiv  (two-pass?)    String  data  =  readInputStream(inStream,  charSet);  inStream.close();  return  data;  }        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      URL  url  int  timeoutMillis  [VARIABLES]  HttpURLConnection    conn    boolean    InputStream    inStream    String    charSet    contentType    data    protocol    URL    url    int    res    timeoutMillis    
conn.setReadTimeout  (  timeoutMillis  )  ;	[BUGGY]    [CONTEXT]  static  String  load(URL  url,  int  timeoutMillis)  throws  IOException  {  String  protocol  =  url.getProtocol();  Validate.isTrue(protocol.equals( "http ")  ||  protocol.equals( "https "),   "Only  http  &  https  protocols  supported ");    HttpURLConnection  conn  =  (HttpURLConnection)  url.openConnection();  conn.setInstanceFollowRedirects(true);  conn.setConnectTimeout(timeoutMillis);  [BUGGY]  conn.setReadTimeout(timeoutMillis);    conn.connect();    int  res  =  conn.getResponseCode();  if  (res  !=  HttpURLConnection.HTTP_OK)  throw  new  IOException(res  +   "  error  loading  URL   "  +  url.toString());    String  contentType  =  conn.getContentType();  if  (contentType  ==  null  ||  !contentType.startsWith( "text/ "))  throw  new  IOException(String.format( "Unhandled  content  type  \ "%s\ "  on  URL  %s.  Must  be  text/* ",  contentType,  url.toString()));    InputStream  inStream  =  new  BufferedInputStream(conn.getInputStream());  String  charSet  =   "UTF-8 ";  //  todo[must]:  get  from  content-encoding,  or  http-equiv  (two-pass?)    String  data  =  readInputStream(inStream,  charSet);  inStream.close();  return  data;        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      URL  url  int  timeoutMillis  [VARIABLES]  HttpURLConnection    conn    boolean    InputStream    inStream    String    charSet    contentType    data    protocol    URL    url    int    res    timeoutMillis    
conn.setReadTimeout  (  timeoutMillis  )  ;  conn.connect  (  )  ;	[BUGGY]  conn.connect(  );  conn.setReadTimeout(  timeoutMillis);  [CONTEXT]        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      URL  url  int  timeoutMillis  [VARIABLES]  HttpURLConnection    conn    boolean    InputStream    inStream    String    charSet    contentType    data    protocol    URL    url    int    res    timeoutMillis    
conn.setReadTimeout  (  timeoutMillis  )  ;  conn.connect  (  )  ;	[BUGGY]  conn.setConnectTimeout(  timeoutMillis);conn.setReadTimeout(  timeoutMillis);  conn.connect(  );  [CONTEXT]        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      URL  url  int  timeoutMillis  [VARIABLES]  HttpURLConnection    conn    boolean    InputStream    inStream    String    charSet    contentType    data    protocol    URL    url    int    res    timeoutMillis    
conn.setReadTimeout  (  timeoutMillis  )  ;  conn.connect  (  )  ;	[BUGGY]  conn.setReadTimeout(  timeoutMillis);conn.setReadTimeout(  timeoutMillis);  conn.connect(  );  [CONTEXT]        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      URL  url  int  timeoutMillis  [VARIABLES]  HttpURLConnection    conn    boolean    InputStream    inStream    String    charSet    contentType    data    protocol    URL    url    int    res    timeoutMillis    
conn.connect  (  )  ;	[BUGGY]  conn.setConnectTimeout(  );  [CONTEXT]  static  String  load(URL  url,  int  timeoutMillis)  throws  IOException  {  String  protocol  =  url.getProtocol();  Validate.isTrue(protocol.equals( "http ")  ||  protocol.equals( "https "),   "Only  http  &  https  protocols  supported ");    HttpURLConnection  conn  =  (HttpURLConnection)  url.openConnection();  conn.setInstanceFollowRedirects(true);  conn.setConnectTimeout(timeoutMillis);  conn.setReadTimeout(timeoutMillis);  [BUGGY]  conn.setConnectTimeout  ()  ;    int  res  =  conn.getResponseCode();  if  (res  !=  HttpURLConnection.HTTP_OK)  throw  new  IOException(res  +   "  error  loading  URL   "  +  url.toString());    String  contentType  =  conn.getContentType();  if  (contentType  ==  null  ||  !contentType.startsWith( "text/ "))  throw  new  IOException(String.format( "Unhandled  content  type  \ "%s\ "  on  URL  %s.  Must  be  text/* ",  contentType,  url.toString()));    InputStream  inStream  =  new  BufferedInputStream(conn.getInputStream());  String  charSet  =   "UTF-8 ";  //  todo[must]:  get  from  content-encoding,  or  http-equiv  (two-pass?)    String  data  =  readInputStream(inStream,  charSet);  inStream.close();  return  data;  }        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      URL  url  int  timeoutMillis  [VARIABLES]  HttpURLConnection    conn    boolean    InputStream    inStream    String    charSet    contentType    data    protocol    URL    url    int    res    timeoutMillis    
conn.connect  (  )  ;	[BUGGY]    [CONTEXT]  static  String  load(URL  url,  int  timeoutMillis)  throws  IOException  {  String  protocol  =  url.getProtocol();  Validate.isTrue(protocol.equals( "http ")  ||  protocol.equals( "https "),   "Only  http  &  https  protocols  supported ");    HttpURLConnection  conn  =  (HttpURLConnection)  url.openConnection();  conn.setInstanceFollowRedirects(true);  conn.setConnectTimeout(timeoutMillis);  conn.setReadTimeout(timeoutMillis);  [BUGGY]  conn.connect();      int  res  =  conn.getResponseCode();  if  (res  !=  HttpURLConnection.HTTP_OK)  throw  new  IOException(res  +   "  error  loading  URL   "  +  url.toString());    String  contentType  =  conn.getContentType();  if  (contentType  ==  null  ||  !contentType.startsWith( "text/ "))  throw  new  IOException(String.format( "Unhandled  content  type  \ "%s\ "  on  URL  %s.  Must  be  text/* ",  contentType,  url.toString()));    InputStream  inStream  =  new  BufferedInputStream(conn.getInputStream());  String  charSet  =   "UTF-8 ";  //  todo[must]:  get  from  content-encoding,  or  http-equiv  (two-pass?)    String  data  =  readInputStream(inStream,  charSet);  inStream.close();  return  data;        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      URL  url  int  timeoutMillis  [VARIABLES]  HttpURLConnection    conn    boolean    InputStream    inStream    String    charSet    contentType    data    protocol    URL    url    int    res    timeoutMillis    
int  res  =  conn.getResponseCode  (  )  ;	[BUGGY]  short    res  =  conn.getResponseCode(  );  [CONTEXT]  static  String  load(URL  url,  int  timeoutMillis)  throws  IOException  {  String  protocol  =  url.getProtocol();  Validate.isTrue(protocol.equals( "http ")  ||  protocol.equals( "https "),   "Only  http  &  https  protocols  supported ");    HttpURLConnection  conn  =  (HttpURLConnection)  url.openConnection();  conn.setInstanceFollowRedirects(true);  conn.setConnectTimeout(timeoutMillis);  conn.setReadTimeout(timeoutMillis);  conn.connect();    [BUGGY]  shortres  =  conn.getResponseCode  ()  ;  if  (res  !=  HttpURLConnection.HTTP_OK)  throw  new  IOException(res  +   "  error  loading  URL   "  +  url.toString());    String  contentType  =  conn.getContentType();  if  (contentType  ==  null  ||  !contentType.startsWith( "text/ "))  throw  new  IOException(String.format( "Unhandled  content  type  \ "%s\ "  on  URL  %s.  Must  be  text/* ",  contentType,  url.toString()));    InputStream  inStream  =  new  BufferedInputStream(conn.getInputStream());  String  charSet  =   "UTF-8 ";  //  todo[must]:  get  from  content-encoding,  or  http-equiv  (two-pass?)    String  data  =  readInputStream(inStream,  charSet);  inStream.close();  return  data;  }        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      URL  url  int  timeoutMillis  [VARIABLES]  HttpURLConnection    conn    boolean    InputStream    inStream    String    charSet    contentType    data    protocol    URL    url    int    res    timeoutMillis    
int  res  =  conn.getResponseCode  (  )  ;	[BUGGY]  int  res  =  conn.setReadTimeout(  );  [CONTEXT]  static  String  load(URL  url,  int  timeoutMillis)  throws  IOException  {  String  protocol  =  url.getProtocol();  Validate.isTrue(protocol.equals( "http ")  ||  protocol.equals( "https "),   "Only  http  &  https  protocols  supported ");    HttpURLConnection  conn  =  (HttpURLConnection)  url.openConnection();  conn.setInstanceFollowRedirects(true);  conn.setConnectTimeout(timeoutMillis);  conn.setReadTimeout(timeoutMillis);  conn.connect();    [BUGGY]  int  res  =  conn.setReadTimeout  ()  ;  if  (res  !=  HttpURLConnection.HTTP_OK)  throw  new  IOException(res  +   "  error  loading  URL   "  +  url.toString());    String  contentType  =  conn.getContentType();  if  (contentType  ==  null  ||  !contentType.startsWith( "text/ "))  throw  new  IOException(String.format( "Unhandled  content  type  \ "%s\ "  on  URL  %s.  Must  be  text/* ",  contentType,  url.toString()));    InputStream  inStream  =  new  BufferedInputStream(conn.getInputStream());  String  charSet  =   "UTF-8 ";  //  todo[must]:  get  from  content-encoding,  or  http-equiv  (two-pass?)    String  data  =  readInputStream(inStream,  charSet);  inStream.close();  return  data;  }        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      URL  url  int  timeoutMillis  [VARIABLES]  HttpURLConnection    conn    boolean    InputStream    inStream    String    charSet    contentType    data    protocol    URL    url    int    res    timeoutMillis    
int  res  =  conn.getResponseCode  (  )  ;	[BUGGY]  int  res  =  conn  .setReadTimeout(  res)  ;  [CONTEXT]  static  String  load(URL  url,  int  timeoutMillis)  throws  IOException  {  String  protocol  =  url.getProtocol();  Validate.isTrue(protocol.equals( "http ")  ||  protocol.equals( "https "),   "Only  http  &  https  protocols  supported ");    HttpURLConnection  conn  =  (HttpURLConnection)  url.openConnection();  conn.setInstanceFollowRedirects(true);  conn.setConnectTimeout(timeoutMillis);  conn.setReadTimeout(timeoutMillis);  conn.connect();    [BUGGY]  int  res  =  conn  .setReadTimeout  (  res  );  if  (res  !=  HttpURLConnection.HTTP_OK)  throw  new  IOException(res  +   "  error  loading  URL   "  +  url.toString());    String  contentType  =  conn.getContentType();  if  (contentType  ==  null  ||  !contentType.startsWith( "text/ "))  throw  new  IOException(String.format( "Unhandled  content  type  \ "%s\ "  on  URL  %s.  Must  be  text/* ",  contentType,  url.toString()));    InputStream  inStream  =  new  BufferedInputStream(conn.getInputStream());  String  charSet  =   "UTF-8 ";  //  todo[must]:  get  from  content-encoding,  or  http-equiv  (two-pass?)    String  data  =  readInputStream(inStream,  charSet);  inStream.close();  return  data;  }        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      URL  url  int  timeoutMillis  [VARIABLES]  HttpURLConnection    conn    boolean    InputStream    inStream    String    charSet    contentType    data    protocol    URL    url    int    res    timeoutMillis    
int  res  =  conn.getResponseCode  (  )  ;	[BUGGY]    [CONTEXT]  static  String  load(URL  url,  int  timeoutMillis)  throws  IOException  {  String  protocol  =  url.getProtocol();  Validate.isTrue(protocol.equals( "http ")  ||  protocol.equals( "https "),   "Only  http  &  https  protocols  supported ");    HttpURLConnection  conn  =  (HttpURLConnection)  url.openConnection();  conn.setInstanceFollowRedirects(true);  conn.setConnectTimeout(timeoutMillis);  conn.setReadTimeout(timeoutMillis);  conn.connect();    [BUGGY]  int  res  =  conn.getResponseCode();    if  (res  !=  HttpURLConnection.HTTP_OK)  throw  new  IOException(res  +   "  error  loading  URL   "  +  url.toString());    String  contentType  =  conn.getContentType();  if  (contentType  ==  null  ||  !contentType.startsWith( "text/ "))  throw  new  IOException(String.format( "Unhandled  content  type  \ "%s\ "  on  URL  %s.  Must  be  text/* ",  contentType,  url.toString()));    InputStream  inStream  =  new  BufferedInputStream(conn.getInputStream());  String  charSet  =   "UTF-8 ";  //  todo[must]:  get  from  content-encoding,  or  http-equiv  (two-pass?)    String  data  =  readInputStream(inStream,  charSet);  inStream.close();  return  data;        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      URL  url  int  timeoutMillis  [VARIABLES]  HttpURLConnection    conn    boolean    InputStream    inStream    String    charSet    contentType    data    protocol    URL    url    int    res    timeoutMillis    
if  (  res  !=  HttpURLConnection.HTTP_OK  )  throw  new  IOException  ( "   ")  ;	[BUGGY]  if  (  res  ==  HttpURLConnection.HTTP_OK)throw  new  IOException  ( "   ")    ;  [CONTEXT]  static  String  load(URL  url,  int  timeoutMillis)  throws  IOException  {  String  protocol  =  url.getProtocol();  Validate.isTrue(protocol.equals( "http ")  ||  protocol.equals( "https "),   "Only  http  &  https  protocols  supported ");    HttpURLConnection  conn  =  (HttpURLConnection)  url.openConnection();  conn.setInstanceFollowRedirects(true);  conn.setConnectTimeout(timeoutMillis);  conn.setReadTimeout(timeoutMillis);  conn.connect();    int  res  =  conn.getResponseCode();  [BUGGY]  if(  res  ==  HttpURLConnection.HTTP_OK  )  throw  new  IOException( "   ");      String  contentType  =  conn.getContentType();  if  (contentType  ==  null  ||  !contentType.startsWith( "text/ "))  throw  new  IOException(String.format( "Unhandled  content  type  \ "%s\ "  on  URL  %s.  Must  be  text/* ",  contentType,  url.toString()));    InputStream  inStream  =  new  BufferedInputStream(conn.getInputStream());  String  charSet  =   "UTF-8 ";  //  todo[must]:  get  from  content-encoding,  or  http-equiv  (two-pass?)    String  data  =  readInputStream(inStream,  charSet);  inStream.close();  return  data;  }        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      URL  url  int  timeoutMillis  [VARIABLES]  HttpURLConnection    conn    boolean    InputStream    inStream    String    charSet    contentType    data    protocol    URL    url    int    res    timeoutMillis    
if  (  res  !=  HttpURLConnection.HTTP_OK  )  throw  new  IOException  ( "   ")  ;	[BUGGY]  if  (  timeoutMillis  !=  HttpURLConnection.HTTP_OK)throw  new  IOException  ( "   ")    ;  [CONTEXT]  static  String  load(URL  url,  int  timeoutMillis)  throws  IOException  {  String  protocol  =  url.getProtocol();  Validate.isTrue(protocol.equals( "http ")  ||  protocol.equals( "https "),   "Only  http  &  https  protocols  supported ");    HttpURLConnection  conn  =  (HttpURLConnection)  url.openConnection();  conn.setInstanceFollowRedirects(true);  conn.setConnectTimeout(timeoutMillis);  conn.setReadTimeout(timeoutMillis);  conn.connect();    int  res  =  conn.getResponseCode();  [BUGGY]  if(  timeoutMillis  !=  HttpURLConnection.HTTP_OK  )  throw  new  IOException( "   ");      String  contentType  =  conn.getContentType();  if  (contentType  ==  null  ||  !contentType.startsWith( "text/ "))  throw  new  IOException(String.format( "Unhandled  content  type  \ "%s\ "  on  URL  %s.  Must  be  text/* ",  contentType,  url.toString()));    InputStream  inStream  =  new  BufferedInputStream(conn.getInputStream());  String  charSet  =   "UTF-8 ";  //  todo[must]:  get  from  content-encoding,  or  http-equiv  (two-pass?)    String  data  =  readInputStream(inStream,  charSet);  inStream.close();  return  data;  }        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      URL  url  int  timeoutMillis  [VARIABLES]  HttpURLConnection    conn    boolean    InputStream    inStream    String    charSet    contentType    data    protocol    URL    url    int    res    timeoutMillis    
if  (  res  !=  HttpURLConnection.HTTP_OK  )  throw  new  IOException  ( "   ")  ;	[BUGGY]  if  (  res  +   "  error  loading  URL   "  +  url.toString(  ))    ;  [CONTEXT]  static  String  load(URL  url,  int  timeoutMillis)  throws  IOException  {  String  protocol  =  url.getProtocol();  Validate.isTrue(protocol.equals( "http ")  ||  protocol.equals( "https "),   "Only  http  &  https  protocols  supported ");    HttpURLConnection  conn  =  (HttpURLConnection)  url.openConnection();  conn.setInstanceFollowRedirects(true);  conn.setConnectTimeout(timeoutMillis);  conn.setReadTimeout(timeoutMillis);  conn.connect();    int  res  =  conn.getResponseCode();  [BUGGY]  if(  res  +   "  error  loading  URL   "  +  url.toString  ()  );      String  contentType  =  conn.getContentType();  if  (contentType  ==  null  ||  !contentType.startsWith( "text/ "))  throw  new  IOException(String.format( "Unhandled  content  type  \ "%s\ "  on  URL  %s.  Must  be  text/* ",  contentType,  url.toString()));    InputStream  inStream  =  new  BufferedInputStream(conn.getInputStream());  String  charSet  =   "UTF-8 ";  //  todo[must]:  get  from  content-encoding,  or  http-equiv  (two-pass?)    String  data  =  readInputStream(inStream,  charSet);  inStream.close();  return  data;  }        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      URL  url  int  timeoutMillis  [VARIABLES]  HttpURLConnection    conn    boolean    InputStream    inStream    String    charSet    contentType    data    protocol    URL    url    int    res    timeoutMillis    
if  (  res  !=  HttpURLConnection.HTTP_OK  )  throw  new  IOException  ( "   ")  ;	[BUGGY]  if  (  res  +   "  error  loading  URL   ")  ;  [CONTEXT]  static  String  load(URL  url,  int  timeoutMillis)  throws  IOException  {  String  protocol  =  url.getProtocol();  Validate.isTrue(protocol.equals( "http ")  ||  protocol.equals( "https "),   "Only  http  &  https  protocols  supported ");    HttpURLConnection  conn  =  (HttpURLConnection)  url.openConnection();  conn.setInstanceFollowRedirects(true);  conn.setConnectTimeout(timeoutMillis);  conn.setReadTimeout(timeoutMillis);  conn.connect();    int  res  =  conn.getResponseCode();  [BUGGY]  if(  res  +   "  error  loading  URL   "  );      String  contentType  =  conn.getContentType();  if  (contentType  ==  null  ||  !contentType.startsWith( "text/ "))  throw  new  IOException(String.format( "Unhandled  content  type  \ "%s\ "  on  URL  %s.  Must  be  text/* ",  contentType,  url.toString()));    InputStream  inStream  =  new  BufferedInputStream(conn.getInputStream());  String  charSet  =   "UTF-8 ";  //  todo[must]:  get  from  content-encoding,  or  http-equiv  (two-pass?)    String  data  =  readInputStream(inStream,  charSet);  inStream.close();  return  data;  }        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      URL  url  int  timeoutMillis  [VARIABLES]  HttpURLConnection    conn    boolean    InputStream    inStream    String    charSet    contentType    data    protocol    URL    url    int    res    timeoutMillis    
throw  new  IOException  ( "   ")  ;	[BUGGY]    [CONTEXT]  static  String  load(URL  url,  int  timeoutMillis)  throws  IOException  {  String  protocol  =  url.getProtocol();  Validate.isTrue(protocol.equals( "http ")  ||  protocol.equals( "https "),   "Only  http  &  https  protocols  supported ");    HttpURLConnection  conn  =  (HttpURLConnection)  url.openConnection();  conn.setInstanceFollowRedirects(true);  conn.setConnectTimeout(timeoutMillis);  conn.setReadTimeout(timeoutMillis);  conn.connect();    int  res  =  conn.getResponseCode();  if  (res  !=  HttpURLConnection.HTTP_OK)  [BUGGY]  throw  new  IOException(res  +   "  error  loading  URL   "  +  url.toString());      String  contentType  =  conn.getContentType();  if  (contentType  ==  null  ||  !contentType.startsWith( "text/ "))  throw  new  IOException(String.format( "Unhandled  content  type  \ "%s\ "  on  URL  %s.  Must  be  text/* ",  contentType,  url.toString()));    InputStream  inStream  =  new  BufferedInputStream(conn.getInputStream());  String  charSet  =   "UTF-8 ";  //  todo[must]:  get  from  content-encoding,  or  http-equiv  (two-pass?)    String  data  =  readInputStream(inStream,  charSet);  inStream.close();  return  data;        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      URL  url  int  timeoutMillis  [VARIABLES]  HttpURLConnection    conn    boolean    InputStream    inStream    String    charSet    contentType    data    protocol    URL    url    int    res    timeoutMillis    
String  contentType  =  conn.getContentType  (  )  ;	[BUGGY]  char  contentType  =  conn.getContentType(  );  [CONTEXT]  static  String  load(URL  url,  int  timeoutMillis)  throws  IOException  {  String  protocol  =  url.getProtocol();  Validate.isTrue(protocol.equals( "http ")  ||  protocol.equals( "https "),   "Only  http  &  https  protocols  supported ");    HttpURLConnection  conn  =  (HttpURLConnection)  url.openConnection();  conn.setInstanceFollowRedirects(true);  conn.setConnectTimeout(timeoutMillis);  conn.setReadTimeout(timeoutMillis);  conn.connect();    int  res  =  conn.getResponseCode();  if  (res  !=  HttpURLConnection.HTTP_OK)  throw  new  IOException(res  +   "  error  loading  URL   "  +  url.toString());    [BUGGY]  char  contentType  =  conn.getContentType  ()  ;  if  (contentType  ==  null  ||  !contentType.startsWith( "text/ "))  throw  new  IOException(String.format( "Unhandled  content  type  \ "%s\ "  on  URL  %s.  Must  be  text/* ",  contentType,  url.toString()));    InputStream  inStream  =  new  BufferedInputStream(conn.getInputStream());  String  charSet  =   "UTF-8 ";  //  todo[must]:  get  from  content-encoding,  or  http-equiv  (two-pass?)    String  data  =  readInputStream(inStream,  charSet);  inStream.close();  return  data;  }        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      URL  url  int  timeoutMillis  [VARIABLES]  HttpURLConnection    conn    boolean    InputStream    inStream    String    charSet    contentType    data    protocol    URL    url    int    res    timeoutMillis    
String  contentType  =  conn.getContentType  (  )  ;	[BUGGY]  String  contentType  =  conn.setConnectTimeout(  );  [CONTEXT]  static  String  load(URL  url,  int  timeoutMillis)  throws  IOException  {  String  protocol  =  url.getProtocol();  Validate.isTrue(protocol.equals( "http ")  ||  protocol.equals( "https "),   "Only  http  &  https  protocols  supported ");    HttpURLConnection  conn  =  (HttpURLConnection)  url.openConnection();  conn.setInstanceFollowRedirects(true);  conn.setConnectTimeout(timeoutMillis);  conn.setReadTimeout(timeoutMillis);  conn.connect();    int  res  =  conn.getResponseCode();  if  (res  !=  HttpURLConnection.HTTP_OK)  throw  new  IOException(res  +   "  error  loading  URL   "  +  url.toString());    [BUGGY]  String  contentType  =  conn.setConnectTimeout  ()  ;  if  (contentType  ==  null  ||  !contentType.startsWith( "text/ "))  throw  new  IOException(String.format( "Unhandled  content  type  \ "%s\ "  on  URL  %s.  Must  be  text/* ",  contentType,  url.toString()));    InputStream  inStream  =  new  BufferedInputStream(conn.getInputStream());  String  charSet  =   "UTF-8 ";  //  todo[must]:  get  from  content-encoding,  or  http-equiv  (two-pass?)    String  data  =  readInputStream(inStream,  charSet);  inStream.close();  return  data;  }        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      URL  url  int  timeoutMillis  [VARIABLES]  HttpURLConnection    conn    boolean    InputStream    inStream    String    charSet    contentType    data    protocol    URL    url    int    res    timeoutMillis    
String  contentType  =  conn.getContentType  (  )  ;	[BUGGY]  String  contentType  =  conn  .setConnectTimeout(  res)  ;  [CONTEXT]  static  String  load(URL  url,  int  timeoutMillis)  throws  IOException  {  String  protocol  =  url.getProtocol();  Validate.isTrue(protocol.equals( "http ")  ||  protocol.equals( "https "),   "Only  http  &  https  protocols  supported ");    HttpURLConnection  conn  =  (HttpURLConnection)  url.openConnection();  conn.setInstanceFollowRedirects(true);  conn.setConnectTimeout(timeoutMillis);  conn.setReadTimeout(timeoutMillis);  conn.connect();    int  res  =  conn.getResponseCode();  if  (res  !=  HttpURLConnection.HTTP_OK)  throw  new  IOException(res  +   "  error  loading  URL   "  +  url.toString());    [BUGGY]  String  contentType  =  conn  .setConnectTimeout  (  res  );  if  (contentType  ==  null  ||  !contentType.startsWith( "text/ "))  throw  new  IOException(String.format( "Unhandled  content  type  \ "%s\ "  on  URL  %s.  Must  be  text/* ",  contentType,  url.toString()));    InputStream  inStream  =  new  BufferedInputStream(conn.getInputStream());  String  charSet  =   "UTF-8 ";  //  todo[must]:  get  from  content-encoding,  or  http-equiv  (two-pass?)    String  data  =  readInputStream(inStream,  charSet);  inStream.close();  return  data;  }        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      URL  url  int  timeoutMillis  [VARIABLES]  HttpURLConnection    conn    boolean    InputStream    inStream    String    charSet    contentType    data    protocol    URL    url    int    res    timeoutMillis    
String  contentType  =  conn.getContentType  (  )  ;	[BUGGY]    [CONTEXT]  static  String  load(URL  url,  int  timeoutMillis)  throws  IOException  {  String  protocol  =  url.getProtocol();  Validate.isTrue(protocol.equals( "http ")  ||  protocol.equals( "https "),   "Only  http  &  https  protocols  supported ");    HttpURLConnection  conn  =  (HttpURLConnection)  url.openConnection();  conn.setInstanceFollowRedirects(true);  conn.setConnectTimeout(timeoutMillis);  conn.setReadTimeout(timeoutMillis);  conn.connect();    int  res  =  conn.getResponseCode();  if  (res  !=  HttpURLConnection.HTTP_OK)  throw  new  IOException(res  +   "  error  loading  URL   "  +  url.toString());    [BUGGY]  String  contentType  =  conn.getContentType();    if  (contentType  ==  null  ||  !contentType.startsWith( "text/ "))  throw  new  IOException(String.format( "Unhandled  content  type  \ "%s\ "  on  URL  %s.  Must  be  text/* ",  contentType,  url.toString()));    InputStream  inStream  =  new  BufferedInputStream(conn.getInputStream());  String  charSet  =   "UTF-8 ";  //  todo[must]:  get  from  content-encoding,  or  http-equiv  (two-pass?)    String  data  =  readInputStream(inStream,  charSet);  inStream.close();  return  data;        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      URL  url  int  timeoutMillis  [VARIABLES]  HttpURLConnection    conn    boolean    InputStream    inStream    String    charSet    contentType    data    protocol    URL    url    int    res    timeoutMillis    
if  (  contentType  ==  null  ||  !contentType.startsWith  (   "text/ "  )  )  t  contentType,  url.toString  (  )  )  )  ;	[BUGGY]  if  (  contentType  ==  null  ||  !contentType.startsWith(   "text/ "))t  contentType,  url.tochar(  )));  [CONTEXT]  static  String  load(URL  url,  int  timeoutMillis)  throws  IOException  {  String  protocol  =  url.getProtocol();  Validate.isTrue(protocol.equals( "http ")  ||  protocol.equals( "https "),   "Only  http  &  https  protocols  supported ");    HttpURLConnection  conn  =  (HttpURLConnection)  url.openConnection();  conn.setInstanceFollowRedirects(true);  conn.setConnectTimeout(timeoutMillis);  conn.setReadTimeout(timeoutMillis);  conn.connect();    int  res  =  conn.getResponseCode();  if  (res  !=  HttpURLConnection.HTTP_OK)  throw  new  IOException(res  +   "  error  loading  URL   "  +  url.toString());    String  contentType  =  conn.getContentType();  [BUGGY]  if(  contentType  ==  null  ||  !contentType.startsWith  (   "text/ "  ))  t  contentType,  url.tochar  ()))  ;        InputStream  inStream  =  new  BufferedInputStream(conn.getInputStream());  String  charSet  =   "UTF-8 ";  //  todo[must]:  get  from  content-encoding,  or  http-equiv  (two-pass?)    String  data  =  readInputStream(inStream,  charSet);  inStream.close();  return  data;  }        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      URL  url  int  timeoutMillis  [VARIABLES]  HttpURLConnection    conn    boolean    InputStream    inStream    String    charSet    contentType    data    protocol    URL    url    int    res    timeoutMillis    
if  (  contentType  ==  null  ||  !contentType.startsWith  (   "text/ "  )  )  t  contentType,  url.toString  (  )  )  )  ;	[BUGGY]  if  (  contentType  ==  null  &&  !contentType.startsWith(   "text/ "))t  contentType,  url.toString(  )));  [CONTEXT]  static  String  load(URL  url,  int  timeoutMillis)  throws  IOException  {  String  protocol  =  url.getProtocol();  Validate.isTrue(protocol.equals( "http ")  ||  protocol.equals( "https "),   "Only  http  &  https  protocols  supported ");    HttpURLConnection  conn  =  (HttpURLConnection)  url.openConnection();  conn.setInstanceFollowRedirects(true);  conn.setConnectTimeout(timeoutMillis);  conn.setReadTimeout(timeoutMillis);  conn.connect();    int  res  =  conn.getResponseCode();  if  (res  !=  HttpURLConnection.HTTP_OK)  throw  new  IOException(res  +   "  error  loading  URL   "  +  url.toString());    String  contentType  =  conn.getContentType();  [BUGGY]  if(  contentType  ==  null  &&  !contentType.startsWith  (   "text/ "  ))  t  contentType,  url.toString  ()))  ;        InputStream  inStream  =  new  BufferedInputStream(conn.getInputStream());  String  charSet  =   "UTF-8 ";  //  todo[must]:  get  from  content-encoding,  or  http-equiv  (two-pass?)    String  data  =  readInputStream(inStream,  charSet);  inStream.close();  return  data;  }        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      URL  url  int  timeoutMillis  [VARIABLES]  HttpURLConnection    conn    boolean    InputStream    inStream    String    charSet    contentType    data    protocol    URL    url    int    res    timeoutMillis    
if  (  contentType  ==  null  ||  !contentType.startsWith  (   "text/ "  )  )  t  contentType,  url.toString  (  )  )  )  ;	[BUGGY]  if  (  contentType  !=  null  ||  !contentType.startsWith(   "text/ "))t  contentType,  url.toString(  )));  [CONTEXT]  static  String  load(URL  url,  int  timeoutMillis)  throws  IOException  {  String  protocol  =  url.getProtocol();  Validate.isTrue(protocol.equals( "http ")  ||  protocol.equals( "https "),   "Only  http  &  https  protocols  supported ");    HttpURLConnection  conn  =  (HttpURLConnection)  url.openConnection();  conn.setInstanceFollowRedirects(true);  conn.setConnectTimeout(timeoutMillis);  conn.setReadTimeout(timeoutMillis);  conn.connect();    int  res  =  conn.getResponseCode();  if  (res  !=  HttpURLConnection.HTTP_OK)  throw  new  IOException(res  +   "  error  loading  URL   "  +  url.toString());    String  contentType  =  conn.getContentType();  [BUGGY]  if(  contentType  !=  null  ||  !contentType.startsWith  (   "text/ "  ))  t  contentType,  url.toString  ()))  ;        InputStream  inStream  =  new  BufferedInputStream(conn.getInputStream());  String  charSet  =   "UTF-8 ";  //  todo[must]:  get  from  content-encoding,  or  http-equiv  (two-pass?)    String  data  =  readInputStream(inStream,  charSet);  inStream.close();  return  data;  }        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      URL  url  int  timeoutMillis  [VARIABLES]  HttpURLConnection    conn    boolean    InputStream    inStream    String    charSet    contentType    data    protocol    URL    url    int    res    timeoutMillis    
if  (  contentType  ==  null  ||  !contentType.startsWith  (   "text/ "  )  )  t  contentType,  url.toString  (  )  )  )  ;	[BUGGY]  if  (  contentType  ==  null  ||  !contentType.startsWith(   "t "))t  contentType,  url.toString(  )));  [CONTEXT]  static  String  load(URL  url,  int  timeoutMillis)  throws  IOException  {  String  protocol  =  url.getProtocol();  Validate.isTrue(protocol.equals( "http ")  ||  protocol.equals( "https "),   "Only  http  &  https  protocols  supported ");    HttpURLConnection  conn  =  (HttpURLConnection)  url.openConnection();  conn.setInstanceFollowRedirects(true);  conn.setConnectTimeout(timeoutMillis);  conn.setReadTimeout(timeoutMillis);  conn.connect();    int  res  =  conn.getResponseCode();  if  (res  !=  HttpURLConnection.HTTP_OK)  throw  new  IOException(res  +   "  error  loading  URL   "  +  url.toString());    String  contentType  =  conn.getContentType();  [BUGGY]  if(  contentType  ==  null  ||  !contentType.startsWith  (   "t "  ))  t  contentType,  url.toString  ()))  ;        InputStream  inStream  =  new  BufferedInputStream(conn.getInputStream());  String  charSet  =   "UTF-8 ";  //  todo[must]:  get  from  content-encoding,  or  http-equiv  (two-pass?)    String  data  =  readInputStream(inStream,  charSet);  inStream.close();  return  data;  }        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      URL  url  int  timeoutMillis  [VARIABLES]  HttpURLConnection    conn    boolean    InputStream    inStream    String    charSet    contentType    data    protocol    URL    url    int    res    timeoutMillis    
if  (  contentType  ==  null  ||  !contentType.startsWith  (   "text/ "  )  )  t  contentType,  url.toString  (  )  )  )  ;	[BUGGY]  if  (  contentType  ==  null  ||  !contentType.startsWith(   "text/ "))t    url.toString(  )));  [CONTEXT]  static  String  load(URL  url,  int  timeoutMillis)  throws  IOException  {  String  protocol  =  url.getProtocol();  Validate.isTrue(protocol.equals( "http ")  ||  protocol.equals( "https "),   "Only  http  &  https  protocols  supported ");    HttpURLConnection  conn  =  (HttpURLConnection)  url.openConnection();  conn.setInstanceFollowRedirects(true);  conn.setConnectTimeout(timeoutMillis);  conn.setReadTimeout(timeoutMillis);  conn.connect();    int  res  =  conn.getResponseCode();  if  (res  !=  HttpURLConnection.HTTP_OK)  throw  new  IOException(res  +   "  error  loading  URL   "  +  url.toString());    String  contentType  =  conn.getContentType();  [BUGGY]  if(  contentType  ==  null  ||  !contentType.startsWith  (   "text/ "  ))  turl.toString  ()))  ;        InputStream  inStream  =  new  BufferedInputStream(conn.getInputStream());  String  charSet  =   "UTF-8 ";  //  todo[must]:  get  from  content-encoding,  or  http-equiv  (two-pass?)    String  data  =  readInputStream(inStream,  charSet);  inStream.close();  return  data;  }        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      URL  url  int  timeoutMillis  [VARIABLES]  HttpURLConnection    conn    boolean    InputStream    inStream    String    charSet    contentType    data    protocol    URL    url    int    res    timeoutMillis    
if  (  contentType  ==  null  ||  !contentType.startsWith  (   "text/ "  )  )  t  contentType,  url.toString  (  )  )  )  ;	[BUGGY]  if  (  contentType  ==  null  ||  !contentType.startsWith(   "text/ "))t  contentType.toString(  )));  [CONTEXT]  static  String  load(URL  url,  int  timeoutMillis)  throws  IOException  {  String  protocol  =  url.getProtocol();  Validate.isTrue(protocol.equals( "http ")  ||  protocol.equals( "https "),   "Only  http  &  https  protocols  supported ");    HttpURLConnection  conn  =  (HttpURLConnection)  url.openConnection();  conn.setInstanceFollowRedirects(true);  conn.setConnectTimeout(timeoutMillis);  conn.setReadTimeout(timeoutMillis);  conn.connect();    int  res  =  conn.getResponseCode();  if  (res  !=  HttpURLConnection.HTTP_OK)  throw  new  IOException(res  +   "  error  loading  URL   "  +  url.toString());    String  contentType  =  conn.getContentType();  [BUGGY]  if(  contentType  ==  null  ||  !contentType.startsWith  (   "text/ "  ))  t  contentType.toString  ()))  ;        InputStream  inStream  =  new  BufferedInputStream(conn.getInputStream());  String  charSet  =   "UTF-8 ";  //  todo[must]:  get  from  content-encoding,  or  http-equiv  (two-pass?)    String  data  =  readInputStream(inStream,  charSet);  inStream.close();  return  data;  }        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      URL  url  int  timeoutMillis  [VARIABLES]  HttpURLConnection    conn    boolean    InputStream    inStream    String    charSet    contentType    data    protocol    URL    url    int    res    timeoutMillis    
if  (  contentType  ==  null  ||  !contentType.startsWith  (   "text/ "  )  )  t  contentType,  url.toString  (  )  )  )  ;	[BUGGY]  if  (  protocol  ==  null  ||  !contentType.startsWith(   "text/ "))t  contentType,  url.toString(  )));  [CONTEXT]  static  String  load(URL  url,  int  timeoutMillis)  throws  IOException  {  String  protocol  =  url.getProtocol();  Validate.isTrue(protocol.equals( "http ")  ||  protocol.equals( "https "),   "Only  http  &  https  protocols  supported ");    HttpURLConnection  conn  =  (HttpURLConnection)  url.openConnection();  conn.setInstanceFollowRedirects(true);  conn.setConnectTimeout(timeoutMillis);  conn.setReadTimeout(timeoutMillis);  conn.connect();    int  res  =  conn.getResponseCode();  if  (res  !=  HttpURLConnection.HTTP_OK)  throw  new  IOException(res  +   "  error  loading  URL   "  +  url.toString());    String  contentType  =  conn.getContentType();  [BUGGY]  if(  protocol  ==  null  ||  !contentType.startsWith  (   "text/ "  ))  t  contentType,  url.toString  ()))  ;        InputStream  inStream  =  new  BufferedInputStream(conn.getInputStream());  String  charSet  =   "UTF-8 ";  //  todo[must]:  get  from  content-encoding,  or  http-equiv  (two-pass?)    String  data  =  readInputStream(inStream,  charSet);  inStream.close();  return  data;  }        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      URL  url  int  timeoutMillis  [VARIABLES]  HttpURLConnection    conn    boolean    InputStream    inStream    String    charSet    contentType    data    protocol    URL    url    int    res    timeoutMillis    
if  (  contentType  ==  null  ||  !contentType.startsWith  (   "text/ "  )  )  t  contentType,  url.toString  (  )  )  )  ;	[BUGGY]  if  (  url  ==  null  ||  !contentType.startsWith(   "text/ "))t  contentType,  contentType.toString(  )));  [CONTEXT]  static  String  load(URL  url,  int  timeoutMillis)  throws  IOException  {  String  protocol  =  url.getProtocol();  Validate.isTrue(protocol.equals( "http ")  ||  protocol.equals( "https "),   "Only  http  &  https  protocols  supported ");    HttpURLConnection  conn  =  (HttpURLConnection)  url.openConnection();  conn.setInstanceFollowRedirects(true);  conn.setConnectTimeout(timeoutMillis);  conn.setReadTimeout(timeoutMillis);  conn.connect();    int  res  =  conn.getResponseCode();  if  (res  !=  HttpURLConnection.HTTP_OK)  throw  new  IOException(res  +   "  error  loading  URL   "  +  url.toString());    String  contentType  =  conn.getContentType();  [BUGGY]  if(  url  ==  null  ||  !contentType.startsWith  (   "text/ "  ))  t  contentType,  contentType.toString  ()))  ;        InputStream  inStream  =  new  BufferedInputStream(conn.getInputStream());  String  charSet  =   "UTF-8 ";  //  todo[must]:  get  from  content-encoding,  or  http-equiv  (two-pass?)    String  data  =  readInputStream(inStream,  charSet);  inStream.close();  return  data;  }        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      URL  url  int  timeoutMillis  [VARIABLES]  HttpURLConnection    conn    boolean    InputStream    inStream    String    charSet    contentType    data    protocol    URL    url    int    res    timeoutMillis    
if  (  contentType  ==  null  ||  !contentType.startsWith  (   "text/ "  )  )  t  contentType,  url.toString  (  )  )  )  ;	[BUGGY]  if  (  contentType  ==  null);  [CONTEXT]  static  String  load(URL  url,  int  timeoutMillis)  throws  IOException  {  String  protocol  =  url.getProtocol();  Validate.isTrue(protocol.equals( "http ")  ||  protocol.equals( "https "),   "Only  http  &  https  protocols  supported ");    HttpURLConnection  conn  =  (HttpURLConnection)  url.openConnection();  conn.setInstanceFollowRedirects(true);  conn.setConnectTimeout(timeoutMillis);  conn.setReadTimeout(timeoutMillis);  conn.connect();    int  res  =  conn.getResponseCode();  if  (res  !=  HttpURLConnection.HTTP_OK)  throw  new  IOException(res  +   "  error  loading  URL   "  +  url.toString());    String  contentType  =  conn.getContentType();  [BUGGY]  if(  contentType  ==  null  )  ;        InputStream  inStream  =  new  BufferedInputStream(conn.getInputStream());  String  charSet  =   "UTF-8 ";  //  todo[must]:  get  from  content-encoding,  or  http-equiv  (two-pass?)    String  data  =  readInputStream(inStream,  charSet);  inStream.close();  return  data;  }        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      URL  url  int  timeoutMillis  [VARIABLES]  HttpURLConnection    conn    boolean    InputStream    inStream    String    charSet    contentType    data    protocol    URL    url    int    res    timeoutMillis    
if  (  contentType  ==  null  ||  !contentType.startsWith  (   "text/ "  )  )  t  contentType,  url.toString  (  )  )  )  ;	[BUGGY]  if  (  contentType  ==  null  ||  !contentType.format(   "text/ "))t  contentType,  url.toString(  )));  [CONTEXT]  static  String  load(URL  url,  int  timeoutMillis)  throws  IOException  {  String  protocol  =  url.getProtocol();  Validate.isTrue(protocol.equals( "http ")  ||  protocol.equals( "https "),   "Only  http  &  https  protocols  supported ");    HttpURLConnection  conn  =  (HttpURLConnection)  url.openConnection();  conn.setInstanceFollowRedirects(true);  conn.setConnectTimeout(timeoutMillis);  conn.setReadTimeout(timeoutMillis);  conn.connect();    int  res  =  conn.getResponseCode();  if  (res  !=  HttpURLConnection.HTTP_OK)  throw  new  IOException(res  +   "  error  loading  URL   "  +  url.toString());    String  contentType  =  conn.getContentType();  [BUGGY]  if(  contentType  ==  null  ||  !contentType.format  (   "text/ "  ))  t  contentType,  url.toString  ()))  ;        InputStream  inStream  =  new  BufferedInputStream(conn.getInputStream());  String  charSet  =   "UTF-8 ";  //  todo[must]:  get  from  content-encoding,  or  http-equiv  (two-pass?)    String  data  =  readInputStream(inStream,  charSet);  inStream.close();  return  data;  }        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      URL  url  int  timeoutMillis  [VARIABLES]  HttpURLConnection    conn    boolean    InputStream    inStream    String    charSet    contentType    data    protocol    URL    url    int    res    timeoutMillis    
if  (  contentType  ==  null  ||  !contentType.startsWith  (   "text/ "  )  )  t  contentType,  url.toString  (  )  )  )  ;	[BUGGY]  if  (  contentType  ==  null  ||  !contentType  .format(  charSet  ,  charSet)  )t  contentType,  url.toString(  )));  [CONTEXT]  static  String  load(URL  url,  int  timeoutMillis)  throws  IOException  {  String  protocol  =  url.getProtocol();  Validate.isTrue(protocol.equals( "http ")  ||  protocol.equals( "https "),   "Only  http  &  https  protocols  supported ");    HttpURLConnection  conn  =  (HttpURLConnection)  url.openConnection();  conn.setInstanceFollowRedirects(true);  conn.setConnectTimeout(timeoutMillis);  conn.setReadTimeout(timeoutMillis);  conn.connect();    int  res  =  conn.getResponseCode();  if  (res  !=  HttpURLConnection.HTTP_OK)  throw  new  IOException(res  +   "  error  loading  URL   "  +  url.toString());    String  contentType  =  conn.getContentType();  [BUGGY]  if(  contentType  ==  null  ||  !contentType  .format  (  charSet  ,  charSet  )  )  t  contentType,  url.toString  ()))  ;        InputStream  inStream  =  new  BufferedInputStream(conn.getInputStream());  String  charSet  =   "UTF-8 ";  //  todo[must]:  get  from  content-encoding,  or  http-equiv  (two-pass?)    String  data  =  readInputStream(inStream,  charSet);  inStream.close();  return  data;  }        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      URL  url  int  timeoutMillis  [VARIABLES]  HttpURLConnection    conn    boolean    InputStream    inStream    String    charSet    contentType    data    protocol    URL    url    int    res    timeoutMillis    
if  (  contentType  ==  null  ||  !contentType.startsWith  (   "text/ "  )  )  t  contentType,  url.toString  (  )  )  )  ;	[BUGGY]  if  (  contentType  ==  false  ||  !contentType.format(   "text/ "))t  contentType,  url.toString(  )));  [CONTEXT]  static  String  load(URL  url,  int  timeoutMillis)  throws  IOException  {  String  protocol  =  url.getProtocol();  Validate.isTrue(protocol.equals( "http ")  ||  protocol.equals( "https "),   "Only  http  &  https  protocols  supported ");    HttpURLConnection  conn  =  (HttpURLConnection)  url.openConnection();  conn.setInstanceFollowRedirects(true);  conn.setConnectTimeout(timeoutMillis);  conn.setReadTimeout(timeoutMillis);  conn.connect();    int  res  =  conn.getResponseCode();  if  (res  !=  HttpURLConnection.HTTP_OK)  throw  new  IOException(res  +   "  error  loading  URL   "  +  url.toString());    String  contentType  =  conn.getContentType();  [BUGGY]  if(  contentType  ==  false  ||  !contentType.format  (   "text/ "  ))  t  contentType,  url.toString  ()))  ;        InputStream  inStream  =  new  BufferedInputStream(conn.getInputStream());  String  charSet  =   "UTF-8 ";  //  todo[must]:  get  from  content-encoding,  or  http-equiv  (two-pass?)    String  data  =  readInputStream(inStream,  charSet);  inStream.close();  return  data;  }        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      URL  url  int  timeoutMillis  [VARIABLES]  HttpURLConnection    conn    boolean    InputStream    inStream    String    charSet    contentType    data    protocol    URL    url    int    res    timeoutMillis    
t  contentType,  url.toString  (  )  )  )  ;	[BUGGY]  t    url.toString(  )));  [CONTEXT]  static  String  load(URL  url,  int  timeoutMillis)  throws  IOException  {  String  protocol  =  url.getProtocol();  Validate.isTrue(protocol.equals( "http ")  ||  protocol.equals( "https "),   "Only  http  &  https  protocols  supported ");    HttpURLConnection  conn  =  (HttpURLConnection)  url.openConnection();  conn.setInstanceFollowRedirects(true);  conn.setConnectTimeout(timeoutMillis);  conn.setReadTimeout(timeoutMillis);  conn.connect();    int  res  =  conn.getResponseCode();  if  (res  !=  HttpURLConnection.HTTP_OK)  throw  new  IOException(res  +   "  error  loading  URL   "  +  url.toString());    String  contentType  =  conn.getContentType();  if  (contentType  ==  null  ||  !contentType.startsWith( "text/ "))  [BUGGY]  turl.toString  ()))  ;      InputStream  inStream  =  new  BufferedInputStream(conn.getInputStream());  String  charSet  =   "UTF-8 ";  //  todo[must]:  get  from  content-encoding,  or  http-equiv  (two-pass?)    String  data  =  readInputStream(inStream,  charSet);  inStream.close();  return  data;  }        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      URL  url  int  timeoutMillis  [VARIABLES]  HttpURLConnection    conn    boolean    InputStream    inStream    String    charSet    contentType    data    protocol    URL    url    int    res    timeoutMillis    
t  contentType,  url.toString  (  )  )  )  ;	[BUGGY]  t  contentType.toString(  )));  [CONTEXT]  static  String  load(URL  url,  int  timeoutMillis)  throws  IOException  {  String  protocol  =  url.getProtocol();  Validate.isTrue(protocol.equals( "http ")  ||  protocol.equals( "https "),   "Only  http  &  https  protocols  supported ");    HttpURLConnection  conn  =  (HttpURLConnection)  url.openConnection();  conn.setInstanceFollowRedirects(true);  conn.setConnectTimeout(timeoutMillis);  conn.setReadTimeout(timeoutMillis);  conn.connect();    int  res  =  conn.getResponseCode();  if  (res  !=  HttpURLConnection.HTTP_OK)  throw  new  IOException(res  +   "  error  loading  URL   "  +  url.toString());    String  contentType  =  conn.getContentType();  if  (contentType  ==  null  ||  !contentType.startsWith( "text/ "))  [BUGGY]  t  contentType.toString  ()))  ;      InputStream  inStream  =  new  BufferedInputStream(conn.getInputStream());  String  charSet  =   "UTF-8 ";  //  todo[must]:  get  from  content-encoding,  or  http-equiv  (two-pass?)    String  data  =  readInputStream(inStream,  charSet);  inStream.close();  return  data;  }        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      URL  url  int  timeoutMillis  [VARIABLES]  HttpURLConnection    conn    boolean    InputStream    inStream    String    charSet    contentType    data    protocol    URL    url    int    res    timeoutMillis    
t  contentType,  url.toString  (  )  )  )  ;	[BUGGY]  t  protocol,  url.toString(  )));  [CONTEXT]  static  String  load(URL  url,  int  timeoutMillis)  throws  IOException  {  String  protocol  =  url.getProtocol();  Validate.isTrue(protocol.equals( "http ")  ||  protocol.equals( "https "),   "Only  http  &  https  protocols  supported ");    HttpURLConnection  conn  =  (HttpURLConnection)  url.openConnection();  conn.setInstanceFollowRedirects(true);  conn.setConnectTimeout(timeoutMillis);  conn.setReadTimeout(timeoutMillis);  conn.connect();    int  res  =  conn.getResponseCode();  if  (res  !=  HttpURLConnection.HTTP_OK)  throw  new  IOException(res  +   "  error  loading  URL   "  +  url.toString());    String  contentType  =  conn.getContentType();  if  (contentType  ==  null  ||  !contentType.startsWith( "text/ "))  [BUGGY]  t  protocol,  url.toString  ()))  ;      InputStream  inStream  =  new  BufferedInputStream(conn.getInputStream());  String  charSet  =   "UTF-8 ";  //  todo[must]:  get  from  content-encoding,  or  http-equiv  (two-pass?)    String  data  =  readInputStream(inStream,  charSet);  inStream.close();  return  data;  }        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      URL  url  int  timeoutMillis  [VARIABLES]  HttpURLConnection    conn    boolean    InputStream    inStream    String    charSet    contentType    data    protocol    URL    url    int    res    timeoutMillis    
t  contentType,  url.toString  (  )  )  )  ;	[BUGGY]  t  url,  contentType.toString(  )));  [CONTEXT]  static  String  load(URL  url,  int  timeoutMillis)  throws  IOException  {  String  protocol  =  url.getProtocol();  Validate.isTrue(protocol.equals( "http ")  ||  protocol.equals( "https "),   "Only  http  &  https  protocols  supported ");    HttpURLConnection  conn  =  (HttpURLConnection)  url.openConnection();  conn.setInstanceFollowRedirects(true);  conn.setConnectTimeout(timeoutMillis);  conn.setReadTimeout(timeoutMillis);  conn.connect();    int  res  =  conn.getResponseCode();  if  (res  !=  HttpURLConnection.HTTP_OK)  throw  new  IOException(res  +   "  error  loading  URL   "  +  url.toString());    String  contentType  =  conn.getContentType();  if  (contentType  ==  null  ||  !contentType.startsWith( "text/ "))  [BUGGY]  t  url,  contentType.toString  ()))  ;      InputStream  inStream  =  new  BufferedInputStream(conn.getInputStream());  String  charSet  =   "UTF-8 ";  //  todo[must]:  get  from  content-encoding,  or  http-equiv  (two-pass?)    String  data  =  readInputStream(inStream,  charSet);  inStream.close();  return  data;  }        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      URL  url  int  timeoutMillis  [VARIABLES]  HttpURLConnection    conn    boolean    InputStream    inStream    String    charSet    contentType    data    protocol    URL    url    int    res    timeoutMillis    
t  contentType,  url.toString  (  )  )  )  ;	[BUGGY]  t  contentType,  url  .getProtocol(  )  ));  [CONTEXT]  static  String  load(URL  url,  int  timeoutMillis)  throws  IOException  {  String  protocol  =  url.getProtocol();  Validate.isTrue(protocol.equals( "http ")  ||  protocol.equals( "https "),   "Only  http  &  https  protocols  supported ");    HttpURLConnection  conn  =  (HttpURLConnection)  url.openConnection();  conn.setInstanceFollowRedirects(true);  conn.setConnectTimeout(timeoutMillis);  conn.setReadTimeout(timeoutMillis);  conn.connect();    int  res  =  conn.getResponseCode();  if  (res  !=  HttpURLConnection.HTTP_OK)  throw  new  IOException(res  +   "  error  loading  URL   "  +  url.toString());    String  contentType  =  conn.getContentType();  if  (contentType  ==  null  ||  !contentType.startsWith( "text/ "))  [BUGGY]  t  contentType,  url  .getProtocol  ()  ))  ;      InputStream  inStream  =  new  BufferedInputStream(conn.getInputStream());  String  charSet  =   "UTF-8 ";  //  todo[must]:  get  from  content-encoding,  or  http-equiv  (two-pass?)    String  data  =  readInputStream(inStream,  charSet);  inStream.close();  return  data;  }        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      URL  url  int  timeoutMillis  [VARIABLES]  HttpURLConnection    conn    boolean    InputStream    inStream    String    charSet    contentType    data    protocol    URL    url    int    res    timeoutMillis    
t  contentType,  url.toString  (  )  )  )  ;	[BUGGY]  t  contentType,  url.tochar(  )));  [CONTEXT]  static  String  load(URL  url,  int  timeoutMillis)  throws  IOException  {  String  protocol  =  url.getProtocol();  Validate.isTrue(protocol.equals( "http ")  ||  protocol.equals( "https "),   "Only  http  &  https  protocols  supported ");    HttpURLConnection  conn  =  (HttpURLConnection)  url.openConnection();  conn.setInstanceFollowRedirects(true);  conn.setConnectTimeout(timeoutMillis);  conn.setReadTimeout(timeoutMillis);  conn.connect();    int  res  =  conn.getResponseCode();  if  (res  !=  HttpURLConnection.HTTP_OK)  throw  new  IOException(res  +   "  error  loading  URL   "  +  url.toString());    String  contentType  =  conn.getContentType();  if  (contentType  ==  null  ||  !contentType.startsWith( "text/ "))  [BUGGY]  t  contentType,  url.tochar  ()))  ;      InputStream  inStream  =  new  BufferedInputStream(conn.getInputStream());  String  charSet  =   "UTF-8 ";  //  todo[must]:  get  from  content-encoding,  or  http-equiv  (two-pass?)    String  data  =  readInputStream(inStream,  charSet);  inStream.close();  return  data;  }        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      URL  url  int  timeoutMillis  [VARIABLES]  HttpURLConnection    conn    boolean    InputStream    inStream    String    charSet    contentType    data    protocol    URL    url    int    res    timeoutMillis    
t  contentType,  url.toString  (  )  )  )  ;	[BUGGY]    [CONTEXT]  static  String  load(URL  url,  int  timeoutMillis)  throws  IOException  {  String  protocol  =  url.getProtocol();  Validate.isTrue(protocol.equals( "http ")  ||  protocol.equals( "https "),   "Only  http  &  https  protocols  supported ");    HttpURLConnection  conn  =  (HttpURLConnection)  url.openConnection();  conn.setInstanceFollowRedirects(true);  conn.setConnectTimeout(timeoutMillis);  conn.setReadTimeout(timeoutMillis);  conn.connect();    int  res  =  conn.getResponseCode();  if  (res  !=  HttpURLConnection.HTTP_OK)  throw  new  IOException(res  +   "  error  loading  URL   "  +  url.toString());    String  contentType  =  conn.getContentType();  if  (contentType  ==  null  ||  !contentType.startsWith( "text/ "))  [BUGGY]  throw  new  IOException(String.format( "Unhandled  content  type  \ "%s\ "  on  URL  %s.  Must  be  text/* ",        InputStream  inStream  =  new  BufferedInputStream(conn.getInputStream());  String  charSet  =   "UTF-8 ";  //  todo[must]:  get  from  content-encoding,  or  http-equiv  (two-pass?)    String  data  =  readInputStream(inStream,  charSet);  inStream.close();  return  data;        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      URL  url  int  timeoutMillis  [VARIABLES]  HttpURLConnection    conn    boolean    InputStream    inStream    String    charSet    contentType    data    protocol    URL    url    int    res    timeoutMillis    
t  contentType,  url.toString  (  )  )  )  ;	[BUGGY]  contentType,  url.toString(  )));t  contentType,  url.toString(  )));  [CONTEXT]        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      URL  url  int  timeoutMillis  [VARIABLES]  HttpURLConnection    conn    boolean    InputStream    inStream    String    charSet    contentType    data    protocol    URL    url    int    res    timeoutMillis    
contentType,  url.toString  (  )  )  )  ;	[BUGGY]  contentType,  url  .getProtocol(  )  ));  [CONTEXT]  static  String  load(URL  url,  int  timeoutMillis)  throws  IOException  {  String  protocol  =  url.getProtocol();  Validate.isTrue(protocol.equals( "http ")  ||  protocol.equals( "https "),   "Only  http  &  https  protocols  supported ");    HttpURLConnection  conn  =  (HttpURLConnection)  url.openConnection();  conn.setInstanceFollowRedirects(true);  conn.setConnectTimeout(timeoutMillis);  conn.setReadTimeout(timeoutMillis);  conn.connect();    int  res  =  conn.getResponseCode();  if  (res  !=  HttpURLConnection.HTTP_OK)  throw  new  IOException(res  +   "  error  loading  URL   "  +  url.toString());    String  contentType  =  conn.getContentType();  if  (contentType  ==  null  ||  !contentType.startsWith( "text/ "))  throw  new  IOException(String.format( "Unhandled  content  type  \ "%s\ "  on  URL  %s.  Must  be  text/* ",  [BUGGY]  contentType,  url  .getProtocol  ()  ))  ;    InputStream  inStream  =  new  BufferedInputStream(conn.getInputStream());  String  charSet  =   "UTF-8 ";  //  todo[must]:  get  from  content-encoding,  or  http-equiv  (two-pass?)    String  data  =  readInputStream(inStream,  charSet);  inStream.close();  return  data;  }        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      URL  url  int  timeoutMillis  [VARIABLES]  HttpURLConnection    conn    boolean    InputStream    inStream    String    charSet    contentType    data    protocol    URL    url    int    res    timeoutMillis    
contentType,  url.toString  (  )  )  )  ;	[BUGGY]    [CONTEXT]  static  String  load(URL  url,  int  timeoutMillis)  throws  IOException  {  String  protocol  =  url.getProtocol();  Validate.isTrue(protocol.equals( "http ")  ||  protocol.equals( "https "),   "Only  http  &  https  protocols  supported ");    HttpURLConnection  conn  =  (HttpURLConnection)  url.openConnection();  conn.setInstanceFollowRedirects(true);  conn.setConnectTimeout(timeoutMillis);  conn.setReadTimeout(timeoutMillis);  conn.connect();    int  res  =  conn.getResponseCode();  if  (res  !=  HttpURLConnection.HTTP_OK)  throw  new  IOException(res  +   "  error  loading  URL   "  +  url.toString());    String  contentType  =  conn.getContentType();  if  (contentType  ==  null  ||  !contentType.startsWith( "text/ "))  throw  new  IOException(String.format( "Unhandled  content  type  \ "%s\ "  on  URL  %s.  Must  be  text/* ",  [BUGGY]  contentType,  url.toString()));      InputStream  inStream  =  new  BufferedInputStream(conn.getInputStream());  String  charSet  =   "UTF-8 ";  //  todo[must]:  get  from  content-encoding,  or  http-equiv  (two-pass?)    String  data  =  readInputStream(inStream,  charSet);  inStream.close();  return  data;        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      URL  url  int  timeoutMillis  [VARIABLES]  HttpURLConnection    conn    boolean    InputStream    inStream    String    charSet    contentType    data    protocol    URL    url    int    res    timeoutMillis    
t  contentType,  url.toString  (  )  )  )  ;	[BUGGY]  return  ;  [CONTEXT]  static  String  load(URL  url,  int  timeoutMillis)  throws  IOException  {  String  protocol  =  url.getProtocol();  Validate.isTrue(protocol.equals( "http ")  ||  protocol.equals( "https "),   "Only  http  &  https  protocols  supported ");    HttpURLConnection  conn  =  (HttpURLConnection)  url.openConnection();  conn.setInstanceFollowRedirects(true);  conn.setConnectTimeout(timeoutMillis);  conn.setReadTimeout(timeoutMillis);  conn.connect();    int  res  =  conn.getResponseCode();  if  (res  !=  HttpURLConnection.HTTP_OK)  throw  new  IOException(res  +   "  error  loading  URL   "  +  url.toString());    String  contentType  =  conn.getContentType();  if  (contentType  ==  null  ||  !contentType.startsWith( "text/ "))  [BUGGY]  return  ;      InputStream  inStream  =  new  BufferedInputStream(conn.getInputStream());  String  charSet  =   "UTF-8 ";  //  todo[must]:  get  from  content-encoding,  or  http-equiv  (two-pass?)    String  data  =  readInputStream(inStream,  charSet);  inStream.close();  return  data;  }        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      URL  url  int  timeoutMillis  [VARIABLES]  HttpURLConnection    conn    boolean    InputStream    inStream    String    charSet    contentType    data    protocol    URL    url    int    res    timeoutMillis    
if  (  contentType  ==  null  ||  !contentType.startsWith  (   "text/ "  )  )  t  contentType,  url.toString  (  )  )  )  ;	[BUGGY]  if  (  contentType  ==  null  ||  !contentType.startsWith(   "text "))t  contentType,  url.toString(  )));  [CONTEXT]  static  String  load(URL  url,  int  timeoutMillis)  throws  IOException  {  String  protocol  =  url.getProtocol();  Validate.isTrue(protocol.equals( "http ")  ||  protocol.equals( "https "),   "Only  http  &  https  protocols  supported ");    HttpURLConnection  conn  =  (HttpURLConnection)  url.openConnection();  conn.setInstanceFollowRedirects(true);  conn.setConnectTimeout(timeoutMillis);  conn.setReadTimeout(timeoutMillis);  conn.connect();    int  res  =  conn.getResponseCode();  if  (res  !=  HttpURLConnection.HTTP_OK)  throw  new  IOException(res  +   "  error  loading  URL   "  +  url.toString());    String  contentType  =  conn.getContentType();  [BUGGY]  if(  contentType  ==  null  ||  !contentType.startsWith  (   "text "  ))  t  contentType,  url.toString  ()))  ;        InputStream  inStream  =  new  BufferedInputStream(conn.getInputStream());  String  charSet  =   "UTF-8 ";  //  todo[must]:  get  from  content-encoding,  or  http-equiv  (two-pass?)    String  data  =  readInputStream(inStream,  charSet);  inStream.close();  return  data;  }        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      URL  url  int  timeoutMillis  [VARIABLES]  HttpURLConnection    conn    boolean    InputStream    inStream    String    charSet    contentType    data    protocol    URL    url    int    res    timeoutMillis    
InputStream  inStream  =  new  BufferedInputStream  (  conn.getInputStream  (  )  )  ;	[BUGGY]  InputStream  inStream  =  new  BufferedInputStream(  conn.setReadTimeout(  ));  [CONTEXT]  static  String  load(URL  url,  int  timeoutMillis)  throws  IOException  {  String  protocol  =  url.getProtocol();  Validate.isTrue(protocol.equals( "http ")  ||  protocol.equals( "https "),   "Only  http  &  https  protocols  supported ");    HttpURLConnection  conn  =  (HttpURLConnection)  url.openConnection();  conn.setInstanceFollowRedirects(true);  conn.setConnectTimeout(timeoutMillis);  conn.setReadTimeout(timeoutMillis);  conn.connect();    int  res  =  conn.getResponseCode();  if  (res  !=  HttpURLConnection.HTTP_OK)  throw  new  IOException(res  +   "  error  loading  URL   "  +  url.toString());    String  contentType  =  conn.getContentType();  if  (contentType  ==  null  ||  !contentType.startsWith( "text/ "))  throw  new  IOException(String.format( "Unhandled  content  type  \ "%s\ "  on  URL  %s.  Must  be  text/* ",  contentType,  url.toString()));    [BUGGY]  InputStream  inStream  =  new  BufferedInputStream  (  conn.setReadTimeout  ())  ;  String  charSet  =   "UTF-8 ";  //  todo[must]:  get  from  content-encoding,  or  http-equiv  (two-pass?)    String  data  =  readInputStream(inStream,  charSet);  inStream.close();  return  data;  }        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      URL  url  int  timeoutMillis  [VARIABLES]  HttpURLConnection    conn    boolean    InputStream    inStream    String    charSet    contentType    data    protocol    URL    url    int    res    timeoutMillis    
InputStream  inStream  =  new  BufferedInputStream  (  conn.getInputStream  (  )  )  ;	[BUGGY]  InputStream  inStream  =  new  FileInputStream(  in);InputStream  inStream  =  new  BufferedInputStream(  conn.getInputStream(  ));  [CONTEXT]        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      URL  url  int  timeoutMillis  [VARIABLES]  HttpURLConnection    conn    boolean    InputStream    inStream    String    charSet    contentType    data    protocol    URL    url    int    res    timeoutMillis    
InputStream  inStream  =  new  BufferedInputStream  (  conn.getInputStream  (  )  )  ;	[BUGGY]  InputStream  inStream  =  new  BufferedInputStream(  conn  .getResponseCode(  )  );  [CONTEXT]  static  String  load(URL  url,  int  timeoutMillis)  throws  IOException  {  String  protocol  =  url.getProtocol();  Validate.isTrue(protocol.equals( "http ")  ||  protocol.equals( "https "),   "Only  http  &  https  protocols  supported ");    HttpURLConnection  conn  =  (HttpURLConnection)  url.openConnection();  conn.setInstanceFollowRedirects(true);  conn.setConnectTimeout(timeoutMillis);  conn.setReadTimeout(timeoutMillis);  conn.connect();    int  res  =  conn.getResponseCode();  if  (res  !=  HttpURLConnection.HTTP_OK)  throw  new  IOException(res  +   "  error  loading  URL   "  +  url.toString());    String  contentType  =  conn.getContentType();  if  (contentType  ==  null  ||  !contentType.startsWith( "text/ "))  throw  new  IOException(String.format( "Unhandled  content  type  \ "%s\ "  on  URL  %s.  Must  be  text/* ",  contentType,  url.toString()));    [BUGGY]  InputStream  inStream  =  new  BufferedInputStream  (  conn  .getResponseCode  ()  )  ;  String  charSet  =   "UTF-8 ";  //  todo[must]:  get  from  content-encoding,  or  http-equiv  (two-pass?)    String  data  =  readInputStream(inStream,  charSet);  inStream.close();  return  data;  }        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      URL  url  int  timeoutMillis  [VARIABLES]  HttpURLConnection    conn    boolean    InputStream    inStream    String    charSet    contentType    data    protocol    URL    url    int    res    timeoutMillis    
InputStream  inStream  =  new  BufferedInputStream  (  conn.getInputStream  (  )  )  ;  String  charSet  =   "UTF-8 ";	[BUGGY]    [CONTEXT]  static  String  load(URL  url,  int  timeoutMillis)  throws  IOException  {  String  protocol  =  url.getProtocol();  Validate.isTrue(protocol.equals( "http ")  ||  protocol.equals( "https "),   "Only  http  &  https  protocols  supported ");    HttpURLConnection  conn  =  (HttpURLConnection)  url.openConnection();  conn.setInstanceFollowRedirects(true);  conn.setConnectTimeout(timeoutMillis);  conn.setReadTimeout(timeoutMillis);  conn.connect();    int  res  =  conn.getResponseCode();  if  (res  !=  HttpURLConnection.HTTP_OK)  throw  new  IOException(res  +   "  error  loading  URL   "  +  url.toString());    String  contentType  =  conn.getContentType();  if  (contentType  ==  null  ||  !contentType.startsWith( "text/ "))  throw  new  IOException(String.format( "Unhandled  content  type  \ "%s\ "  on  URL  %s.  Must  be  text/* ",  contentType,  url.toString()));    [BUGGY]  InputStream  inStream  =  new  BufferedInputStream(conn.getInputStream());        String  data  =  readInputStream(inStream,  charSet);  inStream.close();  return  data;        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      URL  url  int  timeoutMillis  [VARIABLES]  HttpURLConnection    conn    boolean    InputStream    inStream    String    charSet    contentType    data    protocol    URL    url    int    res    timeoutMillis    
String  charSet  =   "UTF-8 ";	[BUGGY]  char  charSet  =   "UTF-8 ";  [CONTEXT]  static  String  load(URL  url,  int  timeoutMillis)  throws  IOException  {  String  protocol  =  url.getProtocol();  Validate.isTrue(protocol.equals( "http ")  ||  protocol.equals( "https "),   "Only  http  &  https  protocols  supported ");    HttpURLConnection  conn  =  (HttpURLConnection)  url.openConnection();  conn.setInstanceFollowRedirects(true);  conn.setConnectTimeout(timeoutMillis);  conn.setReadTimeout(timeoutMillis);  conn.connect();    int  res  =  conn.getResponseCode();  if  (res  !=  HttpURLConnection.HTTP_OK)  throw  new  IOException(res  +   "  error  loading  URL   "  +  url.toString());    String  contentType  =  conn.getContentType();  if  (contentType  ==  null  ||  !contentType.startsWith( "text/ "))  throw  new  IOException(String.format( "Unhandled  content  type  \ "%s\ "  on  URL  %s.  Must  be  text/* ",  contentType,  url.toString()));    InputStream  inStream  =  new  BufferedInputStream(conn.getInputStream());  [BUGGY]  char  charSet  =   "UTF-8 ";    String  data  =  readInputStream(inStream,  charSet);  inStream.close();  return  data;  }        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      URL  url  int  timeoutMillis  [VARIABLES]  HttpURLConnection    conn    boolean    InputStream    inStream    String    charSet    contentType    data    protocol    URL    url    int    res    timeoutMillis    
String  charSet  =   "UTF-8 ";	[BUGGY]  String  charSet  =   "UTF-8U ";  [CONTEXT]  static  String  load(URL  url,  int  timeoutMillis)  throws  IOException  {  String  protocol  =  url.getProtocol();  Validate.isTrue(protocol.equals( "http ")  ||  protocol.equals( "https "),   "Only  http  &  https  protocols  supported ");    HttpURLConnection  conn  =  (HttpURLConnection)  url.openConnection();  conn.setInstanceFollowRedirects(true);  conn.setConnectTimeout(timeoutMillis);  conn.setReadTimeout(timeoutMillis);  conn.connect();    int  res  =  conn.getResponseCode();  if  (res  !=  HttpURLConnection.HTTP_OK)  throw  new  IOException(res  +   "  error  loading  URL   "  +  url.toString());    String  contentType  =  conn.getContentType();  if  (contentType  ==  null  ||  !contentType.startsWith( "text/ "))  throw  new  IOException(String.format( "Unhandled  content  type  \ "%s\ "  on  URL  %s.  Must  be  text/* ",  contentType,  url.toString()));    InputStream  inStream  =  new  BufferedInputStream(conn.getInputStream());  [BUGGY]  String  charSet  =   "UTF-8U ";    String  data  =  readInputStream(inStream,  charSet);  inStream.close();  return  data;  }        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      URL  url  int  timeoutMillis  [VARIABLES]  HttpURLConnection    conn    boolean    InputStream    inStream    String    charSet    contentType    data    protocol    URL    url    int    res    timeoutMillis    
String  data  =  readInputStream  (  inStream,  charSet  )  ;	[BUGGY]  char  data  =  readInputStream(  inStream,  charSet);  [CONTEXT]  static  String  load(URL  url,  int  timeoutMillis)  throws  IOException  {  String  protocol  =  url.getProtocol();  Validate.isTrue(protocol.equals( "http ")  ||  protocol.equals( "https "),   "Only  http  &  https  protocols  supported ");    HttpURLConnection  conn  =  (HttpURLConnection)  url.openConnection();  conn.setInstanceFollowRedirects(true);  conn.setConnectTimeout(timeoutMillis);  conn.setReadTimeout(timeoutMillis);  conn.connect();    int  res  =  conn.getResponseCode();  if  (res  !=  HttpURLConnection.HTTP_OK)  throw  new  IOException(res  +   "  error  loading  URL   "  +  url.toString());    String  contentType  =  conn.getContentType();  if  (contentType  ==  null  ||  !contentType.startsWith( "text/ "))  throw  new  IOException(String.format( "Unhandled  content  type  \ "%s\ "  on  URL  %s.  Must  be  text/* ",  contentType,  url.toString()));    InputStream  inStream  =  new  BufferedInputStream(conn.getInputStream());  String  charSet  =   "UTF-8 ";  //  todo[must]:  get  from  content-encoding,  or  http-equiv  (two-pass?)    [BUGGY]  char  data  =  readInputStream  (  inStream,  charSet  )  ;  inStream.close();  return  data;  }        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      URL  url  int  timeoutMillis  [VARIABLES]  HttpURLConnection    conn    boolean    InputStream    inStream    String    charSet    contentType    data    protocol    URL    url    int    res    timeoutMillis    
String  data  =  readInputStream  (  inStream,  charSet  )  ;	[BUGGY]  String  data  =  readInputStream(  inStream,  protocol);  [CONTEXT]  static  String  load(URL  url,  int  timeoutMillis)  throws  IOException  {  String  protocol  =  url.getProtocol();  Validate.isTrue(protocol.equals( "http ")  ||  protocol.equals( "https "),   "Only  http  &  https  protocols  supported ");    HttpURLConnection  conn  =  (HttpURLConnection)  url.openConnection();  conn.setInstanceFollowRedirects(true);  conn.setConnectTimeout(timeoutMillis);  conn.setReadTimeout(timeoutMillis);  conn.connect();    int  res  =  conn.getResponseCode();  if  (res  !=  HttpURLConnection.HTTP_OK)  throw  new  IOException(res  +   "  error  loading  URL   "  +  url.toString());    String  contentType  =  conn.getContentType();  if  (contentType  ==  null  ||  !contentType.startsWith( "text/ "))  throw  new  IOException(String.format( "Unhandled  content  type  \ "%s\ "  on  URL  %s.  Must  be  text/* ",  contentType,  url.toString()));    InputStream  inStream  =  new  BufferedInputStream(conn.getInputStream());  String  charSet  =   "UTF-8 ";  //  todo[must]:  get  from  content-encoding,  or  http-equiv  (two-pass?)    [BUGGY]  String  data  =  readInputStream  (  inStream,  protocol  )  ;  inStream.close();  return  data;  }        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      URL  url  int  timeoutMillis  [VARIABLES]  HttpURLConnection    conn    boolean    InputStream    inStream    String    charSet    contentType    data    protocol    URL    url    int    res    timeoutMillis    
String  data  =  readInputStream  (  inStream,  charSet  )  ;	[BUGGY]  String  data  =  readInputStream(  charSet,  inStream);  [CONTEXT]  static  String  load(URL  url,  int  timeoutMillis)  throws  IOException  {  String  protocol  =  url.getProtocol();  Validate.isTrue(protocol.equals( "http ")  ||  protocol.equals( "https "),   "Only  http  &  https  protocols  supported ");    HttpURLConnection  conn  =  (HttpURLConnection)  url.openConnection();  conn.setInstanceFollowRedirects(true);  conn.setConnectTimeout(timeoutMillis);  conn.setReadTimeout(timeoutMillis);  conn.connect();    int  res  =  conn.getResponseCode();  if  (res  !=  HttpURLConnection.HTTP_OK)  throw  new  IOException(res  +   "  error  loading  URL   "  +  url.toString());    String  contentType  =  conn.getContentType();  if  (contentType  ==  null  ||  !contentType.startsWith( "text/ "))  throw  new  IOException(String.format( "Unhandled  content  type  \ "%s\ "  on  URL  %s.  Must  be  text/* ",  contentType,  url.toString()));    InputStream  inStream  =  new  BufferedInputStream(conn.getInputStream());  String  charSet  =   "UTF-8 ";  //  todo[must]:  get  from  content-encoding,  or  http-equiv  (two-pass?)    [BUGGY]  String  data  =  readInputStream  (  charSet,  inStream  )  ;  inStream.close();  return  data;  }        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      URL  url  int  timeoutMillis  [VARIABLES]  HttpURLConnection    conn    boolean    InputStream    inStream    String    charSet    contentType    data    protocol    URL    url    int    res    timeoutMillis    
String  data  =  readInputStream  (  inStream,  charSet  )  ;	[BUGGY]  String  data  =  readInputStream(    charSet);  [CONTEXT]  static  String  load(URL  url,  int  timeoutMillis)  throws  IOException  {  String  protocol  =  url.getProtocol();  Validate.isTrue(protocol.equals( "http ")  ||  protocol.equals( "https "),   "Only  http  &  https  protocols  supported ");    HttpURLConnection  conn  =  (HttpURLConnection)  url.openConnection();  conn.setInstanceFollowRedirects(true);  conn.setConnectTimeout(timeoutMillis);  conn.setReadTimeout(timeoutMillis);  conn.connect();    int  res  =  conn.getResponseCode();  if  (res  !=  HttpURLConnection.HTTP_OK)  throw  new  IOException(res  +   "  error  loading  URL   "  +  url.toString());    String  contentType  =  conn.getContentType();  if  (contentType  ==  null  ||  !contentType.startsWith( "text/ "))  throw  new  IOException(String.format( "Unhandled  content  type  \ "%s\ "  on  URL  %s.  Must  be  text/* ",  contentType,  url.toString()));    InputStream  inStream  =  new  BufferedInputStream(conn.getInputStream());  String  charSet  =   "UTF-8 ";  //  todo[must]:  get  from  content-encoding,  or  http-equiv  (two-pass?)    [BUGGY]  String  data  =  readInputStream  (charSet  )  ;  inStream.close();  return  data;  }        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      URL  url  int  timeoutMillis  [VARIABLES]  HttpURLConnection    conn    boolean    InputStream    inStream    String    charSet    contentType    data    protocol    URL    url    int    res    timeoutMillis    
String  data  =  readInputStream  (  inStream,  charSet  )  ;	[BUGGY]  String  data  =  readInputStream(  inStream);  [CONTEXT]  static  String  load(URL  url,  int  timeoutMillis)  throws  IOException  {  String  protocol  =  url.getProtocol();  Validate.isTrue(protocol.equals( "http ")  ||  protocol.equals( "https "),   "Only  http  &  https  protocols  supported ");    HttpURLConnection  conn  =  (HttpURLConnection)  url.openConnection();  conn.setInstanceFollowRedirects(true);  conn.setConnectTimeout(timeoutMillis);  conn.setReadTimeout(timeoutMillis);  conn.connect();    int  res  =  conn.getResponseCode();  if  (res  !=  HttpURLConnection.HTTP_OK)  throw  new  IOException(res  +   "  error  loading  URL   "  +  url.toString());    String  contentType  =  conn.getContentType();  if  (contentType  ==  null  ||  !contentType.startsWith( "text/ "))  throw  new  IOException(String.format( "Unhandled  content  type  \ "%s\ "  on  URL  %s.  Must  be  text/* ",  contentType,  url.toString()));    InputStream  inStream  =  new  BufferedInputStream(conn.getInputStream());  String  charSet  =   "UTF-8 ";  //  todo[must]:  get  from  content-encoding,  or  http-equiv  (two-pass?)    [BUGGY]  String  data  =  readInputStream  (  inStream  )  ;  inStream.close();  return  data;  }        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      URL  url  int  timeoutMillis  [VARIABLES]  HttpURLConnection    conn    boolean    InputStream    inStream    String    charSet    contentType    data    protocol    URL    url    int    res    timeoutMillis    
String  data  =  readInputStream  (  inStream,  charSet  )  ;	[BUGGY]  String  data  =  load(  inStream,  charSet);  [CONTEXT]  static  String  load(URL  url,  int  timeoutMillis)  throws  IOException  {  String  protocol  =  url.getProtocol();  Validate.isTrue(protocol.equals( "http ")  ||  protocol.equals( "https "),   "Only  http  &  https  protocols  supported ");    HttpURLConnection  conn  =  (HttpURLConnection)  url.openConnection();  conn.setInstanceFollowRedirects(true);  conn.setConnectTimeout(timeoutMillis);  conn.setReadTimeout(timeoutMillis);  conn.connect();    int  res  =  conn.getResponseCode();  if  (res  !=  HttpURLConnection.HTTP_OK)  throw  new  IOException(res  +   "  error  loading  URL   "  +  url.toString());    String  contentType  =  conn.getContentType();  if  (contentType  ==  null  ||  !contentType.startsWith( "text/ "))  throw  new  IOException(String.format( "Unhandled  content  type  \ "%s\ "  on  URL  %s.  Must  be  text/* ",  contentType,  url.toString()));    InputStream  inStream  =  new  BufferedInputStream(conn.getInputStream());  String  charSet  =   "UTF-8 ";  //  todo[must]:  get  from  content-encoding,  or  http-equiv  (two-pass?)    [BUGGY]  String  data  =  load  (  inStream,  charSet  )  ;  inStream.close();  return  data;  }        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      URL  url  int  timeoutMillis  [VARIABLES]  HttpURLConnection    conn    boolean    InputStream    inStream    String    charSet    contentType    data    protocol    URL    url    int    res    timeoutMillis    
String  data  =  readInputStream  (  inStream,  charSet  )  ;  inStream.close  (  )  ;	[BUGGY]  inStream.close(  );  String  data  =  readInputStream(  inStream,  charSet);  [CONTEXT]        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      URL  url  int  timeoutMillis  [VARIABLES]  HttpURLConnection    conn    boolean    InputStream    inStream    String    charSet    contentType    data    protocol    URL    url    int    res    timeoutMillis    
String  data  =  readInputStream  (  inStream,  charSet  )  ;  inStream.close  (  )  ;	[BUGGY]  String  data  =  readInputStream(  inStream,  charSet);String  data  =  readInputStream(  inStream,  charSet);  inStream.close(  );  [CONTEXT]        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      URL  url  int  timeoutMillis  [VARIABLES]  HttpURLConnection    conn    boolean    InputStream    inStream    String    charSet    contentType    data    protocol    URL    url    int    res    timeoutMillis    
String  data  =  readInputStream  (  inStream,  charSet  )  ;  inStream.close  (  )  ;	[BUGGY]  String  data  =  readInputStream(  inStream,  charsetName);String  data  =  readInputStream(  inStream,  charSet);  inStream.close(  );  [CONTEXT]        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      URL  url  int  timeoutMillis  [VARIABLES]  HttpURLConnection    conn    boolean    InputStream    inStream    String    charSet    contentType    data    protocol    URL    url    int    res    timeoutMillis    
String  data  =  readInputStream  (  inStream,  charSet  )  ;	[BUGGY]    [CONTEXT]  static  String  load(URL  url,  int  timeoutMillis)  throws  IOException  {  String  protocol  =  url.getProtocol();  Validate.isTrue(protocol.equals( "http ")  ||  protocol.equals( "https "),   "Only  http  &  https  protocols  supported ");    HttpURLConnection  conn  =  (HttpURLConnection)  url.openConnection();  conn.setInstanceFollowRedirects(true);  conn.setConnectTimeout(timeoutMillis);  conn.setReadTimeout(timeoutMillis);  conn.connect();    int  res  =  conn.getResponseCode();  if  (res  !=  HttpURLConnection.HTTP_OK)  throw  new  IOException(res  +   "  error  loading  URL   "  +  url.toString());    String  contentType  =  conn.getContentType();  if  (contentType  ==  null  ||  !contentType.startsWith( "text/ "))  throw  new  IOException(String.format( "Unhandled  content  type  \ "%s\ "  on  URL  %s.  Must  be  text/* ",  contentType,  url.toString()));    InputStream  inStream  =  new  BufferedInputStream(conn.getInputStream());  String  charSet  =   "UTF-8 ";  //  todo[must]:  get  from  content-encoding,  or  http-equiv  (two-pass?)    [BUGGY]  String  data  =  readInputStream(inStream,  charSet);    inStream.close();  return  data;        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      URL  url  int  timeoutMillis  [VARIABLES]  HttpURLConnection    conn    boolean    InputStream    inStream    String    charSet    contentType    data    protocol    URL    url    int    res    timeoutMillis    
inStream.close  (  )  ;  return  data;	[BUGGY]    [CONTEXT]  static  String  load(URL  url,  int  timeoutMillis)  throws  IOException  {  String  protocol  =  url.getProtocol();  Validate.isTrue(protocol.equals( "http ")  ||  protocol.equals( "https "),   "Only  http  &  https  protocols  supported ");    HttpURLConnection  conn  =  (HttpURLConnection)  url.openConnection();  conn.setInstanceFollowRedirects(true);  conn.setConnectTimeout(timeoutMillis);  conn.setReadTimeout(timeoutMillis);  conn.connect();    int  res  =  conn.getResponseCode();  if  (res  !=  HttpURLConnection.HTTP_OK)  throw  new  IOException(res  +   "  error  loading  URL   "  +  url.toString());    String  contentType  =  conn.getContentType();  if  (contentType  ==  null  ||  !contentType.startsWith( "text/ "))  throw  new  IOException(String.format( "Unhandled  content  type  \ "%s\ "  on  URL  %s.  Must  be  text/* ",  contentType,  url.toString()));    InputStream  inStream  =  new  BufferedInputStream(conn.getInputStream());  String  charSet  =   "UTF-8 ";  //  todo[must]:  get  from  content-encoding,  or  http-equiv  (two-pass?)    String  data  =  readInputStream(inStream,  charSet);  [BUGGY]  inStream.close();            [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      URL  url  int  timeoutMillis  [VARIABLES]  HttpURLConnection    conn    boolean    InputStream    inStream    String    charSet    contentType    data    protocol    URL    url    int    res    timeoutMillis    
return  data;	[BUGGY]  return  protocol;  [CONTEXT]  static  String  load(URL  url,  int  timeoutMillis)  throws  IOException  {  String  protocol  =  url.getProtocol();  Validate.isTrue(protocol.equals( "http ")  ||  protocol.equals( "https "),   "Only  http  &  https  protocols  supported ");    HttpURLConnection  conn  =  (HttpURLConnection)  url.openConnection();  conn.setInstanceFollowRedirects(true);  conn.setConnectTimeout(timeoutMillis);  conn.setReadTimeout(timeoutMillis);  conn.connect();    int  res  =  conn.getResponseCode();  if  (res  !=  HttpURLConnection.HTTP_OK)  throw  new  IOException(res  +   "  error  loading  URL   "  +  url.toString());    String  contentType  =  conn.getContentType();  if  (contentType  ==  null  ||  !contentType.startsWith( "text/ "))  throw  new  IOException(String.format( "Unhandled  content  type  \ "%s\ "  on  URL  %s.  Must  be  text/* ",  contentType,  url.toString()));    InputStream  inStream  =  new  BufferedInputStream(conn.getInputStream());  String  charSet  =   "UTF-8 ";  //  todo[must]:  get  from  content-encoding,  or  http-equiv  (two-pass?)    String  data  =  readInputStream(inStream,  charSet);  inStream.close();  [BUGGY]  return  protocol;  }        [CLASS]  DataUtil    [METHOD]  load  [RETURN_TYPE]  String      URL  url  int  timeoutMillis  [VARIABLES]  HttpURLConnection    conn    boolean    InputStream    inStream    String    charSet    contentType    data    protocol    URL    url    int    res    timeoutMillis    
StringBuilder  data  =  new  StringBuilder  (  0x20000  )  ;  Reader  inReader  =  new  InputStreamReader  (  inStream,  charsetName  )  ;	[BUGGY]  Reader  inReader  =  new  InputStreamReader(  inStream,  charsetName);  StringBuilder  data  =  new  StringBuilder(  0x20000);  [CONTEXT]        [CLASS]  DataUtil    [METHOD]  readInputStream  [RETURN_TYPE]  String      InputStream  inStream  String  charsetName  [VARIABLES]  boolean    StringBuilder    data    InputStream    inStream    Reader    inReader    String    charsetName    int    read    char[]    buffer    
StringBuilder  data  =  new  StringBuilder  (  0x20000  )  ;  Reader  inReader  =  new  InputStreamReader  (  inStream,  charsetName  )  ;	[BUGGY]  Reader  inReader  =  new  InputStreamReader(  inStream,  charsetName);StringBuilder  data  =  new  StringBuilder(  0x20000);  Reader  inReader  =  new  InputStreamReader(  inStream,  charsetName);  [CONTEXT]        [CLASS]  DataUtil    [METHOD]  readInputStream  [RETURN_TYPE]  String      InputStream  inStream  String  charsetName  [VARIABLES]  boolean    StringBuilder    data    InputStream    inStream    Reader    inReader    String    charsetName    int    read    char[]    buffer    
Reader  inReader  =  new  InputStreamReader  (  inStream,  charsetName  )  ;	[BUGGY]  Reader  inReader  =  new  InputStreamReader(    charsetName);  [CONTEXT]  private  static  String  readInputStream(InputStream  inStream,  String  charsetName)  throws  IOException  {  char[]  buffer  =  new  char[0x20000];  //  ~  130K  StringBuilder  data  =  new  StringBuilder(0x20000);  [BUGGY]  Reader  inReader  =  new  InputStreamReader  (charsetName  )  ;  int  read;  do  {  read  =  inReader.read(buffer,  0,  buffer.length);  if  (read  >  0)  {  data.append(buffer,  0,  read);  }    }  while  (read  >=  0);    return  data.toString();  }        [CLASS]  DataUtil    [METHOD]  readInputStream  [RETURN_TYPE]  String      InputStream  inStream  String  charsetName  [VARIABLES]  boolean    StringBuilder    data    InputStream    inStream    Reader    inReader    String    charsetName    int    read    char[]    buffer    
Reader  inReader  =  new  InputStreamReader  (  inStream,  charsetName  )  ;	[BUGGY]  Reader  inReader  =  new  InputStreamReader(  inStream);  [CONTEXT]  private  static  String  readInputStream(InputStream  inStream,  String  charsetName)  throws  IOException  {  char[]  buffer  =  new  char[0x20000];  //  ~  130K  StringBuilder  data  =  new  StringBuilder(0x20000);  [BUGGY]  Reader  inReader  =  new  InputStreamReader  (  inStream  )  ;  int  read;  do  {  read  =  inReader.read(buffer,  0,  buffer.length);  if  (read  >  0)  {  data.append(buffer,  0,  read);  }    }  while  (read  >=  0);    return  data.toString();  }        [CLASS]  DataUtil    [METHOD]  readInputStream  [RETURN_TYPE]  String      InputStream  inStream  String  charsetName  [VARIABLES]  boolean    StringBuilder    data    InputStream    inStream    Reader    inReader    String    charsetName    int    read    char[]    buffer    
Reader  inReader  =  new  InputStreamReader  (  inStream,  charsetName  )  ;	[BUGGY]  Reader  inReader  =  new  InputStreamReader(  charsetName,  inStream);  [CONTEXT]  private  static  String  readInputStream(InputStream  inStream,  String  charsetName)  throws  IOException  {  char[]  buffer  =  new  char[0x20000];  //  ~  130K  StringBuilder  data  =  new  StringBuilder(0x20000);  [BUGGY]  Reader  inReader  =  new  InputStreamReader  (  charsetName,  inStream  )  ;  int  read;  do  {  read  =  inReader.read(buffer,  0,  buffer.length);  if  (read  >  0)  {  data.append(buffer,  0,  read);  }    }  while  (read  >=  0);    return  data.toString();  }        [CLASS]  DataUtil    [METHOD]  readInputStream  [RETURN_TYPE]  String      InputStream  inStream  String  charsetName  [VARIABLES]  boolean    StringBuilder    data    InputStream    inStream    Reader    inReader    String    charsetName    int    read    char[]    buffer    
Reader  inReader  =  new  InputStreamReader  (  inStream,  charsetName  )  ;	[BUGGY]  do  {  Reader  inReader  =  new  InputStreamReader(  inStream,  charsetName);  [CONTEXT]        [CLASS]  DataUtil    [METHOD]  readInputStream  [RETURN_TYPE]  String      InputStream  inStream  String  charsetName  [VARIABLES]  boolean    StringBuilder    data    InputStream    inStream    Reader    inReader    String    charsetName    int    read    char[]    buffer    
Reader  inReader  =  new  InputStreamReader  (  inStream,  charsetName  )  ;	[BUGGY]  String  data  =  readInputStream(  inStream,  charSet);Reader  inReader  =  new  InputStreamReader(  inStream,  charsetName);  [CONTEXT]        [CLASS]  DataUtil    [METHOD]  readInputStream  [RETURN_TYPE]  String      InputStream  inStream  String  charsetName  [VARIABLES]  boolean    StringBuilder    data    InputStream    inStream    Reader    inReader    String    charsetName    int    read    char[]    buffer    
Reader  inReader  =  new  InputStreamReader  (  inStream,  charsetName  )  ;	[BUGGY]  String  data  =  readInputStream(  inStream,  charsetName);Reader  inReader  =  new  InputStreamReader(  inStream,  charsetName);  [CONTEXT]        [CLASS]  DataUtil    [METHOD]  readInputStream  [RETURN_TYPE]  String      InputStream  inStream  String  charsetName  [VARIABLES]  boolean    StringBuilder    data    InputStream    inStream    Reader    inReader    String    charsetName    int    read    char[]    buffer    
int  read;	[BUGGY]  short    read;  [CONTEXT]  private  static  String  readInputStream(InputStream  inStream,  String  charsetName)  throws  IOException  {  char[]  buffer  =  new  char[0x20000];  //  ~  130K  StringBuilder  data  =  new  StringBuilder(0x20000);  Reader  inReader  =  new  InputStreamReader(inStream,  charsetName);  [BUGGY]  shortread;  do  {  read  =  inReader.read(buffer,  0,  buffer.length);  if  (read  >  0)  {  data.append(buffer,  0,  read);  }    }  while  (read  >=  0);    return  data.toString();  }        [CLASS]  DataUtil    [METHOD]  readInputStream  [RETURN_TYPE]  String      InputStream  inStream  String  charsetName  [VARIABLES]  boolean    StringBuilder    data    InputStream    inStream    Reader    inReader    String    charsetName    int    read    char[]    buffer    
if  (  read  >  0  )  {	[BUGGY]  if  (  read  >=  0)  {  [CONTEXT]  private  static  String  readInputStream(InputStream  inStream,  String  charsetName)  throws  IOException  {  char[]  buffer  =  new  char[0x20000];  //  ~  130K  StringBuilder  data  =  new  StringBuilder(0x20000);  Reader  inReader  =  new  InputStreamReader(inStream,  charsetName);  int  read;  do  {  read  =  inReader.read(buffer,  0,  buffer.length);  [BUGGY]  if(  read  >=  0  ){  data.append(buffer,  0,  read);  }    }  while  (read  >=  0);    return  data.toString();  }        [CLASS]  DataUtil    [METHOD]  readInputStream  [RETURN_TYPE]  String      InputStream  inStream  String  charsetName  [VARIABLES]  boolean    StringBuilder    data    InputStream    inStream    Reader    inReader    String    charsetName    int    read    char[]    buffer    
if  (  read  >  0  )  {	[BUGGY]  if  (  read  >  2)  {  [CONTEXT]  private  static  String  readInputStream(InputStream  inStream,  String  charsetName)  throws  IOException  {  char[]  buffer  =  new  char[0x20000];  //  ~  130K  StringBuilder  data  =  new  StringBuilder(0x20000);  Reader  inReader  =  new  InputStreamReader(inStream,  charsetName);  int  read;  do  {  read  =  inReader.read(buffer,  0,  buffer.length);  [BUGGY]  if(  read  >  2  ){  data.append(buffer,  0,  read);  }    }  while  (read  >=  0);    return  data.toString();  }        [CLASS]  DataUtil    [METHOD]  readInputStream  [RETURN_TYPE]  String      InputStream  inStream  String  charsetName  [VARIABLES]  boolean    StringBuilder    data    InputStream    inStream    Reader    inReader    String    charsetName    int    read    char[]    buffer    
if  (  read  >  0  )  {	[BUGGY]  if  (  read  >  1)  {  [CONTEXT]  private  static  String  readInputStream(InputStream  inStream,  String  charsetName)  throws  IOException  {  char[]  buffer  =  new  char[0x20000];  //  ~  130K  StringBuilder  data  =  new  StringBuilder(0x20000);  Reader  inReader  =  new  InputStreamReader(inStream,  charsetName);  int  read;  do  {  read  =  inReader.read(buffer,  0,  buffer.length);  [BUGGY]  if(  read  >  1  ){  data.append(buffer,  0,  read);  }    }  while  (read  >=  0);    return  data.toString();  }        [CLASS]  DataUtil    [METHOD]  readInputStream  [RETURN_TYPE]  String      InputStream  inStream  String  charsetName  [VARIABLES]  boolean    StringBuilder    data    InputStream    inStream    Reader    inReader    String    charsetName    int    read    char[]    buffer    
if  (  read  >  0  )  {  data.append  (  buffer,  0,  read  )  ;  }	[BUGGY]  data.append(buffer,  0,  read);  [CONTEXT]  private  static  String  readInputStream(InputStream  inStream,  String  charsetName)  throws  IOException  {  char[]  buffer  =  new  char[0x20000];  //  ~  130K  StringBuilder  data  =  new  StringBuilder(0x20000);  Reader  inReader  =  new  InputStreamReader(inStream,  charsetName);  int  read;  do  {  read  =  inReader.read(buffer,  0,  buffer.length);  [BUGGY]  if  (read  >  0)  {    data.append(buffer,  0,  read);      }  while  (read  >=  0);    return  data.toString();        [CLASS]  DataUtil    [METHOD]  readInputStream  [RETURN_TYPE]  String      InputStream  inStream  String  charsetName  [VARIABLES]  boolean    StringBuilder    data    InputStream    inStream    Reader    inReader    String    charsetName    int    read    char[]    buffer    
if  (  read  >  0  )  {  data.append  (  buffer,  0,  read  )  ;  }	[BUGGY]    [CONTEXT]  private  static  String  readInputStream(InputStream  inStream,  String  charsetName)  throws  IOException  {  char[]  buffer  =  new  char[0x20000];  //  ~  130K  StringBuilder  data  =  new  StringBuilder(0x20000);  Reader  inReader  =  new  InputStreamReader(inStream,  charsetName);  int  read;  do  {  read  =  inReader.read(buffer,  0,  buffer.length);  [BUGGY]  if  (read  >  0)  {          }  while  (read  >=  0);    return  data.toString();        [CLASS]  DataUtil    [METHOD]  readInputStream  [RETURN_TYPE]  String      InputStream  inStream  String  charsetName  [VARIABLES]  boolean    StringBuilder    data    InputStream    inStream    Reader    inReader    String    charsetName    int    read    char[]    buffer    
data.append  (  buffer,  0,  read  )  ;	[BUGGY]  data.append(  buffer,  -4,  read);  [CONTEXT]  private  static  String  readInputStream(InputStream  inStream,  String  charsetName)  throws  IOException  {  char[]  buffer  =  new  char[0x20000];  //  ~  130K  StringBuilder  data  =  new  StringBuilder(0x20000);  Reader  inReader  =  new  InputStreamReader(inStream,  charsetName);  int  read;  do  {  read  =  inReader.read(buffer,  0,  buffer.length);  if  (read  >  0)  {  [BUGGY]  data.append  (  buffer,  -4,  read  )  ;  }    }  while  (read  >=  0);    return  data.toString();  }        [CLASS]  DataUtil    [METHOD]  readInputStream  [RETURN_TYPE]  String      InputStream  inStream  String  charsetName  [VARIABLES]  boolean    StringBuilder    data    InputStream    inStream    Reader    inReader    String    charsetName    int    read    char[]    buffer    
data.append  (  buffer,  0,  read  )  ;	[BUGGY]  data.append(  read,  0,  buffer);  [CONTEXT]  private  static  String  readInputStream(InputStream  inStream,  String  charsetName)  throws  IOException  {  char[]  buffer  =  new  char[0x20000];  //  ~  130K  StringBuilder  data  =  new  StringBuilder(0x20000);  Reader  inReader  =  new  InputStreamReader(inStream,  charsetName);  int  read;  do  {  read  =  inReader.read(buffer,  0,  buffer.length);  if  (read  >  0)  {  [BUGGY]  data.append  (  read,  0,  buffer  )  ;  }    }  while  (read  >=  0);    return  data.toString();  }        [CLASS]  DataUtil    [METHOD]  readInputStream  [RETURN_TYPE]  String      InputStream  inStream  String  charsetName  [VARIABLES]  boolean    StringBuilder    data    InputStream    inStream    Reader    inReader    String    charsetName    int    read    char[]    buffer    
data.append  (  buffer,  0,  read  )  ;	[BUGGY]  data.append(    0,  read);  [CONTEXT]  private  static  String  readInputStream(InputStream  inStream,  String  charsetName)  throws  IOException  {  char[]  buffer  =  new  char[0x20000];  //  ~  130K  StringBuilder  data  =  new  StringBuilder(0x20000);  Reader  inReader  =  new  InputStreamReader(inStream,  charsetName);  int  read;  do  {  read  =  inReader.read(buffer,  0,  buffer.length);  if  (read  >  0)  {  [BUGGY]  data.append  (0,  read  )  ;  }    }  while  (read  >=  0);    return  data.toString();  }        [CLASS]  DataUtil    [METHOD]  readInputStream  [RETURN_TYPE]  String      InputStream  inStream  String  charsetName  [VARIABLES]  boolean    StringBuilder    data    InputStream    inStream    Reader    inReader    String    charsetName    int    read    char[]    buffer    
data.append  (  buffer,  0,  read  )  ;	[BUGGY]  data.append(  buffer,  0);  [CONTEXT]  private  static  String  readInputStream(InputStream  inStream,  String  charsetName)  throws  IOException  {  char[]  buffer  =  new  char[0x20000];  //  ~  130K  StringBuilder  data  =  new  StringBuilder(0x20000);  Reader  inReader  =  new  InputStreamReader(inStream,  charsetName);  int  read;  do  {  read  =  inReader.read(buffer,  0,  buffer.length);  if  (read  >  0)  {  [BUGGY]  data.append  (  buffer,  0  )  ;  }    }  while  (read  >=  0);    return  data.toString();  }        [CLASS]  DataUtil    [METHOD]  readInputStream  [RETURN_TYPE]  String      InputStream  inStream  String  charsetName  [VARIABLES]  boolean    StringBuilder    data    InputStream    inStream    Reader    inReader    String    charsetName    int    read    char[]    buffer    
data.append  (  buffer,  0,  read  )  ;	[BUGGY]  data  .toString(  )  ;  [CONTEXT]  private  static  String  readInputStream(InputStream  inStream,  String  charsetName)  throws  IOException  {  char[]  buffer  =  new  char[0x20000];  //  ~  130K  StringBuilder  data  =  new  StringBuilder(0x20000);  Reader  inReader  =  new  InputStreamReader(inStream,  charsetName);  int  read;  do  {  read  =  inReader.read(buffer,  0,  buffer.length);  if  (read  >  0)  {  [BUGGY]  data  .toString  ();  }    }  while  (read  >=  0);    return  data.toString();  }        [CLASS]  DataUtil    [METHOD]  readInputStream  [RETURN_TYPE]  String      InputStream  inStream  String  charsetName  [VARIABLES]  boolean    StringBuilder    data    InputStream    inStream    Reader    inReader    String    charsetName    int    read    char[]    buffer    
data.append  (  buffer,  0,  read  )  ;	[BUGGY]    [CONTEXT]  private  static  String  readInputStream(InputStream  inStream,  String  charsetName)  throws  IOException  {  char[]  buffer  =  new  char[0x20000];  //  ~  130K  StringBuilder  data  =  new  StringBuilder(0x20000);  Reader  inReader  =  new  InputStreamReader(inStream,  charsetName);  int  read;  do  {  read  =  inReader.read(buffer,  0,  buffer.length);  if  (read  >  0)  {  [BUGGY]  data.append(buffer,  0,  read);    }    }  while  (read  >=  0);    return  data.toString();        [CLASS]  DataUtil    [METHOD]  readInputStream  [RETURN_TYPE]  String      InputStream  inStream  String  charsetName  [VARIABLES]  boolean    StringBuilder    data    InputStream    inStream    Reader    inReader    String    charsetName    int    read    char[]    buffer    
[Delete]	[BUGGY]  if  (  read  >  0)  {          data.append(  buffer,  0,  read);  }  [CONTEXT]        [CLASS]  DataUtil    [METHOD]  readInputStream  [RETURN_TYPE]  String      InputStream  inStream  String  charsetName  [VARIABLES]  boolean    StringBuilder    data    InputStream    inStream    Reader    inReader    String    charsetName    int    read    char[]    buffer    
read  =  inReader.read  (  buffer,  0,  buffer.length  )  ;	[BUGGY]  read  =  inReader.read(  buffer,  read,  buffer.length);  [CONTEXT]  private  static  String  readInputStream(InputStream  inStream,  String  charsetName)  throws  IOException  {  char[]  buffer  =  new  char[0x20000];  //  ~  130K  StringBuilder  data  =  new  StringBuilder(0x20000);  Reader  inReader  =  new  InputStreamReader(inStream,  charsetName);  int  read;  do  {  [BUGGY]  read  =  inReader.read  (  buffer,  read,  buffer.length  )  ;  if  (read  >  0)  {  data.append(buffer,  0,  read);  }    }  while  (read  >=  0);    return  data.toString();  }        [CLASS]  DataUtil    [METHOD]  readInputStream  [RETURN_TYPE]  String      InputStream  inStream  String  charsetName  [VARIABLES]  boolean    StringBuilder    data    InputStream    inStream    Reader    inReader    String    charsetName    int    read    char[]    buffer    
read  =  inReader.read  (  buffer,  0,  buffer.length  )  ;	[BUGGY]  read  =  inReader.read(  buffer,  0,  read);  [CONTEXT]  private  static  String  readInputStream(InputStream  inStream,  String  charsetName)  throws  IOException  {  char[]  buffer  =  new  char[0x20000];  //  ~  130K  StringBuilder  data  =  new  StringBuilder(0x20000);  Reader  inReader  =  new  InputStreamReader(inStream,  charsetName);  int  read;  do  {  [BUGGY]  read  =  inReader.read  (  buffer,  0,  read  )  ;  if  (read  >  0)  {  data.append(buffer,  0,  read);  }    }  while  (read  >=  0);    return  data.toString();  }        [CLASS]  DataUtil    [METHOD]  readInputStream  [RETURN_TYPE]  String      InputStream  inStream  String  charsetName  [VARIABLES]  boolean    StringBuilder    data    InputStream    inStream    Reader    inReader    String    charsetName    int    read    char[]    buffer    
read  =  inReader.read  (  buffer,  0,  buffer.length  )  ;	[BUGGY]  read  =  buffer.length.read(  buffer,  0,  inReader);  [CONTEXT]  private  static  String  readInputStream(InputStream  inStream,  String  charsetName)  throws  IOException  {  char[]  buffer  =  new  char[0x20000];  //  ~  130K  StringBuilder  data  =  new  StringBuilder(0x20000);  Reader  inReader  =  new  InputStreamReader(inStream,  charsetName);  int  read;  do  {  [BUGGY]  read  =  buffer.length.read  (  buffer,  0,  inReader  )  ;  if  (read  >  0)  {  data.append(buffer,  0,  read);  }    }  while  (read  >=  0);    return  data.toString();  }        [CLASS]  DataUtil    [METHOD]  readInputStream  [RETURN_TYPE]  String      InputStream  inStream  String  charsetName  [VARIABLES]  boolean    StringBuilder    data    InputStream    inStream    Reader    inReader    String    charsetName    int    read    char[]    buffer    
read  =  inReader.read  (  buffer,  0,  buffer.length  )  ;	[BUGGY]  read  =  buffer.read(  inReader,  0,  buffer.length);  [CONTEXT]  private  static  String  readInputStream(InputStream  inStream,  String  charsetName)  throws  IOException  {  char[]  buffer  =  new  char[0x20000];  //  ~  130K  StringBuilder  data  =  new  StringBuilder(0x20000);  Reader  inReader  =  new  InputStreamReader(inStream,  charsetName);  int  read;  do  {  [BUGGY]  read  =  buffer.read  (  inReader,  0,  buffer.length  )  ;  if  (read  >  0)  {  data.append(buffer,  0,  read);  }    }  while  (read  >=  0);    return  data.toString();  }        [CLASS]  DataUtil    [METHOD]  readInputStream  [RETURN_TYPE]  String      InputStream  inStream  String  charsetName  [VARIABLES]  boolean    StringBuilder    data    InputStream    inStream    Reader    inReader    String    charsetName    int    read    char[]    buffer    
read  =  inReader.read  (  buffer,  0,  buffer.length  )  ;	[BUGGY]  read  =  inReader.read(    0,  buffer.length);  [CONTEXT]  private  static  String  readInputStream(InputStream  inStream,  String  charsetName)  throws  IOException  {  char[]  buffer  =  new  char[0x20000];  //  ~  130K  StringBuilder  data  =  new  StringBuilder(0x20000);  Reader  inReader  =  new  InputStreamReader(inStream,  charsetName);  int  read;  do  {  [BUGGY]  read  =  inReader.read  (0,  buffer.length  )  ;  if  (read  >  0)  {  data.append(buffer,  0,  read);  }    }  while  (read  >=  0);    return  data.toString();  }        [CLASS]  DataUtil    [METHOD]  readInputStream  [RETURN_TYPE]  String      InputStream  inStream  String  charsetName  [VARIABLES]  boolean    StringBuilder    data    InputStream    inStream    Reader    inReader    String    charsetName    int    read    char[]    buffer    
read  =  inReader.read  (  buffer,  0,  buffer.length  )  ;	[BUGGY]  read  =  inReader.read(  buffer,  0);  [CONTEXT]  private  static  String  readInputStream(InputStream  inStream,  String  charsetName)  throws  IOException  {  char[]  buffer  =  new  char[0x20000];  //  ~  130K  StringBuilder  data  =  new  StringBuilder(0x20000);  Reader  inReader  =  new  InputStreamReader(inStream,  charsetName);  int  read;  do  {  [BUGGY]  read  =  inReader.read  (  buffer,  0  )  ;  if  (read  >  0)  {  data.append(buffer,  0,  read);  }    }  while  (read  >=  0);    return  data.toString();  }        [CLASS]  DataUtil    [METHOD]  readInputStream  [RETURN_TYPE]  String      InputStream  inStream  String  charsetName  [VARIABLES]  boolean    StringBuilder    data    InputStream    inStream    Reader    inReader    String    charsetName    int    read    char[]    buffer    
read  =  inReader.read  (  buffer,  0,  buffer.length  )  ;	[BUGGY]  read  =  inReader.read(  buffer,  0  ,  buffer.length);  [CONTEXT]  private  static  String  readInputStream(InputStream  inStream,  String  charsetName)  throws  IOException  {  char[]  buffer  =  new  char[0x20000];  //  ~  130K  StringBuilder  data  =  new  StringBuilder(0x20000);  Reader  inReader  =  new  InputStreamReader(inStream,  charsetName);  int  read;  do  {  [BUGGY]  read  =  inReader.read  (  buffer,  0  ,  buffer.length  )  ;  if  (read  >  0)  {  data.append(buffer,  0,  read);  }    }  while  (read  >=  0);    return  data.toString();  }        [CLASS]  DataUtil    [METHOD]  readInputStream  [RETURN_TYPE]  String      InputStream  inStream  String  charsetName  [VARIABLES]  boolean    StringBuilder    data    InputStream    inStream    Reader    inReader    String    charsetName    int    read    char[]    buffer    
read  =  inReader.read  (  buffer,  0,  buffer.length  )  ;	[BUGGY]  read  =  inReader.read(  buffer,  6,  buffer.length);  [CONTEXT]  private  static  String  readInputStream(InputStream  inStream,  String  charsetName)  throws  IOException  {  char[]  buffer  =  new  char[0x20000];  //  ~  130K  StringBuilder  data  =  new  StringBuilder(0x20000);  Reader  inReader  =  new  InputStreamReader(inStream,  charsetName);  int  read;  do  {  [BUGGY]  read  =  inReader.read  (  buffer,  6,  buffer.length  )  ;  if  (read  >  0)  {  data.append(buffer,  0,  read);  }    }  while  (read  >=  0);    return  data.toString();  }        [CLASS]  DataUtil    [METHOD]  readInputStream  [RETURN_TYPE]  String      InputStream  inStream  String  charsetName  [VARIABLES]  boolean    StringBuilder    data    InputStream    inStream    Reader    inReader    String    charsetName    int    read    char[]    buffer    
read  =  inReader.read  (  buffer,  0,  buffer.length  )  ;	[BUGGY]    [CONTEXT]  private  static  String  readInputStream(InputStream  inStream,  String  charsetName)  throws  IOException  {  char[]  buffer  =  new  char[0x20000];  //  ~  130K  StringBuilder  data  =  new  StringBuilder(0x20000);  Reader  inReader  =  new  InputStreamReader(inStream,  charsetName);  int  read;  do  {  [BUGGY]  read  =  inReader.read(buffer,  0,  buffer.length);    if  (read  >  0)  {  data.append(buffer,  0,  read);  }    }  while  (read  >=  0);    return  data.toString();        [CLASS]  DataUtil    [METHOD]  readInputStream  [RETURN_TYPE]  String      InputStream  inStream  String  charsetName  [VARIABLES]  boolean    StringBuilder    data    InputStream    inStream    Reader    inReader    String    charsetName    int    read    char[]    buffer    
data.append  (  buffer,  0,  read  )  ;	[BUGGY]  data.append(  buffer,  read,  read);  [CONTEXT]  private  static  String  readInputStream(InputStream  inStream,  String  charsetName)  throws  IOException  {  char[]  buffer  =  new  char[0x20000];  //  ~  130K  StringBuilder  data  =  new  StringBuilder(0x20000);  Reader  inReader  =  new  InputStreamReader(inStream,  charsetName);  int  read;  do  {  read  =  inReader.read(buffer,  0,  buffer.length);  if  (read  >  0)  {  [BUGGY]  data.append  (  buffer,  read,  read  )  ;  }    }  while  (read  >=  0);    return  data.toString();  }        [CLASS]  DataUtil    [METHOD]  readInputStream  [RETURN_TYPE]  String      InputStream  inStream  String  charsetName  [VARIABLES]  boolean    StringBuilder    data    InputStream    inStream    Reader    inReader    String    charsetName    int    read    char[]    buffer    
return  data.toString  (  )  ;	[BUGGY]  return  data  .getProtocol(  )  ;  [CONTEXT]  private  static  String  readInputStream(InputStream  inStream,  String  charsetName)  throws  IOException  {  char[]  buffer  =  new  char[0x20000];  //  ~  130K  StringBuilder  data  =  new  StringBuilder(0x20000);  Reader  inReader  =  new  InputStreamReader(inStream,  charsetName);  int  read;  do  {  read  =  inReader.read(buffer,  0,  buffer.length);  if  (read  >  0)  {  data.append(buffer,  0,  read);  }    }  while  (read  >=  0);    [BUGGY]  return  data  .getProtocol  ();  }        [CLASS]  DataUtil    [METHOD]  readInputStream  [RETURN_TYPE]  String      InputStream  inStream  String  charsetName  [VARIABLES]  boolean    StringBuilder    data    InputStream    inStream    Reader    inReader    String    charsetName    int    read    char[]    buffer    
return  data.toString  (  )  ;	[BUGGY]    [CONTEXT]  private  static  String  readInputStream(InputStream  inStream,  String  charsetName)  throws  IOException  {  char[]  buffer  =  new  char[0x20000];  //  ~  130K  StringBuilder  data  =  new  StringBuilder(0x20000);  Reader  inReader  =  new  InputStreamReader(inStream,  charsetName);  int  read;  do  {  read  =  inReader.read(buffer,  0,  buffer.length);  if  (read  >  0)  {  data.append(buffer,  0,  read);  }    }  while  (read  >=  0);    [BUGGY]  return  data.toString();          [CLASS]  DataUtil    [METHOD]  readInputStream  [RETURN_TYPE]  String      InputStream  inStream  String  charsetName  [VARIABLES]  boolean    StringBuilder    data    InputStream    inStream    Reader    inReader    String    charsetName    int    read    char[]    buffer    
int  numAttribsDiscarded;	[BUGGY]  short    numAttribsDiscarded;  [CONTEXT]  return  new  ElementMeta(dest,  numDiscarded);  }    private  static  class  ElementMeta  {  Element  el;  [BUGGY]  shortnumAttribsDiscarded;    ElementMeta(Element  el,  int  numAttribsDiscarded)  {  this.el  =  el;  this.numAttribsDiscarded  =  numAttribsDiscarded;  }        [CLASS]  Cleaner  ElementMeta      [VARIABLES]  
int  numAttribsDiscarded;	[BUGGY]  long    numAttribsDiscarded;  [CONTEXT]  return  new  ElementMeta(dest,  numDiscarded);  }    private  static  class  ElementMeta  {  Element  el;  [BUGGY]  longnumAttribsDiscarded;    ElementMeta(Element  el,  int  numAttribsDiscarded)  {  this.el  =  el;  this.numAttribsDiscarded  =  numAttribsDiscarded;  }        [CLASS]  Cleaner  ElementMeta      [VARIABLES]  
Validate.notNull  (  whitelist  )  ;	[BUGGY]    [CONTEXT]  public  Cleaner(Whitelist  whitelist)  {  [BUGGY]  Validate.notNull(whitelist);    this.whitelist  =  whitelist;        [CLASS]  Cleaner  ElementMeta    [METHOD]  <init>  [RETURN_TYPE]  Whitelist)      Whitelist  whitelist  [VARIABLES]  Whitelist    whitelist    boolean    int    numAttribsDiscarded    Element    el    
Validate.notNull  (  whitelist  )  ;	[BUGGY]  this.whitelist  =  whitelist;  Validate.notNull(  whitelist);  [CONTEXT]        [CLASS]  Cleaner  ElementMeta    [METHOD]  <init>  [RETURN_TYPE]  Whitelist)      Whitelist  whitelist  [VARIABLES]  Whitelist    whitelist    boolean    int    numAttribsDiscarded    Element    el    
Validate.notNull  (  whitelist  )  ;	[BUGGY]  Validate.notNull(  dirtyDocument);Validate.notNull(  whitelist);  [CONTEXT]        [CLASS]  Cleaner  ElementMeta    [METHOD]  <init>  [RETURN_TYPE]  Whitelist)      Whitelist  whitelist  [VARIABLES]  Whitelist    whitelist    boolean    int    numAttribsDiscarded    Element    el    
this.whitelist  =  whitelist;	[BUGGY]  this.whitelist  =    null;  [CONTEXT]  public  Cleaner(Whitelist  whitelist)  {  Validate.notNull(whitelist);  [BUGGY]  this.whitelist  =null;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  <init>  [RETURN_TYPE]  Whitelist)      Whitelist  whitelist  [VARIABLES]  Whitelist    whitelist    boolean    int    numAttribsDiscarded    Element    el    
this.el  =  el;	[BUGGY]  this.el  =    null;  [CONTEXT]  ElementMeta(Element  el,  int  numAttribsDiscarded)  {  [BUGGY]  this.el  =null;  this.numAttribsDiscarded  =  numAttribsDiscarded;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  <init>  [RETURN_TYPE]  Element,int)      Element  el  int  numAttribsDiscarded  [VARIABLES]  Whitelist    whitelist    boolean    int    numAttribsDiscarded    Element    el    
this.numAttribsDiscarded  =  numAttribsDiscarded;	[BUGGY]  this.numAttribsDiscarded  =    null;  [CONTEXT]  ElementMeta(Element  el,  int  numAttribsDiscarded)  {  this.el  =  el;  [BUGGY]  this.numAttribsDiscarded  =null;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  <init>  [RETURN_TYPE]  Element,int)      Element  el  int  numAttribsDiscarded  [VARIABLES]  Whitelist    whitelist    boolean    int    numAttribsDiscarded    Element    el    
Validate.notNull  (  dirtyDocument  )  ;	[BUGGY]  Validate.notNull(  clean);  [CONTEXT]  public  Document  clean(Document  dirtyDocument)  {  [BUGGY]  Validate.notNull  (  clean  )  ;    Document  clean  =  Document.createShell(dirtyDocument.baseUri());  copySafeNodes(dirtyDocument.body(),  clean.body());    return  clean;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  clean  [RETURN_TYPE]  Document      Document  dirtyDocument  [VARIABLES]  Whitelist    whitelist    boolean    Document    clean    dirtyDocument    int    numAttribsDiscarded    Element    el    
Validate.notNull  (  dirtyDocument  )  ;	[BUGGY]    [CONTEXT]  public  Document  clean(Document  dirtyDocument)  {  [BUGGY]  Validate.notNull(dirtyDocument);      Document  clean  =  Document.createShell(dirtyDocument.baseUri());  copySafeNodes(dirtyDocument.body(),  clean.body());    return  clean;        [CLASS]  Cleaner  ElementMeta    [METHOD]  clean  [RETURN_TYPE]  Document      Document  dirtyDocument  [VARIABLES]  Whitelist    whitelist    boolean    Document    clean    dirtyDocument    int    numAttribsDiscarded    Element    el    
Document  clean  =  Document.createShell  (  dirtyDocument.baseUri  (  )  )  ;	[BUGGY]  Document  clean  =  Document.createShell(  clean.baseUri(  ));  [CONTEXT]  public  Document  clean(Document  dirtyDocument)  {  Validate.notNull(dirtyDocument);    [BUGGY]  Document  clean  =  Document.createShell  (  clean.baseUri  ())  ;  copySafeNodes(dirtyDocument.body(),  clean.body());    return  clean;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  clean  [RETURN_TYPE]  Document      Document  dirtyDocument  [VARIABLES]  Whitelist    whitelist    boolean    Document    clean    dirtyDocument    int    numAttribsDiscarded    Element    el    
Document  clean  =  Document.createShell  (  dirtyDocument.baseUri  (  )  )  ;	[BUGGY]  Document  clean  =  Document  .baseUri(  )  ;  [CONTEXT]  public  Document  clean(Document  dirtyDocument)  {  Validate.notNull(dirtyDocument);    [BUGGY]  Document  clean  =  Document  .baseUri  ();  copySafeNodes(dirtyDocument.body(),  clean.body());    return  clean;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  clean  [RETURN_TYPE]  Document      Document  dirtyDocument  [VARIABLES]  Whitelist    whitelist    boolean    Document    clean    dirtyDocument    int    numAttribsDiscarded    Element    el    
Document  clean  =  Document.createShell  (  dirtyDocument.baseUri  (  )  )  ;	[BUGGY]  Document  clean  =  Document.createShell(  dirtyDocument  .createShell(  )  );  [CONTEXT]  public  Document  clean(Document  dirtyDocument)  {  Validate.notNull(dirtyDocument);    [BUGGY]  Document  clean  =  Document.createShell  (  dirtyDocument  .createShell  ()  )  ;  copySafeNodes(dirtyDocument.body(),  clean.body());    return  clean;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  clean  [RETURN_TYPE]  Document      Document  dirtyDocument  [VARIABLES]  Whitelist    whitelist    boolean    Document    clean    dirtyDocument    int    numAttribsDiscarded    Element    el    
Document  clean  =  Document.createShell  (  dirtyDocument.baseUri  (  )  )  ;	[BUGGY]    [CONTEXT]  public  Document  clean(Document  dirtyDocument)  {  Validate.notNull(dirtyDocument);    [BUGGY]  Document  clean  =  Document.createShell(dirtyDocument.baseUri());    copySafeNodes(dirtyDocument.body(),  clean.body());    return  clean;        [CLASS]  Cleaner  ElementMeta    [METHOD]  clean  [RETURN_TYPE]  Document      Document  dirtyDocument  [VARIABLES]  Whitelist    whitelist    boolean    Document    clean    dirtyDocument    int    numAttribsDiscarded    Element    el    
Document  clean  =  Document.createShell  (  dirtyDocument.baseUri  (  )  )  ;  copySafeNodes  (  dirtyDocument.body  (  )  ,  clean.body  (  )  )  ;	[BUGGY]  copySafeNodes(  dirtyDocument.body(  ),  clean.body(  ));  Document  clean  =  Document.createShell(  dirtyDocument.baseUri(  ));  [CONTEXT]        [CLASS]  Cleaner  ElementMeta    [METHOD]  clean  [RETURN_TYPE]  Document      Document  dirtyDocument  [VARIABLES]  Whitelist    whitelist    boolean    Document    clean    dirtyDocument    int    numAttribsDiscarded    Element    el    
Document  clean  =  Document.createShell  (  dirtyDocument.baseUri  (  )  )  ;  copySafeNodes  (  dirtyDocument.body  (  )  ,  clean.body  (  )  )  ;	[BUGGY]  int  numDiscarded  =  copySafeNodes(  dirtyDocument.body(  ),  clean.body(  ));Document  clean  =  Document.createShell(  dirtyDocument.baseUri(  ));  copySafeNodes(  dirtyDocument.body(  ),  clean.body(  ));  [CONTEXT]        [CLASS]  Cleaner  ElementMeta    [METHOD]  clean  [RETURN_TYPE]  Document      Document  dirtyDocument  [VARIABLES]  Whitelist    whitelist    boolean    Document    clean    dirtyDocument    int    numAttribsDiscarded    Element    el    
Document  clean  =  Document.createShell  (  dirtyDocument.baseUri  (  )  )  ;  copySafeNodes  (  dirtyDocument.body  (  )  ,  clean.body  (  )  )  ;	[BUGGY]  Document  clean  =  Document.createShell(  dirtyDocument.baseUri(  ));Document  clean  =  Document.createShell(  dirtyDocument.baseUri(  ));  copySafeNodes(  dirtyDocument.body(  ),  clean.body(  ));  [CONTEXT]        [CLASS]  Cleaner  ElementMeta    [METHOD]  clean  [RETURN_TYPE]  Document      Document  dirtyDocument  [VARIABLES]  Whitelist    whitelist    boolean    Document    clean    dirtyDocument    int    numAttribsDiscarded    Element    el    
copySafeNodes  (  dirtyDocument.body  (  )  ,  clean.body  (  )  )  ;	[BUGGY]  copySafeNodes(  clean.body(  ),  dirtyDocument.body(  ));  [CONTEXT]  public  Document  clean(Document  dirtyDocument)  {  Validate.notNull(dirtyDocument);    Document  clean  =  Document.createShell(dirtyDocument.baseUri());  [BUGGY]  copySafeNodes  (  clean.body  ()  ,  dirtyDocument.body  ())  ;    return  clean;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  clean  [RETURN_TYPE]  Document      Document  dirtyDocument  [VARIABLES]  Whitelist    whitelist    boolean    Document    clean    dirtyDocument    int    numAttribsDiscarded    Element    el    
copySafeNodes  (  dirtyDocument.body  (  )  ,  clean.body  (  )  )  ;	[BUGGY]  copySafeNodes(  dirtyDocument.body(  ).body(  ));  [CONTEXT]  public  Document  clean(Document  dirtyDocument)  {  Validate.notNull(dirtyDocument);    Document  clean  =  Document.createShell(dirtyDocument.baseUri());  [BUGGY]  copySafeNodes  (  dirtyDocument.body  ()  .body  ())  ;    return  clean;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  clean  [RETURN_TYPE]  Document      Document  dirtyDocument  [VARIABLES]  Whitelist    whitelist    boolean    Document    clean    dirtyDocument    int    numAttribsDiscarded    Element    el    
copySafeNodes  (  dirtyDocument.body  (  )  ,  clean.body  (  )  )  ;	[BUGGY]    [CONTEXT]  public  Document  clean(Document  dirtyDocument)  {  Validate.notNull(dirtyDocument);    Document  clean  =  Document.createShell(dirtyDocument.baseUri());  [BUGGY]  copySafeNodes(dirtyDocument.body(),  clean.body());      return  clean;        [CLASS]  Cleaner  ElementMeta    [METHOD]  clean  [RETURN_TYPE]  Document      Document  dirtyDocument  [VARIABLES]  Whitelist    whitelist    boolean    Document    clean    dirtyDocument    int    numAttribsDiscarded    Element    el    
copySafeNodes  (  dirtyDocument.body  (  )  ,  clean.body  (  )  )  ;	[BUGGY]  copySafeNodes(  clean.body(  ),  clean.body(  ));  [CONTEXT]  public  Document  clean(Document  dirtyDocument)  {  Validate.notNull(dirtyDocument);    Document  clean  =  Document.createShell(dirtyDocument.baseUri());  [BUGGY]  copySafeNodes  (  clean.body  ()  ,  clean.body  ())  ;    return  clean;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  clean  [RETURN_TYPE]  Document      Document  dirtyDocument  [VARIABLES]  Whitelist    whitelist    boolean    Document    clean    dirtyDocument    int    numAttribsDiscarded    Element    el    
copySafeNodes  (  dirtyDocument.body  (  )  ,  clean.body  (  )  )  ;	[BUGGY]  copySafeNodes(  dirtyDocument  .baseUri(  )  ,  clean  [CONTEXT]  public  Document  clean(Document  dirtyDocument)  {  Validate.notNull(dirtyDocument);    Document  clean  =  Document.createShell(dirtyDocument.baseUri());  [BUGGY]  copySafeNodes  (  dirtyDocument  .baseUri  (),  clean    return  clean;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  clean  [RETURN_TYPE]  Document      Document  dirtyDocument  [VARIABLES]  Whitelist    whitelist    boolean    Document    clean    dirtyDocument    int    numAttribsDiscarded    Element    el    
copySafeNodes  (  dirtyDocument.body  (  )  ,  clean.body  (  )  )  ;	[BUGGY]  copySafeNodes(  dirtyDocument.body(  ),  dirtyDocument.body(  ));  [CONTEXT]  public  Document  clean(Document  dirtyDocument)  {  Validate.notNull(dirtyDocument);    Document  clean  =  Document.createShell(dirtyDocument.baseUri());  [BUGGY]  copySafeNodes  (  dirtyDocument.body  ()  ,  dirtyDocument.body  ())  ;    return  clean;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  clean  [RETURN_TYPE]  Document      Document  dirtyDocument  [VARIABLES]  Whitelist    whitelist    boolean    Document    clean    dirtyDocument    int    numAttribsDiscarded    Element    el    
return  clean;	[BUGGY]  return  dirtyDocument;  [CONTEXT]  public  Document  clean(Document  dirtyDocument)  {  Validate.notNull(dirtyDocument);    Document  clean  =  Document.createShell(dirtyDocument.baseUri());  copySafeNodes(dirtyDocument.body(),  clean.body());    [BUGGY]  return  dirtyDocument;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  clean  [RETURN_TYPE]  Document      Document  dirtyDocument  [VARIABLES]  Whitelist    whitelist    boolean    Document    clean    dirtyDocument    int    numAttribsDiscarded    Element    el    
Validate.notNull  (  dirtyDocument  )  ;	[BUGGY]  Validate.notNull(  clean);  [CONTEXT]  public  boolean  isValid(Document  dirtyDocument)  {  [BUGGY]  Validate.notNull  (  clean  )  ;    Document  clean  =  Document.createShell(dirtyDocument.baseUri());  int  numDiscarded  =  copySafeNodes(dirtyDocument.body(),  clean.body());  return  numDiscarded  ==  0;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  isValid  [RETURN_TYPE]  boolean      Document  dirtyDocument  [VARIABLES]  Whitelist    whitelist    boolean    Document    clean    dirtyDocument    int    numAttribsDiscarded    numDiscarded    Element    el    
Validate.notNull  (  dirtyDocument  )  ;	[BUGGY]    [CONTEXT]  public  boolean  isValid(Document  dirtyDocument)  {  [BUGGY]  Validate.notNull(dirtyDocument);      Document  clean  =  Document.createShell(dirtyDocument.baseUri());  int  numDiscarded  =  copySafeNodes(dirtyDocument.body(),  clean.body());  return  numDiscarded  ==  0;        [CLASS]  Cleaner  ElementMeta    [METHOD]  isValid  [RETURN_TYPE]  boolean      Document  dirtyDocument  [VARIABLES]  Whitelist    whitelist    boolean    Document    clean    dirtyDocument    int    numAttribsDiscarded    numDiscarded    Element    el    
Document  clean  =  Document.createShell  (  dirtyDocument.baseUri  (  )  )  ;	[BUGGY]  Document  clean  =  Document  .baseUri(  )  ;  [CONTEXT]  public  boolean  isValid(Document  dirtyDocument)  {  Validate.notNull(dirtyDocument);    [BUGGY]  Document  clean  =  Document  .baseUri  ();  int  numDiscarded  =  copySafeNodes(dirtyDocument.body(),  clean.body());  return  numDiscarded  ==  0;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  isValid  [RETURN_TYPE]  boolean      Document  dirtyDocument  [VARIABLES]  Whitelist    whitelist    boolean    Document    clean    dirtyDocument    int    numAttribsDiscarded    numDiscarded    Element    el    
Document  clean  =  Document.createShell  (  dirtyDocument.baseUri  (  )  )  ;  int  numDiscarded  =  copySafeNodes  (  dirtyDocument.body  (  )  ,  clean.body  (  )  )  ;	[BUGGY]  int  numDiscarded  =  copySafeNodes(  dirtyDocument.body(  ),  clean.body(  ));  Document  clean  =  Document.createShell(  dirtyDocument.baseUri(  ));  [CONTEXT]        [CLASS]  Cleaner  ElementMeta    [METHOD]  isValid  [RETURN_TYPE]  boolean      Document  dirtyDocument  [VARIABLES]  Whitelist    whitelist    boolean    Document    clean    dirtyDocument    int    numAttribsDiscarded    numDiscarded    Element    el    
Document  clean  =  Document.createShell  (  dirtyDocument.baseUri  (  )  )  ;  int  numDiscarded  =  copySafeNodes  (  dirtyDocument.body  (  )  ,  clean.body  (  )  )  ;	[BUGGY]  int  numDiscarded  =  copySafeNodes(  dirtyDocument.body(  ),  clean.body(  ));Document  clean  =  Document.createShell(  dirtyDocument.baseUri(  ));  int  numDiscarded  =  copySafeNodes(  dirtyDocument.body(  ),  clean.body(  ));  [CONTEXT]        [CLASS]  Cleaner  ElementMeta    [METHOD]  isValid  [RETURN_TYPE]  boolean      Document  dirtyDocument  [VARIABLES]  Whitelist    whitelist    boolean    Document    clean    dirtyDocument    int    numAttribsDiscarded    numDiscarded    Element    el    
Document  clean  =  Document.createShell  (  dirtyDocument.baseUri  (  )  )  ;	[BUGGY]  Document  clean  =  Document.createShell(  clean.baseUri(  ));  [CONTEXT]  public  boolean  isValid(Document  dirtyDocument)  {  Validate.notNull(dirtyDocument);    [BUGGY]  Document  clean  =  Document.createShell  (  clean.baseUri  ())  ;  int  numDiscarded  =  copySafeNodes(dirtyDocument.body(),  clean.body());  return  numDiscarded  ==  0;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  isValid  [RETURN_TYPE]  boolean      Document  dirtyDocument  [VARIABLES]  Whitelist    whitelist    boolean    Document    clean    dirtyDocument    int    numAttribsDiscarded    numDiscarded    Element    el    
Document  clean  =  Document.createShell  (  dirtyDocument.baseUri  (  )  )  ;	[BUGGY]  Document  clean  =  Document.createShell(  dirtyDocument  .createShell(  )  );  [CONTEXT]  public  boolean  isValid(Document  dirtyDocument)  {  Validate.notNull(dirtyDocument);    [BUGGY]  Document  clean  =  Document.createShell  (  dirtyDocument  .createShell  ()  )  ;  int  numDiscarded  =  copySafeNodes(dirtyDocument.body(),  clean.body());  return  numDiscarded  ==  0;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  isValid  [RETURN_TYPE]  boolean      Document  dirtyDocument  [VARIABLES]  Whitelist    whitelist    boolean    Document    clean    dirtyDocument    int    numAttribsDiscarded    numDiscarded    Element    el    
Document  clean  =  Document.createShell  (  dirtyDocument.baseUri  (  )  )  ;	[BUGGY]    [CONTEXT]  public  boolean  isValid(Document  dirtyDocument)  {  Validate.notNull(dirtyDocument);    [BUGGY]  Document  clean  =  Document.createShell(dirtyDocument.baseUri());    int  numDiscarded  =  copySafeNodes(dirtyDocument.body(),  clean.body());  return  numDiscarded  ==  0;        [CLASS]  Cleaner  ElementMeta    [METHOD]  isValid  [RETURN_TYPE]  boolean      Document  dirtyDocument  [VARIABLES]  Whitelist    whitelist    boolean    Document    clean    dirtyDocument    int    numAttribsDiscarded    numDiscarded    Element    el    
Document  clean  =  Document.createShell  (  dirtyDocument.baseUri  (  )  )  ;  int  numDiscarded  =  copySafeNodes  (  dirtyDocument.body  (  )  ,  clean.body  (  )  )  ;	[BUGGY]    [CONTEXT]  public  boolean  isValid(Document  dirtyDocument)  {  Validate.notNull(dirtyDocument);    [BUGGY]  Document  clean  =  Document.createShell(dirtyDocument.baseUri());      return  numDiscarded  ==  0;        [CLASS]  Cleaner  ElementMeta    [METHOD]  isValid  [RETURN_TYPE]  boolean      Document  dirtyDocument  [VARIABLES]  Whitelist    whitelist    boolean    Document    clean    dirtyDocument    int    numAttribsDiscarded    numDiscarded    Element    el    
int  numDiscarded  =  copySafeNodes  (  dirtyDocument.body  (  )  ,  clean.body  (  )  )  ;	[BUGGY]  short    numDiscarded  =  copySafeNodes(  dirtyDocument.body(  ),  clean.body(  ));  [CONTEXT]  public  boolean  isValid(Document  dirtyDocument)  {  Validate.notNull(dirtyDocument);    Document  clean  =  Document.createShell(dirtyDocument.baseUri());  [BUGGY]  shortnumDiscarded  =  copySafeNodes  (  dirtyDocument.body  ()  ,  clean.body  ())  ;  return  numDiscarded  ==  0;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  isValid  [RETURN_TYPE]  boolean      Document  dirtyDocument  [VARIABLES]  Whitelist    whitelist    boolean    Document    clean    dirtyDocument    int    numAttribsDiscarded    numDiscarded    Element    el    
int  numDiscarded  =  copySafeNodes  (  dirtyDocument.body  (  )  ,  clean.body  (  )  )  ;	[BUGGY]  int  numDiscarded  =  copySafeNodes(  clean.body(  ),  clean.body(  ));  [CONTEXT]  public  boolean  isValid(Document  dirtyDocument)  {  Validate.notNull(dirtyDocument);    Document  clean  =  Document.createShell(dirtyDocument.baseUri());  [BUGGY]  int  numDiscarded  =  copySafeNodes  (  clean.body  ()  ,  clean.body  ())  ;  return  numDiscarded  ==  0;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  isValid  [RETURN_TYPE]  boolean      Document  dirtyDocument  [VARIABLES]  Whitelist    whitelist    boolean    Document    clean    dirtyDocument    int    numAttribsDiscarded    numDiscarded    Element    el    
int  numDiscarded  =  copySafeNodes  (  dirtyDocument.body  (  )  ,  clean.body  (  )  )  ;	[BUGGY]  int  numDiscarded  =  copySafeNodes(  dirtyDocument.body(  ),  dirtyDocument.body(  ));  [CONTEXT]  public  boolean  isValid(Document  dirtyDocument)  {  Validate.notNull(dirtyDocument);    Document  clean  =  Document.createShell(dirtyDocument.baseUri());  [BUGGY]  int  numDiscarded  =  copySafeNodes  (  dirtyDocument.body  ()  ,  dirtyDocument.body  ())  ;  return  numDiscarded  ==  0;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  isValid  [RETURN_TYPE]  boolean      Document  dirtyDocument  [VARIABLES]  Whitelist    whitelist    boolean    Document    clean    dirtyDocument    int    numAttribsDiscarded    numDiscarded    Element    el    
int  numDiscarded  =  copySafeNodes  (  dirtyDocument.body  (  )  ,  clean.body  (  )  )  ;	[BUGGY]  int  numDiscarded  =  copySafeNodes(  clean.body(  ),  dirtyDocument.body(  ));  [CONTEXT]  public  boolean  isValid(Document  dirtyDocument)  {  Validate.notNull(dirtyDocument);    Document  clean  =  Document.createShell(dirtyDocument.baseUri());  [BUGGY]  int  numDiscarded  =  copySafeNodes  (  clean.body  ()  ,  dirtyDocument.body  ())  ;  return  numDiscarded  ==  0;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  isValid  [RETURN_TYPE]  boolean      Document  dirtyDocument  [VARIABLES]  Whitelist    whitelist    boolean    Document    clean    dirtyDocument    int    numAttribsDiscarded    numDiscarded    Element    el    
int  numDiscarded  =  copySafeNodes  (  dirtyDocument.body  (  )  ,  clean.body  (  )  )  ;	[BUGGY]  int  numDiscarded  =  copySafeNodes(  dirtyDocument.body(  ).body(  ));  [CONTEXT]  public  boolean  isValid(Document  dirtyDocument)  {  Validate.notNull(dirtyDocument);    Document  clean  =  Document.createShell(dirtyDocument.baseUri());  [BUGGY]  int  numDiscarded  =  copySafeNodes  (  dirtyDocument.body  ()  .body  ())  ;  return  numDiscarded  ==  0;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  isValid  [RETURN_TYPE]  boolean      Document  dirtyDocument  [VARIABLES]  Whitelist    whitelist    boolean    Document    clean    dirtyDocument    int    numAttribsDiscarded    numDiscarded    Element    el    
int  numDiscarded  =  copySafeNodes  (  dirtyDocument.body  (  )  ,  clean.body  (  )  )  ;	[BUGGY]  int  numDiscarded  =  copySafeNodes(  dirtyDocument  .baseUri(  )  ,  dirtyDocument  [CONTEXT]  public  boolean  isValid(Document  dirtyDocument)  {  Validate.notNull(dirtyDocument);    Document  clean  =  Document.createShell(dirtyDocument.baseUri());  [BUGGY]  int  numDiscarded  =  copySafeNodes  (  dirtyDocument  .baseUri  (),  dirtyDocument  return  numDiscarded  ==  0;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  isValid  [RETURN_TYPE]  boolean      Document  dirtyDocument  [VARIABLES]  Whitelist    whitelist    boolean    Document    clean    dirtyDocument    int    numAttribsDiscarded    numDiscarded    Element    el    
int  numDiscarded  =  copySafeNodes  (  dirtyDocument.body  (  )  ,  clean.body  (  )  )  ;	[BUGGY]  int  numDiscarded  =  copySafeNodes(  dirtyDocument  .baseUri(  )  ,  clean  [CONTEXT]  public  boolean  isValid(Document  dirtyDocument)  {  Validate.notNull(dirtyDocument);    Document  clean  =  Document.createShell(dirtyDocument.baseUri());  [BUGGY]  int  numDiscarded  =  copySafeNodes  (  dirtyDocument  .baseUri  (),  clean  return  numDiscarded  ==  0;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  isValid  [RETURN_TYPE]  boolean      Document  dirtyDocument  [VARIABLES]  Whitelist    whitelist    boolean    Document    clean    dirtyDocument    int    numAttribsDiscarded    numDiscarded    Element    el    
int  numDiscarded  =  copySafeNodes  (  dirtyDocument.body  (  )  ,  clean.body  (  )  )  ;  return  numDiscarded  ==  0;	[BUGGY]    [CONTEXT]  public  boolean  isValid(Document  dirtyDocument)  {  Validate.notNull(dirtyDocument);    Document  clean  =  Document.createShell(dirtyDocument.baseUri());  [BUGGY]  int  numDiscarded  =  copySafeNodes(dirtyDocument.body(),  clean.body());            [CLASS]  Cleaner  ElementMeta    [METHOD]  isValid  [RETURN_TYPE]  boolean      Document  dirtyDocument  [VARIABLES]  Whitelist    whitelist    boolean    Document    clean    dirtyDocument    int    numAttribsDiscarded    numDiscarded    Element    el    
int  numDiscarded  =  copySafeNodes  (  dirtyDocument.body  (  )  ,  clean.body  (  )  )  ;	[BUGGY]    int  numDiscarded  =  copySafeNodes(  dirtyDocument.body(  ),  clean.body(  ));  [CONTEXT]        [CLASS]  Cleaner  ElementMeta    [METHOD]  isValid  [RETURN_TYPE]  boolean      Document  dirtyDocument  [VARIABLES]  Whitelist    whitelist    boolean    Document    clean    dirtyDocument    int    numAttribsDiscarded    numDiscarded    Element    el    
int  numDiscarded  =  copySafeNodes  (  dirtyDocument.body  (  )  ,  clean.body  (  )  )  ;	[BUGGY]  copySafeNodes(  dirtyDocument.body(  ),  clean.body(  ));int  numDiscarded  =  copySafeNodes(  dirtyDocument.body(  ),  clean.body(  ));  [CONTEXT]        [CLASS]  Cleaner  ElementMeta    [METHOD]  isValid  [RETURN_TYPE]  boolean      Document  dirtyDocument  [VARIABLES]  Whitelist    whitelist    boolean    Document    clean    dirtyDocument    int    numAttribsDiscarded    numDiscarded    Element    el    
int  numDiscarded  =  copySafeNodes  (  dirtyDocument.body  (  )  ,  clean.body  (  )  )  ;	[BUGGY]    [CONTEXT]  public  boolean  isValid(Document  dirtyDocument)  {  Validate.notNull(dirtyDocument);    Document  clean  =  Document.createShell(dirtyDocument.baseUri());  [BUGGY]  int  numDiscarded  =  copySafeNodes(dirtyDocument.body(),  clean.body());    return  numDiscarded  ==  0;        [CLASS]  Cleaner  ElementMeta    [METHOD]  isValid  [RETURN_TYPE]  boolean      Document  dirtyDocument  [VARIABLES]  Whitelist    whitelist    boolean    Document    clean    dirtyDocument    int    numAttribsDiscarded    numDiscarded    Element    el    
return  numDiscarded  ==  0;	[BUGGY]  return  numDiscarded  >=  0;  [CONTEXT]  public  boolean  isValid(Document  dirtyDocument)  {  Validate.notNull(dirtyDocument);    Document  clean  =  Document.createShell(dirtyDocument.baseUri());  int  numDiscarded  =  copySafeNodes(dirtyDocument.body(),  clean.body());  [BUGGY]  return  numDiscarded  >=  0;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  isValid  [RETURN_TYPE]  boolean      Document  dirtyDocument  [VARIABLES]  Whitelist    whitelist    boolean    Document    clean    dirtyDocument    int    numAttribsDiscarded    numDiscarded    Element    el    
return  numDiscarded  ==  0;	[BUGGY]  return  numDiscarded  ==  9;  [CONTEXT]  public  boolean  isValid(Document  dirtyDocument)  {  Validate.notNull(dirtyDocument);    Document  clean  =  Document.createShell(dirtyDocument.baseUri());  int  numDiscarded  =  copySafeNodes(dirtyDocument.body(),  clean.body());  [BUGGY]  return  numDiscarded  ==  9;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  isValid  [RETURN_TYPE]  boolean      Document  dirtyDocument  [VARIABLES]  Whitelist    whitelist    boolean    Document    clean    dirtyDocument    int    numAttribsDiscarded    numDiscarded    Element    el    
return  numDiscarded  ==  0;	[BUGGY]  return  numAttribsDiscarded  ==  0;  [CONTEXT]  public  boolean  isValid(Document  dirtyDocument)  {  Validate.notNull(dirtyDocument);    Document  clean  =  Document.createShell(dirtyDocument.baseUri());  int  numDiscarded  =  copySafeNodes(dirtyDocument.body(),  clean.body());  [BUGGY]  return  numAttribsDiscarded  ==  0;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  isValid  [RETURN_TYPE]  boolean      Document  dirtyDocument  [VARIABLES]  Whitelist    whitelist    boolean    Document    clean    dirtyDocument    int    numAttribsDiscarded    numDiscarded    Element    el    
return  numDiscarded  ==  0;	[BUGGY]  return  numDiscarded    !=    0;;  [CONTEXT]  public  boolean  isValid(Document  dirtyDocument)  {  Validate.notNull(dirtyDocument);    Document  clean  =  Document.createShell(dirtyDocument.baseUri());  int  numDiscarded  =  copySafeNodes(dirtyDocument.body(),  clean.body());  [BUGGY]  return  numDiscarded!=0;;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  isValid  [RETURN_TYPE]  boolean      Document  dirtyDocument  [VARIABLES]  Whitelist    whitelist    boolean    Document    clean    dirtyDocument    int    numAttribsDiscarded    numDiscarded    Element    el    
List<Node>  sourceChildren  =  source.childNodes  (  )  ;	[BUGGY]  List<Node>  sourceElChildren  =  source.childNodes(  );  [CONTEXT]  private  int  copySafeNodes(Element  source,  Element  dest)  {  [BUGGY]  List<Node>  sourceElChildren  =  source.childNodes  ()  ;  int  numDiscarded  =  0;    for  (Node  sourceChild  :  sourceChildren)  {  if  (sourceChild  instanceof  Element)  {  Element  sourceEl  =  (Element)  sourceChild;    if  (whitelist.isSafeTag(sourceEl.tagName()))  {  //  safe,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement(sourceEl);  Element  destChild  =  meta.el;  dest.appendChild(destChild);    numDiscarded  +=  meta.numAttribsDiscarded;  numDiscarded  +=  copySafeNodes(sourceEl,  destChild);  //  recurs  }  else  {  //  not  a  safe  tag,  but  it  may  have  children  (els  or  text)  that  are,  so  recurse  numDiscarded++;  numDiscarded  +=  copySafeNodes(sourceEl,  dest);  }  }  else  if  (sourceChild  instanceof  TextNode)  {  TextNode  sourceText  =  (TextNode)  sourceChild;  TextNode  destText  =  new  TextNode(sourceText.getWholeText(),  sourceChild.baseUri());  dest.appendChild(destText);  }  //  else,  we  don't  care  about  comments,  xml  proc  instructions,  etc  }  return  numDiscarded;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
List<Node>  sourceChildren  =  source.childNodes  (  )  ;	[BUGGY]  List<Node>  sourceChildren  =  source.appendChild(  );  [CONTEXT]  private  int  copySafeNodes(Element  source,  Element  dest)  {  [BUGGY]  List<Node>  sourceChildren  =  source.appendChild  ()  ;  int  numDiscarded  =  0;    for  (Node  sourceChild  :  sourceChildren)  {  if  (sourceChild  instanceof  Element)  {  Element  sourceEl  =  (Element)  sourceChild;    if  (whitelist.isSafeTag(sourceEl.tagName()))  {  //  safe,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement(sourceEl);  Element  destChild  =  meta.el;  dest.appendChild(destChild);    numDiscarded  +=  meta.numAttribsDiscarded;  numDiscarded  +=  copySafeNodes(sourceEl,  destChild);  //  recurs  }  else  {  //  not  a  safe  tag,  but  it  may  have  children  (els  or  text)  that  are,  so  recurse  numDiscarded++;  numDiscarded  +=  copySafeNodes(sourceEl,  dest);  }  }  else  if  (sourceChild  instanceof  TextNode)  {  TextNode  sourceText  =  (TextNode)  sourceChild;  TextNode  destText  =  new  TextNode(sourceText.getWholeText(),  sourceChild.baseUri());  dest.appendChild(destText);  }  //  else,  we  don't  care  about  comments,  xml  proc  instructions,  etc  }  return  numDiscarded;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
List<Node>  sourceChildren  =  source.childNodes  (  )  ;	[BUGGY]  List<Node>  sourceElChildren  =  source.appendChild(  );  [CONTEXT]  private  int  copySafeNodes(Element  source,  Element  dest)  {  [BUGGY]  List<Node>  sourceElChildren  =  source.appendChild  ()  ;  int  numDiscarded  =  0;    for  (Node  sourceChild  :  sourceChildren)  {  if  (sourceChild  instanceof  Element)  {  Element  sourceEl  =  (Element)  sourceChild;    if  (whitelist.isSafeTag(sourceEl.tagName()))  {  //  safe,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement(sourceEl);  Element  destChild  =  meta.el;  dest.appendChild(destChild);    numDiscarded  +=  meta.numAttribsDiscarded;  numDiscarded  +=  copySafeNodes(sourceEl,  destChild);  //  recurs  }  else  {  //  not  a  safe  tag,  but  it  may  have  children  (els  or  text)  that  are,  so  recurse  numDiscarded++;  numDiscarded  +=  copySafeNodes(sourceEl,  dest);  }  }  else  if  (sourceChild  instanceof  TextNode)  {  TextNode  sourceText  =  (TextNode)  sourceChild;  TextNode  destText  =  new  TextNode(sourceText.getWholeText(),  sourceChild.baseUri());  dest.appendChild(destText);  }  //  else,  we  don't  care  about  comments,  xml  proc  instructions,  etc  }  return  numDiscarded;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
List<Node>  sourceChildren  =  source.childNodes  (  )  ;	[BUGGY]  String  sourceTag  =  sourceEl.tagName(  );List<Node>  sourceChildren  =  source.childNodes(  );  [CONTEXT]        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
List<Node>  sourceChildren  =  source.childNodes  (  )  ;	[BUGGY]    [CONTEXT]  private  int  copySafeNodes(Element  source,  Element  dest)  {  [BUGGY]  List<Node>  sourceChildren  =  source.childNodes();    int  numDiscarded  =  0;    for  (Node  sourceChild  :  sourceChildren)  {  if  (sourceChild  instanceof  Element)  {  Element  sourceEl  =  (Element)  sourceChild;    if  (whitelist.isSafeTag(sourceEl.tagName()))  {  //  safe,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement(sourceEl);  Element  destChild  =  meta.el;  dest.appendChild(destChild);    numDiscarded  +=  meta.numAttribsDiscarded;  numDiscarded  +=  copySafeNodes(sourceEl,  destChild);  //  recurs  }  else  {  //  not  a  safe  tag,  but  it  may  have  children  (els  or  text)  that  are,  so  recurse  numDiscarded++;  numDiscarded  +=  copySafeNodes(sourceEl,  dest);  }  }  else  if  (sourceChild  instanceof  TextNode)  {  TextNode  sourceText  =  (TextNode)  sourceChild;  TextNode  destText  =  new  TextNode(sourceText.getWholeText(),  sourceChild.baseUri());  dest.appendChild(destText);  }  //  else,  we  don't  care  about  comments,  xml  proc  instructions,  etc  }  return  numDiscarded;        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
int  numDiscarded  =  0;	[BUGGY]  long    numDiscarded  =  0;  [CONTEXT]  private  int  copySafeNodes(Element  source,  Element  dest)  {  List<Node>  sourceChildren  =  source.childNodes();  [BUGGY]  longnumDiscarded  =  0;    for  (Node  sourceChild  :  sourceChildren)  {  if  (sourceChild  instanceof  Element)  {  Element  sourceEl  =  (Element)  sourceChild;    if  (whitelist.isSafeTag(sourceEl.tagName()))  {  //  safe,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement(sourceEl);  Element  destChild  =  meta.el;  dest.appendChild(destChild);    numDiscarded  +=  meta.numAttribsDiscarded;  numDiscarded  +=  copySafeNodes(sourceEl,  destChild);  //  recurs  }  else  {  //  not  a  safe  tag,  but  it  may  have  children  (els  or  text)  that  are,  so  recurse  numDiscarded++;  numDiscarded  +=  copySafeNodes(sourceEl,  dest);  }  }  else  if  (sourceChild  instanceof  TextNode)  {  TextNode  sourceText  =  (TextNode)  sourceChild;  TextNode  destText  =  new  TextNode(sourceText.getWholeText(),  sourceChild.baseUri());  dest.appendChild(destText);  }  //  else,  we  don't  care  about  comments,  xml  proc  instructions,  etc  }  return  numDiscarded;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
int  numDiscarded  =  0;	[BUGGY]  int  numDiscarded  =  numAttribsDiscarded;  [CONTEXT]  private  int  copySafeNodes(Element  source,  Element  dest)  {  List<Node>  sourceChildren  =  source.childNodes();  [BUGGY]  int  numDiscarded  =  numAttribsDiscarded;    for  (Node  sourceChild  :  sourceChildren)  {  if  (sourceChild  instanceof  Element)  {  Element  sourceEl  =  (Element)  sourceChild;    if  (whitelist.isSafeTag(sourceEl.tagName()))  {  //  safe,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement(sourceEl);  Element  destChild  =  meta.el;  dest.appendChild(destChild);    numDiscarded  +=  meta.numAttribsDiscarded;  numDiscarded  +=  copySafeNodes(sourceEl,  destChild);  //  recurs  }  else  {  //  not  a  safe  tag,  but  it  may  have  children  (els  or  text)  that  are,  so  recurse  numDiscarded++;  numDiscarded  +=  copySafeNodes(sourceEl,  dest);  }  }  else  if  (sourceChild  instanceof  TextNode)  {  TextNode  sourceText  =  (TextNode)  sourceChild;  TextNode  destText  =  new  TextNode(sourceText.getWholeText(),  sourceChild.baseUri());  dest.appendChild(destText);  }  //  else,  we  don't  care  about  comments,  xml  proc  instructions,  etc  }  return  numDiscarded;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
if  (  sourceChild  instanceof  Element  )  {	[BUGGY]  if  (  sourceChild    ==    Element)  {  [CONTEXT]  private  int  copySafeNodes(Element  source,  Element  dest)  {  List<Node>  sourceChildren  =  source.childNodes();  int  numDiscarded  =  0;    for  (Node  sourceChild  :  sourceChildren)  {  [BUGGY]  if(  sourceChild==Element  ){  Element  sourceEl  =  (Element)  sourceChild;    if  (whitelist.isSafeTag(sourceEl.tagName()))  {  //  safe,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement(sourceEl);  Element  destChild  =  meta.el;  dest.appendChild(destChild);    numDiscarded  +=  meta.numAttribsDiscarded;  numDiscarded  +=  copySafeNodes(sourceEl,  destChild);  //  recurs  }  else  {  //  not  a  safe  tag,  but  it  may  have  children  (els  or  text)  that  are,  so  recurse  numDiscarded++;  numDiscarded  +=  copySafeNodes(sourceEl,  dest);  }  }  else  if  (sourceChild  instanceof  TextNode)  {  TextNode  sourceText  =  (TextNode)  sourceChild;  TextNode  destText  =  new  TextNode(sourceText.getWholeText(),  sourceChild.baseUri());  dest.appendChild(destText);  }  //  else,  we  don't  care  about  comments,  xml  proc  instructions,  etc  }  return  numDiscarded;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
if  (  sourceChild  instanceof  Element  )  {	[BUGGY]  if  (  sourceChild    &&    Element)  {  [CONTEXT]  private  int  copySafeNodes(Element  source,  Element  dest)  {  List<Node>  sourceChildren  =  source.childNodes();  int  numDiscarded  =  0;    for  (Node  sourceChild  :  sourceChildren)  {  [BUGGY]  if(  sourceChild&&Element  ){  Element  sourceEl  =  (Element)  sourceChild;    if  (whitelist.isSafeTag(sourceEl.tagName()))  {  //  safe,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement(sourceEl);  Element  destChild  =  meta.el;  dest.appendChild(destChild);    numDiscarded  +=  meta.numAttribsDiscarded;  numDiscarded  +=  copySafeNodes(sourceEl,  destChild);  //  recurs  }  else  {  //  not  a  safe  tag,  but  it  may  have  children  (els  or  text)  that  are,  so  recurse  numDiscarded++;  numDiscarded  +=  copySafeNodes(sourceEl,  dest);  }  }  else  if  (sourceChild  instanceof  TextNode)  {  TextNode  sourceText  =  (TextNode)  sourceChild;  TextNode  destText  =  new  TextNode(sourceText.getWholeText(),  sourceChild.baseUri());  dest.appendChild(destText);  }  //  else,  we  don't  care  about  comments,  xml  proc  instructions,  etc  }  return  numDiscarded;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
if  (  sourceChild  instanceof  Element  )  {	[BUGGY]  if  (  sourceChild  instanceof  TextNode)  {  [CONTEXT]  private  int  copySafeNodes(Element  source,  Element  dest)  {  List<Node>  sourceChildren  =  source.childNodes();  int  numDiscarded  =  0;    for  (Node  sourceChild  :  sourceChildren)  {  [BUGGY]  if(  sourceChild  instanceof  TextNode  ){  Element  sourceEl  =  (Element)  sourceChild;    if  (whitelist.isSafeTag(sourceEl.tagName()))  {  //  safe,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement(sourceEl);  Element  destChild  =  meta.el;  dest.appendChild(destChild);    numDiscarded  +=  meta.numAttribsDiscarded;  numDiscarded  +=  copySafeNodes(sourceEl,  destChild);  //  recurs  }  else  {  //  not  a  safe  tag,  but  it  may  have  children  (els  or  text)  that  are,  so  recurse  numDiscarded++;  numDiscarded  +=  copySafeNodes(sourceEl,  dest);  }  }  else  if  (sourceChild  instanceof  TextNode)  {  TextNode  sourceText  =  (TextNode)  sourceChild;  TextNode  destText  =  new  TextNode(sourceText.getWholeText(),  sourceChild.baseUri());  dest.appendChild(destText);  }  //  else,  we  don't  care  about  comments,  xml  proc  instructions,  etc  }  return  numDiscarded;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
}  else  if  (  sourceChild  instanceof  TextNode  )  {	[BUGGY]    else  if  (  sourceChild    &&    TextNode)  {  [CONTEXT]  private  int  copySafeNodes(Element  source,  Element  dest)  {  List<Node>  sourceChildren  =  source.childNodes();  int  numDiscarded  =  0;    for  (Node  sourceChild  :  sourceChildren)  {  if  (sourceChild  instanceof  Element)  {  Element  sourceEl  =  (Element)  sourceChild;    if  (whitelist.isSafeTag(sourceEl.tagName()))  {  //  safe,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement(sourceEl);  Element  destChild  =  meta.el;  dest.appendChild(destChild);    numDiscarded  +=  meta.numAttribsDiscarded;  numDiscarded  +=  copySafeNodes(sourceEl,  destChild);  //  recurs  }  else  {  //  not  a  safe  tag,  but  it  may  have  children  (els  or  text)  that  are,  so  recurse  numDiscarded++;  numDiscarded  +=  copySafeNodes(sourceEl,  dest);  }  [BUGGY]  }  else  if(  sourceChild&&TextNode  ){  TextNode  sourceText  =  (TextNode)  sourceChild;  TextNode  destText  =  new  TextNode(sourceText.getWholeText(),  sourceChild.baseUri());  dest.appendChild(destText);  }  //  else,  we  don't  care  about  comments,  xml  proc  instructions,  etc  }  return  numDiscarded;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
}  else  if  (  sourceChild  instanceof  TextNode  )  {	[BUGGY]    else  {  [CONTEXT]  private  int  copySafeNodes(Element  source,  Element  dest)  {  List<Node>  sourceChildren  =  source.childNodes();  int  numDiscarded  =  0;    for  (Node  sourceChild  :  sourceChildren)  {  if  (sourceChild  instanceof  Element)  {  Element  sourceEl  =  (Element)  sourceChild;    if  (whitelist.isSafeTag(sourceEl.tagName()))  {  //  safe,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement(sourceEl);  Element  destChild  =  meta.el;  dest.appendChild(destChild);    numDiscarded  +=  meta.numAttribsDiscarded;  numDiscarded  +=  copySafeNodes(sourceEl,  destChild);  //  recurs  }  else  {  //  not  a  safe  tag,  but  it  may  have  children  (els  or  text)  that  are,  so  recurse  numDiscarded++;  numDiscarded  +=  copySafeNodes(sourceEl,  dest);  }  [BUGGY]  }  else  {  TextNode  sourceText  =  (TextNode)  sourceChild;  TextNode  destText  =  new  TextNode(sourceText.getWholeText(),  sourceChild.baseUri());  dest.appendChild(destText);  }  //  else,  we  don't  care  about  comments,  xml  proc  instructions,  etc  }  return  numDiscarded;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
}  else  if  (  sourceChild  instanceof  TextNode  )  {  TextNode  sourceText  =  (  TextNode  )  sourceChild;  TextNode  destText  =  new  TextNode  (  sourceText.getWholeText  (  )  ,  sourceChild.baseUri  (  )  )  ;  dest.appendChild  (  destText  )  ;  }	[BUGGY]  org.jsoup.safety.TextNode  sourceText  =((org.jsoup.safety.TextNode)(sourceChild));  org.jsoup.safety.TextNode  destText  =  new  org.jsoup.safety.TextNode(sourceText.getWholeText(),  sourceChild.baseUri());  dest.appendChild(destText);  [CONTEXT]  private  int  copySafeNodes(Element  source,  Element  dest)  {  List<Node>  sourceChildren  =  source.childNodes();  int  numDiscarded  =  0;    for  (Node  sourceChild  :  sourceChildren)  {  if  (sourceChild  instanceof  Element)  {  Element  sourceEl  =  (Element)  sourceChild;    if  (whitelist.isSafeTag(sourceEl.tagName()))  {  //  safe,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement(sourceEl);  Element  destChild  =  meta.el;  dest.appendChild(destChild);    numDiscarded  +=  meta.numAttribsDiscarded;  numDiscarded  +=  copySafeNodes(sourceEl,  destChild);  //  recurs  }  else  {  //  not  a  safe  tag,  but  it  may  have  children  (els  or  text)  that  are,  so  recurse  numDiscarded++;  numDiscarded  +=  copySafeNodes(sourceEl,  dest);  }  [BUGGY]  }  else  if  (sourceChild  instanceof  TextNode)  {    org.jsoup.safety.TextNode  sourceText  =  ((org.jsoup.safety.TextNode)  (sourceChild));  org.jsoup.safety.TextNode  destText  =  new  org.jsoup.safety.TextNode(sourceText.getWholeText(),  sourceChild.baseUri());  dest.appendChild(destText);        }  return  numDiscarded;        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
}  else  if  (  sourceChild  instanceof  TextNode  )  {  TextNode  sourceText  =  (  TextNode  )  sourceChild;  TextNode  destText  =  new  TextNode  (  sourceText.getWholeText  (  )  ,  sourceChild.baseUri  (  )  )  ;  dest.appendChild  (  destText  )  ;  }	[BUGGY]    [CONTEXT]  private  int  copySafeNodes(Element  source,  Element  dest)  {  List<Node>  sourceChildren  =  source.childNodes();  int  numDiscarded  =  0;    for  (Node  sourceChild  :  sourceChildren)  {  if  (sourceChild  instanceof  Element)  {  Element  sourceEl  =  (Element)  sourceChild;    if  (whitelist.isSafeTag(sourceEl.tagName()))  {  //  safe,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement(sourceEl);  Element  destChild  =  meta.el;  dest.appendChild(destChild);    numDiscarded  +=  meta.numAttribsDiscarded;  numDiscarded  +=  copySafeNodes(sourceEl,  destChild);  //  recurs  }  else  {  //  not  a  safe  tag,  but  it  may  have  children  (els  or  text)  that  are,  so  recurse  numDiscarded++;  numDiscarded  +=  copySafeNodes(sourceEl,  dest);  }  [BUGGY]  }  else  if  (sourceChild  instanceof  TextNode)  {            }  return  numDiscarded;        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
TextNode  destText  =  new  TextNode  (  sourceText.getWholeText  (  )  ,  sourceChild.baseUri  (  )  )  ;	[BUGGY]  TextNode  destText  =  new  TextNode(  sourceText.getWholeText(  ).baseUri(  ));  [CONTEXT]  private  int  copySafeNodes(Element  source,  Element  dest)  {  List<Node>  sourceChildren  =  source.childNodes();  int  numDiscarded  =  0;    for  (Node  sourceChild  :  sourceChildren)  {  if  (sourceChild  instanceof  Element)  {  Element  sourceEl  =  (Element)  sourceChild;    if  (whitelist.isSafeTag(sourceEl.tagName()))  {  //  safe,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement(sourceEl);  Element  destChild  =  meta.el;  dest.appendChild(destChild);    numDiscarded  +=  meta.numAttribsDiscarded;  numDiscarded  +=  copySafeNodes(sourceEl,  destChild);  //  recurs  }  else  {  //  not  a  safe  tag,  but  it  may  have  children  (els  or  text)  that  are,  so  recurse  numDiscarded++;  numDiscarded  +=  copySafeNodes(sourceEl,  dest);  }  }  else  if  (sourceChild  instanceof  TextNode)  {  TextNode  sourceText  =  (TextNode)  sourceChild;  [BUGGY]  TextNode  destText  =  new  TextNode  (  sourceText.getWholeText  ()  .baseUri  ())  ;  dest.appendChild(destText);  }  //  else,  we  don't  care  about  comments,  xml  proc  instructions,  etc  }  return  numDiscarded;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
TextNode  destText  =  new  TextNode  (  sourceText.getWholeText  (  )  ,  sourceChild.baseUri  (  )  )  ;	[BUGGY]  TextNode  destText  =  new  TextNode(  sourceChild.getWholeText(  ),  sourceText.baseUri(  ));  [CONTEXT]  private  int  copySafeNodes(Element  source,  Element  dest)  {  List<Node>  sourceChildren  =  source.childNodes();  int  numDiscarded  =  0;    for  (Node  sourceChild  :  sourceChildren)  {  if  (sourceChild  instanceof  Element)  {  Element  sourceEl  =  (Element)  sourceChild;    if  (whitelist.isSafeTag(sourceEl.tagName()))  {  //  safe,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement(sourceEl);  Element  destChild  =  meta.el;  dest.appendChild(destChild);    numDiscarded  +=  meta.numAttribsDiscarded;  numDiscarded  +=  copySafeNodes(sourceEl,  destChild);  //  recurs  }  else  {  //  not  a  safe  tag,  but  it  may  have  children  (els  or  text)  that  are,  so  recurse  numDiscarded++;  numDiscarded  +=  copySafeNodes(sourceEl,  dest);  }  }  else  if  (sourceChild  instanceof  TextNode)  {  TextNode  sourceText  =  (TextNode)  sourceChild;  [BUGGY]  TextNode  destText  =  new  TextNode  (  sourceChild.getWholeText  ()  ,  sourceText.baseUri  ())  ;  dest.appendChild(destText);  }  //  else,  we  don't  care  about  comments,  xml  proc  instructions,  etc  }  return  numDiscarded;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
TextNode  destText  =  new  TextNode  (  sourceText.getWholeText  (  )  ,  sourceChild.baseUri  (  )  )  ;	[BUGGY]  TextNode  destText  =  new  TextNode(  destText  .TextNode(  )  ,  sourceChild.baseUri(  ));  [CONTEXT]  private  int  copySafeNodes(Element  source,  Element  dest)  {  List<Node>  sourceChildren  =  source.childNodes();  int  numDiscarded  =  0;    for  (Node  sourceChild  :  sourceChildren)  {  if  (sourceChild  instanceof  Element)  {  Element  sourceEl  =  (Element)  sourceChild;    if  (whitelist.isSafeTag(sourceEl.tagName()))  {  //  safe,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement(sourceEl);  Element  destChild  =  meta.el;  dest.appendChild(destChild);    numDiscarded  +=  meta.numAttribsDiscarded;  numDiscarded  +=  copySafeNodes(sourceEl,  destChild);  //  recurs  }  else  {  //  not  a  safe  tag,  but  it  may  have  children  (els  or  text)  that  are,  so  recurse  numDiscarded++;  numDiscarded  +=  copySafeNodes(sourceEl,  dest);  }  }  else  if  (sourceChild  instanceof  TextNode)  {  TextNode  sourceText  =  (TextNode)  sourceChild;  [BUGGY]  TextNode  destText  =  new  TextNode  (  destText  .TextNode  (),  sourceChild.baseUri  ())  ;  dest.appendChild(destText);  }  //  else,  we  don't  care  about  comments,  xml  proc  instructions,  etc  }  return  numDiscarded;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
TextNode  sourceText  =  (  TextNode  )  sourceChild;  TextNode  destText  =  new  TextNode  (  sourceText.getWholeText  (  )  ,  sourceChild.baseUri  (  )  )  ;	[BUGGY]  TextNode  destText  =  new  TextNode(  sourceText.getWholeText(  ),  sourceChild.baseUri(  ));  TextNode  sourceText  =  (  TextNode)  sourceChild;  [CONTEXT]        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
TextNode  sourceText  =  (  TextNode  )  sourceChild;  TextNode  destText  =  new  TextNode  (  sourceText.getWholeText  (  )  ,  sourceChild.baseUri  (  )  )  ;	[BUGGY]  TextNode  destText  =  new  TextNode(  sourceText.getWholeText(  ),  sourceChild.baseUri(  ));TextNode  sourceText  =  (  TextNode)  sourceChild;  TextNode  destText  =  new  TextNode(  sourceText.getWholeText(  ),  sourceChild.baseUri(  ));  [CONTEXT]        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
TextNode  destText  =  new  TextNode  (  sourceText.getWholeText  (  )  ,  sourceChild.baseUri  (  )  )  ;	[BUGGY]  TextNode  destText  =  new  TextNode(  sourceText.getWholeText(  ),  sourceChild  .createShell(  )  );  [CONTEXT]  private  int  copySafeNodes(Element  source,  Element  dest)  {  List<Node>  sourceChildren  =  source.childNodes();  int  numDiscarded  =  0;    for  (Node  sourceChild  :  sourceChildren)  {  if  (sourceChild  instanceof  Element)  {  Element  sourceEl  =  (Element)  sourceChild;    if  (whitelist.isSafeTag(sourceEl.tagName()))  {  //  safe,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement(sourceEl);  Element  destChild  =  meta.el;  dest.appendChild(destChild);    numDiscarded  +=  meta.numAttribsDiscarded;  numDiscarded  +=  copySafeNodes(sourceEl,  destChild);  //  recurs  }  else  {  //  not  a  safe  tag,  but  it  may  have  children  (els  or  text)  that  are,  so  recurse  numDiscarded++;  numDiscarded  +=  copySafeNodes(sourceEl,  dest);  }  }  else  if  (sourceChild  instanceof  TextNode)  {  TextNode  sourceText  =  (TextNode)  sourceChild;  [BUGGY]  TextNode  destText  =  new  TextNode  (  sourceText.getWholeText  ()  ,  sourceChild  .createShell  ()  )  ;  dest.appendChild(destText);  }  //  else,  we  don't  care  about  comments,  xml  proc  instructions,  etc  }  return  numDiscarded;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
TextNode  destText  =  new  TextNode  (  sourceText.getWholeText  (  )  ,  sourceChild.baseUri  (  )  )  ;	[BUGGY]  TextNode  destText  =  new  TextNode(  sourceText  .TextNode(  )  ,  sourceChild.baseUri(  ));  [CONTEXT]  private  int  copySafeNodes(Element  source,  Element  dest)  {  List<Node>  sourceChildren  =  source.childNodes();  int  numDiscarded  =  0;    for  (Node  sourceChild  :  sourceChildren)  {  if  (sourceChild  instanceof  Element)  {  Element  sourceEl  =  (Element)  sourceChild;    if  (whitelist.isSafeTag(sourceEl.tagName()))  {  //  safe,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement(sourceEl);  Element  destChild  =  meta.el;  dest.appendChild(destChild);    numDiscarded  +=  meta.numAttribsDiscarded;  numDiscarded  +=  copySafeNodes(sourceEl,  destChild);  //  recurs  }  else  {  //  not  a  safe  tag,  but  it  may  have  children  (els  or  text)  that  are,  so  recurse  numDiscarded++;  numDiscarded  +=  copySafeNodes(sourceEl,  dest);  }  }  else  if  (sourceChild  instanceof  TextNode)  {  TextNode  sourceText  =  (TextNode)  sourceChild;  [BUGGY]  TextNode  destText  =  new  TextNode  (  sourceText  .TextNode  (),  sourceChild.baseUri  ())  ;  dest.appendChild(destText);  }  //  else,  we  don't  care  about  comments,  xml  proc  instructions,  etc  }  return  numDiscarded;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
TextNode  destText  =  new  TextNode  (  sourceText.getWholeText  (  )  ,  sourceChild.baseUri  (  )  )  ;	[BUGGY]  TextNode  destText  =  new  TextNode(  destText.getWholeText(  ),  sourceChild.baseUri(  ));  [CONTEXT]  private  int  copySafeNodes(Element  source,  Element  dest)  {  List<Node>  sourceChildren  =  source.childNodes();  int  numDiscarded  =  0;    for  (Node  sourceChild  :  sourceChildren)  {  if  (sourceChild  instanceof  Element)  {  Element  sourceEl  =  (Element)  sourceChild;    if  (whitelist.isSafeTag(sourceEl.tagName()))  {  //  safe,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement(sourceEl);  Element  destChild  =  meta.el;  dest.appendChild(destChild);    numDiscarded  +=  meta.numAttribsDiscarded;  numDiscarded  +=  copySafeNodes(sourceEl,  destChild);  //  recurs  }  else  {  //  not  a  safe  tag,  but  it  may  have  children  (els  or  text)  that  are,  so  recurse  numDiscarded++;  numDiscarded  +=  copySafeNodes(sourceEl,  dest);  }  }  else  if  (sourceChild  instanceof  TextNode)  {  TextNode  sourceText  =  (TextNode)  sourceChild;  [BUGGY]  TextNode  destText  =  new  TextNode  (  destText.getWholeText  ()  ,  sourceChild.baseUri  ())  ;  dest.appendChild(destText);  }  //  else,  we  don't  care  about  comments,  xml  proc  instructions,  etc  }  return  numDiscarded;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
TextNode  destText  =  new  TextNode  (  sourceText.getWholeText  (  )  ,  sourceChild.baseUri  (  )  )  ;  dest.appendChild  (  destText  )  ;	[BUGGY]    [CONTEXT]  private  int  copySafeNodes(Element  source,  Element  dest)  {  List<Node>  sourceChildren  =  source.childNodes();  int  numDiscarded  =  0;    for  (Node  sourceChild  :  sourceChildren)  {  if  (sourceChild  instanceof  Element)  {  Element  sourceEl  =  (Element)  sourceChild;    if  (whitelist.isSafeTag(sourceEl.tagName()))  {  //  safe,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement(sourceEl);  Element  destChild  =  meta.el;  dest.appendChild(destChild);    numDiscarded  +=  meta.numAttribsDiscarded;  numDiscarded  +=  copySafeNodes(sourceEl,  destChild);  //  recurs  }  else  {  //  not  a  safe  tag,  but  it  may  have  children  (els  or  text)  that  are,  so  recurse  numDiscarded++;  numDiscarded  +=  copySafeNodes(sourceEl,  dest);  }  }  else  if  (sourceChild  instanceof  TextNode)  {  TextNode  sourceText  =  (TextNode)  sourceChild;  [BUGGY]  TextNode  destText  =  new  TextNode(sourceText.getWholeText(),  sourceChild.baseUri());      }  //  else,  we  don't  care  about  comments,  xml  proc  instructions,  etc  }  return  numDiscarded;        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
TextNode  destText  =  new  TextNode  (  sourceText.getWholeText  (  )  ,  sourceChild.baseUri  (  )  )  ;	[BUGGY]    [CONTEXT]  private  int  copySafeNodes(Element  source,  Element  dest)  {  List<Node>  sourceChildren  =  source.childNodes();  int  numDiscarded  =  0;    for  (Node  sourceChild  :  sourceChildren)  {  if  (sourceChild  instanceof  Element)  {  Element  sourceEl  =  (Element)  sourceChild;    if  (whitelist.isSafeTag(sourceEl.tagName()))  {  //  safe,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement(sourceEl);  Element  destChild  =  meta.el;  dest.appendChild(destChild);    numDiscarded  +=  meta.numAttribsDiscarded;  numDiscarded  +=  copySafeNodes(sourceEl,  destChild);  //  recurs  }  else  {  //  not  a  safe  tag,  but  it  may  have  children  (els  or  text)  that  are,  so  recurse  numDiscarded++;  numDiscarded  +=  copySafeNodes(sourceEl,  dest);  }  }  else  if  (sourceChild  instanceof  TextNode)  {  TextNode  sourceText  =  (TextNode)  sourceChild;  [BUGGY]  TextNode  destText  =  new  TextNode(sourceText.getWholeText(),  sourceChild.baseUri());    dest.appendChild(destText);  }  //  else,  we  don't  care  about  comments,  xml  proc  instructions,  etc  }  return  numDiscarded;        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
dest.appendChild  (  destText  )  ;	[BUGGY]  dest.appendChild(  sourceElText);  [CONTEXT]  private  int  copySafeNodes(Element  source,  Element  dest)  {  List<Node>  sourceChildren  =  source.childNodes();  int  numDiscarded  =  0;    for  (Node  sourceChild  :  sourceChildren)  {  if  (sourceChild  instanceof  Element)  {  Element  sourceEl  =  (Element)  sourceChild;    if  (whitelist.isSafeTag(sourceEl.tagName()))  {  //  safe,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement(sourceEl);  Element  destChild  =  meta.el;  dest.appendChild(destChild);    numDiscarded  +=  meta.numAttribsDiscarded;  numDiscarded  +=  copySafeNodes(sourceEl,  destChild);  //  recurs  }  else  {  //  not  a  safe  tag,  but  it  may  have  children  (els  or  text)  that  are,  so  recurse  numDiscarded++;  numDiscarded  +=  copySafeNodes(sourceEl,  dest);  }  }  else  if  (sourceChild  instanceof  TextNode)  {  TextNode  sourceText  =  (TextNode)  sourceChild;  TextNode  destText  =  new  TextNode(sourceText.getWholeText(),  sourceChild.baseUri());  [BUGGY]  dest.appendChild  (  sourceElText  )  ;  }  //  else,  we  don't  care  about  comments,  xml  proc  instructions,  etc  }  return  numDiscarded;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
dest.appendChild  (  destText  )  ;	[BUGGY]  dest.appendChild(  sourceText);  [CONTEXT]  private  int  copySafeNodes(Element  source,  Element  dest)  {  List<Node>  sourceChildren  =  source.childNodes();  int  numDiscarded  =  0;    for  (Node  sourceChild  :  sourceChildren)  {  if  (sourceChild  instanceof  Element)  {  Element  sourceEl  =  (Element)  sourceChild;    if  (whitelist.isSafeTag(sourceEl.tagName()))  {  //  safe,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement(sourceEl);  Element  destChild  =  meta.el;  dest.appendChild(destChild);    numDiscarded  +=  meta.numAttribsDiscarded;  numDiscarded  +=  copySafeNodes(sourceEl,  destChild);  //  recurs  }  else  {  //  not  a  safe  tag,  but  it  may  have  children  (els  or  text)  that  are,  so  recurse  numDiscarded++;  numDiscarded  +=  copySafeNodes(sourceEl,  dest);  }  }  else  if  (sourceChild  instanceof  TextNode)  {  TextNode  sourceText  =  (TextNode)  sourceChild;  TextNode  destText  =  new  TextNode(sourceText.getWholeText(),  sourceChild.baseUri());  [BUGGY]  dest.appendChild  (  sourceText  )  ;  }  //  else,  we  don't  care  about  comments,  xml  proc  instructions,  etc  }  return  numDiscarded;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
dest.appendChild  (  destText  )  ;	[BUGGY]  dest.appendChild(  destTextText);  [CONTEXT]  private  int  copySafeNodes(Element  source,  Element  dest)  {  List<Node>  sourceChildren  =  source.childNodes();  int  numDiscarded  =  0;    for  (Node  sourceChild  :  sourceChildren)  {  if  (sourceChild  instanceof  Element)  {  Element  sourceEl  =  (Element)  sourceChild;    if  (whitelist.isSafeTag(sourceEl.tagName()))  {  //  safe,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement(sourceEl);  Element  destChild  =  meta.el;  dest.appendChild(destChild);    numDiscarded  +=  meta.numAttribsDiscarded;  numDiscarded  +=  copySafeNodes(sourceEl,  destChild);  //  recurs  }  else  {  //  not  a  safe  tag,  but  it  may  have  children  (els  or  text)  that  are,  so  recurse  numDiscarded++;  numDiscarded  +=  copySafeNodes(sourceEl,  dest);  }  }  else  if  (sourceChild  instanceof  TextNode)  {  TextNode  sourceText  =  (TextNode)  sourceChild;  TextNode  destText  =  new  TextNode(sourceText.getWholeText(),  sourceChild.baseUri());  [BUGGY]  dest.appendChild  (  destTextText  )  ;  }  //  else,  we  don't  care  about  comments,  xml  proc  instructions,  etc  }  return  numDiscarded;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
dest.appendChild  (  destText  )  ;	[BUGGY]  dest.appendChild(  dest);  [CONTEXT]  private  int  copySafeNodes(Element  source,  Element  dest)  {  List<Node>  sourceChildren  =  source.childNodes();  int  numDiscarded  =  0;    for  (Node  sourceChild  :  sourceChildren)  {  if  (sourceChild  instanceof  Element)  {  Element  sourceEl  =  (Element)  sourceChild;    if  (whitelist.isSafeTag(sourceEl.tagName()))  {  //  safe,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement(sourceEl);  Element  destChild  =  meta.el;  dest.appendChild(destChild);    numDiscarded  +=  meta.numAttribsDiscarded;  numDiscarded  +=  copySafeNodes(sourceEl,  destChild);  //  recurs  }  else  {  //  not  a  safe  tag,  but  it  may  have  children  (els  or  text)  that  are,  so  recurse  numDiscarded++;  numDiscarded  +=  copySafeNodes(sourceEl,  dest);  }  }  else  if  (sourceChild  instanceof  TextNode)  {  TextNode  sourceText  =  (TextNode)  sourceChild;  TextNode  destText  =  new  TextNode(sourceText.getWholeText(),  sourceChild.baseUri());  [BUGGY]  dest.appendChild  (  dest  )  ;  }  //  else,  we  don't  care  about  comments,  xml  proc  instructions,  etc  }  return  numDiscarded;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
dest.appendChild  (  destText  )  ;	[BUGGY]    [CONTEXT]  private  int  copySafeNodes(Element  source,  Element  dest)  {  List<Node>  sourceChildren  =  source.childNodes();  int  numDiscarded  =  0;    for  (Node  sourceChild  :  sourceChildren)  {  if  (sourceChild  instanceof  Element)  {  Element  sourceEl  =  (Element)  sourceChild;    if  (whitelist.isSafeTag(sourceEl.tagName()))  {  //  safe,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement(sourceEl);  Element  destChild  =  meta.el;  dest.appendChild(destChild);    numDiscarded  +=  meta.numAttribsDiscarded;  numDiscarded  +=  copySafeNodes(sourceEl,  destChild);  //  recurs  }  else  {  //  not  a  safe  tag,  but  it  may  have  children  (els  or  text)  that  are,  so  recurse  numDiscarded++;  numDiscarded  +=  copySafeNodes(sourceEl,  dest);  }  }  else  if  (sourceChild  instanceof  TextNode)  {  TextNode  sourceText  =  (TextNode)  sourceChild;  TextNode  destText  =  new  TextNode(sourceText.getWholeText(),  sourceChild.baseUri());  [BUGGY]  dest.appendChild(destText);    }  //  else,  we  don't  care  about  comments,  xml  proc  instructions,  etc  }  return  numDiscarded;        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
TextNode  sourceText  =  (  TextNode  )  sourceChild;	[BUGGY]  Element  sourceEl  =  (  Element)  sourceChild;TextNode  sourceText  =  (  TextNode)  sourceChild;  [CONTEXT]        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
TextNode  destText  =  new  TextNode  (  sourceText.getWholeText  (  )  ,  sourceChild.baseUri  (  )  )  ;  dest.appendChild  (  destText  )  ;	[BUGGY]  dest.appendChild(  destText);  TextNode  destText  =  new  TextNode(  sourceText.getWholeText(  ),  sourceChild.baseUri(  ));  [CONTEXT]        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
TextNode  destText  =  new  TextNode  (  sourceText.getWholeText  (  )  ,  sourceChild.baseUri  (  )  )  ;  dest.appendChild  (  destText  )  ;	[BUGGY]  TextNode  destText  =  new  TextNode(  sourceText.getWholeText(  ),  sourceChild.baseUri(  ));TextNode  destText  =  new  TextNode(  sourceText.getWholeText(  ),  sourceChild.baseUri(  ));  dest.appendChild(  destText);  [CONTEXT]        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
if  (  whitelist.isSafeTag  (  sourceEl.tagName  (  )  )  )  {	[BUGGY]  if  (  whitelist.isSafeTag(  source.tagName(  )))  {  [CONTEXT]  private  int  copySafeNodes(Element  source,  Element  dest)  {  List<Node>  sourceChildren  =  source.childNodes();  int  numDiscarded  =  0;    for  (Node  sourceChild  :  sourceChildren)  {  if  (sourceChild  instanceof  Element)  {  Element  sourceEl  =  (Element)  sourceChild;    [BUGGY]  if(  whitelist.isSafeTag  (  source.tagName  ())){  ElementMeta  meta  =  createSafeElement(sourceEl);  Element  destChild  =  meta.el;  dest.appendChild(destChild);    numDiscarded  +=  meta.numAttribsDiscarded;  numDiscarded  +=  copySafeNodes(sourceEl,  destChild);  //  recurs  }  else  {  //  not  a  safe  tag,  but  it  may  have  children  (els  or  text)  that  are,  so  recurse  numDiscarded++;  numDiscarded  +=  copySafeNodes(sourceEl,  dest);  }  }  else  if  (sourceChild  instanceof  TextNode)  {  TextNode  sourceText  =  (TextNode)  sourceChild;  TextNode  destText  =  new  TextNode(sourceText.getWholeText(),  sourceChild.baseUri());  dest.appendChild(destText);  }  //  else,  we  don't  care  about  comments,  xml  proc  instructions,  etc  }  return  numDiscarded;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
if  (  whitelist.isSafeTag  (  sourceEl.tagName  (  )  )  )  {	[BUGGY]  if  (  whitelist.getEnforcedAttributes(  sourceEl.tagName(  )))  {  [CONTEXT]  private  int  copySafeNodes(Element  source,  Element  dest)  {  List<Node>  sourceChildren  =  source.childNodes();  int  numDiscarded  =  0;    for  (Node  sourceChild  :  sourceChildren)  {  if  (sourceChild  instanceof  Element)  {  Element  sourceEl  =  (Element)  sourceChild;    [BUGGY]  if(  whitelist.getEnforcedAttributes  (  sourceEl.tagName  ())){  ElementMeta  meta  =  createSafeElement(sourceEl);  Element  destChild  =  meta.el;  dest.appendChild(destChild);    numDiscarded  +=  meta.numAttribsDiscarded;  numDiscarded  +=  copySafeNodes(sourceEl,  destChild);  //  recurs  }  else  {  //  not  a  safe  tag,  but  it  may  have  children  (els  or  text)  that  are,  so  recurse  numDiscarded++;  numDiscarded  +=  copySafeNodes(sourceEl,  dest);  }  }  else  if  (sourceChild  instanceof  TextNode)  {  TextNode  sourceText  =  (TextNode)  sourceChild;  TextNode  destText  =  new  TextNode(sourceText.getWholeText(),  sourceChild.baseUri());  dest.appendChild(destText);  }  //  else,  we  don't  care  about  comments,  xml  proc  instructions,  etc  }  return  numDiscarded;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
if  (  whitelist.isSafeTag  (  sourceEl.tagName  (  )  )  )  {	[BUGGY]  if  (  whitelist.isSafeTag(  sourceEl.appendChild(  )))  {  [CONTEXT]  private  int  copySafeNodes(Element  source,  Element  dest)  {  List<Node>  sourceChildren  =  source.childNodes();  int  numDiscarded  =  0;    for  (Node  sourceChild  :  sourceChildren)  {  if  (sourceChild  instanceof  Element)  {  Element  sourceEl  =  (Element)  sourceChild;    [BUGGY]  if(  whitelist.isSafeTag  (  sourceEl.appendChild  ())){  ElementMeta  meta  =  createSafeElement(sourceEl);  Element  destChild  =  meta.el;  dest.appendChild(destChild);    numDiscarded  +=  meta.numAttribsDiscarded;  numDiscarded  +=  copySafeNodes(sourceEl,  destChild);  //  recurs  }  else  {  //  not  a  safe  tag,  but  it  may  have  children  (els  or  text)  that  are,  so  recurse  numDiscarded++;  numDiscarded  +=  copySafeNodes(sourceEl,  dest);  }  }  else  if  (sourceChild  instanceof  TextNode)  {  TextNode  sourceText  =  (TextNode)  sourceChild;  TextNode  destText  =  new  TextNode(sourceText.getWholeText(),  sourceChild.baseUri());  dest.appendChild(destText);  }  //  else,  we  don't  care  about  comments,  xml  proc  instructions,  etc  }  return  numDiscarded;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
if  (  whitelist.isSafeTag  (  sourceEl.tagName  (  )  )  )  {	[BUGGY]  if  (  whitelist.isSafeTag(  el.tagName(  )))  {  [CONTEXT]  private  int  copySafeNodes(Element  source,  Element  dest)  {  List<Node>  sourceChildren  =  source.childNodes();  int  numDiscarded  =  0;    for  (Node  sourceChild  :  sourceChildren)  {  if  (sourceChild  instanceof  Element)  {  Element  sourceEl  =  (Element)  sourceChild;    [BUGGY]  if(  whitelist.isSafeTag  (  el.tagName  ())){  ElementMeta  meta  =  createSafeElement(sourceEl);  Element  destChild  =  meta.el;  dest.appendChild(destChild);    numDiscarded  +=  meta.numAttribsDiscarded;  numDiscarded  +=  copySafeNodes(sourceEl,  destChild);  //  recurs  }  else  {  //  not  a  safe  tag,  but  it  may  have  children  (els  or  text)  that  are,  so  recurse  numDiscarded++;  numDiscarded  +=  copySafeNodes(sourceEl,  dest);  }  }  else  if  (sourceChild  instanceof  TextNode)  {  TextNode  sourceText  =  (TextNode)  sourceChild;  TextNode  destText  =  new  TextNode(sourceText.getWholeText(),  sourceChild.baseUri());  dest.appendChild(destText);  }  //  else,  we  don't  care  about  comments,  xml  proc  instructions,  etc  }  return  numDiscarded;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
numDiscarded  +=  copySafeNodes  (  sourceEl,  dest  )  ;	[BUGGY]  numDiscarded  +=  copySafeNodes(  source,  dest);  [CONTEXT]  if  (whitelist.isSafeTag(sourceEl.tagName()))  {  //  safe,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement(sourceEl);  Element  destChild  =  meta.el;  dest.appendChild(destChild);    numDiscarded  +=  meta.numAttribsDiscarded;  numDiscarded  +=  copySafeNodes(sourceEl,  destChild);  //  recurs  }  else  {  //  not  a  safe  tag,  but  it  may  have  children  (els  or  text)  that  are,  so  recurse  numDiscarded++;  [BUGGY]  numDiscarded  +=  copySafeNodes  (  source,  dest  )  ;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
numDiscarded  +=  copySafeNodes  (  sourceEl,  dest  )  ;	[BUGGY]  numDiscarded  +=  copySafeNodes(  sourceEl,  source);  [CONTEXT]  if  (whitelist.isSafeTag(sourceEl.tagName()))  {  //  safe,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement(sourceEl);  Element  destChild  =  meta.el;  dest.appendChild(destChild);    numDiscarded  +=  meta.numAttribsDiscarded;  numDiscarded  +=  copySafeNodes(sourceEl,  destChild);  //  recurs  }  else  {  //  not  a  safe  tag,  but  it  may  have  children  (els  or  text)  that  are,  so  recurse  numDiscarded++;  [BUGGY]  numDiscarded  +=  copySafeNodes  (  sourceEl,  source  )  ;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
numDiscarded  +=  copySafeNodes  (  sourceEl,  dest  )  ;	[BUGGY]  numDiscarded  +=  copySafeNodes(  dest,  sourceEl);  [CONTEXT]  if  (whitelist.isSafeTag(sourceEl.tagName()))  {  //  safe,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement(sourceEl);  Element  destChild  =  meta.el;  dest.appendChild(destChild);    numDiscarded  +=  meta.numAttribsDiscarded;  numDiscarded  +=  copySafeNodes(sourceEl,  destChild);  //  recurs  }  else  {  //  not  a  safe  tag,  but  it  may  have  children  (els  or  text)  that  are,  so  recurse  numDiscarded++;  [BUGGY]  numDiscarded  +=  copySafeNodes  (  dest,  sourceEl  )  ;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
numDiscarded  +=  copySafeNodes  (  sourceEl,  dest  )  ;	[BUGGY]  numDiscarded  +=  copySafeNodes(    dest);  [CONTEXT]  if  (whitelist.isSafeTag(sourceEl.tagName()))  {  //  safe,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement(sourceEl);  Element  destChild  =  meta.el;  dest.appendChild(destChild);    numDiscarded  +=  meta.numAttribsDiscarded;  numDiscarded  +=  copySafeNodes(sourceEl,  destChild);  //  recurs  }  else  {  //  not  a  safe  tag,  but  it  may  have  children  (els  or  text)  that  are,  so  recurse  numDiscarded++;  [BUGGY]  numDiscarded  +=  copySafeNodes  (dest  )  ;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
numDiscarded  +=  copySafeNodes  (  sourceEl,  dest  )  ;	[BUGGY]  numDiscarded  +=  copySafeNodes(  sourceEl);  [CONTEXT]  if  (whitelist.isSafeTag(sourceEl.tagName()))  {  //  safe,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement(sourceEl);  Element  destChild  =  meta.el;  dest.appendChild(destChild);    numDiscarded  +=  meta.numAttribsDiscarded;  numDiscarded  +=  copySafeNodes(sourceEl,  destChild);  //  recurs  }  else  {  //  not  a  safe  tag,  but  it  may  have  children  (els  or  text)  that  are,  so  recurse  numDiscarded++;  [BUGGY]  numDiscarded  +=  copySafeNodes  (  sourceEl  )  ;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
numDiscarded  +=  copySafeNodes  (  sourceEl,  dest  )  ;	[BUGGY]  numDiscarded  +=    copySafeNodes(  el,  dest);  [CONTEXT]  if  (whitelist.isSafeTag(sourceEl.tagName()))  {  //  safe,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement(sourceEl);  Element  destChild  =  meta.el;  dest.appendChild(destChild);    numDiscarded  +=  meta.numAttribsDiscarded;  numDiscarded  +=  copySafeNodes(sourceEl,  destChild);  //  recurs  }  else  {  //  not  a  safe  tag,  but  it  may  have  children  (els  or  text)  that  are,  so  recurse  numDiscarded++;  [BUGGY]  numDiscarded  +=copySafeNodes  (  el,  dest  )  ;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
numDiscarded  +=  copySafeNodes  (  sourceEl,  dest  )  ;	[BUGGY]    [CONTEXT]  if  (whitelist.isSafeTag(sourceEl.tagName()))  {  //  safe,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement(sourceEl);  Element  destChild  =  meta.el;  dest.appendChild(destChild);    numDiscarded  +=  meta.numAttribsDiscarded;  numDiscarded  +=  copySafeNodes(sourceEl,  destChild);  //  recurs  }  else  {  //  not  a  safe  tag,  but  it  may  have  children  (els  or  text)  that  are,  so  recurse  numDiscarded++;  [BUGGY]  numDiscarded  +=  copySafeNodes(sourceEl,  dest);          [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
numDiscarded  +=  meta.numAttribsDiscarded;	[BUGGY]  numDiscarded  +=  numDiscarded;  [CONTEXT]  private  int  copySafeNodes(Element  source,  Element  dest)  {  List<Node>  sourceChildren  =  source.childNodes();  int  numDiscarded  =  0;    for  (Node  sourceChild  :  sourceChildren)  {  if  (sourceChild  instanceof  Element)  {  Element  sourceEl  =  (Element)  sourceChild;    if  (whitelist.isSafeTag(sourceEl.tagName()))  {  //  safe,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement(sourceEl);  Element  destChild  =  meta.el;  dest.appendChild(destChild);    [BUGGY]  numDiscarded  +=  numDiscarded;  numDiscarded  +=  copySafeNodes(sourceEl,  destChild);  //  recurs  }  else  {  //  not  a  safe  tag,  but  it  may  have  children  (els  or  text)  that  are,  so  recurse  numDiscarded++;  numDiscarded  +=  copySafeNodes(sourceEl,  dest);  }  }  else  if  (sourceChild  instanceof  TextNode)  {  TextNode  sourceText  =  (TextNode)  sourceChild;  TextNode  destText  =  new  TextNode(sourceText.getWholeText(),  sourceChild.baseUri());  dest.appendChild(destText);  }  //  else,  we  don't  care  about  comments,  xml  proc  instructions,  etc  }  return  numDiscarded;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
numDiscarded  +=  meta.numAttribsDiscarded;	[BUGGY]  numDiscarded  +=  meta.numAttribsDiscarded.numAttribsDiscarded;  [CONTEXT]  private  int  copySafeNodes(Element  source,  Element  dest)  {  List<Node>  sourceChildren  =  source.childNodes();  int  numDiscarded  =  0;    for  (Node  sourceChild  :  sourceChildren)  {  if  (sourceChild  instanceof  Element)  {  Element  sourceEl  =  (Element)  sourceChild;    if  (whitelist.isSafeTag(sourceEl.tagName()))  {  //  safe,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement(sourceEl);  Element  destChild  =  meta.el;  dest.appendChild(destChild);    [BUGGY]  numDiscarded  +=  meta.numAttribsDiscarded.numAttribsDiscarded;  numDiscarded  +=  copySafeNodes(sourceEl,  destChild);  //  recurs  }  else  {  //  not  a  safe  tag,  but  it  may  have  children  (els  or  text)  that  are,  so  recurse  numDiscarded++;  numDiscarded  +=  copySafeNodes(sourceEl,  dest);  }  }  else  if  (sourceChild  instanceof  TextNode)  {  TextNode  sourceText  =  (TextNode)  sourceChild;  TextNode  destText  =  new  TextNode(sourceText.getWholeText(),  sourceChild.baseUri());  dest.appendChild(destText);  }  //  else,  we  don't  care  about  comments,  xml  proc  instructions,  etc  }  return  numDiscarded;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
numDiscarded  +=  meta.numAttribsDiscarded;	[BUGGY]  numDiscarded  +=  meta;  [CONTEXT]  private  int  copySafeNodes(Element  source,  Element  dest)  {  List<Node>  sourceChildren  =  source.childNodes();  int  numDiscarded  =  0;    for  (Node  sourceChild  :  sourceChildren)  {  if  (sourceChild  instanceof  Element)  {  Element  sourceEl  =  (Element)  sourceChild;    if  (whitelist.isSafeTag(sourceEl.tagName()))  {  //  safe,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement(sourceEl);  Element  destChild  =  meta.el;  dest.appendChild(destChild);    [BUGGY]  numDiscarded  +=  meta;  numDiscarded  +=  copySafeNodes(sourceEl,  destChild);  //  recurs  }  else  {  //  not  a  safe  tag,  but  it  may  have  children  (els  or  text)  that  are,  so  recurse  numDiscarded++;  numDiscarded  +=  copySafeNodes(sourceEl,  dest);  }  }  else  if  (sourceChild  instanceof  TextNode)  {  TextNode  sourceText  =  (TextNode)  sourceChild;  TextNode  destText  =  new  TextNode(sourceText.getWholeText(),  sourceChild.baseUri());  dest.appendChild(destText);  }  //  else,  we  don't  care  about  comments,  xml  proc  instructions,  etc  }  return  numDiscarded;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
numDiscarded  +=  meta.numAttribsDiscarded;	[BUGGY]  numDiscarded  +=    null.numAttribsDiscarded;  [CONTEXT]  private  int  copySafeNodes(Element  source,  Element  dest)  {  List<Node>  sourceChildren  =  source.childNodes();  int  numDiscarded  =  0;    for  (Node  sourceChild  :  sourceChildren)  {  if  (sourceChild  instanceof  Element)  {  Element  sourceEl  =  (Element)  sourceChild;    if  (whitelist.isSafeTag(sourceEl.tagName()))  {  //  safe,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement(sourceEl);  Element  destChild  =  meta.el;  dest.appendChild(destChild);    [BUGGY]  numDiscarded  +=null.numAttribsDiscarded;  numDiscarded  +=  copySafeNodes(sourceEl,  destChild);  //  recurs  }  else  {  //  not  a  safe  tag,  but  it  may  have  children  (els  or  text)  that  are,  so  recurse  numDiscarded++;  numDiscarded  +=  copySafeNodes(sourceEl,  dest);  }  }  else  if  (sourceChild  instanceof  TextNode)  {  TextNode  sourceText  =  (TextNode)  sourceChild;  TextNode  destText  =  new  TextNode(sourceText.getWholeText(),  sourceChild.baseUri());  dest.appendChild(destText);  }  //  else,  we  don't  care  about  comments,  xml  proc  instructions,  etc  }  return  numDiscarded;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
numDiscarded  +=  meta.numAttribsDiscarded;  numDiscarded  +=  copySafeNodes  (  sourceEl,  destChild  )  ;	[BUGGY]  numDiscarded  +=  copySafeNodes(  sourceEl,  destChild);  numDiscarded  +=  meta.numAttribsDiscarded;  [CONTEXT]        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
numDiscarded  +=  meta.numAttribsDiscarded;  numDiscarded  +=  copySafeNodes  (  sourceEl,  destChild  )  ;	[BUGGY]  numDiscarded  +=  copySafeNodes(  sourceEl,  destChild);numDiscarded  +=  meta.numAttribsDiscarded;  numDiscarded  +=  copySafeNodes(  sourceEl,  destChild);  [CONTEXT]        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
numDiscarded  +=  meta.numAttribsDiscarded;  numDiscarded  +=  copySafeNodes  (  sourceEl,  destChild  )  ;	[BUGGY]  numDiscarded  +=  copySafeNodes(  sourceEl,  dest);numDiscarded  +=  meta.numAttribsDiscarded;  numDiscarded  +=  copySafeNodes(  sourceEl,  destChild);  [CONTEXT]        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
numDiscarded  +=  copySafeNodes  (  sourceEl,  destChild  )  ;	[BUGGY]  numDiscarded  +=  copySafeNodes(  source,  destChild);  [CONTEXT]  private  int  copySafeNodes(Element  source,  Element  dest)  {  List<Node>  sourceChildren  =  source.childNodes();  int  numDiscarded  =  0;    for  (Node  sourceChild  :  sourceChildren)  {  if  (sourceChild  instanceof  Element)  {  Element  sourceEl  =  (Element)  sourceChild;    if  (whitelist.isSafeTag(sourceEl.tagName()))  {  //  safe,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement(sourceEl);  Element  destChild  =  meta.el;  dest.appendChild(destChild);    numDiscarded  +=  meta.numAttribsDiscarded;  [BUGGY]  numDiscarded  +=  copySafeNodes  (  source,  destChild  )  ;  }  else  {  //  not  a  safe  tag,  but  it  may  have  children  (els  or  text)  that  are,  so  recurse  numDiscarded++;  numDiscarded  +=  copySafeNodes(sourceEl,  dest);  }  }  else  if  (sourceChild  instanceof  TextNode)  {  TextNode  sourceText  =  (TextNode)  sourceChild;  TextNode  destText  =  new  TextNode(sourceText.getWholeText(),  sourceChild.baseUri());  dest.appendChild(destText);  }  //  else,  we  don't  care  about  comments,  xml  proc  instructions,  etc  }  return  numDiscarded;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
numDiscarded  +=  copySafeNodes  (  sourceEl,  destChild  )  ;	[BUGGY]  numDiscarded  +=  copySafeNodes(  sourceEl,  source);  [CONTEXT]  private  int  copySafeNodes(Element  source,  Element  dest)  {  List<Node>  sourceChildren  =  source.childNodes();  int  numDiscarded  =  0;    for  (Node  sourceChild  :  sourceChildren)  {  if  (sourceChild  instanceof  Element)  {  Element  sourceEl  =  (Element)  sourceChild;    if  (whitelist.isSafeTag(sourceEl.tagName()))  {  //  safe,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement(sourceEl);  Element  destChild  =  meta.el;  dest.appendChild(destChild);    numDiscarded  +=  meta.numAttribsDiscarded;  [BUGGY]  numDiscarded  +=  copySafeNodes  (  sourceEl,  source  )  ;  }  else  {  //  not  a  safe  tag,  but  it  may  have  children  (els  or  text)  that  are,  so  recurse  numDiscarded++;  numDiscarded  +=  copySafeNodes(sourceEl,  dest);  }  }  else  if  (sourceChild  instanceof  TextNode)  {  TextNode  sourceText  =  (TextNode)  sourceChild;  TextNode  destText  =  new  TextNode(sourceText.getWholeText(),  sourceChild.baseUri());  dest.appendChild(destText);  }  //  else,  we  don't  care  about  comments,  xml  proc  instructions,  etc  }  return  numDiscarded;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
numDiscarded  +=  copySafeNodes  (  sourceEl,  destChild  )  ;	[BUGGY]  numDiscarded  +=  copySafeNodes(  destChild,  sourceEl);  [CONTEXT]  private  int  copySafeNodes(Element  source,  Element  dest)  {  List<Node>  sourceChildren  =  source.childNodes();  int  numDiscarded  =  0;    for  (Node  sourceChild  :  sourceChildren)  {  if  (sourceChild  instanceof  Element)  {  Element  sourceEl  =  (Element)  sourceChild;    if  (whitelist.isSafeTag(sourceEl.tagName()))  {  //  safe,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement(sourceEl);  Element  destChild  =  meta.el;  dest.appendChild(destChild);    numDiscarded  +=  meta.numAttribsDiscarded;  [BUGGY]  numDiscarded  +=  copySafeNodes  (  destChild,  sourceEl  )  ;  }  else  {  //  not  a  safe  tag,  but  it  may  have  children  (els  or  text)  that  are,  so  recurse  numDiscarded++;  numDiscarded  +=  copySafeNodes(sourceEl,  dest);  }  }  else  if  (sourceChild  instanceof  TextNode)  {  TextNode  sourceText  =  (TextNode)  sourceChild;  TextNode  destText  =  new  TextNode(sourceText.getWholeText(),  sourceChild.baseUri());  dest.appendChild(destText);  }  //  else,  we  don't  care  about  comments,  xml  proc  instructions,  etc  }  return  numDiscarded;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
numDiscarded  +=  copySafeNodes  (  sourceEl,  destChild  )  ;	[BUGGY]  numDiscarded  +=  copySafeNodes(    destChild);  [CONTEXT]  private  int  copySafeNodes(Element  source,  Element  dest)  {  List<Node>  sourceChildren  =  source.childNodes();  int  numDiscarded  =  0;    for  (Node  sourceChild  :  sourceChildren)  {  if  (sourceChild  instanceof  Element)  {  Element  sourceEl  =  (Element)  sourceChild;    if  (whitelist.isSafeTag(sourceEl.tagName()))  {  //  safe,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement(sourceEl);  Element  destChild  =  meta.el;  dest.appendChild(destChild);    numDiscarded  +=  meta.numAttribsDiscarded;  [BUGGY]  numDiscarded  +=  copySafeNodes  (destChild  )  ;  }  else  {  //  not  a  safe  tag,  but  it  may  have  children  (els  or  text)  that  are,  so  recurse  numDiscarded++;  numDiscarded  +=  copySafeNodes(sourceEl,  dest);  }  }  else  if  (sourceChild  instanceof  TextNode)  {  TextNode  sourceText  =  (TextNode)  sourceChild;  TextNode  destText  =  new  TextNode(sourceText.getWholeText(),  sourceChild.baseUri());  dest.appendChild(destText);  }  //  else,  we  don't  care  about  comments,  xml  proc  instructions,  etc  }  return  numDiscarded;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
numDiscarded  +=  copySafeNodes  (  sourceEl,  destChild  )  ;	[BUGGY]  numDiscarded  +=  copySafeNodes(  sourceEl);  [CONTEXT]  private  int  copySafeNodes(Element  source,  Element  dest)  {  List<Node>  sourceChildren  =  source.childNodes();  int  numDiscarded  =  0;    for  (Node  sourceChild  :  sourceChildren)  {  if  (sourceChild  instanceof  Element)  {  Element  sourceEl  =  (Element)  sourceChild;    if  (whitelist.isSafeTag(sourceEl.tagName()))  {  //  safe,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement(sourceEl);  Element  destChild  =  meta.el;  dest.appendChild(destChild);    numDiscarded  +=  meta.numAttribsDiscarded;  [BUGGY]  numDiscarded  +=  copySafeNodes  (  sourceEl  )  ;  }  else  {  //  not  a  safe  tag,  but  it  may  have  children  (els  or  text)  that  are,  so  recurse  numDiscarded++;  numDiscarded  +=  copySafeNodes(sourceEl,  dest);  }  }  else  if  (sourceChild  instanceof  TextNode)  {  TextNode  sourceText  =  (TextNode)  sourceChild;  TextNode  destText  =  new  TextNode(sourceText.getWholeText(),  sourceChild.baseUri());  dest.appendChild(destText);  }  //  else,  we  don't  care  about  comments,  xml  proc  instructions,  etc  }  return  numDiscarded;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
numDiscarded  +=  copySafeNodes  (  sourceEl,  destChild  )  ;	[BUGGY]  numDiscarded  +=    copySafeNodes(  el,  destChild);  [CONTEXT]  private  int  copySafeNodes(Element  source,  Element  dest)  {  List<Node>  sourceChildren  =  source.childNodes();  int  numDiscarded  =  0;    for  (Node  sourceChild  :  sourceChildren)  {  if  (sourceChild  instanceof  Element)  {  Element  sourceEl  =  (Element)  sourceChild;    if  (whitelist.isSafeTag(sourceEl.tagName()))  {  //  safe,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement(sourceEl);  Element  destChild  =  meta.el;  dest.appendChild(destChild);    numDiscarded  +=  meta.numAttribsDiscarded;  [BUGGY]  numDiscarded  +=copySafeNodes  (  el,  destChild  )  ;  }  else  {  //  not  a  safe  tag,  but  it  may  have  children  (els  or  text)  that  are,  so  recurse  numDiscarded++;  numDiscarded  +=  copySafeNodes(sourceEl,  dest);  }  }  else  if  (sourceChild  instanceof  TextNode)  {  TextNode  sourceText  =  (TextNode)  sourceChild;  TextNode  destText  =  new  TextNode(sourceText.getWholeText(),  sourceChild.baseUri());  dest.appendChild(destText);  }  //  else,  we  don't  care  about  comments,  xml  proc  instructions,  etc  }  return  numDiscarded;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
ElementMeta  meta  =  createSafeElement  (  sourceEl  )  ;	[BUGGY]  ElementMeta  meta  =  createSafeElement(  source);  [CONTEXT]  private  int  copySafeNodes(Element  source,  Element  dest)  {  List<Node>  sourceChildren  =  source.childNodes();  int  numDiscarded  =  0;    for  (Node  sourceChild  :  sourceChildren)  {  if  (sourceChild  instanceof  Element)  {  Element  sourceEl  =  (Element)  sourceChild;    if  (whitelist.isSafeTag(sourceEl.tagName()))  {  //  safe,  clone  and  copy  safe  attrs  [BUGGY]  ElementMeta  meta  =  createSafeElement  (  source  )  ;  Element  destChild  =  meta.el;  dest.appendChild(destChild);    numDiscarded  +=  meta.numAttribsDiscarded;  numDiscarded  +=  copySafeNodes(sourceEl,  destChild);  //  recurs  }  else  {  //  not  a  safe  tag,  but  it  may  have  children  (els  or  text)  that  are,  so  recurse  numDiscarded++;  numDiscarded  +=  copySafeNodes(sourceEl,  dest);  }  }  else  if  (sourceChild  instanceof  TextNode)  {  TextNode  sourceText  =  (TextNode)  sourceChild;  TextNode  destText  =  new  TextNode(sourceText.getWholeText(),  sourceChild.baseUri());  dest.appendChild(destText);  }  //  else,  we  don't  care  about  comments,  xml  proc  instructions,  etc  }  return  numDiscarded;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
ElementMeta  meta  =  createSafeElement  (  sourceEl  )  ;	[BUGGY]  ElementMeta  meta  =  clean(  sourceEl);  [CONTEXT]  private  int  copySafeNodes(Element  source,  Element  dest)  {  List<Node>  sourceChildren  =  source.childNodes();  int  numDiscarded  =  0;    for  (Node  sourceChild  :  sourceChildren)  {  if  (sourceChild  instanceof  Element)  {  Element  sourceEl  =  (Element)  sourceChild;    if  (whitelist.isSafeTag(sourceEl.tagName()))  {  //  safe,  clone  and  copy  safe  attrs  [BUGGY]  ElementMeta  meta  =  clean  (  sourceEl  )  ;  Element  destChild  =  meta.el;  dest.appendChild(destChild);    numDiscarded  +=  meta.numAttribsDiscarded;  numDiscarded  +=  copySafeNodes(sourceEl,  destChild);  //  recurs  }  else  {  //  not  a  safe  tag,  but  it  may  have  children  (els  or  text)  that  are,  so  recurse  numDiscarded++;  numDiscarded  +=  copySafeNodes(sourceEl,  dest);  }  }  else  if  (sourceChild  instanceof  TextNode)  {  TextNode  sourceText  =  (TextNode)  sourceChild;  TextNode  destText  =  new  TextNode(sourceText.getWholeText(),  sourceChild.baseUri());  dest.appendChild(destText);  }  //  else,  we  don't  care  about  comments,  xml  proc  instructions,  etc  }  return  numDiscarded;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
ElementMeta  meta  =  createSafeElement  (  sourceEl  )  ;	[BUGGY]  ElementMeta  meta  =  clean(  source);  [CONTEXT]  private  int  copySafeNodes(Element  source,  Element  dest)  {  List<Node>  sourceChildren  =  source.childNodes();  int  numDiscarded  =  0;    for  (Node  sourceChild  :  sourceChildren)  {  if  (sourceChild  instanceof  Element)  {  Element  sourceEl  =  (Element)  sourceChild;    if  (whitelist.isSafeTag(sourceEl.tagName()))  {  //  safe,  clone  and  copy  safe  attrs  [BUGGY]  ElementMeta  meta  =  clean  (  source  )  ;  Element  destChild  =  meta.el;  dest.appendChild(destChild);    numDiscarded  +=  meta.numAttribsDiscarded;  numDiscarded  +=  copySafeNodes(sourceEl,  destChild);  //  recurs  }  else  {  //  not  a  safe  tag,  but  it  may  have  children  (els  or  text)  that  are,  so  recurse  numDiscarded++;  numDiscarded  +=  copySafeNodes(sourceEl,  dest);  }  }  else  if  (sourceChild  instanceof  TextNode)  {  TextNode  sourceText  =  (TextNode)  sourceChild;  TextNode  destText  =  new  TextNode(sourceText.getWholeText(),  sourceChild.baseUri());  dest.appendChild(destText);  }  //  else,  we  don't  care  about  comments,  xml  proc  instructions,  etc  }  return  numDiscarded;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
ElementMeta  meta  =  createSafeElement  (  sourceEl  )  ;	[BUGGY]  Element  sourceEl  =  (  Element)  sourceChild;ElementMeta  meta  =  createSafeElement(  sourceEl);  [CONTEXT]        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
Element  destChild  =  meta.el;	[BUGGY]  Element  destChild  =  sourceEl;  [CONTEXT]  private  int  copySafeNodes(Element  source,  Element  dest)  {  List<Node>  sourceChildren  =  source.childNodes();  int  numDiscarded  =  0;    for  (Node  sourceChild  :  sourceChildren)  {  if  (sourceChild  instanceof  Element)  {  Element  sourceEl  =  (Element)  sourceChild;    if  (whitelist.isSafeTag(sourceEl.tagName()))  {  //  safe,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement(sourceEl);  [BUGGY]  Element  destChild  =  sourceEl;  dest.appendChild(destChild);    numDiscarded  +=  meta.numAttribsDiscarded;  numDiscarded  +=  copySafeNodes(sourceEl,  destChild);  //  recurs  }  else  {  //  not  a  safe  tag,  but  it  may  have  children  (els  or  text)  that  are,  so  recurse  numDiscarded++;  numDiscarded  +=  copySafeNodes(sourceEl,  dest);  }  }  else  if  (sourceChild  instanceof  TextNode)  {  TextNode  sourceText  =  (TextNode)  sourceChild;  TextNode  destText  =  new  TextNode(sourceText.getWholeText(),  sourceChild.baseUri());  dest.appendChild(destText);  }  //  else,  we  don't  care  about  comments,  xml  proc  instructions,  etc  }  return  numDiscarded;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
Element  destChild  =  meta.el;	[BUGGY]  Element  destChild  =  meta.el.el;  [CONTEXT]  private  int  copySafeNodes(Element  source,  Element  dest)  {  List<Node>  sourceChildren  =  source.childNodes();  int  numDiscarded  =  0;    for  (Node  sourceChild  :  sourceChildren)  {  if  (sourceChild  instanceof  Element)  {  Element  sourceEl  =  (Element)  sourceChild;    if  (whitelist.isSafeTag(sourceEl.tagName()))  {  //  safe,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement(sourceEl);  [BUGGY]  Element  destChild  =  meta.el.el;  dest.appendChild(destChild);    numDiscarded  +=  meta.numAttribsDiscarded;  numDiscarded  +=  copySafeNodes(sourceEl,  destChild);  //  recurs  }  else  {  //  not  a  safe  tag,  but  it  may  have  children  (els  or  text)  that  are,  so  recurse  numDiscarded++;  numDiscarded  +=  copySafeNodes(sourceEl,  dest);  }  }  else  if  (sourceChild  instanceof  TextNode)  {  TextNode  sourceText  =  (TextNode)  sourceChild;  TextNode  destText  =  new  TextNode(sourceText.getWholeText(),  sourceChild.baseUri());  dest.appendChild(destText);  }  //  else,  we  don't  care  about  comments,  xml  proc  instructions,  etc  }  return  numDiscarded;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
Element  destChild  =  meta.el;	[BUGGY]  Element  destChild  =  meta;  [CONTEXT]  private  int  copySafeNodes(Element  source,  Element  dest)  {  List<Node>  sourceChildren  =  source.childNodes();  int  numDiscarded  =  0;    for  (Node  sourceChild  :  sourceChildren)  {  if  (sourceChild  instanceof  Element)  {  Element  sourceEl  =  (Element)  sourceChild;    if  (whitelist.isSafeTag(sourceEl.tagName()))  {  //  safe,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement(sourceEl);  [BUGGY]  Element  destChild  =  meta;  dest.appendChild(destChild);    numDiscarded  +=  meta.numAttribsDiscarded;  numDiscarded  +=  copySafeNodes(sourceEl,  destChild);  //  recurs  }  else  {  //  not  a  safe  tag,  but  it  may  have  children  (els  or  text)  that  are,  so  recurse  numDiscarded++;  numDiscarded  +=  copySafeNodes(sourceEl,  dest);  }  }  else  if  (sourceChild  instanceof  TextNode)  {  TextNode  sourceText  =  (TextNode)  sourceChild;  TextNode  destText  =  new  TextNode(sourceText.getWholeText(),  sourceChild.baseUri());  dest.appendChild(destText);  }  //  else,  we  don't  care  about  comments,  xml  proc  instructions,  etc  }  return  numDiscarded;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
Element  destChild  =  meta.el;	[BUGGY]  Element  destChild  =  source;  [CONTEXT]  private  int  copySafeNodes(Element  source,  Element  dest)  {  List<Node>  sourceChildren  =  source.childNodes();  int  numDiscarded  =  0;    for  (Node  sourceChild  :  sourceChildren)  {  if  (sourceChild  instanceof  Element)  {  Element  sourceEl  =  (Element)  sourceChild;    if  (whitelist.isSafeTag(sourceEl.tagName()))  {  //  safe,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement(sourceEl);  [BUGGY]  Element  destChild  =  source;  dest.appendChild(destChild);    numDiscarded  +=  meta.numAttribsDiscarded;  numDiscarded  +=  copySafeNodes(sourceEl,  destChild);  //  recurs  }  else  {  //  not  a  safe  tag,  but  it  may  have  children  (els  or  text)  that  are,  so  recurse  numDiscarded++;  numDiscarded  +=  copySafeNodes(sourceEl,  dest);  }  }  else  if  (sourceChild  instanceof  TextNode)  {  TextNode  sourceText  =  (TextNode)  sourceChild;  TextNode  destText  =  new  TextNode(sourceText.getWholeText(),  sourceChild.baseUri());  dest.appendChild(destText);  }  //  else,  we  don't  care  about  comments,  xml  proc  instructions,  etc  }  return  numDiscarded;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
ElementMeta  meta  =  createSafeElement  (  sourceEl  )  ;	[BUGGY]  ElementMeta  meta  =  createSafeElement(  el);  [CONTEXT]  private  int  copySafeNodes(Element  source,  Element  dest)  {  List<Node>  sourceChildren  =  source.childNodes();  int  numDiscarded  =  0;    for  (Node  sourceChild  :  sourceChildren)  {  if  (sourceChild  instanceof  Element)  {  Element  sourceEl  =  (Element)  sourceChild;    if  (whitelist.isSafeTag(sourceEl.tagName()))  {  //  safe,  clone  and  copy  safe  attrs  [BUGGY]  ElementMeta  meta  =  createSafeElement  (  el  )  ;  Element  destChild  =  meta.el;  dest.appendChild(destChild);    numDiscarded  +=  meta.numAttribsDiscarded;  numDiscarded  +=  copySafeNodes(sourceEl,  destChild);  //  recurs  }  else  {  //  not  a  safe  tag,  but  it  may  have  children  (els  or  text)  that  are,  so  recurse  numDiscarded++;  numDiscarded  +=  copySafeNodes(sourceEl,  dest);  }  }  else  if  (sourceChild  instanceof  TextNode)  {  TextNode  sourceText  =  (TextNode)  sourceChild;  TextNode  destText  =  new  TextNode(sourceText.getWholeText(),  sourceChild.baseUri());  dest.appendChild(destText);  }  //  else,  we  don't  care  about  comments,  xml  proc  instructions,  etc  }  return  numDiscarded;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
ElementMeta  meta  =  createSafeElement  (  sourceEl  )  ;  Element  destChild  =  meta.el;	[BUGGY]    [CONTEXT]  private  int  copySafeNodes(Element  source,  Element  dest)  {  List<Node>  sourceChildren  =  source.childNodes();  int  numDiscarded  =  0;    for  (Node  sourceChild  :  sourceChildren)  {  if  (sourceChild  instanceof  Element)  {  Element  sourceEl  =  (Element)  sourceChild;    if  (whitelist.isSafeTag(sourceEl.tagName()))  {  //  safe,  clone  and  copy  safe  attrs  [BUGGY]  ElementMeta  meta  =  createSafeElement(sourceEl);      dest.appendChild(destChild);    numDiscarded  +=  meta.numAttribsDiscarded;  numDiscarded  +=  copySafeNodes(sourceEl,  destChild);  //  recurs  }  else  {  //  not  a  safe  tag,  but  it  may  have  children  (els  or  text)  that  are,  so  recurse  numDiscarded++;  numDiscarded  +=  copySafeNodes(sourceEl,  dest);  }  }  else  if  (sourceChild  instanceof  TextNode)  {  TextNode  sourceText  =  (TextNode)  sourceChild;  TextNode  destText  =  new  TextNode(sourceText.getWholeText(),  sourceChild.baseUri());  dest.appendChild(destText);  }  //  else,  we  don't  care  about  comments,  xml  proc  instructions,  etc  }  return  numDiscarded;        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
dest.appendChild  (  destChild  )  ;	[BUGGY]  dest.appendChild(  sourceElChild);  [CONTEXT]  private  int  copySafeNodes(Element  source,  Element  dest)  {  List<Node>  sourceChildren  =  source.childNodes();  int  numDiscarded  =  0;    for  (Node  sourceChild  :  sourceChildren)  {  if  (sourceChild  instanceof  Element)  {  Element  sourceEl  =  (Element)  sourceChild;    if  (whitelist.isSafeTag(sourceEl.tagName()))  {  //  safe,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement(sourceEl);  Element  destChild  =  meta.el;  [BUGGY]  dest.appendChild  (  sourceElChild  )  ;    numDiscarded  +=  meta.numAttribsDiscarded;  numDiscarded  +=  copySafeNodes(sourceEl,  destChild);  //  recurs  }  else  {  //  not  a  safe  tag,  but  it  may  have  children  (els  or  text)  that  are,  so  recurse  numDiscarded++;  numDiscarded  +=  copySafeNodes(sourceEl,  dest);  }  }  else  if  (sourceChild  instanceof  TextNode)  {  TextNode  sourceText  =  (TextNode)  sourceChild;  TextNode  destText  =  new  TextNode(sourceText.getWholeText(),  sourceChild.baseUri());  dest.appendChild(destText);  }  //  else,  we  don't  care  about  comments,  xml  proc  instructions,  etc  }  return  numDiscarded;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
dest.appendChild  (  destChild  )  ;	[BUGGY]  dest.appendChild(  sourceEl);  [CONTEXT]  private  int  copySafeNodes(Element  source,  Element  dest)  {  List<Node>  sourceChildren  =  source.childNodes();  int  numDiscarded  =  0;    for  (Node  sourceChild  :  sourceChildren)  {  if  (sourceChild  instanceof  Element)  {  Element  sourceEl  =  (Element)  sourceChild;    if  (whitelist.isSafeTag(sourceEl.tagName()))  {  //  safe,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement(sourceEl);  Element  destChild  =  meta.el;  [BUGGY]  dest.appendChild  (  sourceEl  )  ;    numDiscarded  +=  meta.numAttribsDiscarded;  numDiscarded  +=  copySafeNodes(sourceEl,  destChild);  //  recurs  }  else  {  //  not  a  safe  tag,  but  it  may  have  children  (els  or  text)  that  are,  so  recurse  numDiscarded++;  numDiscarded  +=  copySafeNodes(sourceEl,  dest);  }  }  else  if  (sourceChild  instanceof  TextNode)  {  TextNode  sourceText  =  (TextNode)  sourceChild;  TextNode  destText  =  new  TextNode(sourceText.getWholeText(),  sourceChild.baseUri());  dest.appendChild(destText);  }  //  else,  we  don't  care  about  comments,  xml  proc  instructions,  etc  }  return  numDiscarded;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
dest.appendChild  (  destChild  )  ;	[BUGGY]  dest.appendChild(  destChildChild);  [CONTEXT]  private  int  copySafeNodes(Element  source,  Element  dest)  {  List<Node>  sourceChildren  =  source.childNodes();  int  numDiscarded  =  0;    for  (Node  sourceChild  :  sourceChildren)  {  if  (sourceChild  instanceof  Element)  {  Element  sourceEl  =  (Element)  sourceChild;    if  (whitelist.isSafeTag(sourceEl.tagName()))  {  //  safe,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement(sourceEl);  Element  destChild  =  meta.el;  [BUGGY]  dest.appendChild  (  destChildChild  )  ;    numDiscarded  +=  meta.numAttribsDiscarded;  numDiscarded  +=  copySafeNodes(sourceEl,  destChild);  //  recurs  }  else  {  //  not  a  safe  tag,  but  it  may  have  children  (els  or  text)  that  are,  so  recurse  numDiscarded++;  numDiscarded  +=  copySafeNodes(sourceEl,  dest);  }  }  else  if  (sourceChild  instanceof  TextNode)  {  TextNode  sourceText  =  (TextNode)  sourceChild;  TextNode  destText  =  new  TextNode(sourceText.getWholeText(),  sourceChild.baseUri());  dest.appendChild(destText);  }  //  else,  we  don't  care  about  comments,  xml  proc  instructions,  etc  }  return  numDiscarded;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
dest.appendChild  (  destChild  )  ;	[BUGGY]  dest.appendChild(  dest);  [CONTEXT]  private  int  copySafeNodes(Element  source,  Element  dest)  {  List<Node>  sourceChildren  =  source.childNodes();  int  numDiscarded  =  0;    for  (Node  sourceChild  :  sourceChildren)  {  if  (sourceChild  instanceof  Element)  {  Element  sourceEl  =  (Element)  sourceChild;    if  (whitelist.isSafeTag(sourceEl.tagName()))  {  //  safe,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement(sourceEl);  Element  destChild  =  meta.el;  [BUGGY]  dest.appendChild  (  dest  )  ;    numDiscarded  +=  meta.numAttribsDiscarded;  numDiscarded  +=  copySafeNodes(sourceEl,  destChild);  //  recurs  }  else  {  //  not  a  safe  tag,  but  it  may  have  children  (els  or  text)  that  are,  so  recurse  numDiscarded++;  numDiscarded  +=  copySafeNodes(sourceEl,  dest);  }  }  else  if  (sourceChild  instanceof  TextNode)  {  TextNode  sourceText  =  (TextNode)  sourceChild;  TextNode  destText  =  new  TextNode(sourceText.getWholeText(),  sourceChild.baseUri());  dest.appendChild(destText);  }  //  else,  we  don't  care  about  comments,  xml  proc  instructions,  etc  }  return  numDiscarded;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
dest.appendChild  (  destChild  )  ;	[BUGGY]    [CONTEXT]  private  int  copySafeNodes(Element  source,  Element  dest)  {  List<Node>  sourceChildren  =  source.childNodes();  int  numDiscarded  =  0;    for  (Node  sourceChild  :  sourceChildren)  {  if  (sourceChild  instanceof  Element)  {  Element  sourceEl  =  (Element)  sourceChild;    if  (whitelist.isSafeTag(sourceEl.tagName()))  {  //  safe,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement(sourceEl);  Element  destChild  =  meta.el;  [BUGGY]  dest.appendChild(destChild);      numDiscarded  +=  meta.numAttribsDiscarded;  numDiscarded  +=  copySafeNodes(sourceEl,  destChild);  //  recurs  }  else  {  //  not  a  safe  tag,  but  it  may  have  children  (els  or  text)  that  are,  so  recurse  numDiscarded++;  numDiscarded  +=  copySafeNodes(sourceEl,  dest);  }  }  else  if  (sourceChild  instanceof  TextNode)  {  TextNode  sourceText  =  (TextNode)  sourceChild;  TextNode  destText  =  new  TextNode(sourceText.getWholeText(),  sourceChild.baseUri());  dest.appendChild(destText);  }  //  else,  we  don't  care  about  comments,  xml  proc  instructions,  etc  }  return  numDiscarded;        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
numDiscarded  +=  copySafeNodes  (  sourceEl,  destChild  )  ;	[BUGGY]    [CONTEXT]  private  int  copySafeNodes(Element  source,  Element  dest)  {  List<Node>  sourceChildren  =  source.childNodes();  int  numDiscarded  =  0;    for  (Node  sourceChild  :  sourceChildren)  {  if  (sourceChild  instanceof  Element)  {  Element  sourceEl  =  (Element)  sourceChild;    if  (whitelist.isSafeTag(sourceEl.tagName()))  {  //  safe,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement(sourceEl);  Element  destChild  =  meta.el;  dest.appendChild(destChild);    numDiscarded  +=  meta.numAttribsDiscarded;  [BUGGY]  numDiscarded  +=  copySafeNodes(sourceEl,  destChild);  //  recurs    }  else  {  //  not  a  safe  tag,  but  it  may  have  children  (els  or  text)  that  are,  so  recurse  numDiscarded++;  numDiscarded  +=  copySafeNodes(sourceEl,  dest);  }  }  else  if  (sourceChild  instanceof  TextNode)  {  TextNode  sourceText  =  (TextNode)  sourceChild;  TextNode  destText  =  new  TextNode(sourceText.getWholeText(),  sourceChild.baseUri());  dest.appendChild(destText);  }  //  else,  we  don't  care  about  comments,  xml  proc  instructions,  etc  }  return  numDiscarded;        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
numDiscarded  +=  meta.numAttribsDiscarded;	[BUGGY]  numDiscarded  +=  copySafeNodes(  sourceEl,  destChild);  numDiscarded  +=  meta.numAttribsDiscarded;  [CONTEXT]        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
numDiscarded  +=  meta.numAttribsDiscarded;	[BUGGY]  this.numAttribsDiscarded  =  numAttribsDiscarded;numDiscarded  +=  meta.numAttribsDiscarded;  [CONTEXT]        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
numDiscarded  +=  copySafeNodes  (  sourceEl,  dest  )  ;	[BUGGY]  numDiscarded  +=  copySafeNodes(  sourceEl,  source);  [CONTEXT]  private  int  copySafeNodes(Element  source,  Element  dest)  {  List<Node>  sourceChildren  =  source.childNodes();  int  numDiscarded  =  0;    for  (Node  sourceChild  :  sourceChildren)  {  if  (sourceChild  instanceof  Element)  {  Element  sourceEl  =  (Element)  sourceChild;    if  (whitelist.isSafeTag(sourceEl.tagName()))  {  //  safe,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement(sourceEl);  Element  destChild  =  meta.el;  dest.appendChild(destChild);    numDiscarded  +=  meta.numAttribsDiscarded;  numDiscarded  +=  copySafeNodes(sourceEl,  destChild);  //  recurs  }  else  {  //  not  a  safe  tag,  but  it  may  have  children  (els  or  text)  that  are,  so  recurse  numDiscarded++;  [BUGGY]  numDiscarded  +=  copySafeNodes  (  sourceEl,  source  )  ;  }  }  else  if  (sourceChild  instanceof  TextNode)  {  TextNode  sourceText  =  (TextNode)  sourceChild;  TextNode  destText  =  new  TextNode(sourceText.getWholeText(),  sourceChild.baseUri());  dest.appendChild(destText);  }  //  else,  we  don't  care  about  comments,  xml  proc  instructions,  etc  }  return  numDiscarded;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
numDiscarded  +=  copySafeNodes  (  sourceEl,  dest  )  ;	[BUGGY]  numDiscarded  +=  copySafeNodes(  dest,  sourceEl);  [CONTEXT]  private  int  copySafeNodes(Element  source,  Element  dest)  {  List<Node>  sourceChildren  =  source.childNodes();  int  numDiscarded  =  0;    for  (Node  sourceChild  :  sourceChildren)  {  if  (sourceChild  instanceof  Element)  {  Element  sourceEl  =  (Element)  sourceChild;    if  (whitelist.isSafeTag(sourceEl.tagName()))  {  //  safe,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement(sourceEl);  Element  destChild  =  meta.el;  dest.appendChild(destChild);    numDiscarded  +=  meta.numAttribsDiscarded;  numDiscarded  +=  copySafeNodes(sourceEl,  destChild);  //  recurs  }  else  {  //  not  a  safe  tag,  but  it  may  have  children  (els  or  text)  that  are,  so  recurse  numDiscarded++;  [BUGGY]  numDiscarded  +=  copySafeNodes  (  dest,  sourceEl  )  ;  }  }  else  if  (sourceChild  instanceof  TextNode)  {  TextNode  sourceText  =  (TextNode)  sourceChild;  TextNode  destText  =  new  TextNode(sourceText.getWholeText(),  sourceChild.baseUri());  dest.appendChild(destText);  }  //  else,  we  don't  care  about  comments,  xml  proc  instructions,  etc  }  return  numDiscarded;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
numDiscarded  +=  copySafeNodes  (  sourceEl,  dest  )  ;	[BUGGY]  numDiscarded  +=  copySafeNodes(    dest);  [CONTEXT]  private  int  copySafeNodes(Element  source,  Element  dest)  {  List<Node>  sourceChildren  =  source.childNodes();  int  numDiscarded  =  0;    for  (Node  sourceChild  :  sourceChildren)  {  if  (sourceChild  instanceof  Element)  {  Element  sourceEl  =  (Element)  sourceChild;    if  (whitelist.isSafeTag(sourceEl.tagName()))  {  //  safe,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement(sourceEl);  Element  destChild  =  meta.el;  dest.appendChild(destChild);    numDiscarded  +=  meta.numAttribsDiscarded;  numDiscarded  +=  copySafeNodes(sourceEl,  destChild);  //  recurs  }  else  {  //  not  a  safe  tag,  but  it  may  have  children  (els  or  text)  that  are,  so  recurse  numDiscarded++;  [BUGGY]  numDiscarded  +=  copySafeNodes  (dest  )  ;  }  }  else  if  (sourceChild  instanceof  TextNode)  {  TextNode  sourceText  =  (TextNode)  sourceChild;  TextNode  destText  =  new  TextNode(sourceText.getWholeText(),  sourceChild.baseUri());  dest.appendChild(destText);  }  //  else,  we  don't  care  about  comments,  xml  proc  instructions,  etc  }  return  numDiscarded;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
numDiscarded  +=  copySafeNodes  (  sourceEl,  dest  )  ;	[BUGGY]  numDiscarded  +=  copySafeNodes(  sourceEl);  [CONTEXT]  private  int  copySafeNodes(Element  source,  Element  dest)  {  List<Node>  sourceChildren  =  source.childNodes();  int  numDiscarded  =  0;    for  (Node  sourceChild  :  sourceChildren)  {  if  (sourceChild  instanceof  Element)  {  Element  sourceEl  =  (Element)  sourceChild;    if  (whitelist.isSafeTag(sourceEl.tagName()))  {  //  safe,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement(sourceEl);  Element  destChild  =  meta.el;  dest.appendChild(destChild);    numDiscarded  +=  meta.numAttribsDiscarded;  numDiscarded  +=  copySafeNodes(sourceEl,  destChild);  //  recurs  }  else  {  //  not  a  safe  tag,  but  it  may  have  children  (els  or  text)  that  are,  so  recurse  numDiscarded++;  [BUGGY]  numDiscarded  +=  copySafeNodes  (  sourceEl  )  ;  }  }  else  if  (sourceChild  instanceof  TextNode)  {  TextNode  sourceText  =  (TextNode)  sourceChild;  TextNode  destText  =  new  TextNode(sourceText.getWholeText(),  sourceChild.baseUri());  dest.appendChild(destText);  }  //  else,  we  don't  care  about  comments,  xml  proc  instructions,  etc  }  return  numDiscarded;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
numDiscarded  +=  copySafeNodes  (  sourceEl,  dest  )  ;	[BUGGY]  numDiscarded  +=    copySafeNodes(  null,  dest);  [CONTEXT]  private  int  copySafeNodes(Element  source,  Element  dest)  {  List<Node>  sourceChildren  =  source.childNodes();  int  numDiscarded  =  0;    for  (Node  sourceChild  :  sourceChildren)  {  if  (sourceChild  instanceof  Element)  {  Element  sourceEl  =  (Element)  sourceChild;    if  (whitelist.isSafeTag(sourceEl.tagName()))  {  //  safe,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement(sourceEl);  Element  destChild  =  meta.el;  dest.appendChild(destChild);    numDiscarded  +=  meta.numAttribsDiscarded;  numDiscarded  +=  copySafeNodes(sourceEl,  destChild);  //  recurs  }  else  {  //  not  a  safe  tag,  but  it  may  have  children  (els  or  text)  that  are,  so  recurse  numDiscarded++;  [BUGGY]  numDiscarded  +=copySafeNodes  (  null,  dest  )  ;  }  }  else  if  (sourceChild  instanceof  TextNode)  {  TextNode  sourceText  =  (TextNode)  sourceChild;  TextNode  destText  =  new  TextNode(sourceText.getWholeText(),  sourceChild.baseUri());  dest.appendChild(destText);  }  //  else,  we  don't  care  about  comments,  xml  proc  instructions,  etc  }  return  numDiscarded;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
ElementMeta  meta  =  createSafeElement  (  sourceEl  )  ;	[BUGGY]  ElementMeta  meta  =  clean(  el);  [CONTEXT]  private  int  copySafeNodes(Element  source,  Element  dest)  {  List<Node>  sourceChildren  =  source.childNodes();  int  numDiscarded  =  0;    for  (Node  sourceChild  :  sourceChildren)  {  if  (sourceChild  instanceof  Element)  {  Element  sourceEl  =  (Element)  sourceChild;    if  (whitelist.isSafeTag(sourceEl.tagName()))  {  //  safe,  clone  and  copy  safe  attrs  [BUGGY]  ElementMeta  meta  =  clean  (  el  )  ;  Element  destChild  =  meta.el;  dest.appendChild(destChild);    numDiscarded  +=  meta.numAttribsDiscarded;  numDiscarded  +=  copySafeNodes(sourceEl,  destChild);  //  recurs  }  else  {  //  not  a  safe  tag,  but  it  may  have  children  (els  or  text)  that  are,  so  recurse  numDiscarded++;  numDiscarded  +=  copySafeNodes(sourceEl,  dest);  }  }  else  if  (sourceChild  instanceof  TextNode)  {  TextNode  sourceText  =  (TextNode)  sourceChild;  TextNode  destText  =  new  TextNode(sourceText.getWholeText(),  sourceChild.baseUri());  dest.appendChild(destText);  }  //  else,  we  don't  care  about  comments,  xml  proc  instructions,  etc  }  return  numDiscarded;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
if  (  whitelist.isSafeTag  (  sourceEl.tagName  (  )  )  )  {	[BUGGY]  if  (  sourceEl.isSafeTag(  whitelist.tagName(  )))  {  [CONTEXT]  private  int  copySafeNodes(Element  source,  Element  dest)  {  List<Node>  sourceChildren  =  source.childNodes();  int  numDiscarded  =  0;    for  (Node  sourceChild  :  sourceChildren)  {  if  (sourceChild  instanceof  Element)  {  Element  sourceEl  =  (Element)  sourceChild;    [BUGGY]  if(  sourceEl.isSafeTag  (  whitelist.tagName  ())){  ElementMeta  meta  =  createSafeElement(sourceEl);  Element  destChild  =  meta.el;  dest.appendChild(destChild);    numDiscarded  +=  meta.numAttribsDiscarded;  numDiscarded  +=  copySafeNodes(sourceEl,  destChild);  //  recurs  }  else  {  //  not  a  safe  tag,  but  it  may  have  children  (els  or  text)  that  are,  so  recurse  numDiscarded++;  numDiscarded  +=  copySafeNodes(sourceEl,  dest);  }  }  else  if  (sourceChild  instanceof  TextNode)  {  TextNode  sourceText  =  (TextNode)  sourceChild;  TextNode  destText  =  new  TextNode(sourceText.getWholeText(),  sourceChild.baseUri());  dest.appendChild(destText);  }  //  else,  we  don't  care  about  comments,  xml  proc  instructions,  etc  }  return  numDiscarded;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
if  (  whitelist.isSafeTag  (  sourceEl.tagName  (  )  )  )  {	[BUGGY]  if  (  whitelist.isSafeTag(  sourceEl  .childNodes(  )  ))  {  [CONTEXT]  private  int  copySafeNodes(Element  source,  Element  dest)  {  List<Node>  sourceChildren  =  source.childNodes();  int  numDiscarded  =  0;    for  (Node  sourceChild  :  sourceChildren)  {  if  (sourceChild  instanceof  Element)  {  Element  sourceEl  =  (Element)  sourceChild;    [BUGGY]  if(  whitelist.isSafeTag  (  sourceEl  .childNodes  ()  )){  ElementMeta  meta  =  createSafeElement(sourceEl);  Element  destChild  =  meta.el;  dest.appendChild(destChild);    numDiscarded  +=  meta.numAttribsDiscarded;  numDiscarded  +=  copySafeNodes(sourceEl,  destChild);  //  recurs  }  else  {  //  not  a  safe  tag,  but  it  may  have  children  (els  or  text)  that  are,  so  recurse  numDiscarded++;  numDiscarded  +=  copySafeNodes(sourceEl,  dest);  }  }  else  if  (sourceChild  instanceof  TextNode)  {  TextNode  sourceText  =  (TextNode)  sourceChild;  TextNode  destText  =  new  TextNode(sourceText.getWholeText(),  sourceChild.baseUri());  dest.appendChild(destText);  }  //  else,  we  don't  care  about  comments,  xml  proc  instructions,  etc  }  return  numDiscarded;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
ElementMeta  meta  =  createSafeElement  (  sourceEl  )  ;  Element  destChild  =  meta.el;	[BUGGY]  Element  destChild  =  meta.el;  ElementMeta  meta  =  createSafeElement(  sourceEl);  [CONTEXT]        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
ElementMeta  meta  =  createSafeElement  (  sourceEl  )  ;  Element  destChild  =  meta.el;	[BUGGY]  ElementMeta  meta  =  createSafeElement(  sourceEl);ElementMeta  meta  =  createSafeElement(  sourceEl);  Element  destChild  =  meta.el;  [CONTEXT]        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
numDiscarded  +=  copySafeNodes  (  sourceEl,  dest  )  ;	[BUGGY]  numDiscarded  +=  copySafeNodes(  source,  dest);  [CONTEXT]  private  int  copySafeNodes(Element  source,  Element  dest)  {  List<Node>  sourceChildren  =  source.childNodes();  int  numDiscarded  =  0;    for  (Node  sourceChild  :  sourceChildren)  {  if  (sourceChild  instanceof  Element)  {  Element  sourceEl  =  (Element)  sourceChild;    if  (whitelist.isSafeTag(sourceEl.tagName()))  {  //  safe,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement(sourceEl);  Element  destChild  =  meta.el;  dest.appendChild(destChild);    numDiscarded  +=  meta.numAttribsDiscarded;  numDiscarded  +=  copySafeNodes(sourceEl,  destChild);  //  recurs  }  else  {  //  not  a  safe  tag,  but  it  may  have  children  (els  or  text)  that  are,  so  recurse  numDiscarded++;  [BUGGY]  numDiscarded  +=  copySafeNodes  (  source,  dest  )  ;  }  }  else  if  (sourceChild  instanceof  TextNode)  {  TextNode  sourceText  =  (TextNode)  sourceChild;  TextNode  destText  =  new  TextNode(sourceText.getWholeText(),  sourceChild.baseUri());  dest.appendChild(destText);  }  //  else,  we  don't  care  about  comments,  xml  proc  instructions,  etc  }  return  numDiscarded;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
numDiscarded  +=  copySafeNodes  (  sourceEl,  dest  )  ;	[BUGGY]    [CONTEXT]  private  int  copySafeNodes(Element  source,  Element  dest)  {  List<Node>  sourceChildren  =  source.childNodes();  int  numDiscarded  =  0;    for  (Node  sourceChild  :  sourceChildren)  {  if  (sourceChild  instanceof  Element)  {  Element  sourceEl  =  (Element)  sourceChild;    if  (whitelist.isSafeTag(sourceEl.tagName()))  {  //  safe,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement(sourceEl);  Element  destChild  =  meta.el;  dest.appendChild(destChild);    numDiscarded  +=  meta.numAttribsDiscarded;  numDiscarded  +=  copySafeNodes(sourceEl,  destChild);  //  recurs  }  else  {  //  not  a  safe  tag,  but  it  may  have  children  (els  or  text)  that  are,  so  recurse  numDiscarded++;  [BUGGY]  numDiscarded  +=  copySafeNodes(sourceEl,  dest);    }  }  else  if  (sourceChild  instanceof  TextNode)  {  TextNode  sourceText  =  (TextNode)  sourceChild;  TextNode  destText  =  new  TextNode(sourceText.getWholeText(),  sourceChild.baseUri());  dest.appendChild(destText);  }  //  else,  we  don't  care  about  comments,  xml  proc  instructions,  etc  }  return  numDiscarded;        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
numDiscarded  +=  copySafeNodes  (  sourceEl,  dest  )  ;	[BUGGY]  numDiscarded  +=    copySafeNodes(  null,  dest);  [CONTEXT]  if  (whitelist.isSafeTag(sourceEl.tagName()))  {  //  safe,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement(sourceEl);  Element  destChild  =  meta.el;  dest.appendChild(destChild);    numDiscarded  +=  meta.numAttribsDiscarded;  numDiscarded  +=  copySafeNodes(sourceEl,  destChild);  //  recurs  }  else  {  //  not  a  safe  tag,  but  it  may  have  children  (els  or  text)  that  are,  so  recurse  numDiscarded++;  [BUGGY]  numDiscarded  +=copySafeNodes  (  null,  dest  )  ;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
ElementMeta  meta  =  createSafeElement  (  sourceEl  )  ;	[BUGGY]    [CONTEXT]  private  int  copySafeNodes(Element  source,  Element  dest)  {  List<Node>  sourceChildren  =  source.childNodes();  int  numDiscarded  =  0;    for  (Node  sourceChild  :  sourceChildren)  {  if  (sourceChild  instanceof  Element)  {  Element  sourceEl  =  (Element)  sourceChild;    if  (whitelist.isSafeTag(sourceEl.tagName()))  {  //  safe,  clone  and  copy  safe  attrs  [BUGGY]  ElementMeta  meta  =  createSafeElement(sourceEl);    Element  destChild  =  meta.el;  dest.appendChild(destChild);    numDiscarded  +=  meta.numAttribsDiscarded;  numDiscarded  +=  copySafeNodes(sourceEl,  destChild);  //  recurs  }  else  {  //  not  a  safe  tag,  but  it  may  have  children  (els  or  text)  that  are,  so  recurse  numDiscarded++;  numDiscarded  +=  copySafeNodes(sourceEl,  dest);  }  }  else  if  (sourceChild  instanceof  TextNode)  {  TextNode  sourceText  =  (TextNode)  sourceChild;  TextNode  destText  =  new  TextNode(sourceText.getWholeText(),  sourceChild.baseUri());  dest.appendChild(destText);  }  //  else,  we  don't  care  about  comments,  xml  proc  instructions,  etc  }  return  numDiscarded;        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
dest.appendChild  (  destChild  )  ;	[BUGGY]  dest  .appendChild(  source)  ;  [CONTEXT]  private  int  copySafeNodes(Element  source,  Element  dest)  {  List<Node>  sourceChildren  =  source.childNodes();  int  numDiscarded  =  0;    for  (Node  sourceChild  :  sourceChildren)  {  if  (sourceChild  instanceof  Element)  {  Element  sourceEl  =  (Element)  sourceChild;    if  (whitelist.isSafeTag(sourceEl.tagName()))  {  //  safe,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement(sourceEl);  Element  destChild  =  meta.el;  [BUGGY]  dest  .appendChild  (  source  );    numDiscarded  +=  meta.numAttribsDiscarded;  numDiscarded  +=  copySafeNodes(sourceEl,  destChild);  //  recurs  }  else  {  //  not  a  safe  tag,  but  it  may  have  children  (els  or  text)  that  are,  so  recurse  numDiscarded++;  numDiscarded  +=  copySafeNodes(sourceEl,  dest);  }  }  else  if  (sourceChild  instanceof  TextNode)  {  TextNode  sourceText  =  (TextNode)  sourceChild;  TextNode  destText  =  new  TextNode(sourceText.getWholeText(),  sourceChild.baseUri());  dest.appendChild(destText);  }  //  else,  we  don't  care  about  comments,  xml  proc  instructions,  etc  }  return  numDiscarded;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
}  else  if  (  sourceChild  instanceof  TextNode  )  {	[BUGGY]    else  if  (  sourceChild    >>    TextNode)  {  [CONTEXT]  private  int  copySafeNodes(Element  source,  Element  dest)  {  List<Node>  sourceChildren  =  source.childNodes();  int  numDiscarded  =  0;    for  (Node  sourceChild  :  sourceChildren)  {  if  (sourceChild  instanceof  Element)  {  Element  sourceEl  =  (Element)  sourceChild;    if  (whitelist.isSafeTag(sourceEl.tagName()))  {  //  safe,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement(sourceEl);  Element  destChild  =  meta.el;  dest.appendChild(destChild);    numDiscarded  +=  meta.numAttribsDiscarded;  numDiscarded  +=  copySafeNodes(sourceEl,  destChild);  //  recurs  }  else  {  //  not  a  safe  tag,  but  it  may  have  children  (els  or  text)  that  are,  so  recurse  numDiscarded++;  numDiscarded  +=  copySafeNodes(sourceEl,  dest);  }  [BUGGY]  }  else  if(  sourceChild>>TextNode  ){  TextNode  sourceText  =  (TextNode)  sourceChild;  TextNode  destText  =  new  TextNode(sourceText.getWholeText(),  sourceChild.baseUri());  dest.appendChild(destText);  }  //  else,  we  don't  care  about  comments,  xml  proc  instructions,  etc  }  return  numDiscarded;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
dest.appendChild  (  destText  )  ;	[BUGGY]  dest  .appendChild(  destChild)  ;  [CONTEXT]  private  int  copySafeNodes(Element  source,  Element  dest)  {  List<Node>  sourceChildren  =  source.childNodes();  int  numDiscarded  =  0;    for  (Node  sourceChild  :  sourceChildren)  {  if  (sourceChild  instanceof  Element)  {  Element  sourceEl  =  (Element)  sourceChild;    if  (whitelist.isSafeTag(sourceEl.tagName()))  {  //  safe,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement(sourceEl);  Element  destChild  =  meta.el;  dest.appendChild(destChild);    numDiscarded  +=  meta.numAttribsDiscarded;  numDiscarded  +=  copySafeNodes(sourceEl,  destChild);  //  recurs  }  else  {  //  not  a  safe  tag,  but  it  may  have  children  (els  or  text)  that  are,  so  recurse  numDiscarded++;  numDiscarded  +=  copySafeNodes(sourceEl,  dest);  }  }  else  if  (sourceChild  instanceof  TextNode)  {  TextNode  sourceText  =  (TextNode)  sourceChild;  TextNode  destText  =  new  TextNode(sourceText.getWholeText(),  sourceChild.baseUri());  [BUGGY]  dest  .appendChild  (  destChild  );  }  //  else,  we  don't  care  about  comments,  xml  proc  instructions,  etc  }  return  numDiscarded;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
if  (  whitelist.isSafeTag  (  sourceEl.tagName  (  )  )  )  {	[BUGGY]  if  (  whitelist.getEnforcedAttributes(  el.tagName(  )))  {  [CONTEXT]  private  int  copySafeNodes(Element  source,  Element  dest)  {  List<Node>  sourceChildren  =  source.childNodes();  int  numDiscarded  =  0;    for  (Node  sourceChild  :  sourceChildren)  {  if  (sourceChild  instanceof  Element)  {  Element  sourceEl  =  (Element)  sourceChild;    [BUGGY]  if(  whitelist.getEnforcedAttributes  (  el.tagName  ())){  ElementMeta  meta  =  createSafeElement(sourceEl);  Element  destChild  =  meta.el;  dest.appendChild(destChild);    numDiscarded  +=  meta.numAttribsDiscarded;  numDiscarded  +=  copySafeNodes(sourceEl,  destChild);  //  recurs  }  else  {  //  not  a  safe  tag,  but  it  may  have  children  (els  or  text)  that  are,  so  recurse  numDiscarded++;  numDiscarded  +=  copySafeNodes(sourceEl,  dest);  }  }  else  if  (sourceChild  instanceof  TextNode)  {  TextNode  sourceText  =  (TextNode)  sourceChild;  TextNode  destText  =  new  TextNode(sourceText.getWholeText(),  sourceChild.baseUri());  dest.appendChild(destText);  }  //  else,  we  don't  care  about  comments,  xml  proc  instructions,  etc  }  return  numDiscarded;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
return  numDiscarded;	[BUGGY]  return  numAttribsDiscarded;  [CONTEXT]  private  int  copySafeNodes(Element  source,  Element  dest)  {  List<Node>  sourceChildren  =  source.childNodes();  int  numDiscarded  =  0;    for  (Node  sourceChild  :  sourceChildren)  {  if  (sourceChild  instanceof  Element)  {  Element  sourceEl  =  (Element)  sourceChild;    if  (whitelist.isSafeTag(sourceEl.tagName()))  {  //  safe,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement(sourceEl);  Element  destChild  =  meta.el;  dest.appendChild(destChild);    numDiscarded  +=  meta.numAttribsDiscarded;  numDiscarded  +=  copySafeNodes(sourceEl,  destChild);  //  recurs  }  else  {  //  not  a  safe  tag,  but  it  may  have  children  (els  or  text)  that  are,  so  recurse  numDiscarded++;  numDiscarded  +=  copySafeNodes(sourceEl,  dest);  }  }  else  if  (sourceChild  instanceof  TextNode)  {  TextNode  sourceText  =  (TextNode)  sourceChild;  TextNode  destText  =  new  TextNode(sourceText.getWholeText(),  sourceChild.baseUri());  dest.appendChild(destText);  }  //  else,  we  don't  care  about  comments,  xml  proc  instructions,  etc  }  [BUGGY]  return  numAttribsDiscarded;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  copySafeNodes  [RETURN_TYPE]  int      Element  source  Element  dest  [VARIABLES]  ElementMeta    meta    boolean    Element    dest    destChild    el    source    sourceEl    Node    sourceChild    Whitelist    whitelist    List    sourceChildren    TextNode    destText    sourceText    int    numAttribsDiscarded    numDiscarded    
String  sourceTag  =  sourceEl.tagName  (  )  ;	[BUGGY]  char  sourceTag  =  sourceEl.tagName(  );  [CONTEXT]  private  ElementMeta  createSafeElement(Element  sourceEl)  {  [BUGGY]  char  sourceTag  =  sourceEl.tagName  ()  ;  Attributes  destAttrs  =  new  Attributes();  Element  dest  =  new  Element(Tag.valueOf(sourceTag),  sourceEl.baseUri(),  destAttrs);  int  numDiscarded  =  0;    Attributes  sourceAttrs  =  sourceEl.attributes();  for  (Attribute  sourceAttr  :  sourceAttrs)  {  if  (whitelist.isSafeAttribute(sourceTag,  sourceEl,  sourceAttr))  destAttrs.put(sourceAttr);  else  numDiscarded++;  }  Attributes  enforcedAttrs  =  whitelist.getEnforcedAttributes(sourceTag);  destAttrs.addAll(enforcedAttrs);    return  new  ElementMeta(dest,  numDiscarded);  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  createSafeElement  [RETURN_TYPE]  Cleaner$ElementMeta      Element  sourceEl  [VARIABLES]  boolean    Attribute    sourceAttr    Element    dest    destChild    el    source    sourceEl    Attributes    destAttrs    enforcedAttrs    sourceAttrs    Whitelist    whitelist    String    sourceTag    int    numAttribsDiscarded    numDiscarded    
String  sourceTag  =  sourceEl.tagName  (  )  ;	[BUGGY]  String  sourceTag  =  source.tagName(  );  [CONTEXT]  private  ElementMeta  createSafeElement(Element  sourceEl)  {  [BUGGY]  String  sourceTag  =  source.tagName  ()  ;  Attributes  destAttrs  =  new  Attributes();  Element  dest  =  new  Element(Tag.valueOf(sourceTag),  sourceEl.baseUri(),  destAttrs);  int  numDiscarded  =  0;    Attributes  sourceAttrs  =  sourceEl.attributes();  for  (Attribute  sourceAttr  :  sourceAttrs)  {  if  (whitelist.isSafeAttribute(sourceTag,  sourceEl,  sourceAttr))  destAttrs.put(sourceAttr);  else  numDiscarded++;  }  Attributes  enforcedAttrs  =  whitelist.getEnforcedAttributes(sourceTag);  destAttrs.addAll(enforcedAttrs);    return  new  ElementMeta(dest,  numDiscarded);  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  createSafeElement  [RETURN_TYPE]  Cleaner$ElementMeta      Element  sourceEl  [VARIABLES]  boolean    Attribute    sourceAttr    Element    dest    destChild    el    source    sourceEl    Attributes    destAttrs    enforcedAttrs    sourceAttrs    Whitelist    whitelist    String    sourceTag    int    numAttribsDiscarded    numDiscarded    
String  sourceTag  =  sourceEl.tagName  (  )  ;	[BUGGY]  String  sourceTag  =  sourceEl.appendChild(  );  [CONTEXT]  private  ElementMeta  createSafeElement(Element  sourceEl)  {  [BUGGY]  String  sourceTag  =  sourceEl.appendChild  ()  ;  Attributes  destAttrs  =  new  Attributes();  Element  dest  =  new  Element(Tag.valueOf(sourceTag),  sourceEl.baseUri(),  destAttrs);  int  numDiscarded  =  0;    Attributes  sourceAttrs  =  sourceEl.attributes();  for  (Attribute  sourceAttr  :  sourceAttrs)  {  if  (whitelist.isSafeAttribute(sourceTag,  sourceEl,  sourceAttr))  destAttrs.put(sourceAttr);  else  numDiscarded++;  }  Attributes  enforcedAttrs  =  whitelist.getEnforcedAttributes(sourceTag);  destAttrs.addAll(enforcedAttrs);    return  new  ElementMeta(dest,  numDiscarded);  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  createSafeElement  [RETURN_TYPE]  Cleaner$ElementMeta      Element  sourceEl  [VARIABLES]  boolean    Attribute    sourceAttr    Element    dest    destChild    el    source    sourceEl    Attributes    destAttrs    enforcedAttrs    sourceAttrs    Whitelist    whitelist    String    sourceTag    int    numAttribsDiscarded    numDiscarded    
String  sourceTag  =  sourceEl.tagName  (  )  ;	[BUGGY]  String  sourceTag  =  sourceEl  .childNodes(  )  ;  [CONTEXT]  private  ElementMeta  createSafeElement(Element  sourceEl)  {  [BUGGY]  String  sourceTag  =  sourceEl  .childNodes  ();  Attributes  destAttrs  =  new  Attributes();  Element  dest  =  new  Element(Tag.valueOf(sourceTag),  sourceEl.baseUri(),  destAttrs);  int  numDiscarded  =  0;    Attributes  sourceAttrs  =  sourceEl.attributes();  for  (Attribute  sourceAttr  :  sourceAttrs)  {  if  (whitelist.isSafeAttribute(sourceTag,  sourceEl,  sourceAttr))  destAttrs.put(sourceAttr);  else  numDiscarded++;  }  Attributes  enforcedAttrs  =  whitelist.getEnforcedAttributes(sourceTag);  destAttrs.addAll(enforcedAttrs);    return  new  ElementMeta(dest,  numDiscarded);  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  createSafeElement  [RETURN_TYPE]  Cleaner$ElementMeta      Element  sourceEl  [VARIABLES]  boolean    Attribute    sourceAttr    Element    dest    destChild    el    source    sourceEl    Attributes    destAttrs    enforcedAttrs    sourceAttrs    Whitelist    whitelist    String    sourceTag    int    numAttribsDiscarded    numDiscarded    
String  sourceTag  =  sourceEl.tagName  (  )  ;	[BUGGY]  Attributes  sourceAttrs  =  sourceEl.attributes(  );String  sourceTag  =  sourceEl.tagName(  );  [CONTEXT]        [CLASS]  Cleaner  ElementMeta    [METHOD]  createSafeElement  [RETURN_TYPE]  Cleaner$ElementMeta      Element  sourceEl  [VARIABLES]  boolean    Attribute    sourceAttr    Element    dest    destChild    el    source    sourceEl    Attributes    destAttrs    enforcedAttrs    sourceAttrs    Whitelist    whitelist    String    sourceTag    int    numAttribsDiscarded    numDiscarded    
String  sourceTag  =  sourceEl.tagName  (  )  ;	[BUGGY]  List<Node>  sourceChildren  =  source.childNodes(  );String  sourceTag  =  sourceEl.tagName(  );  [CONTEXT]        [CLASS]  Cleaner  ElementMeta    [METHOD]  createSafeElement  [RETURN_TYPE]  Cleaner$ElementMeta      Element  sourceEl  [VARIABLES]  boolean    Attribute    sourceAttr    Element    dest    destChild    el    source    sourceEl    Attributes    destAttrs    enforcedAttrs    sourceAttrs    Whitelist    whitelist    String    sourceTag    int    numAttribsDiscarded    numDiscarded    
String  sourceTag  =  sourceEl.tagName  (  )  ;	[BUGGY]  if  (  whitelist.isSafeTag(  sourceEl.tagName(  )))  {  String  sourceTag  =  sourceEl.tagName(  );  }  [CONTEXT]        [CLASS]  Cleaner  ElementMeta    [METHOD]  createSafeElement  [RETURN_TYPE]  Cleaner$ElementMeta      Element  sourceEl  [VARIABLES]  boolean    Attribute    sourceAttr    Element    dest    destChild    el    source    sourceEl    Attributes    destAttrs    enforcedAttrs    sourceAttrs    Whitelist    whitelist    String    sourceTag    int    numAttribsDiscarded    numDiscarded    
String  sourceTag  =  sourceEl.tagName  (  )  ;	[BUGGY]  String  sourceTag  =  el.tagName(  );  [CONTEXT]  private  ElementMeta  createSafeElement(Element  sourceEl)  {  [BUGGY]  String  sourceTag  =  el.tagName  ()  ;  Attributes  destAttrs  =  new  Attributes();  Element  dest  =  new  Element(Tag.valueOf(sourceTag),  sourceEl.baseUri(),  destAttrs);  int  numDiscarded  =  0;    Attributes  sourceAttrs  =  sourceEl.attributes();  for  (Attribute  sourceAttr  :  sourceAttrs)  {  if  (whitelist.isSafeAttribute(sourceTag,  sourceEl,  sourceAttr))  destAttrs.put(sourceAttr);  else  numDiscarded++;  }  Attributes  enforcedAttrs  =  whitelist.getEnforcedAttributes(sourceTag);  destAttrs.addAll(enforcedAttrs);    return  new  ElementMeta(dest,  numDiscarded);  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  createSafeElement  [RETURN_TYPE]  Cleaner$ElementMeta      Element  sourceEl  [VARIABLES]  boolean    Attribute    sourceAttr    Element    dest    destChild    el    source    sourceEl    Attributes    destAttrs    enforcedAttrs    sourceAttrs    Whitelist    whitelist    String    sourceTag    int    numAttribsDiscarded    numDiscarded    
String  sourceTag  =  sourceEl.tagName  (  )  ;	[BUGGY]    [CONTEXT]  private  ElementMeta  createSafeElement(Element  sourceEl)  {  [BUGGY]  String  sourceTag  =  sourceEl.tagName();    Attributes  destAttrs  =  new  Attributes();  Element  dest  =  new  Element(Tag.valueOf(sourceTag),  sourceEl.baseUri(),  destAttrs);  int  numDiscarded  =  0;    Attributes  sourceAttrs  =  sourceEl.attributes();  for  (Attribute  sourceAttr  :  sourceAttrs)  {  if  (whitelist.isSafeAttribute(sourceTag,  sourceEl,  sourceAttr))  destAttrs.put(sourceAttr);  else  numDiscarded++;  }  Attributes  enforcedAttrs  =  whitelist.getEnforcedAttributes(sourceTag);  destAttrs.addAll(enforcedAttrs);    return  new  ElementMeta(dest,  numDiscarded);        [CLASS]  Cleaner  ElementMeta    [METHOD]  createSafeElement  [RETURN_TYPE]  Cleaner$ElementMeta      Element  sourceEl  [VARIABLES]  boolean    Attribute    sourceAttr    Element    dest    destChild    el    source    sourceEl    Attributes    destAttrs    enforcedAttrs    sourceAttrs    Whitelist    whitelist    String    sourceTag    int    numAttribsDiscarded    numDiscarded    
String  sourceTag  =  sourceEl.tagName  (  )  ;	[BUGGY]  Attributes  destAttrs  =  new  Attributes(  );  String  sourceTag  =  sourceEl.tagName(  );  [CONTEXT]        [CLASS]  Cleaner  ElementMeta    [METHOD]  createSafeElement  [RETURN_TYPE]  Cleaner$ElementMeta      Element  sourceEl  [VARIABLES]  boolean    Attribute    sourceAttr    Element    dest    destChild    el    source    sourceEl    Attributes    destAttrs    enforcedAttrs    sourceAttrs    Whitelist    whitelist    String    sourceTag    int    numAttribsDiscarded    numDiscarded    
Attributes  destAttrs  =  new  Attributes  (  )  ;	[BUGGY]  Attributes  sourceAttrs  =  sourceEl.attributes(  );Attributes  destAttrs  =  new  Attributes(  );  [CONTEXT]        [CLASS]  Cleaner  ElementMeta    [METHOD]  createSafeElement  [RETURN_TYPE]  Cleaner$ElementMeta      Element  sourceEl  [VARIABLES]  boolean    Attribute    sourceAttr    Element    dest    destChild    el    source    sourceEl    Attributes    destAttrs    enforcedAttrs    sourceAttrs    Whitelist    whitelist    String    sourceTag    int    numAttribsDiscarded    numDiscarded    
Element  dest  =  new  Element  (  Tag.valueOf  (  sourceTag  )  ,  sourceEl.baseUri  (  )  ,  destAttrs  )  ;	[BUGGY]  Element  dest  =  new  Element(  Tag.valueOf(  sourceTag).baseUri(  ),  destAttrs);  [CONTEXT]  private  ElementMeta  createSafeElement(Element  sourceEl)  {  String  sourceTag  =  sourceEl.tagName();  Attributes  destAttrs  =  new  Attributes();  [BUGGY]  Element  dest  =  new  Element  (  Tag.valueOf  (  sourceTag  )  .baseUri  ()  ,  destAttrs  )  ;  int  numDiscarded  =  0;    Attributes  sourceAttrs  =  sourceEl.attributes();  for  (Attribute  sourceAttr  :  sourceAttrs)  {  if  (whitelist.isSafeAttribute(sourceTag,  sourceEl,  sourceAttr))  destAttrs.put(sourceAttr);  else  numDiscarded++;  }  Attributes  enforcedAttrs  =  whitelist.getEnforcedAttributes(sourceTag);  destAttrs.addAll(enforcedAttrs);    return  new  ElementMeta(dest,  numDiscarded);  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  createSafeElement  [RETURN_TYPE]  Cleaner$ElementMeta      Element  sourceEl  [VARIABLES]  boolean    Attribute    sourceAttr    Element    dest    destChild    el    source    sourceEl    Attributes    destAttrs    enforcedAttrs    sourceAttrs    Whitelist    whitelist    String    sourceTag    int    numAttribsDiscarded    numDiscarded    
Element  dest  =  new  Element  (  Tag.valueOf  (  sourceTag  )  ,  sourceEl.baseUri  (  )  ,  destAttrs  )  ;	[BUGGY]  Element  dest  =  new  Element(  Tag.valueOf(  sourceTag),  sourceEl.baseUri(  ));  [CONTEXT]  private  ElementMeta  createSafeElement(Element  sourceEl)  {  String  sourceTag  =  sourceEl.tagName();  Attributes  destAttrs  =  new  Attributes();  [BUGGY]  Element  dest  =  new  Element  (  Tag.valueOf  (  sourceTag  )  ,  sourceEl.baseUri  ())  ;  int  numDiscarded  =  0;    Attributes  sourceAttrs  =  sourceEl.attributes();  for  (Attribute  sourceAttr  :  sourceAttrs)  {  if  (whitelist.isSafeAttribute(sourceTag,  sourceEl,  sourceAttr))  destAttrs.put(sourceAttr);  else  numDiscarded++;  }  Attributes  enforcedAttrs  =  whitelist.getEnforcedAttributes(sourceTag);  destAttrs.addAll(enforcedAttrs);    return  new  ElementMeta(dest,  numDiscarded);  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  createSafeElement  [RETURN_TYPE]  Cleaner$ElementMeta      Element  sourceEl  [VARIABLES]  boolean    Attribute    sourceAttr    Element    dest    destChild    el    source    sourceEl    Attributes    destAttrs    enforcedAttrs    sourceAttrs    Whitelist    whitelist    String    sourceTag    int    numAttribsDiscarded    numDiscarded    
Element  dest  =  new  Element  (  Tag.valueOf  (  sourceTag  )  ,  sourceEl.baseUri  (  )  ,  destAttrs  )  ;	[BUGGY]  Element  dest  =  new  Element(  Tag.valueOf(  sourceTag),  el.baseUri(  ),  destAttrs);  [CONTEXT]  private  ElementMeta  createSafeElement(Element  sourceEl)  {  String  sourceTag  =  sourceEl.tagName();  Attributes  destAttrs  =  new  Attributes();  [BUGGY]  Element  dest  =  new  Element  (  Tag.valueOf  (  sourceTag  )  ,  el.baseUri  ()  ,  destAttrs  )  ;  int  numDiscarded  =  0;    Attributes  sourceAttrs  =  sourceEl.attributes();  for  (Attribute  sourceAttr  :  sourceAttrs)  {  if  (whitelist.isSafeAttribute(sourceTag,  sourceEl,  sourceAttr))  destAttrs.put(sourceAttr);  else  numDiscarded++;  }  Attributes  enforcedAttrs  =  whitelist.getEnforcedAttributes(sourceTag);  destAttrs.addAll(enforcedAttrs);    return  new  ElementMeta(dest,  numDiscarded);  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  createSafeElement  [RETURN_TYPE]  Cleaner$ElementMeta      Element  sourceEl  [VARIABLES]  boolean    Attribute    sourceAttr    Element    dest    destChild    el    source    sourceEl    Attributes    destAttrs    enforcedAttrs    sourceAttrs    Whitelist    whitelist    String    sourceTag    int    numAttribsDiscarded    numDiscarded    
Element  dest  =  new  Element  (  Tag.valueOf  (  sourceTag  )  ,  sourceEl.baseUri  (  )  ,  destAttrs  )  ;	[BUGGY]  Element  dest  =  new  Element(  Tag.valueOf(  sourceTag),  sourceEl.baseUri(  ),  sourceAttrs);  [CONTEXT]  private  ElementMeta  createSafeElement(Element  sourceEl)  {  String  sourceTag  =  sourceEl.tagName();  Attributes  destAttrs  =  new  Attributes();  [BUGGY]  Element  dest  =  new  Element  (  Tag.valueOf  (  sourceTag  )  ,  sourceEl.baseUri  ()  ,  sourceAttrs  )  ;  int  numDiscarded  =  0;    Attributes  sourceAttrs  =  sourceEl.attributes();  for  (Attribute  sourceAttr  :  sourceAttrs)  {  if  (whitelist.isSafeAttribute(sourceTag,  sourceEl,  sourceAttr))  destAttrs.put(sourceAttr);  else  numDiscarded++;  }  Attributes  enforcedAttrs  =  whitelist.getEnforcedAttributes(sourceTag);  destAttrs.addAll(enforcedAttrs);    return  new  ElementMeta(dest,  numDiscarded);  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  createSafeElement  [RETURN_TYPE]  Cleaner$ElementMeta      Element  sourceEl  [VARIABLES]  boolean    Attribute    sourceAttr    Element    dest    destChild    el    source    sourceEl    Attributes    destAttrs    enforcedAttrs    sourceAttrs    Whitelist    whitelist    String    sourceTag    int    numAttribsDiscarded    numDiscarded    
Element  dest  =  new  Element  (  Tag.valueOf  (  sourceTag  )  ,  sourceEl.baseUri  (  )  ,  destAttrs  )  ;	[BUGGY]  Element  dest  =  new  Element(  Tag.valueOf(  destAttrs),  sourceEl.baseUri(  ),  sourceTag);  [CONTEXT]  private  ElementMeta  createSafeElement(Element  sourceEl)  {  String  sourceTag  =  sourceEl.tagName();  Attributes  destAttrs  =  new  Attributes();  [BUGGY]  Element  dest  =  new  Element  (  Tag.valueOf  (  destAttrs  )  ,  sourceEl.baseUri  ()  ,  sourceTag  )  ;  int  numDiscarded  =  0;    Attributes  sourceAttrs  =  sourceEl.attributes();  for  (Attribute  sourceAttr  :  sourceAttrs)  {  if  (whitelist.isSafeAttribute(sourceTag,  sourceEl,  sourceAttr))  destAttrs.put(sourceAttr);  else  numDiscarded++;  }  Attributes  enforcedAttrs  =  whitelist.getEnforcedAttributes(sourceTag);  destAttrs.addAll(enforcedAttrs);    return  new  ElementMeta(dest,  numDiscarded);  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  createSafeElement  [RETURN_TYPE]  Cleaner$ElementMeta      Element  sourceEl  [VARIABLES]  boolean    Attribute    sourceAttr    Element    dest    destChild    el    source    sourceEl    Attributes    destAttrs    enforcedAttrs    sourceAttrs    Whitelist    whitelist    String    sourceTag    int    numAttribsDiscarded    numDiscarded    
Element  dest  =  new  Element  (  Tag.valueOf  (  sourceTag  )  ,  sourceEl.baseUri  (  )  ,  destAttrs  )  ;	[BUGGY]  Element  dest  =  new  Element(  Tag.valueOf(  sourceEl),  sourceTag.baseUri(  ),  destAttrs);  [CONTEXT]  private  ElementMeta  createSafeElement(Element  sourceEl)  {  String  sourceTag  =  sourceEl.tagName();  Attributes  destAttrs  =  new  Attributes();  [BUGGY]  Element  dest  =  new  Element  (  Tag.valueOf  (  sourceEl  )  ,  sourceTag.baseUri  ()  ,  destAttrs  )  ;  int  numDiscarded  =  0;    Attributes  sourceAttrs  =  sourceEl.attributes();  for  (Attribute  sourceAttr  :  sourceAttrs)  {  if  (whitelist.isSafeAttribute(sourceTag,  sourceEl,  sourceAttr))  destAttrs.put(sourceAttr);  else  numDiscarded++;  }  Attributes  enforcedAttrs  =  whitelist.getEnforcedAttributes(sourceTag);  destAttrs.addAll(enforcedAttrs);    return  new  ElementMeta(dest,  numDiscarded);  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  createSafeElement  [RETURN_TYPE]  Cleaner$ElementMeta      Element  sourceEl  [VARIABLES]  boolean    Attribute    sourceAttr    Element    dest    destChild    el    source    sourceEl    Attributes    destAttrs    enforcedAttrs    sourceAttrs    Whitelist    whitelist    String    sourceTag    int    numAttribsDiscarded    numDiscarded    
Element  dest  =  new  Element  (  Tag.valueOf  (  sourceTag  )  ,  sourceEl.baseUri  (  )  ,  destAttrs  )  ;	[BUGGY]  Element  dest  =  new  Element(  Tag.valueOf(  sourceTag),  destAttrs.baseUri(  ),  sourceEl);  [CONTEXT]  private  ElementMeta  createSafeElement(Element  sourceEl)  {  String  sourceTag  =  sourceEl.tagName();  Attributes  destAttrs  =  new  Attributes();  [BUGGY]  Element  dest  =  new  Element  (  Tag.valueOf  (  sourceTag  )  ,  destAttrs.baseUri  ()  ,  sourceEl  )  ;  int  numDiscarded  =  0;    Attributes  sourceAttrs  =  sourceEl.attributes();  for  (Attribute  sourceAttr  :  sourceAttrs)  {  if  (whitelist.isSafeAttribute(sourceTag,  sourceEl,  sourceAttr))  destAttrs.put(sourceAttr);  else  numDiscarded++;  }  Attributes  enforcedAttrs  =  whitelist.getEnforcedAttributes(sourceTag);  destAttrs.addAll(enforcedAttrs);    return  new  ElementMeta(dest,  numDiscarded);  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  createSafeElement  [RETURN_TYPE]  Cleaner$ElementMeta      Element  sourceEl  [VARIABLES]  boolean    Attribute    sourceAttr    Element    dest    destChild    el    source    sourceEl    Attributes    destAttrs    enforcedAttrs    sourceAttrs    Whitelist    whitelist    String    sourceTag    int    numAttribsDiscarded    numDiscarded    
Element  dest  =  new  Element  (  Tag.valueOf  (  sourceTag  )  ,  sourceEl.baseUri  (  )  ,  destAttrs  )  ;	[BUGGY]  Element  dest  =  new  Element(  Tag.valueOf(  sourceTag),  sourceEl.appendChild(  ),  destAttrs);  [CONTEXT]  private  ElementMeta  createSafeElement(Element  sourceEl)  {  String  sourceTag  =  sourceEl.tagName();  Attributes  destAttrs  =  new  Attributes();  [BUGGY]  Element  dest  =  new  Element  (  Tag.valueOf  (  sourceTag  )  ,  sourceEl.appendChild  ()  ,  destAttrs  )  ;  int  numDiscarded  =  0;    Attributes  sourceAttrs  =  sourceEl.attributes();  for  (Attribute  sourceAttr  :  sourceAttrs)  {  if  (whitelist.isSafeAttribute(sourceTag,  sourceEl,  sourceAttr))  destAttrs.put(sourceAttr);  else  numDiscarded++;  }  Attributes  enforcedAttrs  =  whitelist.getEnforcedAttributes(sourceTag);  destAttrs.addAll(enforcedAttrs);    return  new  ElementMeta(dest,  numDiscarded);  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  createSafeElement  [RETURN_TYPE]  Cleaner$ElementMeta      Element  sourceEl  [VARIABLES]  boolean    Attribute    sourceAttr    Element    dest    destChild    el    source    sourceEl    Attributes    destAttrs    enforcedAttrs    sourceAttrs    Whitelist    whitelist    String    sourceTag    int    numAttribsDiscarded    numDiscarded    
Element  dest  =  new  Element  (  Tag.valueOf  (  sourceTag  )  ,  sourceEl.baseUri  (  )  ,  destAttrs  )  ;	[BUGGY]  Element  dest  =  new  Element(  Tag.valueOf(  sourceTag),  sourceEl  .createShell(  )  ,  destAttrs);  [CONTEXT]  private  ElementMeta  createSafeElement(Element  sourceEl)  {  String  sourceTag  =  sourceEl.tagName();  Attributes  destAttrs  =  new  Attributes();  [BUGGY]  Element  dest  =  new  Element  (  Tag.valueOf  (  sourceTag  )  ,  sourceEl  .createShell  (),  destAttrs  )  ;  int  numDiscarded  =  0;    Attributes  sourceAttrs  =  sourceEl.attributes();  for  (Attribute  sourceAttr  :  sourceAttrs)  {  if  (whitelist.isSafeAttribute(sourceTag,  sourceEl,  sourceAttr))  destAttrs.put(sourceAttr);  else  numDiscarded++;  }  Attributes  enforcedAttrs  =  whitelist.getEnforcedAttributes(sourceTag);  destAttrs.addAll(enforcedAttrs);    return  new  ElementMeta(dest,  numDiscarded);  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  createSafeElement  [RETURN_TYPE]  Cleaner$ElementMeta      Element  sourceEl  [VARIABLES]  boolean    Attribute    sourceAttr    Element    dest    destChild    el    source    sourceEl    Attributes    destAttrs    enforcedAttrs    sourceAttrs    Whitelist    whitelist    String    sourceTag    int    numAttribsDiscarded    numDiscarded    
Element  dest  =  new  Element  (  Tag.valueOf  (  sourceTag  )  ,  sourceEl.baseUri  (  )  ,  destAttrs  )  ;	[BUGGY]  Element  dest  =  new  Element(  Tag.valueOf(  sourceTag),  sourceEl.appendChild(  ),  sourceAttrs);  [CONTEXT]  private  ElementMeta  createSafeElement(Element  sourceEl)  {  String  sourceTag  =  sourceEl.tagName();  Attributes  destAttrs  =  new  Attributes();  [BUGGY]  Element  dest  =  new  Element  (  Tag.valueOf  (  sourceTag  )  ,  sourceEl.appendChild  ()  ,  sourceAttrs  )  ;  int  numDiscarded  =  0;    Attributes  sourceAttrs  =  sourceEl.attributes();  for  (Attribute  sourceAttr  :  sourceAttrs)  {  if  (whitelist.isSafeAttribute(sourceTag,  sourceEl,  sourceAttr))  destAttrs.put(sourceAttr);  else  numDiscarded++;  }  Attributes  enforcedAttrs  =  whitelist.getEnforcedAttributes(sourceTag);  destAttrs.addAll(enforcedAttrs);    return  new  ElementMeta(dest,  numDiscarded);  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  createSafeElement  [RETURN_TYPE]  Cleaner$ElementMeta      Element  sourceEl  [VARIABLES]  boolean    Attribute    sourceAttr    Element    dest    destChild    el    source    sourceEl    Attributes    destAttrs    enforcedAttrs    sourceAttrs    Whitelist    whitelist    String    sourceTag    int    numAttribsDiscarded    numDiscarded    
Element  dest  =  new  Element  (  Tag.valueOf  (  sourceTag  )  ,  sourceEl.baseUri  (  )  ,  destAttrs  )  ;	[BUGGY]  Element  dest  =  new  Element(  Tag.valueOf(  sourceTag),  source.baseUri(  ),  destAttrs);  [CONTEXT]  private  ElementMeta  createSafeElement(Element  sourceEl)  {  String  sourceTag  =  sourceEl.tagName();  Attributes  destAttrs  =  new  Attributes();  [BUGGY]  Element  dest  =  new  Element  (  Tag.valueOf  (  sourceTag  )  ,  source.baseUri  ()  ,  destAttrs  )  ;  int  numDiscarded  =  0;    Attributes  sourceAttrs  =  sourceEl.attributes();  for  (Attribute  sourceAttr  :  sourceAttrs)  {  if  (whitelist.isSafeAttribute(sourceTag,  sourceEl,  sourceAttr))  destAttrs.put(sourceAttr);  else  numDiscarded++;  }  Attributes  enforcedAttrs  =  whitelist.getEnforcedAttributes(sourceTag);  destAttrs.addAll(enforcedAttrs);    return  new  ElementMeta(dest,  numDiscarded);  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  createSafeElement  [RETURN_TYPE]  Cleaner$ElementMeta      Element  sourceEl  [VARIABLES]  boolean    Attribute    sourceAttr    Element    dest    destChild    el    source    sourceEl    Attributes    destAttrs    enforcedAttrs    sourceAttrs    Whitelist    whitelist    String    sourceTag    int    numAttribsDiscarded    numDiscarded    
Element  dest  =  new  Element  (  Tag.valueOf  (  sourceTag  )  ,  sourceEl.baseUri  (  )  ,  destAttrs  )  ;	[BUGGY]    [CONTEXT]  private  ElementMeta  createSafeElement(Element  sourceEl)  {  String  sourceTag  =  sourceEl.tagName();  Attributes  destAttrs  =  new  Attributes();  [BUGGY]  Element  dest  =  new  Element(Tag.valueOf(sourceTag),  sourceEl.baseUri(),  destAttrs);    int  numDiscarded  =  0;    Attributes  sourceAttrs  =  sourceEl.attributes();  for  (Attribute  sourceAttr  :  sourceAttrs)  {  if  (whitelist.isSafeAttribute(sourceTag,  sourceEl,  sourceAttr))  destAttrs.put(sourceAttr);  else  numDiscarded++;  }  Attributes  enforcedAttrs  =  whitelist.getEnforcedAttributes(sourceTag);  destAttrs.addAll(enforcedAttrs);    return  new  ElementMeta(dest,  numDiscarded);        [CLASS]  Cleaner  ElementMeta    [METHOD]  createSafeElement  [RETURN_TYPE]  Cleaner$ElementMeta      Element  sourceEl  [VARIABLES]  boolean    Attribute    sourceAttr    Element    dest    destChild    el    source    sourceEl    Attributes    destAttrs    enforcedAttrs    sourceAttrs    Whitelist    whitelist    String    sourceTag    int    numAttribsDiscarded    numDiscarded    
Element  dest  =  new  Element  (  Tag.valueOf  (  sourceTag  )  ,  sourceEl.baseUri  (  )  ,  destAttrs  )  ;  int  numDiscarded  =  0;	[BUGGY]  int  numDiscarded  =  0;  Element  dest  =  new  Element(  Tag.valueOf(  sourceTag),  sourceEl.baseUri(  ),  destAttrs);  [CONTEXT]        [CLASS]  Cleaner  ElementMeta    [METHOD]  createSafeElement  [RETURN_TYPE]  Cleaner$ElementMeta      Element  sourceEl  [VARIABLES]  boolean    Attribute    sourceAttr    Element    dest    destChild    el    source    sourceEl    Attributes    destAttrs    enforcedAttrs    sourceAttrs    Whitelist    whitelist    String    sourceTag    int    numAttribsDiscarded    numDiscarded    
Element  dest  =  new  Element  (  Tag.valueOf  (  sourceTag  )  ,  sourceEl.baseUri  (  )  ,  destAttrs  )  ;  int  numDiscarded  =  0;	[BUGGY]  Element  dest  =  new  Element(  Tag.valueOf(  sourceTag),  sourceEl.baseUri(  ),  destAttrs);Element  dest  =  new  Element(  Tag.valueOf(  sourceTag),  sourceEl.baseUri(  ),  destAttrs);  int  numDiscarded  =  0;  [CONTEXT]        [CLASS]  Cleaner  ElementMeta    [METHOD]  createSafeElement  [RETURN_TYPE]  Cleaner$ElementMeta      Element  sourceEl  [VARIABLES]  boolean    Attribute    sourceAttr    Element    dest    destChild    el    source    sourceEl    Attributes    destAttrs    enforcedAttrs    sourceAttrs    Whitelist    whitelist    String    sourceTag    int    numAttribsDiscarded    numDiscarded    
Element  dest  =  new  Element  (  Tag.valueOf  (  sourceTag  )  ,  sourceEl.baseUri  (  )  ,  destAttrs  )  ;	[BUGGY]  Element  dest  =  new  Element(  Tag.valueOf(  sourceTag),  el.appendChild(  ),  destAttrs);  [CONTEXT]  private  ElementMeta  createSafeElement(Element  sourceEl)  {  String  sourceTag  =  sourceEl.tagName();  Attributes  destAttrs  =  new  Attributes();  [BUGGY]  Element  dest  =  new  Element  (  Tag.valueOf  (  sourceTag  )  ,  el.appendChild  ()  ,  destAttrs  )  ;  int  numDiscarded  =  0;    Attributes  sourceAttrs  =  sourceEl.attributes();  for  (Attribute  sourceAttr  :  sourceAttrs)  {  if  (whitelist.isSafeAttribute(sourceTag,  sourceEl,  sourceAttr))  destAttrs.put(sourceAttr);  else  numDiscarded++;  }  Attributes  enforcedAttrs  =  whitelist.getEnforcedAttributes(sourceTag);  destAttrs.addAll(enforcedAttrs);    return  new  ElementMeta(dest,  numDiscarded);  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  createSafeElement  [RETURN_TYPE]  Cleaner$ElementMeta      Element  sourceEl  [VARIABLES]  boolean    Attribute    sourceAttr    Element    dest    destChild    el    source    sourceEl    Attributes    destAttrs    enforcedAttrs    sourceAttrs    Whitelist    whitelist    String    sourceTag    int    numAttribsDiscarded    numDiscarded    
Element  dest  =  new  Element  (  Tag.valueOf  (  sourceTag  )  ,  sourceEl.baseUri  (  )  ,  destAttrs  )  ;  int  numDiscarded  =  0;	[BUGGY]    [CONTEXT]  private  ElementMeta  createSafeElement(Element  sourceEl)  {  String  sourceTag  =  sourceEl.tagName();  Attributes  destAttrs  =  new  Attributes();  [BUGGY]  Element  dest  =  new  Element(Tag.valueOf(sourceTag),  sourceEl.baseUri(),  destAttrs);        Attributes  sourceAttrs  =  sourceEl.attributes();  for  (Attribute  sourceAttr  :  sourceAttrs)  {  if  (whitelist.isSafeAttribute(sourceTag,  sourceEl,  sourceAttr))  destAttrs.put(sourceAttr);  else  numDiscarded++;  }  Attributes  enforcedAttrs  =  whitelist.getEnforcedAttributes(sourceTag);  destAttrs.addAll(enforcedAttrs);    return  new  ElementMeta(dest,  numDiscarded);        [CLASS]  Cleaner  ElementMeta    [METHOD]  createSafeElement  [RETURN_TYPE]  Cleaner$ElementMeta      Element  sourceEl  [VARIABLES]  boolean    Attribute    sourceAttr    Element    dest    destChild    el    source    sourceEl    Attributes    destAttrs    enforcedAttrs    sourceAttrs    Whitelist    whitelist    String    sourceTag    int    numAttribsDiscarded    numDiscarded    
int  numDiscarded  =  0;	[BUGGY]  long    numDiscarded  =  0;  [CONTEXT]  private  ElementMeta  createSafeElement(Element  sourceEl)  {  String  sourceTag  =  sourceEl.tagName();  Attributes  destAttrs  =  new  Attributes();  Element  dest  =  new  Element(Tag.valueOf(sourceTag),  sourceEl.baseUri(),  destAttrs);  [BUGGY]  longnumDiscarded  =  0;    Attributes  sourceAttrs  =  sourceEl.attributes();  for  (Attribute  sourceAttr  :  sourceAttrs)  {  if  (whitelist.isSafeAttribute(sourceTag,  sourceEl,  sourceAttr))  destAttrs.put(sourceAttr);  else  numDiscarded++;  }  Attributes  enforcedAttrs  =  whitelist.getEnforcedAttributes(sourceTag);  destAttrs.addAll(enforcedAttrs);    return  new  ElementMeta(dest,  numDiscarded);  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  createSafeElement  [RETURN_TYPE]  Cleaner$ElementMeta      Element  sourceEl  [VARIABLES]  boolean    Attribute    sourceAttr    Element    dest    destChild    el    source    sourceEl    Attributes    destAttrs    enforcedAttrs    sourceAttrs    Whitelist    whitelist    String    sourceTag    int    numAttribsDiscarded    numDiscarded    
Attributes  sourceAttrs  =  sourceEl.attributes  (  )  ;	[BUGGY]  Attributes  sourceAttrs  =  source.attributes(  );  [CONTEXT]  private  ElementMeta  createSafeElement(Element  sourceEl)  {  String  sourceTag  =  sourceEl.tagName();  Attributes  destAttrs  =  new  Attributes();  Element  dest  =  new  Element(Tag.valueOf(sourceTag),  sourceEl.baseUri(),  destAttrs);  int  numDiscarded  =  0;    [BUGGY]  Attributes  sourceAttrs  =  source.attributes  ()  ;  for  (Attribute  sourceAttr  :  sourceAttrs)  {  if  (whitelist.isSafeAttribute(sourceTag,  sourceEl,  sourceAttr))  destAttrs.put(sourceAttr);  else  numDiscarded++;  }  Attributes  enforcedAttrs  =  whitelist.getEnforcedAttributes(sourceTag);  destAttrs.addAll(enforcedAttrs);    return  new  ElementMeta(dest,  numDiscarded);  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  createSafeElement  [RETURN_TYPE]  Cleaner$ElementMeta      Element  sourceEl  [VARIABLES]  boolean    Attribute    sourceAttr    Element    dest    destChild    el    source    sourceEl    Attributes    destAttrs    enforcedAttrs    sourceAttrs    Whitelist    whitelist    String    sourceTag    int    numAttribsDiscarded    numDiscarded    
Attributes  sourceAttrs  =  sourceEl.attributes  (  )  ;	[BUGGY]  Attributes  sourceAttrs  =  sourceEl.appendChild(  );  [CONTEXT]  private  ElementMeta  createSafeElement(Element  sourceEl)  {  String  sourceTag  =  sourceEl.tagName();  Attributes  destAttrs  =  new  Attributes();  Element  dest  =  new  Element(Tag.valueOf(sourceTag),  sourceEl.baseUri(),  destAttrs);  int  numDiscarded  =  0;    [BUGGY]  Attributes  sourceAttrs  =  sourceEl.appendChild  ()  ;  for  (Attribute  sourceAttr  :  sourceAttrs)  {  if  (whitelist.isSafeAttribute(sourceTag,  sourceEl,  sourceAttr))  destAttrs.put(sourceAttr);  else  numDiscarded++;  }  Attributes  enforcedAttrs  =  whitelist.getEnforcedAttributes(sourceTag);  destAttrs.addAll(enforcedAttrs);    return  new  ElementMeta(dest,  numDiscarded);  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  createSafeElement  [RETURN_TYPE]  Cleaner$ElementMeta      Element  sourceEl  [VARIABLES]  boolean    Attribute    sourceAttr    Element    dest    destChild    el    source    sourceEl    Attributes    destAttrs    enforcedAttrs    sourceAttrs    Whitelist    whitelist    String    sourceTag    int    numAttribsDiscarded    numDiscarded    
Attributes  sourceAttrs  =  sourceEl.attributes  (  )  ;	[BUGGY]  Attributes  sourceAttrs  =  source.appendChild(  );  [CONTEXT]  private  ElementMeta  createSafeElement(Element  sourceEl)  {  String  sourceTag  =  sourceEl.tagName();  Attributes  destAttrs  =  new  Attributes();  Element  dest  =  new  Element(Tag.valueOf(sourceTag),  sourceEl.baseUri(),  destAttrs);  int  numDiscarded  =  0;    [BUGGY]  Attributes  sourceAttrs  =  source.appendChild  ()  ;  for  (Attribute  sourceAttr  :  sourceAttrs)  {  if  (whitelist.isSafeAttribute(sourceTag,  sourceEl,  sourceAttr))  destAttrs.put(sourceAttr);  else  numDiscarded++;  }  Attributes  enforcedAttrs  =  whitelist.getEnforcedAttributes(sourceTag);  destAttrs.addAll(enforcedAttrs);    return  new  ElementMeta(dest,  numDiscarded);  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  createSafeElement  [RETURN_TYPE]  Cleaner$ElementMeta      Element  sourceEl  [VARIABLES]  boolean    Attribute    sourceAttr    Element    dest    destChild    el    source    sourceEl    Attributes    destAttrs    enforcedAttrs    sourceAttrs    Whitelist    whitelist    String    sourceTag    int    numAttribsDiscarded    numDiscarded    
Attributes  sourceAttrs  =  sourceEl.attributes  (  )  ;	[BUGGY]  Attributes  sourceAttrs  =  el.attributes(  );  [CONTEXT]  private  ElementMeta  createSafeElement(Element  sourceEl)  {  String  sourceTag  =  sourceEl.tagName();  Attributes  destAttrs  =  new  Attributes();  Element  dest  =  new  Element(Tag.valueOf(sourceTag),  sourceEl.baseUri(),  destAttrs);  int  numDiscarded  =  0;    [BUGGY]  Attributes  sourceAttrs  =  el.attributes  ()  ;  for  (Attribute  sourceAttr  :  sourceAttrs)  {  if  (whitelist.isSafeAttribute(sourceTag,  sourceEl,  sourceAttr))  destAttrs.put(sourceAttr);  else  numDiscarded++;  }  Attributes  enforcedAttrs  =  whitelist.getEnforcedAttributes(sourceTag);  destAttrs.addAll(enforcedAttrs);    return  new  ElementMeta(dest,  numDiscarded);  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  createSafeElement  [RETURN_TYPE]  Cleaner$ElementMeta      Element  sourceEl  [VARIABLES]  boolean    Attribute    sourceAttr    Element    dest    destChild    el    source    sourceEl    Attributes    destAttrs    enforcedAttrs    sourceAttrs    Whitelist    whitelist    String    sourceTag    int    numAttribsDiscarded    numDiscarded    
Attributes  sourceAttrs  =  sourceEl.attributes  (  )  ;	[BUGGY]    [CONTEXT]  private  ElementMeta  createSafeElement(Element  sourceEl)  {  String  sourceTag  =  sourceEl.tagName();  Attributes  destAttrs  =  new  Attributes();  Element  dest  =  new  Element(Tag.valueOf(sourceTag),  sourceEl.baseUri(),  destAttrs);  int  numDiscarded  =  0;    [BUGGY]  Attributes  sourceAttrs  =  sourceEl.attributes();    for  (Attribute  sourceAttr  :  sourceAttrs)  {  if  (whitelist.isSafeAttribute(sourceTag,  sourceEl,  sourceAttr))  destAttrs.put(sourceAttr);  else  numDiscarded++;  }  Attributes  enforcedAttrs  =  whitelist.getEnforcedAttributes(sourceTag);  destAttrs.addAll(enforcedAttrs);    return  new  ElementMeta(dest,  numDiscarded);        [CLASS]  Cleaner  ElementMeta    [METHOD]  createSafeElement  [RETURN_TYPE]  Cleaner$ElementMeta      Element  sourceEl  [VARIABLES]  boolean    Attribute    sourceAttr    Element    dest    destChild    el    source    sourceEl    Attributes    destAttrs    enforcedAttrs    sourceAttrs    Whitelist    whitelist    String    sourceTag    int    numAttribsDiscarded    numDiscarded    
if  (  whitelist.isSafeAttribute  (  sourceTag,  sourceEl,  sourceAttr  )  )  destAttrs.put  (  sourceAttr  )  ;	[BUGGY]  if  (  whitelist.isSafeAttribute(  sourceTag,  sourceEl,  sourceAttr))sourceAttrs.put(  sourceAttr);  [CONTEXT]  private  ElementMeta  createSafeElement(Element  sourceEl)  {  String  sourceTag  =  sourceEl.tagName();  Attributes  destAttrs  =  new  Attributes();  Element  dest  =  new  Element(Tag.valueOf(sourceTag),  sourceEl.baseUri(),  destAttrs);  int  numDiscarded  =  0;    Attributes  sourceAttrs  =  sourceEl.attributes();  for  (Attribute  sourceAttr  :  sourceAttrs)  {  [BUGGY]  if(  whitelist.isSafeAttribute  (  sourceTag,  sourceEl,  sourceAttr  ))  sourceAttrs.put  (  sourceAttr  )  ;    else  numDiscarded++;  }  Attributes  enforcedAttrs  =  whitelist.getEnforcedAttributes(sourceTag);  destAttrs.addAll(enforcedAttrs);    return  new  ElementMeta(dest,  numDiscarded);  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  createSafeElement  [RETURN_TYPE]  Cleaner$ElementMeta      Element  sourceEl  [VARIABLES]  boolean    Attribute    sourceAttr    Element    dest    destChild    el    source    sourceEl    Attributes    destAttrs    enforcedAttrs    sourceAttrs    Whitelist    whitelist    String    sourceTag    int    numAttribsDiscarded    numDiscarded    
if  (  whitelist.isSafeAttribute  (  sourceTag,  sourceEl,  sourceAttr  )  )  destAttrs.put  (  sourceAttr  )  ;	[BUGGY]  if  (  whitelist.isSafeAttribute(  destAttrs,  sourceEl,  sourceAttr))sourceTag.put(  sourceAttr);  [CONTEXT]  private  ElementMeta  createSafeElement(Element  sourceEl)  {  String  sourceTag  =  sourceEl.tagName();  Attributes  destAttrs  =  new  Attributes();  Element  dest  =  new  Element(Tag.valueOf(sourceTag),  sourceEl.baseUri(),  destAttrs);  int  numDiscarded  =  0;    Attributes  sourceAttrs  =  sourceEl.attributes();  for  (Attribute  sourceAttr  :  sourceAttrs)  {  [BUGGY]  if(  whitelist.isSafeAttribute  (  destAttrs,  sourceEl,  sourceAttr  ))  sourceTag.put  (  sourceAttr  )  ;    else  numDiscarded++;  }  Attributes  enforcedAttrs  =  whitelist.getEnforcedAttributes(sourceTag);  destAttrs.addAll(enforcedAttrs);    return  new  ElementMeta(dest,  numDiscarded);  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  createSafeElement  [RETURN_TYPE]  Cleaner$ElementMeta      Element  sourceEl  [VARIABLES]  boolean    Attribute    sourceAttr    Element    dest    destChild    el    source    sourceEl    Attributes    destAttrs    enforcedAttrs    sourceAttrs    Whitelist    whitelist    String    sourceTag    int    numAttribsDiscarded    numDiscarded    
if  (  whitelist.isSafeAttribute  (  sourceTag,  sourceEl,  sourceAttr  )  )  destAttrs.put  (  sourceAttr  )  ;	[BUGGY]  if  (  whitelist.isSafeAttribute(    sourceEl,  sourceAttr))destAttrs.put(  sourceAttr);  [CONTEXT]  private  ElementMeta  createSafeElement(Element  sourceEl)  {  String  sourceTag  =  sourceEl.tagName();  Attributes  destAttrs  =  new  Attributes();  Element  dest  =  new  Element(Tag.valueOf(sourceTag),  sourceEl.baseUri(),  destAttrs);  int  numDiscarded  =  0;    Attributes  sourceAttrs  =  sourceEl.attributes();  for  (Attribute  sourceAttr  :  sourceAttrs)  {  [BUGGY]  if(  whitelist.isSafeAttribute  (sourceEl,  sourceAttr  ))  destAttrs.put  (  sourceAttr  )  ;    else  numDiscarded++;  }  Attributes  enforcedAttrs  =  whitelist.getEnforcedAttributes(sourceTag);  destAttrs.addAll(enforcedAttrs);    return  new  ElementMeta(dest,  numDiscarded);  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  createSafeElement  [RETURN_TYPE]  Cleaner$ElementMeta      Element  sourceEl  [VARIABLES]  boolean    Attribute    sourceAttr    Element    dest    destChild    el    source    sourceEl    Attributes    destAttrs    enforcedAttrs    sourceAttrs    Whitelist    whitelist    String    sourceTag    int    numAttribsDiscarded    numDiscarded    
if  (  whitelist.isSafeAttribute  (  sourceTag,  sourceEl,  sourceAttr  )  )  destAttrs.put  (  sourceAttr  )  ;	[BUGGY]  if  (  whitelist.isSafeAttribute(  sourceTag,  destAttrs,  sourceAttr))sourceEl.put(  sourceAttr);  [CONTEXT]  private  ElementMeta  createSafeElement(Element  sourceEl)  {  String  sourceTag  =  sourceEl.tagName();  Attributes  destAttrs  =  new  Attributes();  Element  dest  =  new  Element(Tag.valueOf(sourceTag),  sourceEl.baseUri(),  destAttrs);  int  numDiscarded  =  0;    Attributes  sourceAttrs  =  sourceEl.attributes();  for  (Attribute  sourceAttr  :  sourceAttrs)  {  [BUGGY]  if(  whitelist.isSafeAttribute  (  sourceTag,  destAttrs,  sourceAttr  ))  sourceEl.put  (  sourceAttr  )  ;    else  numDiscarded++;  }  Attributes  enforcedAttrs  =  whitelist.getEnforcedAttributes(sourceTag);  destAttrs.addAll(enforcedAttrs);    return  new  ElementMeta(dest,  numDiscarded);  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  createSafeElement  [RETURN_TYPE]  Cleaner$ElementMeta      Element  sourceEl  [VARIABLES]  boolean    Attribute    sourceAttr    Element    dest    destChild    el    source    sourceEl    Attributes    destAttrs    enforcedAttrs    sourceAttrs    Whitelist    whitelist    String    sourceTag    int    numAttribsDiscarded    numDiscarded    
if  (  whitelist.isSafeAttribute  (  sourceTag,  sourceEl,  sourceAttr  )  )  destAttrs.put  (  sourceAttr  )  ;	[BUGGY]  if  (  whitelist.isSafeAttribute(  sourceTag,    sourceAttr))destAttrs.put(  sourceAttr);  [CONTEXT]  private  ElementMeta  createSafeElement(Element  sourceEl)  {  String  sourceTag  =  sourceEl.tagName();  Attributes  destAttrs  =  new  Attributes();  Element  dest  =  new  Element(Tag.valueOf(sourceTag),  sourceEl.baseUri(),  destAttrs);  int  numDiscarded  =  0;    Attributes  sourceAttrs  =  sourceEl.attributes();  for  (Attribute  sourceAttr  :  sourceAttrs)  {  [BUGGY]  if(  whitelist.isSafeAttribute  (  sourceTag,sourceAttr  ))  destAttrs.put  (  sourceAttr  )  ;    else  numDiscarded++;  }  Attributes  enforcedAttrs  =  whitelist.getEnforcedAttributes(sourceTag);  destAttrs.addAll(enforcedAttrs);    return  new  ElementMeta(dest,  numDiscarded);  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  createSafeElement  [RETURN_TYPE]  Cleaner$ElementMeta      Element  sourceEl  [VARIABLES]  boolean    Attribute    sourceAttr    Element    dest    destChild    el    source    sourceEl    Attributes    destAttrs    enforcedAttrs    sourceAttrs    Whitelist    whitelist    String    sourceTag    int    numAttribsDiscarded    numDiscarded    
if  (  whitelist.isSafeAttribute  (  sourceTag,  sourceEl,  sourceAttr  )  )  destAttrs.put  (  sourceAttr  )  ;	[BUGGY]  if  (  whitelist.isSafeAttribute(  sourceTag,  sourceEl,  destAttrs))sourceAttr.put(  sourceAttr);  [CONTEXT]  private  ElementMeta  createSafeElement(Element  sourceEl)  {  String  sourceTag  =  sourceEl.tagName();  Attributes  destAttrs  =  new  Attributes();  Element  dest  =  new  Element(Tag.valueOf(sourceTag),  sourceEl.baseUri(),  destAttrs);  int  numDiscarded  =  0;    Attributes  sourceAttrs  =  sourceEl.attributes();  for  (Attribute  sourceAttr  :  sourceAttrs)  {  [BUGGY]  if(  whitelist.isSafeAttribute  (  sourceTag,  sourceEl,  destAttrs  ))  sourceAttr.put  (  sourceAttr  )  ;    else  numDiscarded++;  }  Attributes  enforcedAttrs  =  whitelist.getEnforcedAttributes(sourceTag);  destAttrs.addAll(enforcedAttrs);    return  new  ElementMeta(dest,  numDiscarded);  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  createSafeElement  [RETURN_TYPE]  Cleaner$ElementMeta      Element  sourceEl  [VARIABLES]  boolean    Attribute    sourceAttr    Element    dest    destChild    el    source    sourceEl    Attributes    destAttrs    enforcedAttrs    sourceAttrs    Whitelist    whitelist    String    sourceTag    int    numAttribsDiscarded    numDiscarded    
if  (  whitelist.isSafeAttribute  (  sourceTag,  sourceEl,  sourceAttr  )  )  destAttrs.put  (  sourceAttr  )  ;	[BUGGY]  if  (  whitelist.isSafeAttribute(  sourceTag,  sourceEl))destAttrs.put(  sourceAttr);  [CONTEXT]  private  ElementMeta  createSafeElement(Element  sourceEl)  {  String  sourceTag  =  sourceEl.tagName();  Attributes  destAttrs  =  new  Attributes();  Element  dest  =  new  Element(Tag.valueOf(sourceTag),  sourceEl.baseUri(),  destAttrs);  int  numDiscarded  =  0;    Attributes  sourceAttrs  =  sourceEl.attributes();  for  (Attribute  sourceAttr  :  sourceAttrs)  {  [BUGGY]  if(  whitelist.isSafeAttribute  (  sourceTag,  sourceEl  ))  destAttrs.put  (  sourceAttr  )  ;    else  numDiscarded++;  }  Attributes  enforcedAttrs  =  whitelist.getEnforcedAttributes(sourceTag);  destAttrs.addAll(enforcedAttrs);    return  new  ElementMeta(dest,  numDiscarded);  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  createSafeElement  [RETURN_TYPE]  Cleaner$ElementMeta      Element  sourceEl  [VARIABLES]  boolean    Attribute    sourceAttr    Element    dest    destChild    el    source    sourceEl    Attributes    destAttrs    enforcedAttrs    sourceAttrs    Whitelist    whitelist    String    sourceTag    int    numAttribsDiscarded    numDiscarded    
if  (  whitelist.isSafeAttribute  (  sourceTag,  sourceEl,  sourceAttr  )  )  destAttrs.put  (  sourceAttr  )  ;	[BUGGY]  if  (  sourceEl.isSafeAttribute(  sourceTag,  whitelist,  sourceAttr))destAttrs.put(  sourceAttr);  [CONTEXT]  private  ElementMeta  createSafeElement(Element  sourceEl)  {  String  sourceTag  =  sourceEl.tagName();  Attributes  destAttrs  =  new  Attributes();  Element  dest  =  new  Element(Tag.valueOf(sourceTag),  sourceEl.baseUri(),  destAttrs);  int  numDiscarded  =  0;    Attributes  sourceAttrs  =  sourceEl.attributes();  for  (Attribute  sourceAttr  :  sourceAttrs)  {  [BUGGY]  if(  sourceEl.isSafeAttribute  (  sourceTag,  whitelist,  sourceAttr  ))  destAttrs.put  (  sourceAttr  )  ;    else  numDiscarded++;  }  Attributes  enforcedAttrs  =  whitelist.getEnforcedAttributes(sourceTag);  destAttrs.addAll(enforcedAttrs);    return  new  ElementMeta(dest,  numDiscarded);  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  createSafeElement  [RETURN_TYPE]  Cleaner$ElementMeta      Element  sourceEl  [VARIABLES]  boolean    Attribute    sourceAttr    Element    dest    destChild    el    source    sourceEl    Attributes    destAttrs    enforcedAttrs    sourceAttrs    Whitelist    whitelist    String    sourceTag    int    numAttribsDiscarded    numDiscarded    
if  (  whitelist.isSafeAttribute  (  sourceTag,  sourceEl,  sourceAttr  )  )  destAttrs.put  (  sourceAttr  )  ;  else  numDiscarded++;  }	[BUGGY]  destAttrs.put(sourceAttr);  [CONTEXT]  private  ElementMeta  createSafeElement(Element  sourceEl)  {  String  sourceTag  =  sourceEl.tagName();  Attributes  destAttrs  =  new  Attributes();  Element  dest  =  new  Element(Tag.valueOf(sourceTag),  sourceEl.baseUri(),  destAttrs);  int  numDiscarded  =  0;    Attributes  sourceAttrs  =  sourceEl.attributes();  for  (Attribute  sourceAttr  :  sourceAttrs)  {  [BUGGY]  if  (whitelist.isSafeAttribute(sourceTag,  sourceEl,  sourceAttr))    destAttrs.put(sourceAttr);        Attributes  enforcedAttrs  =  whitelist.getEnforcedAttributes(sourceTag);  destAttrs.addAll(enforcedAttrs);    return  new  ElementMeta(dest,  numDiscarded);        [CLASS]  Cleaner  ElementMeta    [METHOD]  createSafeElement  [RETURN_TYPE]  Cleaner$ElementMeta      Element  sourceEl  [VARIABLES]  boolean    Attribute    sourceAttr    Element    dest    destChild    el    source    sourceEl    Attributes    destAttrs    enforcedAttrs    sourceAttrs    Whitelist    whitelist    String    sourceTag    int    numAttribsDiscarded    numDiscarded    
if  (  whitelist.isSafeAttribute  (  sourceTag,  sourceEl,  sourceAttr  )  )  destAttrs.put  (  sourceAttr  )  ;  else  numDiscarded++;  }	[BUGGY]    [CONTEXT]  private  ElementMeta  createSafeElement(Element  sourceEl)  {  String  sourceTag  =  sourceEl.tagName();  Attributes  destAttrs  =  new  Attributes();  Element  dest  =  new  Element(Tag.valueOf(sourceTag),  sourceEl.baseUri(),  destAttrs);  int  numDiscarded  =  0;    Attributes  sourceAttrs  =  sourceEl.attributes();  for  (Attribute  sourceAttr  :  sourceAttrs)  {  [BUGGY]  if  (whitelist.isSafeAttribute(sourceTag,  sourceEl,  sourceAttr))            Attributes  enforcedAttrs  =  whitelist.getEnforcedAttributes(sourceTag);  destAttrs.addAll(enforcedAttrs);    return  new  ElementMeta(dest,  numDiscarded);        [CLASS]  Cleaner  ElementMeta    [METHOD]  createSafeElement  [RETURN_TYPE]  Cleaner$ElementMeta      Element  sourceEl  [VARIABLES]  boolean    Attribute    sourceAttr    Element    dest    destChild    el    source    sourceEl    Attributes    destAttrs    enforcedAttrs    sourceAttrs    Whitelist    whitelist    String    sourceTag    int    numAttribsDiscarded    numDiscarded    
destAttrs.put  (  sourceAttr  )  ;	[BUGGY]  destAttrs  .Attributes(  )  ;  [CONTEXT]  private  ElementMeta  createSafeElement(Element  sourceEl)  {  String  sourceTag  =  sourceEl.tagName();  Attributes  destAttrs  =  new  Attributes();  Element  dest  =  new  Element(Tag.valueOf(sourceTag),  sourceEl.baseUri(),  destAttrs);  int  numDiscarded  =  0;    Attributes  sourceAttrs  =  sourceEl.attributes();  for  (Attribute  sourceAttr  :  sourceAttrs)  {  if  (whitelist.isSafeAttribute(sourceTag,  sourceEl,  sourceAttr))  [BUGGY]  destAttrs  .Attributes  ();  else  numDiscarded++;  }  Attributes  enforcedAttrs  =  whitelist.getEnforcedAttributes(sourceTag);  destAttrs.addAll(enforcedAttrs);    return  new  ElementMeta(dest,  numDiscarded);  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  createSafeElement  [RETURN_TYPE]  Cleaner$ElementMeta      Element  sourceEl  [VARIABLES]  boolean    Attribute    sourceAttr    Element    dest    destChild    el    source    sourceEl    Attributes    destAttrs    enforcedAttrs    sourceAttrs    Whitelist    whitelist    String    sourceTag    int    numAttribsDiscarded    numDiscarded    
destAttrs.put  (  sourceAttr  )  ;	[BUGGY]    [CONTEXT]  private  ElementMeta  createSafeElement(Element  sourceEl)  {  String  sourceTag  =  sourceEl.tagName();  Attributes  destAttrs  =  new  Attributes();  Element  dest  =  new  Element(Tag.valueOf(sourceTag),  sourceEl.baseUri(),  destAttrs);  int  numDiscarded  =  0;    Attributes  sourceAttrs  =  sourceEl.attributes();  for  (Attribute  sourceAttr  :  sourceAttrs)  {  if  (whitelist.isSafeAttribute(sourceTag,  sourceEl,  sourceAttr))  [BUGGY]  destAttrs.put(sourceAttr);    else  numDiscarded++;  }  Attributes  enforcedAttrs  =  whitelist.getEnforcedAttributes(sourceTag);  destAttrs.addAll(enforcedAttrs);    return  new  ElementMeta(dest,  numDiscarded);        [CLASS]  Cleaner  ElementMeta    [METHOD]  createSafeElement  [RETURN_TYPE]  Cleaner$ElementMeta      Element  sourceEl  [VARIABLES]  boolean    Attribute    sourceAttr    Element    dest    destChild    el    source    sourceEl    Attributes    destAttrs    enforcedAttrs    sourceAttrs    Whitelist    whitelist    String    sourceTag    int    numAttribsDiscarded    numDiscarded    
for  (  Attribute  sourceAttr  :  sourceAttrs  )  {	[BUGGY]  Attributes  sourceAttrs  =  sourceEl.attributes(  );for  (  Attribute  sourceAttr  :  sourceAttrs)  {  [CONTEXT]        [CLASS]  Cleaner  ElementMeta    [METHOD]  createSafeElement  [RETURN_TYPE]  Cleaner$ElementMeta      Element  sourceEl  [VARIABLES]  boolean    Attribute    sourceAttr    Element    dest    destChild    el    source    sourceEl    Attributes    destAttrs    enforcedAttrs    sourceAttrs    Whitelist    whitelist    String    sourceTag    int    numAttribsDiscarded    numDiscarded    
if  (  whitelist.isSafeAttribute  (  sourceTag,  sourceEl,  sourceAttr  )  )  destAttrs.put  (  sourceAttr  )  ;	[BUGGY]  if  (  whitelist.isSafeAttribute(  sourceTag,  el,  sourceAttr))destAttrs.put(  sourceAttr);  [CONTEXT]  private  ElementMeta  createSafeElement(Element  sourceEl)  {  String  sourceTag  =  sourceEl.tagName();  Attributes  destAttrs  =  new  Attributes();  Element  dest  =  new  Element(Tag.valueOf(sourceTag),  sourceEl.baseUri(),  destAttrs);  int  numDiscarded  =  0;    Attributes  sourceAttrs  =  sourceEl.attributes();  for  (Attribute  sourceAttr  :  sourceAttrs)  {  [BUGGY]  if(  whitelist.isSafeAttribute  (  sourceTag,  el,  sourceAttr  ))  destAttrs.put  (  sourceAttr  )  ;    else  numDiscarded++;  }  Attributes  enforcedAttrs  =  whitelist.getEnforcedAttributes(sourceTag);  destAttrs.addAll(enforcedAttrs);    return  new  ElementMeta(dest,  numDiscarded);  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  createSafeElement  [RETURN_TYPE]  Cleaner$ElementMeta      Element  sourceEl  [VARIABLES]  boolean    Attribute    sourceAttr    Element    dest    destChild    el    source    sourceEl    Attributes    destAttrs    enforcedAttrs    sourceAttrs    Whitelist    whitelist    String    sourceTag    int    numAttribsDiscarded    numDiscarded    
if  (  whitelist.isSafeAttribute  (  sourceTag,  sourceEl,  sourceAttr  )  )  destAttrs.put  (  sourceAttr  )  ;	[BUGGY]  if  (  whitelist.isSafeAttribute(  sourceAttr,  sourceEl,  sourceTag))destAttrs.put(  sourceAttr);  [CONTEXT]  private  ElementMeta  createSafeElement(Element  sourceEl)  {  String  sourceTag  =  sourceEl.tagName();  Attributes  destAttrs  =  new  Attributes();  Element  dest  =  new  Element(Tag.valueOf(sourceTag),  sourceEl.baseUri(),  destAttrs);  int  numDiscarded  =  0;    Attributes  sourceAttrs  =  sourceEl.attributes();  for  (Attribute  sourceAttr  :  sourceAttrs)  {  [BUGGY]  if(  whitelist.isSafeAttribute  (  sourceAttr,  sourceEl,  sourceTag  ))  destAttrs.put  (  sourceAttr  )  ;    else  numDiscarded++;  }  Attributes  enforcedAttrs  =  whitelist.getEnforcedAttributes(sourceTag);  destAttrs.addAll(enforcedAttrs);    return  new  ElementMeta(dest,  numDiscarded);  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  createSafeElement  [RETURN_TYPE]  Cleaner$ElementMeta      Element  sourceEl  [VARIABLES]  boolean    Attribute    sourceAttr    Element    dest    destChild    el    source    sourceEl    Attributes    destAttrs    enforcedAttrs    sourceAttrs    Whitelist    whitelist    String    sourceTag    int    numAttribsDiscarded    numDiscarded    
if  (  whitelist.isSafeAttribute  (  sourceTag,  sourceEl,  sourceAttr  )  )  destAttrs.put  (  sourceAttr  )  ;	[BUGGY]  if  (  whitelist.isSafeAttribute(  sourceTag,  sourceAttr,  sourceEl))destAttrs.put(  sourceAttr);  [CONTEXT]  private  ElementMeta  createSafeElement(Element  sourceEl)  {  String  sourceTag  =  sourceEl.tagName();  Attributes  destAttrs  =  new  Attributes();  Element  dest  =  new  Element(Tag.valueOf(sourceTag),  sourceEl.baseUri(),  destAttrs);  int  numDiscarded  =  0;    Attributes  sourceAttrs  =  sourceEl.attributes();  for  (Attribute  sourceAttr  :  sourceAttrs)  {  [BUGGY]  if(  whitelist.isSafeAttribute  (  sourceTag,  sourceAttr,  sourceEl  ))  destAttrs.put  (  sourceAttr  )  ;    else  numDiscarded++;  }  Attributes  enforcedAttrs  =  whitelist.getEnforcedAttributes(sourceTag);  destAttrs.addAll(enforcedAttrs);    return  new  ElementMeta(dest,  numDiscarded);  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  createSafeElement  [RETURN_TYPE]  Cleaner$ElementMeta      Element  sourceEl  [VARIABLES]  boolean    Attribute    sourceAttr    Element    dest    destChild    el    source    sourceEl    Attributes    destAttrs    enforcedAttrs    sourceAttrs    Whitelist    whitelist    String    sourceTag    int    numAttribsDiscarded    numDiscarded    
if  (  whitelist.isSafeAttribute  (  sourceTag,  sourceEl,  sourceAttr  )  )  destAttrs.put  (  sourceAttr  )  ;	[BUGGY]  if  (  whitelist  .getEnforcedAttributes(  sourceTag)  )destAttrs.put(  sourceAttr);  [CONTEXT]  private  ElementMeta  createSafeElement(Element  sourceEl)  {  String  sourceTag  =  sourceEl.tagName();  Attributes  destAttrs  =  new  Attributes();  Element  dest  =  new  Element(Tag.valueOf(sourceTag),  sourceEl.baseUri(),  destAttrs);  int  numDiscarded  =  0;    Attributes  sourceAttrs  =  sourceEl.attributes();  for  (Attribute  sourceAttr  :  sourceAttrs)  {  [BUGGY]  if(  whitelist  .getEnforcedAttributes  (  sourceTag  )  )  destAttrs.put  (  sourceAttr  )  ;    else  numDiscarded++;  }  Attributes  enforcedAttrs  =  whitelist.getEnforcedAttributes(sourceTag);  destAttrs.addAll(enforcedAttrs);    return  new  ElementMeta(dest,  numDiscarded);  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  createSafeElement  [RETURN_TYPE]  Cleaner$ElementMeta      Element  sourceEl  [VARIABLES]  boolean    Attribute    sourceAttr    Element    dest    destChild    el    source    sourceEl    Attributes    destAttrs    enforcedAttrs    sourceAttrs    Whitelist    whitelist    String    sourceTag    int    numAttribsDiscarded    numDiscarded    
if  (  whitelist.isSafeAttribute  (  sourceTag,  sourceEl,  sourceAttr  )  )  destAttrs.put  (  sourceAttr  )  ;	[BUGGY]  if  (  whitelist.isSafeAttribute(  sourceTag,  source,  sourceAttr))destAttrs.put(  sourceAttr);  [CONTEXT]  private  ElementMeta  createSafeElement(Element  sourceEl)  {  String  sourceTag  =  sourceEl.tagName();  Attributes  destAttrs  =  new  Attributes();  Element  dest  =  new  Element(Tag.valueOf(sourceTag),  sourceEl.baseUri(),  destAttrs);  int  numDiscarded  =  0;    Attributes  sourceAttrs  =  sourceEl.attributes();  for  (Attribute  sourceAttr  :  sourceAttrs)  {  [BUGGY]  if(  whitelist.isSafeAttribute  (  sourceTag,  source,  sourceAttr  ))  destAttrs.put  (  sourceAttr  )  ;    else  numDiscarded++;  }  Attributes  enforcedAttrs  =  whitelist.getEnforcedAttributes(sourceTag);  destAttrs.addAll(enforcedAttrs);    return  new  ElementMeta(dest,  numDiscarded);  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  createSafeElement  [RETURN_TYPE]  Cleaner$ElementMeta      Element  sourceEl  [VARIABLES]  boolean    Attribute    sourceAttr    Element    dest    destChild    el    source    sourceEl    Attributes    destAttrs    enforcedAttrs    sourceAttrs    Whitelist    whitelist    String    sourceTag    int    numAttribsDiscarded    numDiscarded    
Attributes  enforcedAttrs  =  whitelist.getEnforcedAttributes  (  sourceTag  )  ;	[BUGGY]  Attributes  enforcedAttrs  =  sourceTag.getEnforcedAttributes(  whitelist);  [CONTEXT]  private  ElementMeta  createSafeElement(Element  sourceEl)  {  String  sourceTag  =  sourceEl.tagName();  Attributes  destAttrs  =  new  Attributes();  Element  dest  =  new  Element(Tag.valueOf(sourceTag),  sourceEl.baseUri(),  destAttrs);  int  numDiscarded  =  0;    Attributes  sourceAttrs  =  sourceEl.attributes();  for  (Attribute  sourceAttr  :  sourceAttrs)  {  if  (whitelist.isSafeAttribute(sourceTag,  sourceEl,  sourceAttr))  destAttrs.put(sourceAttr);  else  numDiscarded++;  }  [BUGGY]  Attributes  enforcedAttrs  =  sourceTag.getEnforcedAttributes  (  whitelist  )  ;  destAttrs.addAll(enforcedAttrs);    return  new  ElementMeta(dest,  numDiscarded);  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  createSafeElement  [RETURN_TYPE]  Cleaner$ElementMeta      Element  sourceEl  [VARIABLES]  boolean    Attribute    sourceAttr    Element    dest    destChild    el    source    sourceEl    Attributes    destAttrs    enforcedAttrs    sourceAttrs    Whitelist    whitelist    String    sourceTag    int    numAttribsDiscarded    numDiscarded    
Attributes  enforcedAttrs  =  whitelist.getEnforcedAttributes  (  sourceTag  )  ;	[BUGGY]  Attributes  enforcedAttrs  =  whitelist  .isSafeAttribute(  sourceTag  ,  sourceEl  ,  sourceAttr)  ;  [CONTEXT]  private  ElementMeta  createSafeElement(Element  sourceEl)  {  String  sourceTag  =  sourceEl.tagName();  Attributes  destAttrs  =  new  Attributes();  Element  dest  =  new  Element(Tag.valueOf(sourceTag),  sourceEl.baseUri(),  destAttrs);  int  numDiscarded  =  0;    Attributes  sourceAttrs  =  sourceEl.attributes();  for  (Attribute  sourceAttr  :  sourceAttrs)  {  if  (whitelist.isSafeAttribute(sourceTag,  sourceEl,  sourceAttr))  destAttrs.put(sourceAttr);  else  numDiscarded++;  }  [BUGGY]  Attributes  enforcedAttrs  =  whitelist  .isSafeAttribute  (  sourceTag  ,  sourceEl  ,  sourceAttr  );  destAttrs.addAll(enforcedAttrs);    return  new  ElementMeta(dest,  numDiscarded);  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  createSafeElement  [RETURN_TYPE]  Cleaner$ElementMeta      Element  sourceEl  [VARIABLES]  boolean    Attribute    sourceAttr    Element    dest    destChild    el    source    sourceEl    Attributes    destAttrs    enforcedAttrs    sourceAttrs    Whitelist    whitelist    String    sourceTag    int    numAttribsDiscarded    numDiscarded    
Attributes  enforcedAttrs  =  whitelist.getEnforcedAttributes  (  sourceTag  )  ;  destAttrs.addAll  (  enforcedAttrs  )  ;	[BUGGY]  destAttrs.addAll(  enforcedAttrs);  Attributes  enforcedAttrs  =  whitelist.getEnforcedAttributes(  sourceTag);  [CONTEXT]        [CLASS]  Cleaner  ElementMeta    [METHOD]  createSafeElement  [RETURN_TYPE]  Cleaner$ElementMeta      Element  sourceEl  [VARIABLES]  boolean    Attribute    sourceAttr    Element    dest    destChild    el    source    sourceEl    Attributes    destAttrs    enforcedAttrs    sourceAttrs    Whitelist    whitelist    String    sourceTag    int    numAttribsDiscarded    numDiscarded    
Attributes  enforcedAttrs  =  whitelist.getEnforcedAttributes  (  sourceTag  )  ;  destAttrs.addAll  (  enforcedAttrs  )  ;	[BUGGY]  Attributes  enforcedAttrs  =  whitelist.getEnforcedAttributes(  sourceTag);Attributes  enforcedAttrs  =  whitelist.getEnforcedAttributes(  sourceTag);  destAttrs.addAll(  enforcedAttrs);  [CONTEXT]        [CLASS]  Cleaner  ElementMeta    [METHOD]  createSafeElement  [RETURN_TYPE]  Cleaner$ElementMeta      Element  sourceEl  [VARIABLES]  boolean    Attribute    sourceAttr    Element    dest    destChild    el    source    sourceEl    Attributes    destAttrs    enforcedAttrs    sourceAttrs    Whitelist    whitelist    String    sourceTag    int    numAttribsDiscarded    numDiscarded    
Attributes  enforcedAttrs  =  whitelist.getEnforcedAttributes  (  sourceTag  )  ;  destAttrs.addAll  (  enforcedAttrs  )  ;  return  new  ElementMeta  (  dest,  numDiscarded  )  ;  }	[BUGGY]    [CONTEXT]  private  ElementMeta  createSafeElement(Element  sourceEl)  {  String  sourceTag  =  sourceEl.tagName();  Attributes  destAttrs  =  new  Attributes();  Element  dest  =  new  Element(Tag.valueOf(sourceTag),  sourceEl.baseUri(),  destAttrs);  int  numDiscarded  =  0;    Attributes  sourceAttrs  =  sourceEl.attributes();  for  (Attribute  sourceAttr  :  sourceAttrs)  {  if  (whitelist.isSafeAttribute(sourceTag,  sourceEl,  sourceAttr))  destAttrs.put(sourceAttr);  else  numDiscarded++;  }  [BUGGY]  Attributes  enforcedAttrs  =  whitelist.getEnforcedAttributes(sourceTag);                [CLASS]  Cleaner  ElementMeta    [METHOD]  createSafeElement  [RETURN_TYPE]  Cleaner$ElementMeta      Element  sourceEl  [VARIABLES]  boolean    Attribute    sourceAttr    Element    dest    destChild    el    source    sourceEl    Attributes    destAttrs    enforcedAttrs    sourceAttrs    Whitelist    whitelist    String    sourceTag    int    numAttribsDiscarded    numDiscarded    
destAttrs.addAll  (  enforcedAttrs  )  ;	[BUGGY]  destAttrs.addAll(  sourceAttrs);  [CONTEXT]  private  ElementMeta  createSafeElement(Element  sourceEl)  {  String  sourceTag  =  sourceEl.tagName();  Attributes  destAttrs  =  new  Attributes();  Element  dest  =  new  Element(Tag.valueOf(sourceTag),  sourceEl.baseUri(),  destAttrs);  int  numDiscarded  =  0;    Attributes  sourceAttrs  =  sourceEl.attributes();  for  (Attribute  sourceAttr  :  sourceAttrs)  {  if  (whitelist.isSafeAttribute(sourceTag,  sourceEl,  sourceAttr))  destAttrs.put(sourceAttr);  else  numDiscarded++;  }  Attributes  enforcedAttrs  =  whitelist.getEnforcedAttributes(sourceTag);  [BUGGY]  destAttrs.addAll  (  sourceAttrs  )  ;    return  new  ElementMeta(dest,  numDiscarded);  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  createSafeElement  [RETURN_TYPE]  Cleaner$ElementMeta      Element  sourceEl  [VARIABLES]  boolean    Attribute    sourceAttr    Element    dest    destChild    el    source    sourceEl    Attributes    destAttrs    enforcedAttrs    sourceAttrs    Whitelist    whitelist    String    sourceTag    int    numAttribsDiscarded    numDiscarded    
destAttrs.addAll  (  enforcedAttrs  )  ;  return  new  ElementMeta  (  dest,  numDiscarded  )  ;  }	[BUGGY]    [CONTEXT]  private  ElementMeta  createSafeElement(Element  sourceEl)  {  String  sourceTag  =  sourceEl.tagName();  Attributes  destAttrs  =  new  Attributes();  Element  dest  =  new  Element(Tag.valueOf(sourceTag),  sourceEl.baseUri(),  destAttrs);  int  numDiscarded  =  0;    Attributes  sourceAttrs  =  sourceEl.attributes();  for  (Attribute  sourceAttr  :  sourceAttrs)  {  if  (whitelist.isSafeAttribute(sourceTag,  sourceEl,  sourceAttr))  destAttrs.put(sourceAttr);  else  numDiscarded++;  }  Attributes  enforcedAttrs  =  whitelist.getEnforcedAttributes(sourceTag);  [BUGGY]  destAttrs.addAll(enforcedAttrs);              [CLASS]  Cleaner  ElementMeta    [METHOD]  createSafeElement  [RETURN_TYPE]  Cleaner$ElementMeta      Element  sourceEl  [VARIABLES]  boolean    Attribute    sourceAttr    Element    dest    destChild    el    source    sourceEl    Attributes    destAttrs    enforcedAttrs    sourceAttrs    Whitelist    whitelist    String    sourceTag    int    numAttribsDiscarded    numDiscarded    
return  new  ElementMeta  (  dest,  numDiscarded  )  ;	[BUGGY]  return  new  ElementMeta(    numDiscarded);  [CONTEXT]  private  ElementMeta  createSafeElement(Element  sourceEl)  {  String  sourceTag  =  sourceEl.tagName();  Attributes  destAttrs  =  new  Attributes();  Element  dest  =  new  Element(Tag.valueOf(sourceTag),  sourceEl.baseUri(),  destAttrs);  int  numDiscarded  =  0;    Attributes  sourceAttrs  =  sourceEl.attributes();  for  (Attribute  sourceAttr  :  sourceAttrs)  {  if  (whitelist.isSafeAttribute(sourceTag,  sourceEl,  sourceAttr))  destAttrs.put(sourceAttr);  else  numDiscarded++;  }  Attributes  enforcedAttrs  =  whitelist.getEnforcedAttributes(sourceTag);  destAttrs.addAll(enforcedAttrs);    [BUGGY]  return  new  ElementMeta  (numDiscarded  )  ;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  createSafeElement  [RETURN_TYPE]  Cleaner$ElementMeta      Element  sourceEl  [VARIABLES]  boolean    Attribute    sourceAttr    Element    dest    destChild    el    source    sourceEl    Attributes    destAttrs    enforcedAttrs    sourceAttrs    Whitelist    whitelist    String    sourceTag    int    numAttribsDiscarded    numDiscarded    
return  new  ElementMeta  (  dest,  numDiscarded  )  ;	[BUGGY]  return  new  ElementMeta(  dest);  [CONTEXT]  private  ElementMeta  createSafeElement(Element  sourceEl)  {  String  sourceTag  =  sourceEl.tagName();  Attributes  destAttrs  =  new  Attributes();  Element  dest  =  new  Element(Tag.valueOf(sourceTag),  sourceEl.baseUri(),  destAttrs);  int  numDiscarded  =  0;    Attributes  sourceAttrs  =  sourceEl.attributes();  for  (Attribute  sourceAttr  :  sourceAttrs)  {  if  (whitelist.isSafeAttribute(sourceTag,  sourceEl,  sourceAttr))  destAttrs.put(sourceAttr);  else  numDiscarded++;  }  Attributes  enforcedAttrs  =  whitelist.getEnforcedAttributes(sourceTag);  destAttrs.addAll(enforcedAttrs);    [BUGGY]  return  new  ElementMeta  (  dest  )  ;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  createSafeElement  [RETURN_TYPE]  Cleaner$ElementMeta      Element  sourceEl  [VARIABLES]  boolean    Attribute    sourceAttr    Element    dest    destChild    el    source    sourceEl    Attributes    destAttrs    enforcedAttrs    sourceAttrs    Whitelist    whitelist    String    sourceTag    int    numAttribsDiscarded    numDiscarded    
return  new  ElementMeta  (  dest,  numDiscarded  )  ;	[BUGGY]  return  new  ElementMeta(  dest,  numAttribsDiscarded);  [CONTEXT]  private  ElementMeta  createSafeElement(Element  sourceEl)  {  String  sourceTag  =  sourceEl.tagName();  Attributes  destAttrs  =  new  Attributes();  Element  dest  =  new  Element(Tag.valueOf(sourceTag),  sourceEl.baseUri(),  destAttrs);  int  numDiscarded  =  0;    Attributes  sourceAttrs  =  sourceEl.attributes();  for  (Attribute  sourceAttr  :  sourceAttrs)  {  if  (whitelist.isSafeAttribute(sourceTag,  sourceEl,  sourceAttr))  destAttrs.put(sourceAttr);  else  numDiscarded++;  }  Attributes  enforcedAttrs  =  whitelist.getEnforcedAttributes(sourceTag);  destAttrs.addAll(enforcedAttrs);    [BUGGY]  return  new  ElementMeta  (  dest,  numAttribsDiscarded  )  ;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  createSafeElement  [RETURN_TYPE]  Cleaner$ElementMeta      Element  sourceEl  [VARIABLES]  boolean    Attribute    sourceAttr    Element    dest    destChild    el    source    sourceEl    Attributes    destAttrs    enforcedAttrs    sourceAttrs    Whitelist    whitelist    String    sourceTag    int    numAttribsDiscarded    numDiscarded    
return  new  ElementMeta  (  dest,  numDiscarded  )  ;	[BUGGY]  return  new  ElementMeta(  numDiscarded,  dest);  [CONTEXT]  private  ElementMeta  createSafeElement(Element  sourceEl)  {  String  sourceTag  =  sourceEl.tagName();  Attributes  destAttrs  =  new  Attributes();  Element  dest  =  new  Element(Tag.valueOf(sourceTag),  sourceEl.baseUri(),  destAttrs);  int  numDiscarded  =  0;    Attributes  sourceAttrs  =  sourceEl.attributes();  for  (Attribute  sourceAttr  :  sourceAttrs)  {  if  (whitelist.isSafeAttribute(sourceTag,  sourceEl,  sourceAttr))  destAttrs.put(sourceAttr);  else  numDiscarded++;  }  Attributes  enforcedAttrs  =  whitelist.getEnforcedAttributes(sourceTag);  destAttrs.addAll(enforcedAttrs);    [BUGGY]  return  new  ElementMeta  (  numDiscarded,  dest  )  ;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  createSafeElement  [RETURN_TYPE]  Cleaner$ElementMeta      Element  sourceEl  [VARIABLES]  boolean    Attribute    sourceAttr    Element    dest    destChild    el    source    sourceEl    Attributes    destAttrs    enforcedAttrs    sourceAttrs    Whitelist    whitelist    String    sourceTag    int    numAttribsDiscarded    numDiscarded    
return  new  ElementMeta  (  dest,  numDiscarded  )  ;	[BUGGY]  return  new  ElementMeta(  sourceEl,  numDiscarded);  [CONTEXT]  private  ElementMeta  createSafeElement(Element  sourceEl)  {  String  sourceTag  =  sourceEl.tagName();  Attributes  destAttrs  =  new  Attributes();  Element  dest  =  new  Element(Tag.valueOf(sourceTag),  sourceEl.baseUri(),  destAttrs);  int  numDiscarded  =  0;    Attributes  sourceAttrs  =  sourceEl.attributes();  for  (Attribute  sourceAttr  :  sourceAttrs)  {  if  (whitelist.isSafeAttribute(sourceTag,  sourceEl,  sourceAttr))  destAttrs.put(sourceAttr);  else  numDiscarded++;  }  Attributes  enforcedAttrs  =  whitelist.getEnforcedAttributes(sourceTag);  destAttrs.addAll(enforcedAttrs);    [BUGGY]  return  new  ElementMeta  (  sourceEl,  numDiscarded  )  ;  }        [CLASS]  Cleaner  ElementMeta    [METHOD]  createSafeElement  [RETURN_TYPE]  Cleaner$ElementMeta      Element  sourceEl  [VARIABLES]  boolean    Attribute    sourceAttr    Element    dest    destChild    el    source    sourceEl    Attributes    destAttrs    enforcedAttrs    sourceAttrs    Whitelist    whitelist    String    sourceTag    int    numAttribsDiscarded    numDiscarded    
int  numAttribsDiscarded;	[BUGGY]  short    numAttribsDiscarded;  [CONTEXT]  return  new  ElementMeta(dest,  numDiscarded);  }    private  static  class  ElementMeta  {  Element  el;  [BUGGY]  shortnumAttribsDiscarded;    ElementMeta(Element  el,  int  numAttribsDiscarded)  {  this.el  =  el;  this.numAttribsDiscarded  =  numAttribsDiscarded;  }        [CLASS]  ElementMeta    [METHOD]  createSafeElement  [RETURN_TYPE]  Cleaner$ElementMeta      Element  sourceEl  [VARIABLES]  boolean    Attribute    sourceAttr    Element    dest    destChild    el    source    sourceEl    Attributes    destAttrs    enforcedAttrs    sourceAttrs    Whitelist    whitelist    String    sourceTag    int    numAttribsDiscarded    numDiscarded    
this.el  =  el;	[BUGGY]  this.el  =    null;  [CONTEXT]  ElementMeta(Element  el,  int  numAttribsDiscarded)  {  [BUGGY]  this.el  =null;  this.numAttribsDiscarded  =  numAttribsDiscarded;  }        [CLASS]  ElementMeta    [METHOD]  <init>  [RETURN_TYPE]  Element,int)      Element  el  int  numAttribsDiscarded  [VARIABLES]  int    numAttribsDiscarded    Element    el    boolean    
this.el  =  el;  this.numAttribsDiscarded  =  numAttribsDiscarded;	[BUGGY]  this.numAttribsDiscarded  =  numAttribsDiscarded;  this.el  =  el;  [CONTEXT]        [CLASS]  ElementMeta    [METHOD]  <init>  [RETURN_TYPE]  Element,int)      Element  el  int  numAttribsDiscarded  [VARIABLES]  int    numAttribsDiscarded    Element    el    boolean    
this.el  =  el;  this.numAttribsDiscarded  =  numAttribsDiscarded;	[BUGGY]  this.numAttribsDiscarded  =  numAttribsDiscarded;this.el  =  el;  this.numAttribsDiscarded  =  numAttribsDiscarded;  [CONTEXT]        [CLASS]  ElementMeta    [METHOD]  <init>  [RETURN_TYPE]  Element,int)      Element  el  int  numAttribsDiscarded  [VARIABLES]  int    numAttribsDiscarded    Element    el    boolean    
this.numAttribsDiscarded  =  numAttribsDiscarded;	[BUGGY]  this.numAttribsDiscarded  =    null;  [CONTEXT]  ElementMeta(Element  el,  int  numAttribsDiscarded)  {  this.el  =  el;  [BUGGY]  this.numAttribsDiscarded  =null;  }        [CLASS]  ElementMeta    [METHOD]  <init>  [RETURN_TYPE]  Element,int)      Element  el  int  numAttribsDiscarded  [VARIABLES]  int    numAttribsDiscarded    Element    el    boolean    
private  String  value;	[BUGGY]  private  char  value;  [CONTEXT]  return  new  Protocol(value);  }  }    abstract  static  class  TypedValue  {  [BUGGY]  private  char  value;    TypedValue(String  value)  {  Validate.notNull(value);  this.value  =  value;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue      [VARIABLES]  
tagNames  =  new  HashSet<TagName>  (  )  ;	[BUGGY]  tagNames  =  tagNames  =    new  Protocol>(  )  ;  [CONTEXT]  public  Whitelist()  {  [BUGGY]  tagNames  =  tagNames  =new  Protocol>  ();  attributes  =  new  HashMap<TagName,  Set<AttributeKey>>();  enforcedAttributes  =  new  HashMap<TagName,  Map<AttributeKey,  AttributeValue>>();  protocols  =  new  HashMap<TagName,  Map<AttributeKey,  Set<Protocol>>>();  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  <init>  [RETURN_TYPE]  Whitelist()      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
tagNames  =  new  HashSet<TagName>  (  )  ;	[BUGGY]  tagNames  =    new  Protocol>(  )  ;  [CONTEXT]  public  Whitelist()  {  [BUGGY]  tagNames  =new  Protocol>  ();  attributes  =  new  HashMap<TagName,  Set<AttributeKey>>();  enforcedAttributes  =  new  HashMap<TagName,  Map<AttributeKey,  AttributeValue>>();  protocols  =  new  HashMap<TagName,  Map<AttributeKey,  Set<Protocol>>>();  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  <init>  [RETURN_TYPE]  Whitelist()      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
tagNames  =  new  HashSet<TagName>  (  )  ;	[BUGGY]  protSet  =  new  HashSet<Protocol>(  );tagNames  =  new  HashSet<TagName>(  );  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  <init>  [RETURN_TYPE]  Whitelist()      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
tagNames  =  new  HashSet<TagName>  (  )  ;	[BUGGY]  attributes  =  new  HashMap<TagName,  Set<AttributeKey>>(  );tagNames  =  new  HashSet<TagName>(  );  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  <init>  [RETURN_TYPE]  Whitelist()      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
attributes  =  new  HashMap<TagName,  Set<AttributeKey>>  (  )  ;	[BUGGY]  attributes  =  attributes  =    new  AttributeKey,  AttributeValue>(  )  ;  [CONTEXT]  public  Whitelist()  {  tagNames  =  new  HashSet<TagName>();  [BUGGY]  attributes  =  attributes  =new  AttributeKey,  AttributeValue>  ();  enforcedAttributes  =  new  HashMap<TagName,  Map<AttributeKey,  AttributeValue>>();  protocols  =  new  HashMap<TagName,  Map<AttributeKey,  Set<Protocol>>>();  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  <init>  [RETURN_TYPE]  Whitelist()      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
attributes  =  new  HashMap<TagName,  Set<AttributeKey>>  (  )  ;	[BUGGY]  attributes  =    new  AttributeKey,  AttributeValue>(  )  ;  [CONTEXT]  public  Whitelist()  {  tagNames  =  new  HashSet<TagName>();  [BUGGY]  attributes  =new  AttributeKey,  AttributeValue>  ();  enforcedAttributes  =  new  HashMap<TagName,  Map<AttributeKey,  AttributeValue>>();  protocols  =  new  HashMap<TagName,  Map<AttributeKey,  Set<Protocol>>>();  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  <init>  [RETURN_TYPE]  Whitelist()      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
attributes  =  new  HashMap<TagName,  Set<AttributeKey>>  (  )  ;  enforcedAttributes  =  new  HashMap<TagName,  Map<AttributeKey,  AttributeValue>>  (  )  ;	[BUGGY]  enforcedAttributes  =  new  HashMap<TagName,  Map<AttributeKey,  AttributeValue>>(  );  attributes  =  new  HashMap<TagName,  Set<AttributeKey>>(  );  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  <init>  [RETURN_TYPE]  Whitelist()      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
attributes  =  new  HashMap<TagName,  Set<AttributeKey>>  (  )  ;  enforcedAttributes  =  new  HashMap<TagName,  Map<AttributeKey,  AttributeValue>>  (  )  ;	[BUGGY]  enforcedAttributes  =  new  HashMap<TagName,  Map<AttributeKey,  AttributeValue>>(  );attributes  =  new  HashMap<TagName,  Set<AttributeKey>>(  );  enforcedAttributes  =  new  HashMap<TagName,  Map<AttributeKey,  AttributeValue>>(  );  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  <init>  [RETURN_TYPE]  Whitelist()      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
enforcedAttributes  =  new  HashMap<TagName,  Map<AttributeKey,  AttributeValue>>  (  )  ;	[BUGGY]  enforcedAttributes  =  enforcedAttributes  =    new  TagName,  AttributeKey,  Protocol>>>(  )  ;  [CONTEXT]  public  Whitelist()  {  tagNames  =  new  HashSet<TagName>();  attributes  =  new  HashMap<TagName,  Set<AttributeKey>>();  [BUGGY]  enforcedAttributes  =  enforcedAttributes  =new  TagName,  AttributeKey,  Protocol>>>  ();  protocols  =  new  HashMap<TagName,  Map<AttributeKey,  Set<Protocol>>>();  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  <init>  [RETURN_TYPE]  Whitelist()      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
enforcedAttributes  =  new  HashMap<TagName,  Map<AttributeKey,  AttributeValue>>  (  )  ;	[BUGGY]  enforcedAttributes  =    new  TagName,  AttributeKey,  Protocol>>>(  )  ;  [CONTEXT]  public  Whitelist()  {  tagNames  =  new  HashSet<TagName>();  attributes  =  new  HashMap<TagName,  Set<AttributeKey>>();  [BUGGY]  enforcedAttributes  =new  TagName,  AttributeKey,  Protocol>>>  ();  protocols  =  new  HashMap<TagName,  Map<AttributeKey,  Set<Protocol>>>();  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  <init>  [RETURN_TYPE]  Whitelist()      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
enforcedAttributes  =  new  HashMap<TagName,  Map<AttributeKey,  AttributeValue>>  (  )  ;  protocols  =  new  HashMap<TagName,  Map<AttributeKey,  Set<Protocol>>>  (  )  ;	[BUGGY]  protocols  =  new  HashMap<TagName,  Map<AttributeKey,  Set<Protocol>>>(  );  enforcedAttributes  =  new  HashMap<TagName,  Map<AttributeKey,  AttributeValue>>(  );  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  <init>  [RETURN_TYPE]  Whitelist()      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
enforcedAttributes  =  new  HashMap<TagName,  Map<AttributeKey,  AttributeValue>>  (  )  ;  protocols  =  new  HashMap<TagName,  Map<AttributeKey,  Set<Protocol>>>  (  )  ;	[BUGGY]  enforcedAttributes  =  new  HashMap<TagName,  Map<AttributeKey,  AttributeValue>>(  );enforcedAttributes  =  new  HashMap<TagName,  Map<AttributeKey,  AttributeValue>>(  );  protocols  =  new  HashMap<TagName,  Map<AttributeKey,  Set<Protocol>>>(  );  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  <init>  [RETURN_TYPE]  Whitelist()      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
protocols  =  new  HashMap<TagName,  Map<AttributeKey,  Set<Protocol>>>  (  )  ;	[BUGGY]  protocols  =  protocols  =    new  TagName,  AttributeKey,  AttributeValue>>(  )  ;  [CONTEXT]  public  Whitelist()  {  tagNames  =  new  HashSet<TagName>();  attributes  =  new  HashMap<TagName,  Set<AttributeKey>>();  enforcedAttributes  =  new  HashMap<TagName,  Map<AttributeKey,  AttributeValue>>();  [BUGGY]  protocols  =  protocols  =new  TagName,  AttributeKey,  AttributeValue>>  ();  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  <init>  [RETURN_TYPE]  Whitelist()      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
protocols  =  new  HashMap<TagName,  Map<AttributeKey,  Set<Protocol>>>  (  )  ;	[BUGGY]  protocols  =    new  TagName,  AttributeKey,  AttributeValue>>(  )  ;  [CONTEXT]  public  Whitelist()  {  tagNames  =  new  HashSet<TagName>();  attributes  =  new  HashMap<TagName,  Set<AttributeKey>>();  enforcedAttributes  =  new  HashMap<TagName,  Map<AttributeKey,  AttributeValue>>();  [BUGGY]  protocols  =new  TagName,  AttributeKey,  AttributeValue>>  ();  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  <init>  [RETURN_TYPE]  Whitelist()      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
super  (  value  )  ;	[BUGGY]    [CONTEXT]  TagName(String  value)  {  [BUGGY]  super(value);          [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  <init>  [RETURN_TYPE]  String)      String  value  [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
super  (  value  )  ;	[BUGGY]    [CONTEXT]  AttributeKey(String  value)  {  [BUGGY]  super(value);          [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  <init>  [RETURN_TYPE]  String)      String  value  [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
super  (  value  )  ;	[BUGGY]    [CONTEXT]  AttributeValue(String  value)  {  [BUGGY]  super(value);          [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  <init>  [RETURN_TYPE]  String)      String  value  [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
super  (  value  )  ;	[BUGGY]    [CONTEXT]  Protocol(String  value)  {  [BUGGY]  super(value);          [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  <init>  [RETURN_TYPE]  String)      String  value  [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
Validate.notNull  (  value  )  ;	[BUGGY]  Validate  .notEmpty(  value)  ;  [CONTEXT]  TypedValue(String  value)  {  [BUGGY]  Validate  .notEmpty  (  value  );  this.value  =  value;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  <init>  [RETURN_TYPE]  String)      String  value  [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
Validate.notNull  (  value  )  ;  this.value  =  value;	[BUGGY]    [CONTEXT]  TypedValue(String  value)  {  [BUGGY]  Validate.notNull(value);            [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  <init>  [RETURN_TYPE]  String)      String  value  [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
Validate.notNull  (  value  )  ;	[BUGGY]  this.value  =  value;  Validate.notNull(  value);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  <init>  [RETURN_TYPE]  String)      String  value  [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
Validate.notNull  (  value  )  ;	[BUGGY]  Validate.notNull(  tags);Validate.notNull(  value);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  <init>  [RETURN_TYPE]  String)      String  value  [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
Validate.notNull  (  value  )  ;	[BUGGY]  Validate.notEmpty(  tag);Validate.notNull(  value);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  <init>  [RETURN_TYPE]  String)      String  value  [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
Validate.notNull  (  value  )  ;	[BUGGY]  Validate.notNull(  keys);Validate.notNull(  value);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  <init>  [RETURN_TYPE]  String)      String  value  [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
Validate.notNull  (  value  )  ;	[BUGGY]  Validate.notEmpty(  key);Validate.notNull(  value);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  <init>  [RETURN_TYPE]  String)      String  value  [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
Validate.notNull  (  value  )  ;	[BUGGY]  Validate.notEmpty(  value);Validate.notNull(  value);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  <init>  [RETURN_TYPE]  String)      String  value  [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
Validate.notNull  (  value  )  ;	[BUGGY]  attr.setValue(  value);Validate.notNull(  value);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  <init>  [RETURN_TYPE]  String)      String  value  [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
Validate.notNull  (  value  )  ;	[BUGGY]  Validate.notNull(  protocols);Validate.notNull(  value);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  <init>  [RETURN_TYPE]  String)      String  value  [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
Validate.notNull  (  value  )  ;	[BUGGY]  Validate.notEmpty(  tagName);Validate.notNull(  value);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  <init>  [RETURN_TYPE]  String)      String  value  [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
Validate.notNull  (  value  )  ;	[BUGGY]  Validate.notEmpty(  protocol);Validate.notNull(  value);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  <init>  [RETURN_TYPE]  String)      String  value  [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
this.value  =  value;	[BUGGY]  this.value  =    null;  [CONTEXT]  TypedValue(String  value)  {  Validate.notNull(value);  [BUGGY]  this.value  =null;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  <init>  [RETURN_TYPE]  String)      String  value  [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  ;	[BUGGY]  return  return    new  TagName(  value)  ;  [CONTEXT]  public  static  Whitelist  none()  {  [BUGGY]  return  returnnew  TagName  (  value  );  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  none  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  ;	[BUGGY]  return    new  TagName(  value)  ;  [CONTEXT]  public  static  Whitelist  none()  {  [BUGGY]  returnnew  TagName  (  value  );  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  none  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "b ",   "em ",   "i ",   "strong ",   "u "  )  ;	[BUGGY]  return  new  Whitelist(  ).addTags(   "b ",   "em ",   "i ",   "ontrong ",   "u ");  [CONTEXT]  public  static  Whitelist  simpleText()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "b ",   "em ",   "i ",   "ontrong ",   "u "  )  ;      }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  simpleText  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "b ",   "em ",   "i ",   "strong ",   "u "  )  ;	[BUGGY]  return  return    new  TagName(  value)  .addTags(   "b ",   "em ",   "i ",   "strong ",   "u ");  [CONTEXT]  public  static  Whitelist  simpleText()  {  [BUGGY]  return  returnnew  TagName  (  value  ).addTags  (   "b ",   "em ",   "i ",   "strong ",   "u "  )  ;      }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  simpleText  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "b ",   "em ",   "i ",   "strong ",   "u "  )  ;	[BUGGY]  return  new  Whitelist(  )  .addProtocols(  value  ,  value  ,  value  ,  value  ,  value  ,  value)  ;  [CONTEXT]  public  static  Whitelist  simpleText()  {  [BUGGY]  return  new  Whitelist  ().addProtocols  (  value  ,  value  ,  value  ,  value  ,  value  ,  value  );      }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  simpleText  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "b ",   "em ",   "i ",   "strong ",   "u "  )  ;	[BUGGY]  return    new  TagName(  value)  .addTags(   "b ",   "em ",   "i ",   "strong ",   "u ");  [CONTEXT]  public  static  Whitelist  simpleText()  {  [BUGGY]  returnnew  TagName  (  value  ).addTags  (   "b ",   "em ",   "i ",   "strong ",   "u "  )  ;      }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  simpleText  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "b ",   "em ",   "i ",   "strong ",   "u "  )  ;	[BUGGY]  return  new  Whitelist(  ).addTags(   " ",   "em ",   "i ",   "strong ",   "u ");  [CONTEXT]  public  static  Whitelist  simpleText()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   " ",   "em ",   "i ",   "strong ",   "u "  )  ;      }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  simpleText  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "b ",   "em ",   "i ",   "strong ",   "u "  )  ;	[BUGGY]  return  new  Whitelist(  ).addTags(   "b ",   "e ",   "i ",   "strong ",   "u ");  [CONTEXT]  public  static  Whitelist  simpleText()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "b ",   "e ",   "i ",   "strong ",   "u "  )  ;      }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  simpleText  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "b ",   "em ",   "i ",   "strong ",   "u "  )  ;	[BUGGY]  return  new  Whitelist(  ).addTags(   "b ",   "em ",   "i ",   "s ",   "u ");  [CONTEXT]  public  static  Whitelist  simpleText()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "b ",   "em ",   "i ",   "s ",   "u "  )  ;      }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  simpleText  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "b ",   "em ",   "i ",   "strong ",   "u "  )  ;	[BUGGY]  return  new  Whitelist(  ).addTags(   "b ",   "em ",   "i ",   "strong ",   " ");  [CONTEXT]  public  static  Whitelist  simpleText()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "b ",   "em ",   "i ",   "strong ",   " "  )  ;      }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  simpleText  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "b ",   "em ",   "i ",   "strong ",   "u "  )  ;	[BUGGY]    [CONTEXT]  public  static  Whitelist  simpleText()  {  [BUGGY]  return  new  Whitelist()              [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  simpleText  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   " ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   " ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "kq ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "kq ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "c ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "c ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "coode ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "coode ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "d ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "d ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "d ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "d ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "eme ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "eme ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "olo ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "olo ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   " ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   " ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   " ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   " ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   " ",   "small ",   "strike ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   " ",   "small ",   "strike ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "m ",   "strike ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "m ",   "strike ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "ttrike ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "ttrike ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "s ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "s ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "subs ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "subs ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "olockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "olockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "citeci ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "citeci ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "ite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "ite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   " ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   " ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "quolockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "quolockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "citecit ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "citecit ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "ciite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "ciite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  return    new  TagName(  value)  .addTags(   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  returnnew  TagName  (  value  ).addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return    new  TagName(  value)  .addTags(   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  returnnew  TagName  (  value  ).addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "quotlockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "quotlockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   " ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   " ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "citec ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "citec ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "c ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "c ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "d ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "d ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dtd ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dtd ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   " ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   " ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "lil ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "lil ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "rre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "rre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "malmall ",   "strike ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "malmall ",   "strike ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "striket ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "striket ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "tro ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "tro ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   " ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   " ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "bloc ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "bloc ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "iite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "iite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquoteb ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquoteb ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "i ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "i ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "brb ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "brb ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "itite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "itite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "coded ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "coded ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   " ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   " ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   " ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   " ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pr ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pr ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "smalls ",   "strike ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "smalls ",   "strike ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "stritrike ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "stritrike ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "str ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "str ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "lockqu ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "lockqu ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "tite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "tite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquotelockquot ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquotelockquot ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "b ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "b ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "dode ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "dode ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "l ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "l ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   " ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   " ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "m ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "m ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   " ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   " ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   " ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   " ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "ma ",   "strike ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "ma ",   "strike ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strikest ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strikest ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strongst ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strongst ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "subsu ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "subsu ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquotekquot ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquotekquot ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   " ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   " ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "ci ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "ci ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "block ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "block ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  )  .addProtocols(  value  ,  value  ,  value  ,  value  ,  value  ,  value)(   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ().addProtocols  (  value  ,  value  ,  value  ,  value  ,  value  ,  value  )(   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "b ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "b ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dld ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dld ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "prep ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "prep ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   " ",   "strike ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   " ",   "strike ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   " ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   " ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "suub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "suub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "lo ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "lo ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "citite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "citite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "prepr ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "prepr ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "mmall ",   "strike ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "mmall ",   "strike ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "s ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "s ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "ttrong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "ttrong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquoteblockq ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquoteblockq ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockqlockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockqlockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "citei ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "citei ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "odode ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "odode ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "ddd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "ddd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "t ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "t ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "p ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "p ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "mal ",   "strike ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "mal ",   "strike ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "k ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "k ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strtrong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strtrong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquoteock ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquoteock ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "ck ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "ck ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "cod ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "cod ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "o ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "o ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "prre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "prre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strongo ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strongo ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "uotlockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "uotlockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "citeit ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "citeit ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "re ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "re ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "smalll ",   "strike ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "smalll ",   "strike ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "itrike ",   "strong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "itrike ",   "strong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "trong ",   "sub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "trong ",   "sub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "uub ",  [CONTEXT]  public  static  Whitelist  basic()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "uub ",         "sup ",   "u ",   "ul ")    .addAttributes( "a ",   "href ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "q ",   "cite ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "cite ",   "cite ",   "http ",   "https ")    .addEnforcedAttribute( "a ",   "rel ",   "nofollow ")  ;    }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basic  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  basic  (  )  .addTags  (   "img "  )  .addAttributes  (   "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width "  )  .addProtocols  (   "img ",   "src ",   "http ",   "https "  )	[BUGGY]  return  basic(  ).addTags(   "mg ").addAttributes(   "mg ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ").addProtocols(   "mg ",   "src ",   "http ",   "https "  )  [CONTEXT]  public  static  Whitelist  basicWithImages()  {  [BUGGY]  return  basic  ()  .addTags  (   "mg "  )  .addAttributes  (   "mg ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width "  )  .addProtocols  (   "mg ",   "src ",   "http ",   "https "  )        ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basicWithImages  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  basic  (  )  .addTags  (   "img "  )  .addAttributes  (   "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width "  )  .addProtocols  (   "img ",   "src ",   "http ",   "https "  )	[BUGGY]  return  basic(  ).addTags(   "img ").addAttributes(   "img ",   "lign ",   "alt ",   "height ",   "src ",   "title ",   "width ").addProtocols(   "img ",   "src ",   "http ",   "https "  )  [CONTEXT]  public  static  Whitelist  basicWithImages()  {  [BUGGY]  return  basic  ()  .addTags  (   "img "  )  .addAttributes  (   "img ",   "lign ",   "alt ",   "height ",   "src ",   "title ",   "width "  )  .addProtocols  (   "img ",   "src ",   "http ",   "https "  )        ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basicWithImages  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  basic  (  )  .addTags  (   "img "  )  .addAttributes  (   "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width "  )  .addProtocols  (   "img ",   "src ",   "http ",   "https "  )	[BUGGY]  return  basic(  ).addTags(   "img ").addAttributes(   "img ",   "align ",   "al ",   "height ",   "src ",   "title ",   "width ").addProtocols(   "img ",   "src ",   "http ",   "https "  )  [CONTEXT]  public  static  Whitelist  basicWithImages()  {  [BUGGY]  return  basic  ()  .addTags  (   "img "  )  .addAttributes  (   "img ",   "align ",   "al ",   "height ",   "src ",   "title ",   "width "  )  .addProtocols  (   "img ",   "src ",   "http ",   "https "  )        ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basicWithImages  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  basic  (  )  .addTags  (   "img "  )  .addAttributes  (   "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width "  )  .addProtocols  (   "img ",   "src ",   "http ",   "https "  )	[BUGGY]  return  basic(  ).addTags(   "img ").addAttributes(   "img ",   "align ",   "alt ",   "eight ",   "src ",   "title ",   "width ").addProtocols(   "img ",   "src ",   "http ",   "https "  )  [CONTEXT]  public  static  Whitelist  basicWithImages()  {  [BUGGY]  return  basic  ()  .addTags  (   "img "  )  .addAttributes  (   "img ",   "align ",   "alt ",   "eight ",   "src ",   "title ",   "width "  )  .addProtocols  (   "img ",   "src ",   "http ",   "https "  )        ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basicWithImages  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  basic  (  )  .addTags  (   "img "  )  .addAttributes  (   "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width "  )  .addProtocols  (   "img ",   "src ",   "http ",   "https "  )	[BUGGY]  return  basic(  ).addTags(   "img ").addAttributes(   "img ",   "align ",   "alt ",   "height ",   "srcs ",   "title ",   "width ").addProtocols(   "img ",   "srcs ",   "http ",   "https "  )  [CONTEXT]  public  static  Whitelist  basicWithImages()  {  [BUGGY]  return  basic  ()  .addTags  (   "img "  )  .addAttributes  (   "img ",   "align ",   "alt ",   "height ",   "srcs ",   "title ",   "width "  )  .addProtocols  (   "img ",   "srcs ",   "http ",   "https "  )        ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basicWithImages  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  basic  (  )  .addTags  (   "img "  )  .addAttributes  (   "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width "  )  .addProtocols  (   "img ",   "src ",   "http ",   "https "  )	[BUGGY]  return  basic(  ).addTags(   "img ").addAttributes(   "img ",   "align ",   "alt ",   "height ",   "src ",   "t ",   "width ").addProtocols(   "img ",   "src ",   "http ",   "https "  )  [CONTEXT]  public  static  Whitelist  basicWithImages()  {  [BUGGY]  return  basic  ()  .addTags  (   "img "  )  .addAttributes  (   "img ",   "align ",   "alt ",   "height ",   "src ",   "t ",   "width "  )  .addProtocols  (   "img ",   "src ",   "http ",   "https "  )        ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basicWithImages  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  basic  (  )  .addTags  (   "img "  )  .addAttributes  (   "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width "  )  .addProtocols  (   "img ",   "src ",   "http ",   "https "  )	[BUGGY]  return  basic(  ).addTags(   "img ").addAttributes(   "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "idth ").addProtocols(   "img ",   "src ",   "http ",   "https "  )  [CONTEXT]  public  static  Whitelist  basicWithImages()  {  [BUGGY]  return  basic  ()  .addTags  (   "img "  )  .addAttributes  (   "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "idth "  )  .addProtocols  (   "img ",   "src ",   "http ",   "https "  )        ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basicWithImages  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  basic  (  )  .addTags  (   "img "  )  .addAttributes  (   "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width "  )  .addProtocols  (   "img ",   "src ",   "http ",   "https "  )	[BUGGY]  return  basic(  ).addTags(   "imgm ").addAttributes(   "imgm ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ").addProtocols(   "imgm ",   "src ",   "http ",   "https "  )  [CONTEXT]  public  static  Whitelist  basicWithImages()  {  [BUGGY]  return  basic  ()  .addTags  (   "imgm "  )  .addAttributes  (   "imgm ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width "  )  .addProtocols  (   "imgm ",   "src ",   "http ",   "https "  )        ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basicWithImages  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  basic  (  )  .addTags  (   "img "  )  .addAttributes  (   "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width "  )  .addProtocols  (   "img ",   "src ",   "http ",   "https "  )	[BUGGY]  return  basic(  ).addTags(   "img ").addAttributes(   "img ",   "align ",   "alt ",   "height ",   "rc ",   "title ",   "width ").addProtocols(   "img ",   "rc ",   "http ",   "https "  )  [CONTEXT]  public  static  Whitelist  basicWithImages()  {  [BUGGY]  return  basic  ()  .addTags  (   "img "  )  .addAttributes  (   "img ",   "align ",   "alt ",   "height ",   "rc ",   "title ",   "width "  )  .addProtocols  (   "img ",   "rc ",   "http ",   "https "  )        ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basicWithImages  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  basic  (  )  .addTags  (   "img "  )  .addAttributes  (   "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width "  )  .addProtocols  (   "img ",   "src ",   "http ",   "https "  )	[BUGGY]  return  basic(  ).addTags(   "img ").addAttributes(   "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ").addProtocols(   "img ",   "src ",   "httph ",   "https "  )  [CONTEXT]  public  static  Whitelist  basicWithImages()  {  [BUGGY]  return  basic  ()  .addTags  (   "img "  )  .addAttributes  (   "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width "  )  .addProtocols  (   "img ",   "src ",   "httph ",   "https "  )        ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basicWithImages  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  basic  (  )  .addTags  (   "img "  )  .addAttributes  (   "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width "  )  .addProtocols  (   "img ",   "src ",   "http ",   "https "  )	[BUGGY]  return  basic(  ).addTags(   "img ").addAttributes(   "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ").addProtocols(   "img ",   "src ",   "http ",   "httpsht "  )  [CONTEXT]  public  static  Whitelist  basicWithImages()  {  [BUGGY]  return  basic  ()  .addTags  (   "img "  )  .addAttributes  (   "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width "  )  .addProtocols  (   "img ",   "src ",   "http ",   "httpsht "  )        ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basicWithImages  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  basic  (  )  .addTags  (   "img "  )  .addAttributes  (   "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width "  )  .addProtocols  (   "img ",   "src ",   "http ",   "https "  )	[BUGGY]  return  basic(  ).isSafeTag(   "img ").addAttributes(   "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ").addProtocols(   "img ",   "src ",   "http ",   "https "  )  [CONTEXT]  public  static  Whitelist  basicWithImages()  {  [BUGGY]  return  basic  ()  .isSafeTag  (   "img "  )  .addAttributes  (   "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width "  )  .addProtocols  (   "img ",   "src ",   "http ",   "https "  )        ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basicWithImages  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  basic  (  )  .addTags  (   "img "  )  .addAttributes  (   "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width "  )  .addProtocols  (   "img ",   "src ",   "http ",   "https "  )	[BUGGY]  return  basic(  )  .addProtocols(  value  ,  value  ,  value  ,  value  ,  value  ,  value)  .addAttributes(   "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ").addProtocols(   "img ",   "src ",   "http ",   "https "  )  [CONTEXT]  public  static  Whitelist  basicWithImages()  {  [BUGGY]  return  basic  ().addProtocols  (  value  ,  value  ,  value  ,  value  ,  value  ,  value  ).addAttributes  (   "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width "  )  .addProtocols  (   "img ",   "src ",   "http ",   "https "  )        ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basicWithImages  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  basic  (  )  .addTags  (   "img "  )  .addAttributes  (   "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width "  )  .addProtocols  (   "img ",   "src ",   "http ",   "https "  )	[BUGGY]  return  Whitelist(  ).addTags(   "img ").addAttributes(   "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ").addProtocols(   "img ",   "src ",   "http ",   "https "  )  [CONTEXT]  public  static  Whitelist  basicWithImages()  {  [BUGGY]  return  Whitelist  ()  .addTags  (   "img "  )  .addAttributes  (   "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width "  )  .addProtocols  (   "img ",   "src ",   "http ",   "https "  )        ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basicWithImages  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  basic  (  )  .addTags  (   "img "  )  .addAttributes  (   "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width "  )  .addProtocols  (   "img ",   "src ",   "http ",   "https "  )	[BUGGY]  return  basic(  ).addTags(   "mmg ").addAttributes(   "mmg ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ").addProtocols(   "mmg ",   "src ",   "http ",   "https "  )  [CONTEXT]  public  static  Whitelist  basicWithImages()  {  [BUGGY]  return  basic  ()  .addTags  (   "mmg "  )  .addAttributes  (   "mmg ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width "  )  .addProtocols  (   "mmg ",   "src ",   "http ",   "https "  )        ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basicWithImages  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  basic  (  )  .addTags  (   "img "  )  .addAttributes  (   "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width "  )  .addProtocols  (   "img ",   "src ",   "http ",   "https "  )	[BUGGY]  return  basic(  ).addTags(   "img ").addAttributes(   "img ",   "alignali ",   "alt ",   "height ",   "src ",   "title ",   "width ").addProtocols(   "img ",   "src ",   "http ",   "https "  )  [CONTEXT]  public  static  Whitelist  basicWithImages()  {  [BUGGY]  return  basic  ()  .addTags  (   "img "  )  .addAttributes  (   "img ",   "alignali ",   "alt ",   "height ",   "src ",   "title ",   "width "  )  .addProtocols  (   "img ",   "src ",   "http ",   "https "  )        ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basicWithImages  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  basic  (  )  .addTags  (   "img "  )  .addAttributes  (   "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width "  )  .addProtocols  (   "img ",   "src ",   "http ",   "https "  )	[BUGGY]  return  basic(  ).addTags(   "img ").addAttributes(   "img ",   "align ",   "alt ",   "heightheigh ",   "src ",   "title ",   "width ").addProtocols(   "img ",   "src ",   "http ",   "https "  )  [CONTEXT]  public  static  Whitelist  basicWithImages()  {  [BUGGY]  return  basic  ()  .addTags  (   "img "  )  .addAttributes  (   "img ",   "align ",   "alt ",   "heightheigh ",   "src ",   "title ",   "width "  )  .addProtocols  (   "img ",   "src ",   "http ",   "https "  )        ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basicWithImages  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  basic  (  )  .addTags  (   "img "  )  .addAttributes  (   "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width "  )  .addProtocols  (   "img ",   "src ",   "http ",   "https "  )	[BUGGY]  return  basic(  ).addTags(   "img ").addAttributes(   "img ",   "align ",   "alt ",   "height ",   "srrc ",   "title ",   "width ").addProtocols(   "img ",   "srrc ",   "http ",   "https "  )  [CONTEXT]  public  static  Whitelist  basicWithImages()  {  [BUGGY]  return  basic  ()  .addTags  (   "img "  )  .addAttributes  (   "img ",   "align ",   "alt ",   "height ",   "srrc ",   "title ",   "width "  )  .addProtocols  (   "img ",   "srrc ",   "http ",   "https "  )        ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basicWithImages  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  basic  (  )  .addTags  (   "img "  )  .addAttributes  (   "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width "  )  .addProtocols  (   "img ",   "src ",   "http ",   "https "  )	[BUGGY]  return  basic(  ).addTags(   "img ").addAttributes(   "img ",   "align ",   "alt ",   "height ",   "src ",   "tititle ",   "width ").addProtocols(   "img ",   "src ",   "http ",   "https "  )  [CONTEXT]  public  static  Whitelist  basicWithImages()  {  [BUGGY]  return  basic  ()  .addTags  (   "img "  )  .addAttributes  (   "img ",   "align ",   "alt ",   "height ",   "src ",   "tititle ",   "width "  )  .addProtocols  (   "img ",   "src ",   "http ",   "https "  )        ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basicWithImages  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  basic  (  )  .addTags  (   "img "  )  .addAttributes  (   "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width "  )  .addProtocols  (   "img ",   "src ",   "http ",   "https "  )	[BUGGY]  return  basic(  ).addTags(   "img ").addAttributes(   "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "widthdt ").addProtocols(   "img ",   "src ",   "http ",   "https "  )  [CONTEXT]  public  static  Whitelist  basicWithImages()  {  [BUGGY]  return  basic  ()  .addTags  (   "img "  )  .addAttributes  (   "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "widthdt "  )  .addProtocols  (   "img ",   "src ",   "http ",   "https "  )        ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basicWithImages  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  basic  (  )  .addTags  (   "img "  )  .addAttributes  (   "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width "  )  .addProtocols  (   "img ",   "src ",   "http ",   "https "  )	[BUGGY]  return  basic(  ).addTags(   "img ").addAttributes(   "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ").addProtocols(   "img ",   "src ",   "ttp ",   "https "  )  [CONTEXT]  public  static  Whitelist  basicWithImages()  {  [BUGGY]  return  basic  ()  .addTags  (   "img "  )  .addAttributes  (   "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width "  )  .addProtocols  (   "img ",   "src ",   "ttp ",   "https "  )        ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basicWithImages  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  basic  (  )  .addTags  (   "img "  )  .addAttributes  (   "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width "  )  .addProtocols  (   "img ",   "src ",   "http ",   "https "  )	[BUGGY]  return  basic(  ).addTags(   "immg ").addAttributes(   "immg ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ").addProtocols(   "immg ",   "src ",   "http ",   "https "  )  [CONTEXT]  public  static  Whitelist  basicWithImages()  {  [BUGGY]  return  basic  ()  .addTags  (   "immg "  )  .addAttributes  (   "immg ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width "  )  .addProtocols  (   "immg ",   "src ",   "http ",   "https "  )        ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basicWithImages  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  basic  (  )  .addTags  (   "img "  )  .addAttributes  (   "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width "  )  .addProtocols  (   "img ",   "src ",   "http ",   "https "  )	[BUGGY]  return  basic(  ).addTags(   "img ").addAttributes(   "img ",   "ilign ",   "alt ",   "height ",   "src ",   "title ",   "width ").addProtocols(   "img ",   "src ",   "http ",   "https "  )  [CONTEXT]  public  static  Whitelist  basicWithImages()  {  [BUGGY]  return  basic  ()  .addTags  (   "img "  )  .addAttributes  (   "img ",   "ilign ",   "alt ",   "height ",   "src ",   "title ",   "width "  )  .addProtocols  (   "img ",   "src ",   "http ",   "https "  )        ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basicWithImages  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  basic  (  )  .addTags  (   "img "  )  .addAttributes  (   "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width "  )  .addProtocols  (   "img ",   "src ",   "http ",   "https "  )	[BUGGY]  return  basic(  ).addTags(   "img ").addAttributes(   "img ",   "align ",   "alt ",   "height ",   "src ",   "itle ",   "width ").addProtocols(   "img ",   "src ",   "http ",   "https "  )  [CONTEXT]  public  static  Whitelist  basicWithImages()  {  [BUGGY]  return  basic  ()  .addTags  (   "img "  )  .addAttributes  (   "img ",   "align ",   "alt ",   "height ",   "src ",   "itle ",   "width "  )  .addProtocols  (   "img ",   "src ",   "http ",   "https "  )        ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  basicWithImages  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   " ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   " ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquoteblockq ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquoteblockq ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "r ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "r ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "a ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "a ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "ciite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "ciite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "codode ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "codode ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "colc ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "colc ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "lolgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "lolgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "ddd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "ddd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "i ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "i ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "eme ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "eme ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   " ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   " ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2h ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2h ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3h ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3h ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5h ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5h ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   " ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   " ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "bllockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "bllockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "citecit ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "citecit ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "ol ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "ol ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroupco ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroupco ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "citeci ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "citeci ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "clockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "clockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "i ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "i ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "ite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "ite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  return    new  TagName(  value)  .addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  returnnew  TagName  (  value  ).addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return    new  TagName(  value)  .addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  returnnew  TagName  (  value  ).addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   " ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   " ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caaption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caaption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "d ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "d ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "cool ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "cool ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroupc ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroupc ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   " ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   " ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "d ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "d ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dld ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dld ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   " ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   " ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "m ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "m ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   " ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   " ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "uo ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "uo ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroupolgro ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroupolgro ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "citite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "citite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "bl ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "bl ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "citei ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "citei ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "ci ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "ci ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "ockquolockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "ockquolockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "brb ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "brb ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "captiono ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "captiono ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "colco ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "colco ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "olgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "olgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "d ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "d ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "d ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "d ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "d ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "d ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   " ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   " ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "kqlockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "kqlockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colg ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colg ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "t ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "t ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "captioncap ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "captioncap ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   " ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   " ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "ode ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "ode ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "di ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "di ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "e ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "e ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6h ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6h ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "loc ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "loc ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "citet ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "citet ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroupolgr ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroupolgr ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquoteckquot ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquoteckquot ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "iaption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "iaption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "od ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "od ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroupcolgr ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroupcolgr ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   " ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   " ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1h ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1h ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   " ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   " ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   " ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   " ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "quotlockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "quotlockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  )  .addProtocols(  value  ,  value  ,  value  ,  value  ,  value  ,  value)(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ().addProtocols  (  value  ,  value  ,  value  ,  value  ,  value  ,  value  )(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquotebloc ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquotebloc ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   " ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   " ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "coode ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "coode ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   " ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   " ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "olockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "olockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "citec ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "citec ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroupo ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroupo ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "c ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "c ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquotec ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquotec ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "olgolgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "olgolgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "diiv ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "diiv ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquoteckq ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquoteckq ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "captionc ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "captionc ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "c ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "c ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "divd ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "divd ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "quo ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "quo ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "tite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "tite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cit ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cit ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquoteockq ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquoteockq ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgrouplg ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgrouplg ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "iiv ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "iiv ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "ckquot ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "ckquot ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "ouolgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "ouolgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "cap ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cap ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "codecod ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "codecod ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "o ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "o ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "divdi ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "divdi ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "l ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "l ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dtd ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dtd ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquoteckqu ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquoteckqu ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "ockqlockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "ockqlockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "oaption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "oaption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "codeco ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "codeco ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "coolgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "coolgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "rolgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "rolgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "aption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "aption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroupcol ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroupcol ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4h ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4h ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "lockq ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "lockq ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "b ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "b ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "captionca ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "captionca ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "iv ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "iv ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "lockqulockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "lockqulockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroupcolgrou ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroupcolgrou ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquotek ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquotek ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "captionap ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "captionap ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "it ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "it ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "cod ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "cod ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   " ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   " ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "ckqulockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "ckqulockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "iite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "iite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquoteblo ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquoteblo ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "captiaption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "captiaption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "olgrou ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "olgrou ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "t ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "t ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquo ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquo ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blocklockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blocklockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "codeod ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "codeod ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "olgr ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "olgr ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "qu ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "qu ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
return  new  Whitelist  (  )  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  Whitelist(  ).addTags(   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "col ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",  [CONTEXT]  public  static  Whitelist  relaxed()  {  [BUGGY]  return  new  Whitelist  ()  .addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "col ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",         "i ",   "img ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",   "sup ",   "table ",   "tbody ",   "td ",   "tfoot ",   "th ",   "thead ",   "tr ",   "u ",   "ul ")    .addAttributes( "a ",   "href ",   "title ")  .addAttributes( "blockquote ",   "cite ")  .addAttributes( "col ",   "span ",   "width ")  .addAttributes( "colgroup ",   "span ",   "width ")  .addAttributes( "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width ")  .addAttributes( "ol ",   "start ",   "type ")  .addAttributes( "q ",   "cite ")  .addAttributes( "table ",   "summary ",   "width ")  .addAttributes( "td ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "width ")  .addAttributes(   "th ",   "abbr ",   "axis ",   "colspan ",   "rowspan ",   "scope ",   "width ")  .addAttributes( "ul ",   "type ")    .addProtocols( "a ",   "href ",   "ftp ",   "http ",   "https ",   "mailto ")  .addProtocols( "blockquote ",   "cite ",   "http ",   "https ")  .addProtocols( "img ",   "src ",   "http ",   "https ")  .addProtocols( "q ",   "cite ",   "http ",   "https ")  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  relaxed  [RETURN_TYPE]  Whitelist      [VARIABLES]  Set    tagNames    String    value    boolean    Map    attributes    enforcedAttributes    protocols    
Validate.notNull  (  tags  )  ;	[BUGGY]  Validate  .notEmpty(  value)  ;  [CONTEXT]  public  Whitelist  addTags(String...  tags)  {  [BUGGY]  Validate  .notEmpty  (  value  );    for  (String  tagName  :  tags)  {  Validate.notEmpty(tagName);  tagNames.add(TagName.valueOf(tagName));  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addTags  [RETURN_TYPE]  Whitelist        tags  [VARIABLES]  Set    tagNames    String    tagName    value    String[]    tags    boolean    Map    attributes    enforcedAttributes    protocols    
Validate.notNull  (  tags  )  ;	[BUGGY]    [CONTEXT]  public  Whitelist  addTags(String...  tags)  {  [BUGGY]  Validate.notNull(tags);      for  (String  tagName  :  tags)  {  Validate.notEmpty(tagName);  tagNames.add(TagName.valueOf(tagName));  }  return  this;        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addTags  [RETURN_TYPE]  Whitelist        tags  [VARIABLES]  Set    tagNames    String    tagName    value    String[]    tags    boolean    Map    attributes    enforcedAttributes    protocols    
for  (  String  tagName  :  tags  )  {	[BUGGY]  for  (  char  tagName  :  tags)  {  [CONTEXT]  public  Whitelist  addTags(String...  tags)  {  Validate.notNull(tags);    [BUGGY]  for(  char  tagName  :  tags  ){  Validate.notEmpty(tagName);  tagNames.add(TagName.valueOf(tagName));  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addTags  [RETURN_TYPE]  Whitelist        tags  [VARIABLES]  Set    tagNames    String    tagName    value    String[]    tags    boolean    Map    attributes    enforcedAttributes    protocols    
Validate.notEmpty  (  tagName  )  ;	[BUGGY]  Validate.notEmpty(  value);  [CONTEXT]  public  Whitelist  addTags(String...  tags)  {  Validate.notNull(tags);    for  (String  tagName  :  tags)  {  [BUGGY]  Validate.notEmpty  (  value  )  ;  tagNames.add(TagName.valueOf(tagName));  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addTags  [RETURN_TYPE]  Whitelist        tags  [VARIABLES]  Set    tagNames    String    tagName    value    String[]    tags    boolean    Map    attributes    enforcedAttributes    protocols    
Validate.notEmpty  (  tagName  )  ;	[BUGGY]  Validate  .notNull(  tags)  ;  [CONTEXT]  public  Whitelist  addTags(String...  tags)  {  Validate.notNull(tags);    for  (String  tagName  :  tags)  {  [BUGGY]  Validate  .notNull  (  tags  );  tagNames.add(TagName.valueOf(tagName));  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addTags  [RETURN_TYPE]  Whitelist        tags  [VARIABLES]  Set    tagNames    String    tagName    value    String[]    tags    boolean    Map    attributes    enforcedAttributes    protocols    
Validate.notEmpty  (  tagName  )  ;	[BUGGY]    [CONTEXT]  public  Whitelist  addTags(String...  tags)  {  Validate.notNull(tags);    for  (String  tagName  :  tags)  {  [BUGGY]  Validate.notEmpty(tagName);    tagNames.add(TagName.valueOf(tagName));  }  return  this;        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addTags  [RETURN_TYPE]  Whitelist        tags  [VARIABLES]  Set    tagNames    String    tagName    value    String[]    tags    boolean    Map    attributes    enforcedAttributes    protocols    
Validate.notEmpty  (  tagName  )  ;	[BUGGY]    Validate.notEmpty(  tagName);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addTags  [RETURN_TYPE]  Whitelist        tags  [VARIABLES]  Set    tagNames    String    tagName    value    String[]    tags    boolean    Map    attributes    enforcedAttributes    protocols    
Validate.notEmpty  (  tagName  )  ;	[BUGGY]  Validate.notNull(  value);Validate.notEmpty(  tagName);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addTags  [RETURN_TYPE]  Whitelist        tags  [VARIABLES]  Set    tagNames    String    tagName    value    String[]    tags    boolean    Map    attributes    enforcedAttributes    protocols    
Validate.notEmpty  (  tagName  )  ;	[BUGGY]  Validate.notNull(  tags);Validate.notEmpty(  tagName);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addTags  [RETURN_TYPE]  Whitelist        tags  [VARIABLES]  Set    tagNames    String    tagName    value    String[]    tags    boolean    Map    attributes    enforcedAttributes    protocols    
Validate.notEmpty  (  tagName  )  ;	[BUGGY]  Validate.notEmpty(  tag);Validate.notEmpty(  tagName);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addTags  [RETURN_TYPE]  Whitelist        tags  [VARIABLES]  Set    tagNames    String    tagName    value    String[]    tags    boolean    Map    attributes    enforcedAttributes    protocols    
Validate.notEmpty  (  tagName  )  ;	[BUGGY]  Validate.notNull(  keys);Validate.notEmpty(  tagName);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addTags  [RETURN_TYPE]  Whitelist        tags  [VARIABLES]  Set    tagNames    String    tagName    value    String[]    tags    boolean    Map    attributes    enforcedAttributes    protocols    
Validate.notEmpty  (  tagName  )  ;	[BUGGY]  Validate.notEmpty(  key);Validate.notEmpty(  tagName);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addTags  [RETURN_TYPE]  Whitelist        tags  [VARIABLES]  Set    tagNames    String    tagName    value    String[]    tags    boolean    Map    attributes    enforcedAttributes    protocols    
Validate.notEmpty  (  tagName  )  ;	[BUGGY]  Validate.notEmpty(  value);Validate.notEmpty(  tagName);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addTags  [RETURN_TYPE]  Whitelist        tags  [VARIABLES]  Set    tagNames    String    tagName    value    String[]    tags    boolean    Map    attributes    enforcedAttributes    protocols    
Validate.notEmpty  (  tagName  )  ;	[BUGGY]  Validate.notNull(  protocols);Validate.notEmpty(  tagName);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addTags  [RETURN_TYPE]  Whitelist        tags  [VARIABLES]  Set    tagNames    String    tagName    value    String[]    tags    boolean    Map    attributes    enforcedAttributes    protocols    
Validate.notEmpty  (  tagName  )  ;	[BUGGY]  Validate.notEmpty(  protocol);Validate.notEmpty(  tagName);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addTags  [RETURN_TYPE]  Whitelist        tags  [VARIABLES]  Set    tagNames    String    tagName    value    String[]    tags    boolean    Map    attributes    enforcedAttributes    protocols    
tagNames.add  (  TagName.valueOf  (  tagName  )  )  ;	[BUGGY]  tagNames.add(  TagName.valueOf(  value));  [CONTEXT]  public  Whitelist  addTags(String...  tags)  {  Validate.notNull(tags);    for  (String  tagName  :  tags)  {  Validate.notEmpty(tagName);  [BUGGY]  tagNames.add  (  TagName.valueOf  (  value  ))  ;  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addTags  [RETURN_TYPE]  Whitelist        tags  [VARIABLES]  Set    tagNames    String    tagName    value    String[]    tags    boolean    Map    attributes    enforcedAttributes    protocols    
tagNames.add  (  TagName.valueOf  (  tagName  )  )  ;	[BUGGY]  tagNames.addAll(  TagName.valueOf(  tagName));  [CONTEXT]  public  Whitelist  addTags(String...  tags)  {  Validate.notNull(tags);    for  (String  tagName  :  tags)  {  Validate.notEmpty(tagName);  [BUGGY]  tagNames.addAll  (  TagName.valueOf  (  tagName  ))  ;  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addTags  [RETURN_TYPE]  Whitelist        tags  [VARIABLES]  Set    tagNames    String    tagName    value    String[]    tags    boolean    Map    attributes    enforcedAttributes    protocols    
tagNames.add  (  TagName.valueOf  (  tagName  )  )  ;	[BUGGY]  tagNames  .addAll(  0)  ;  [CONTEXT]  public  Whitelist  addTags(String...  tags)  {  Validate.notNull(tags);    for  (String  tagName  :  tags)  {  Validate.notEmpty(tagName);  [BUGGY]  tagNames  .addAll  (  0  );  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addTags  [RETURN_TYPE]  Whitelist        tags  [VARIABLES]  Set    tagNames    String    tagName    value    String[]    tags    boolean    Map    attributes    enforcedAttributes    protocols    
tagNames.add  (  TagName.valueOf  (  tagName  )  )  ;	[BUGGY]  tagNames.add(  TagName.TagName(  tagName));  [CONTEXT]  public  Whitelist  addTags(String...  tags)  {  Validate.notNull(tags);    for  (String  tagName  :  tags)  {  Validate.notEmpty(tagName);  [BUGGY]  tagNames.add  (  TagName.TagName  (  tagName  ))  ;  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addTags  [RETURN_TYPE]  Whitelist        tags  [VARIABLES]  Set    tagNames    String    tagName    value    String[]    tags    boolean    Map    attributes    enforcedAttributes    protocols    
tagNames.add  (  TagName.valueOf  (  tagName  )  )  ;	[BUGGY]    [CONTEXT]  public  Whitelist  addTags(String...  tags)  {  Validate.notNull(tags);    for  (String  tagName  :  tags)  {  Validate.notEmpty(tagName);  [BUGGY]  tagNames.add(TagName.valueOf(tagName));    }  return  this;        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addTags  [RETURN_TYPE]  Whitelist        tags  [VARIABLES]  Set    tagNames    String    tagName    value    String[]    tags    boolean    Map    attributes    enforcedAttributes    protocols    
tagNames.add  (  TagName.valueOf  (  tagName  )  )  ;	[BUGGY]  tagNames.add(  TagName.TagName(  value));  [CONTEXT]  public  Whitelist  addTags(String...  tags)  {  Validate.notNull(tags);    for  (String  tagName  :  tags)  {  Validate.notEmpty(tagName);  [BUGGY]  tagNames.add  (  TagName.TagName  (  value  ))  ;  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addTags  [RETURN_TYPE]  Whitelist        tags  [VARIABLES]  Set    tagNames    String    tagName    value    String[]    tags    boolean    Map    attributes    enforcedAttributes    protocols    
return  this;	[BUGGY]  return  null;  [CONTEXT]  public  Whitelist  addTags(String...  tags)  {  Validate.notNull(tags);    for  (String  tagName  :  tags)  {  Validate.notEmpty(tagName);  tagNames.add(TagName.valueOf(tagName));  }  [BUGGY]  return  null;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addTags  [RETURN_TYPE]  Whitelist        tags  [VARIABLES]  Set    tagNames    String    tagName    value    String[]    tags    boolean    Map    attributes    enforcedAttributes    protocols    
Validate.notEmpty  (  tag  )  ;	[BUGGY]  Validate.notEmpty(  value);  [CONTEXT]  public  Whitelist  addAttributes(String  tag,  String...  keys)  {  [BUGGY]  Validate.notEmpty  (  value  )  ;  Validate.notNull(keys);    TagName  tagName  =  TagName.valueOf(tag);  Set<AttributeKey>  attributeSet  =  new  HashSet<AttributeKey>();  for  (String  key  :  keys)  {  Validate.notEmpty(key);  attributeSet.add(AttributeKey.valueOf(key));  }  if  (attributes.containsKey(tagName))  {  Set<AttributeKey>  currentSet  =  attributes.get(tagName);  currentSet.addAll(attributeSet);  }  else  {  attributes.put(tagName,  attributeSet);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addAttributes  [RETURN_TYPE]  Whitelist      String  tag    keys  [VARIABLES]  Set    attributeSet    currentSet    tagNames    String    key    tag    tagName    value    String[]    keys    boolean    TagName    tagName    Map    attributes    enforcedAttributes    protocols    
Validate.notEmpty  (  tag  )  ;	[BUGGY]  Validate.notNull(  tag);  [CONTEXT]  public  Whitelist  addAttributes(String  tag,  String...  keys)  {  [BUGGY]  Validate.notNull  (  tag  )  ;  Validate.notNull(keys);    TagName  tagName  =  TagName.valueOf(tag);  Set<AttributeKey>  attributeSet  =  new  HashSet<AttributeKey>();  for  (String  key  :  keys)  {  Validate.notEmpty(key);  attributeSet.add(AttributeKey.valueOf(key));  }  if  (attributes.containsKey(tagName))  {  Set<AttributeKey>  currentSet  =  attributes.get(tagName);  currentSet.addAll(attributeSet);  }  else  {  attributes.put(tagName,  attributeSet);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addAttributes  [RETURN_TYPE]  Whitelist      String  tag    keys  [VARIABLES]  Set    attributeSet    currentSet    tagNames    String    key    tag    tagName    value    String[]    keys    boolean    TagName    tagName    Map    attributes    enforcedAttributes    protocols    
Validate.notEmpty  (  tag  )  ;	[BUGGY]  Validate  .notNull(  keys)  ;  [CONTEXT]  public  Whitelist  addAttributes(String  tag,  String...  keys)  {  [BUGGY]  Validate  .notNull  (  keys  );  Validate.notNull(keys);    TagName  tagName  =  TagName.valueOf(tag);  Set<AttributeKey>  attributeSet  =  new  HashSet<AttributeKey>();  for  (String  key  :  keys)  {  Validate.notEmpty(key);  attributeSet.add(AttributeKey.valueOf(key));  }  if  (attributes.containsKey(tagName))  {  Set<AttributeKey>  currentSet  =  attributes.get(tagName);  currentSet.addAll(attributeSet);  }  else  {  attributes.put(tagName,  attributeSet);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addAttributes  [RETURN_TYPE]  Whitelist      String  tag    keys  [VARIABLES]  Set    attributeSet    currentSet    tagNames    String    key    tag    tagName    value    String[]    keys    boolean    TagName    tagName    Map    attributes    enforcedAttributes    protocols    
Validate.notEmpty  (  tag  )  ;	[BUGGY]    [CONTEXT]  public  Whitelist  addAttributes(String  tag,  String...  keys)  {  [BUGGY]  Validate.notEmpty(tag);    Validate.notNull(keys);    TagName  tagName  =  TagName.valueOf(tag);  Set<AttributeKey>  attributeSet  =  new  HashSet<AttributeKey>();  for  (String  key  :  keys)  {  Validate.notEmpty(key);  attributeSet.add(AttributeKey.valueOf(key));  }  if  (attributes.containsKey(tagName))  {  Set<AttributeKey>  currentSet  =  attributes.get(tagName);  currentSet.addAll(attributeSet);  }  else  {  attributes.put(tagName,  attributeSet);  }  return  this;        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addAttributes  [RETURN_TYPE]  Whitelist      String  tag    keys  [VARIABLES]  Set    attributeSet    currentSet    tagNames    String    key    tag    tagName    value    String[]    keys    boolean    TagName    tagName    Map    attributes    enforcedAttributes    protocols    
Validate.notEmpty  (  tag  )  ;  Validate.notNull  (  keys  )  ;	[BUGGY]  Validate.notNull(  keys);  Validate.notEmpty(  tag);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addAttributes  [RETURN_TYPE]  Whitelist      String  tag    keys  [VARIABLES]  Set    attributeSet    currentSet    tagNames    String    key    tag    tagName    value    String[]    keys    boolean    TagName    tagName    Map    attributes    enforcedAttributes    protocols    
Validate.notEmpty  (  tag  )  ;  Validate.notNull  (  keys  )  ;	[BUGGY]  Validate.notEmpty(  value);Validate.notEmpty(  tag);  Validate.notNull(  keys);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addAttributes  [RETURN_TYPE]  Whitelist      String  tag    keys  [VARIABLES]  Set    attributeSet    currentSet    tagNames    String    key    tag    tagName    value    String[]    keys    boolean    TagName    tagName    Map    attributes    enforcedAttributes    protocols    
Validate.notEmpty  (  tag  )  ;  Validate.notNull  (  keys  )  ;	[BUGGY]  Validate.notEmpty(  tagName);Validate.notEmpty(  tag);  Validate.notNull(  keys);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addAttributes  [RETURN_TYPE]  Whitelist      String  tag    keys  [VARIABLES]  Set    attributeSet    currentSet    tagNames    String    key    tag    tagName    value    String[]    keys    boolean    TagName    tagName    Map    attributes    enforcedAttributes    protocols    
Validate.notNull  (  keys  )  ;	[BUGGY]    [CONTEXT]  public  Whitelist  addAttributes(String  tag,  String...  keys)  {  Validate.notEmpty(tag);  [BUGGY]  Validate.notNull(keys);      TagName  tagName  =  TagName.valueOf(tag);  Set<AttributeKey>  attributeSet  =  new  HashSet<AttributeKey>();  for  (String  key  :  keys)  {  Validate.notEmpty(key);  attributeSet.add(AttributeKey.valueOf(key));  }  if  (attributes.containsKey(tagName))  {  Set<AttributeKey>  currentSet  =  attributes.get(tagName);  currentSet.addAll(attributeSet);  }  else  {  attributes.put(tagName,  attributeSet);  }  return  this;        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addAttributes  [RETURN_TYPE]  Whitelist      String  tag    keys  [VARIABLES]  Set    attributeSet    currentSet    tagNames    String    key    tag    tagName    value    String[]    keys    boolean    TagName    tagName    Map    attributes    enforcedAttributes    protocols    
TagName  tagName  =  TagName.valueOf  (  tag  )  ;	[BUGGY]  TagName  valueName  =  TagName.valueOf(  tag);  [CONTEXT]  public  Whitelist  addAttributes(String  tag,  String...  keys)  {  Validate.notEmpty(tag);  Validate.notNull(keys);    [BUGGY]  TagName  valueName  =  TagName.valueOf  (  tag  )  ;  Set<AttributeKey>  attributeSet  =  new  HashSet<AttributeKey>();  for  (String  key  :  keys)  {  Validate.notEmpty(key);  attributeSet.add(AttributeKey.valueOf(key));  }  if  (attributes.containsKey(tagName))  {  Set<AttributeKey>  currentSet  =  attributes.get(tagName);  currentSet.addAll(attributeSet);  }  else  {  attributes.put(tagName,  attributeSet);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addAttributes  [RETURN_TYPE]  Whitelist      String  tag    keys  [VARIABLES]  Set    attributeSet    currentSet    tagNames    String    key    tag    tagName    value    String[]    keys    boolean    TagName    tagName    Map    attributes    enforcedAttributes    protocols    
TagName  tagName  =  TagName.valueOf  (  tag  )  ;	[BUGGY]  TagName  tagName  =  TagName.TagName(  tag);  [CONTEXT]  public  Whitelist  addAttributes(String  tag,  String...  keys)  {  Validate.notEmpty(tag);  Validate.notNull(keys);    [BUGGY]  TagName  tagName  =  TagName.TagName  (  tag  )  ;  Set<AttributeKey>  attributeSet  =  new  HashSet<AttributeKey>();  for  (String  key  :  keys)  {  Validate.notEmpty(key);  attributeSet.add(AttributeKey.valueOf(key));  }  if  (attributes.containsKey(tagName))  {  Set<AttributeKey>  currentSet  =  attributes.get(tagName);  currentSet.addAll(attributeSet);  }  else  {  attributes.put(tagName,  attributeSet);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addAttributes  [RETURN_TYPE]  Whitelist      String  tag    keys  [VARIABLES]  Set    attributeSet    currentSet    tagNames    String    key    tag    tagName    value    String[]    keys    boolean    TagName    tagName    Map    attributes    enforcedAttributes    protocols    
TagName  tagName  =  TagName.valueOf  (  tag  )  ;	[BUGGY]  TagName  tagName  =  TagName  .TagName(  tagName)  ;  [CONTEXT]  public  Whitelist  addAttributes(String  tag,  String...  keys)  {  Validate.notEmpty(tag);  Validate.notNull(keys);    [BUGGY]  TagName  tagName  =  TagName  .TagName  (  tagName  );  Set<AttributeKey>  attributeSet  =  new  HashSet<AttributeKey>();  for  (String  key  :  keys)  {  Validate.notEmpty(key);  attributeSet.add(AttributeKey.valueOf(key));  }  if  (attributes.containsKey(tagName))  {  Set<AttributeKey>  currentSet  =  attributes.get(tagName);  currentSet.addAll(attributeSet);  }  else  {  attributes.put(tagName,  attributeSet);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addAttributes  [RETURN_TYPE]  Whitelist      String  tag    keys  [VARIABLES]  Set    attributeSet    currentSet    tagNames    String    key    tag    tagName    value    String[]    keys    boolean    TagName    tagName    Map    attributes    enforcedAttributes    protocols    
TagName  tagName  =  TagName.valueOf  (  tag  )  ;	[BUGGY]  TagName  valueName  =  TagName  .TagName(  key)  ;  [CONTEXT]  public  Whitelist  addAttributes(String  tag,  String...  keys)  {  Validate.notEmpty(tag);  Validate.notNull(keys);    [BUGGY]  TagName  valueName  =  TagName  .TagName  (  key  );  Set<AttributeKey>  attributeSet  =  new  HashSet<AttributeKey>();  for  (String  key  :  keys)  {  Validate.notEmpty(key);  attributeSet.add(AttributeKey.valueOf(key));  }  if  (attributes.containsKey(tagName))  {  Set<AttributeKey>  currentSet  =  attributes.get(tagName);  currentSet.addAll(attributeSet);  }  else  {  attributes.put(tagName,  attributeSet);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addAttributes  [RETURN_TYPE]  Whitelist      String  tag    keys  [VARIABLES]  Set    attributeSet    currentSet    tagNames    String    key    tag    tagName    value    String[]    keys    boolean    TagName    tagName    Map    attributes    enforcedAttributes    protocols    
TagName  tagName  =  TagName.valueOf  (  tag  )  ;	[BUGGY]  for  (  String  key  :  keys)  {  TagName  tagName  =  TagName.valueOf(  tag);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addAttributes  [RETURN_TYPE]  Whitelist      String  tag    keys  [VARIABLES]  Set    attributeSet    currentSet    tagNames    String    key    tag    tagName    value    String[]    keys    boolean    TagName    tagName    Map    attributes    enforcedAttributes    protocols    
TagName  tagName  =  TagName.valueOf  (  tag  )  ;	[BUGGY]  TagName  tag  =  TagName.valueOf(  tagName);TagName  tagName  =  TagName.valueOf(  tag);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addAttributes  [RETURN_TYPE]  Whitelist      String  tag    keys  [VARIABLES]  Set    attributeSet    currentSet    tagNames    String    key    tag    tagName    value    String[]    keys    boolean    TagName    tagName    Map    attributes    enforcedAttributes    protocols    
TagName  tagName  =  TagName.valueOf  (  tag  )  ;	[BUGGY]    [CONTEXT]  public  Whitelist  addAttributes(String  tag,  String...  keys)  {  Validate.notEmpty(tag);  Validate.notNull(keys);    [BUGGY]  TagName  tagName  =  TagName.valueOf(tag);    Set<AttributeKey>  attributeSet  =  new  HashSet<AttributeKey>();  for  (String  key  :  keys)  {  Validate.notEmpty(key);  attributeSet.add(AttributeKey.valueOf(key));  }  if  (attributes.containsKey(tagName))  {  Set<AttributeKey>  currentSet  =  attributes.get(tagName);  currentSet.addAll(attributeSet);  }  else  {  attributes.put(tagName,  attributeSet);  }  return  this;        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addAttributes  [RETURN_TYPE]  Whitelist      String  tag    keys  [VARIABLES]  Set    attributeSet    currentSet    tagNames    String    key    tag    tagName    value    String[]    keys    boolean    TagName    tagName    Map    attributes    enforcedAttributes    protocols    
TagName  tagName  =  TagName.valueOf  (  tag  )  ;	[BUGGY]  Set<AttributeKey>  attributeSet  =  new  HashSet<AttributeKey>(  );  TagName  tagName  =  TagName.valueOf(  tag);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addAttributes  [RETURN_TYPE]  Whitelist      String  tag    keys  [VARIABLES]  Set    attributeSet    currentSet    tagNames    String    key    tag    tagName    value    String[]    keys    boolean    TagName    tagName    Map    attributes    enforcedAttributes    protocols    
TagName  tagName  =  TagName.valueOf  (  tag  )  ;	[BUGGY]  tagNames.add(  TagName.valueOf(  tagName));TagName  tagName  =  TagName.valueOf(  tag);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addAttributes  [RETURN_TYPE]  Whitelist      String  tag    keys  [VARIABLES]  Set    attributeSet    currentSet    tagNames    String    key    tag    tagName    value    String[]    keys    boolean    TagName    tagName    Map    attributes    enforcedAttributes    protocols    
TagName  tagName  =  TagName.valueOf  (  tag  )  ;	[BUGGY]  return  tagNames.contains(  TagName.valueOf(  tag));TagName  tagName  =  TagName.valueOf(  tag);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addAttributes  [RETURN_TYPE]  Whitelist      String  tag    keys  [VARIABLES]  Set    attributeSet    currentSet    tagNames    String    key    tag    tagName    value    String[]    keys    boolean    TagName    tagName    Map    attributes    enforcedAttributes    protocols    
Set<AttributeKey>  attributeSet  =  new  HashSet<AttributeKey>  (  )  ;	[BUGGY]  Set<AttributeKey>  attributeSet  =  Set<AttributeKey>  attributeSet  =    new  Protocol>(  )  ;  [CONTEXT]  public  Whitelist  addAttributes(String  tag,  String...  keys)  {  Validate.notEmpty(tag);  Validate.notNull(keys);    TagName  tagName  =  TagName.valueOf(tag);  [BUGGY]  Set<AttributeKey>  attributeSet  =  Set<AttributeKey>  attributeSet  =new  Protocol>  ();  for  (String  key  :  keys)  {  Validate.notEmpty(key);  attributeSet.add(AttributeKey.valueOf(key));  }  if  (attributes.containsKey(tagName))  {  Set<AttributeKey>  currentSet  =  attributes.get(tagName);  currentSet.addAll(attributeSet);  }  else  {  attributes.put(tagName,  attributeSet);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addAttributes  [RETURN_TYPE]  Whitelist      String  tag    keys  [VARIABLES]  Set    attributeSet    currentSet    tagNames    String    key    tag    tagName    value    String[]    keys    boolean    TagName    tagName    Map    attributes    enforcedAttributes    protocols    
for  (  String  key  :  keys  )  {	[BUGGY]  for  (  char  key  :  keys)  {  [CONTEXT]  public  Whitelist  addAttributes(String  tag,  String...  keys)  {  Validate.notEmpty(tag);  Validate.notNull(keys);    TagName  tagName  =  TagName.valueOf(tag);  Set<AttributeKey>  attributeSet  =  new  HashSet<AttributeKey>();  [BUGGY]  for(  char  key  :  keys  ){  Validate.notEmpty(key);  attributeSet.add(AttributeKey.valueOf(key));  }  if  (attributes.containsKey(tagName))  {  Set<AttributeKey>  currentSet  =  attributes.get(tagName);  currentSet.addAll(attributeSet);  }  else  {  attributes.put(tagName,  attributeSet);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addAttributes  [RETURN_TYPE]  Whitelist      String  tag    keys  [VARIABLES]  Set    attributeSet    currentSet    tagNames    String    key    tag    tagName    value    String[]    keys    boolean    TagName    tagName    Map    attributes    enforcedAttributes    protocols    
Validate.notEmpty  (  key  )  ;	[BUGGY]  Validate.notEmpty(  value);  [CONTEXT]  public  Whitelist  addAttributes(String  tag,  String...  keys)  {  Validate.notEmpty(tag);  Validate.notNull(keys);    TagName  tagName  =  TagName.valueOf(tag);  Set<AttributeKey>  attributeSet  =  new  HashSet<AttributeKey>();  for  (String  key  :  keys)  {  [BUGGY]  Validate.notEmpty  (  value  )  ;  attributeSet.add(AttributeKey.valueOf(key));  }  if  (attributes.containsKey(tagName))  {  Set<AttributeKey>  currentSet  =  attributes.get(tagName);  currentSet.addAll(attributeSet);  }  else  {  attributes.put(tagName,  attributeSet);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addAttributes  [RETURN_TYPE]  Whitelist      String  tag    keys  [VARIABLES]  Set    attributeSet    currentSet    tagNames    String    key    tag    tagName    value    String[]    keys    boolean    TagName    tagName    Map    attributes    enforcedAttributes    protocols    
Validate.notEmpty  (  key  )  ;  attributeSet.add  (  AttributeKey.valueOf  (  key  )  )  ;	[BUGGY]    [CONTEXT]  public  Whitelist  addAttributes(String  tag,  String...  keys)  {  Validate.notEmpty(tag);  Validate.notNull(keys);    TagName  tagName  =  TagName.valueOf(tag);  Set<AttributeKey>  attributeSet  =  new  HashSet<AttributeKey>();  for  (String  key  :  keys)  {  [BUGGY]  Validate.notEmpty(key);      }  if  (attributes.containsKey(tagName))  {  Set<AttributeKey>  currentSet  =  attributes.get(tagName);  currentSet.addAll(attributeSet);  }  else  {  attributes.put(tagName,  attributeSet);  }  return  this;        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addAttributes  [RETURN_TYPE]  Whitelist      String  tag    keys  [VARIABLES]  Set    attributeSet    currentSet    tagNames    String    key    tag    tagName    value    String[]    keys    boolean    TagName    tagName    Map    attributes    enforcedAttributes    protocols    
Validate.notEmpty  (  key  )  ;  attributeSet.add  (  AttributeKey.valueOf  (  key  )  )  ;	[BUGGY]  attributeSet.add(  AttributeKey.valueOf(  key));  Validate.notEmpty(  key);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addAttributes  [RETURN_TYPE]  Whitelist      String  tag    keys  [VARIABLES]  Set    attributeSet    currentSet    tagNames    String    key    tag    tagName    value    String[]    keys    boolean    TagName    tagName    Map    attributes    enforcedAttributes    protocols    
Validate.notEmpty  (  key  )  ;  attributeSet.add  (  AttributeKey.valueOf  (  key  )  )  ;	[BUGGY]  AttributeKey  attrKey  =  AttributeKey.valueOf(  key);Validate.notEmpty(  key);  attributeSet.add(  AttributeKey.valueOf(  key));  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addAttributes  [RETURN_TYPE]  Whitelist      String  tag    keys  [VARIABLES]  Set    attributeSet    currentSet    tagNames    String    key    tag    tagName    value    String[]    keys    boolean    TagName    tagName    Map    attributes    enforcedAttributes    protocols    
Validate.notEmpty  (  key  )  ;  attributeSet.add  (  AttributeKey.valueOf  (  key  )  )  ;	[BUGGY]  attributeSet.add(  AttributeKey.valueOf(  key));Validate.notEmpty(  key);  attributeSet.add(  AttributeKey.valueOf(  key));  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addAttributes  [RETURN_TYPE]  Whitelist      String  tag    keys  [VARIABLES]  Set    attributeSet    currentSet    tagNames    String    key    tag    tagName    value    String[]    keys    boolean    TagName    tagName    Map    attributes    enforcedAttributes    protocols    
attributeSet.add  (  AttributeKey.valueOf  (  key  )  )  ;	[BUGGY]  attributeSet  .add(  )  ;  [CONTEXT]  public  Whitelist  addAttributes(String  tag,  String...  keys)  {  Validate.notEmpty(tag);  Validate.notNull(keys);    TagName  tagName  =  TagName.valueOf(tag);  Set<AttributeKey>  attributeSet  =  new  HashSet<AttributeKey>();  for  (String  key  :  keys)  {  Validate.notEmpty(key);  [BUGGY]  attributeSet  .add  ();  }  if  (attributes.containsKey(tagName))  {  Set<AttributeKey>  currentSet  =  attributes.get(tagName);  currentSet.addAll(attributeSet);  }  else  {  attributes.put(tagName,  attributeSet);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addAttributes  [RETURN_TYPE]  Whitelist      String  tag    keys  [VARIABLES]  Set    attributeSet    currentSet    tagNames    String    key    tag    tagName    value    String[]    keys    boolean    TagName    tagName    Map    attributes    enforcedAttributes    protocols    
attributeSet.add  (  AttributeKey.valueOf  (  key  )  )  ;	[BUGGY]  attributeSet.add(  AttributeKey.AttributeKey(  key));  [CONTEXT]  public  Whitelist  addAttributes(String  tag,  String...  keys)  {  Validate.notEmpty(tag);  Validate.notNull(keys);    TagName  tagName  =  TagName.valueOf(tag);  Set<AttributeKey>  attributeSet  =  new  HashSet<AttributeKey>();  for  (String  key  :  keys)  {  Validate.notEmpty(key);  [BUGGY]  attributeSet.add  (  AttributeKey.AttributeKey  (  key  ))  ;  }  if  (attributes.containsKey(tagName))  {  Set<AttributeKey>  currentSet  =  attributes.get(tagName);  currentSet.addAll(attributeSet);  }  else  {  attributes.put(tagName,  attributeSet);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addAttributes  [RETURN_TYPE]  Whitelist      String  tag    keys  [VARIABLES]  Set    attributeSet    currentSet    tagNames    String    key    tag    tagName    value    String[]    keys    boolean    TagName    tagName    Map    attributes    enforcedAttributes    protocols    
attributeSet.add  (  AttributeKey.valueOf  (  key  )  )  ;	[BUGGY]  attributeSet.add(  AttributeKey.valueOf(  value));  [CONTEXT]  public  Whitelist  addAttributes(String  tag,  String...  keys)  {  Validate.notEmpty(tag);  Validate.notNull(keys);    TagName  tagName  =  TagName.valueOf(tag);  Set<AttributeKey>  attributeSet  =  new  HashSet<AttributeKey>();  for  (String  key  :  keys)  {  Validate.notEmpty(key);  [BUGGY]  attributeSet.add  (  AttributeKey.valueOf  (  value  ))  ;  }  if  (attributes.containsKey(tagName))  {  Set<AttributeKey>  currentSet  =  attributes.get(tagName);  currentSet.addAll(attributeSet);  }  else  {  attributes.put(tagName,  attributeSet);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addAttributes  [RETURN_TYPE]  Whitelist      String  tag    keys  [VARIABLES]  Set    attributeSet    currentSet    tagNames    String    key    tag    tagName    value    String[]    keys    boolean    TagName    tagName    Map    attributes    enforcedAttributes    protocols    
attributeSet.add  (  AttributeKey.valueOf  (  key  )  )  ;	[BUGGY]    [CONTEXT]  public  Whitelist  addAttributes(String  tag,  String...  keys)  {  Validate.notEmpty(tag);  Validate.notNull(keys);    TagName  tagName  =  TagName.valueOf(tag);  Set<AttributeKey>  attributeSet  =  new  HashSet<AttributeKey>();  for  (String  key  :  keys)  {  Validate.notEmpty(key);  [BUGGY]  attributeSet.add(AttributeKey.valueOf(key));    }  if  (attributes.containsKey(tagName))  {  Set<AttributeKey>  currentSet  =  attributes.get(tagName);  currentSet.addAll(attributeSet);  }  else  {  attributes.put(tagName,  attributeSet);  }  return  this;        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addAttributes  [RETURN_TYPE]  Whitelist      String  tag    keys  [VARIABLES]  Set    attributeSet    currentSet    tagNames    String    key    tag    tagName    value    String[]    keys    boolean    TagName    tagName    Map    attributes    enforcedAttributes    protocols    
attributeSet.add  (  AttributeKey.valueOf  (  key  )  )  ;	[BUGGY]  attributeSet.add(  AttributeKey.AttributeKey(  value));  [CONTEXT]  public  Whitelist  addAttributes(String  tag,  String...  keys)  {  Validate.notEmpty(tag);  Validate.notNull(keys);    TagName  tagName  =  TagName.valueOf(tag);  Set<AttributeKey>  attributeSet  =  new  HashSet<AttributeKey>();  for  (String  key  :  keys)  {  Validate.notEmpty(key);  [BUGGY]  attributeSet.add  (  AttributeKey.AttributeKey  (  value  ))  ;  }  if  (attributes.containsKey(tagName))  {  Set<AttributeKey>  currentSet  =  attributes.get(tagName);  currentSet.addAll(attributeSet);  }  else  {  attributes.put(tagName,  attributeSet);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addAttributes  [RETURN_TYPE]  Whitelist      String  tag    keys  [VARIABLES]  Set    attributeSet    currentSet    tagNames    String    key    tag    tagName    value    String[]    keys    boolean    TagName    tagName    Map    attributes    enforcedAttributes    protocols    
if  (  attributes.containsKey  (  tagName  )  )  {	[BUGGY]  if  (  attributes  .entrySet(  )  )  {  [CONTEXT]  public  Whitelist  addAttributes(String  tag,  String...  keys)  {  Validate.notEmpty(tag);  Validate.notNull(keys);    TagName  tagName  =  TagName.valueOf(tag);  Set<AttributeKey>  attributeSet  =  new  HashSet<AttributeKey>();  for  (String  key  :  keys)  {  Validate.notEmpty(key);  attributeSet.add(AttributeKey.valueOf(key));  }  [BUGGY]  if(  attributes  .entrySet  ()  ){  Set<AttributeKey>  currentSet  =  attributes.get(tagName);  currentSet.addAll(attributeSet);  }  else  {  attributes.put(tagName,  attributeSet);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addAttributes  [RETURN_TYPE]  Whitelist      String  tag    keys  [VARIABLES]  Set    attributeSet    currentSet    tagNames    String    key    tag    tagName    value    String[]    keys    boolean    TagName    tagName    Map    attributes    enforcedAttributes    protocols    
if  (  attributes.containsKey  (  tagName  )  )  {	[BUGGY]  if  (  attrMap.containsKey(  attrKey))  {  [CONTEXT]  public  Whitelist  addAttributes(String  tag,  String...  keys)  {  Validate.notEmpty(tag);  Validate.notNull(keys);    TagName  tagName  =  TagName.valueOf(tag);  Set<AttributeKey>  attributeSet  =  new  HashSet<AttributeKey>();  for  (String  key  :  keys)  {  Validate.notEmpty(key);  attributeSet.add(AttributeKey.valueOf(key));  }  [BUGGY]  if(  attrMap.containsKey  (  attrKey  )){  Set<AttributeKey>  currentSet  =  attributes.get(tagName);  currentSet.addAll(attributeSet);  }  else  {  attributes.put(tagName,  attributeSet);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addAttributes  [RETURN_TYPE]  Whitelist      String  tag    keys  [VARIABLES]  Set    attributeSet    currentSet    tagNames    String    key    tag    tagName    value    String[]    keys    boolean    TagName    tagName    Map    attributes    enforcedAttributes    protocols    
if  (  attributes.containsKey  (  tagName  )  )  {	[BUGGY]  if  (  enforcedAttributes.containsKey(  tagName))  {  [CONTEXT]  public  Whitelist  addAttributes(String  tag,  String...  keys)  {  Validate.notEmpty(tag);  Validate.notNull(keys);    TagName  tagName  =  TagName.valueOf(tag);  Set<AttributeKey>  attributeSet  =  new  HashSet<AttributeKey>();  for  (String  key  :  keys)  {  Validate.notEmpty(key);  attributeSet.add(AttributeKey.valueOf(key));  }  [BUGGY]  if(  enforcedAttributes.containsKey  (  tagName  )){  Set<AttributeKey>  currentSet  =  attributes.get(tagName);  currentSet.addAll(attributeSet);  }  else  {  attributes.put(tagName,  attributeSet);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addAttributes  [RETURN_TYPE]  Whitelist      String  tag    keys  [VARIABLES]  Set    attributeSet    currentSet    tagNames    String    key    tag    tagName    value    String[]    keys    boolean    TagName    tagName    Map    attributes    enforcedAttributes    protocols    
if  (  attributes.containsKey  (  tagName  )  )  {	[BUGGY]  if  (  attributes.containsKey(  tag))  {  [CONTEXT]  public  Whitelist  addAttributes(String  tag,  String...  keys)  {  Validate.notEmpty(tag);  Validate.notNull(keys);    TagName  tagName  =  TagName.valueOf(tag);  Set<AttributeKey>  attributeSet  =  new  HashSet<AttributeKey>();  for  (String  key  :  keys)  {  Validate.notEmpty(key);  attributeSet.add(AttributeKey.valueOf(key));  }  [BUGGY]  if(  attributes.containsKey  (  tag  )){  Set<AttributeKey>  currentSet  =  attributes.get(tagName);  currentSet.addAll(attributeSet);  }  else  {  attributes.put(tagName,  attributeSet);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addAttributes  [RETURN_TYPE]  Whitelist      String  tag    keys  [VARIABLES]  Set    attributeSet    currentSet    tagNames    String    key    tag    tagName    value    String[]    keys    boolean    TagName    tagName    Map    attributes    enforcedAttributes    protocols    
if  (  attributes.containsKey  (  tagName  )  )  {	[BUGGY]  if  (  enforcedAttributes.containsKey(  tag))  {  [CONTEXT]  public  Whitelist  addAttributes(String  tag,  String...  keys)  {  Validate.notEmpty(tag);  Validate.notNull(keys);    TagName  tagName  =  TagName.valueOf(tag);  Set<AttributeKey>  attributeSet  =  new  HashSet<AttributeKey>();  for  (String  key  :  keys)  {  Validate.notEmpty(key);  attributeSet.add(AttributeKey.valueOf(key));  }  [BUGGY]  if(  enforcedAttributes.containsKey  (  tag  )){  Set<AttributeKey>  currentSet  =  attributes.get(tagName);  currentSet.addAll(attributeSet);  }  else  {  attributes.put(tagName,  attributeSet);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addAttributes  [RETURN_TYPE]  Whitelist      String  tag    keys  [VARIABLES]  Set    attributeSet    currentSet    tagNames    String    key    tag    tagName    value    String[]    keys    boolean    TagName    tagName    Map    attributes    enforcedAttributes    protocols    
if  (  attributes.containsKey  (  tagName  )  )  {	[BUGGY]  if  (  this.protocols.containsKey(  tagName))  {  [CONTEXT]  public  Whitelist  addAttributes(String  tag,  String...  keys)  {  Validate.notEmpty(tag);  Validate.notNull(keys);    TagName  tagName  =  TagName.valueOf(tag);  Set<AttributeKey>  attributeSet  =  new  HashSet<AttributeKey>();  for  (String  key  :  keys)  {  Validate.notEmpty(key);  attributeSet.add(AttributeKey.valueOf(key));  }  [BUGGY]  if(  this.protocols.containsKey  (  tagName  )){  Set<AttributeKey>  currentSet  =  attributes.get(tagName);  currentSet.addAll(attributeSet);  }  else  {  attributes.put(tagName,  attributeSet);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addAttributes  [RETURN_TYPE]  Whitelist      String  tag    keys  [VARIABLES]  Set    attributeSet    currentSet    tagNames    String    key    tag    tagName    value    String[]    keys    boolean    TagName    tagName    Map    attributes    enforcedAttributes    protocols    
if  (  attributes.containsKey  (  tagName  )  )  {	[BUGGY]  if  (  protocols.containsKey(  tag))  {  [CONTEXT]  public  Whitelist  addAttributes(String  tag,  String...  keys)  {  Validate.notEmpty(tag);  Validate.notNull(keys);    TagName  tagName  =  TagName.valueOf(tag);  Set<AttributeKey>  attributeSet  =  new  HashSet<AttributeKey>();  for  (String  key  :  keys)  {  Validate.notEmpty(key);  attributeSet.add(AttributeKey.valueOf(key));  }  [BUGGY]  if(  protocols.containsKey  (  tag  )){  Set<AttributeKey>  currentSet  =  attributes.get(tagName);  currentSet.addAll(attributeSet);  }  else  {  attributes.put(tagName,  attributeSet);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addAttributes  [RETURN_TYPE]  Whitelist      String  tag    keys  [VARIABLES]  Set    attributeSet    currentSet    tagNames    String    key    tag    tagName    value    String[]    keys    boolean    TagName    tagName    Map    attributes    enforcedAttributes    protocols    
if  (  attributes.containsKey  (  tagName  )  )  {  Set<AttributeKey>  currentSet  =  attributes.get  (  tagName  )  ;  currentSet.addAll  (  attributeSet  )  ;  }  else  {  attributes.put  (  tagName,  attributeSet  )  ;  }	[BUGGY]  java.util.Set<org.jsoup.safety.Whitelist.AttributeKey>  currentSet  =  attributes.get(tagName);  currentSet.addAll(attributeSet);  [CONTEXT]  public  Whitelist  addAttributes(String  tag,  String...  keys)  {  Validate.notEmpty(tag);  Validate.notNull(keys);    TagName  tagName  =  TagName.valueOf(tag);  Set<AttributeKey>  attributeSet  =  new  HashSet<AttributeKey>();  for  (String  key  :  keys)  {  Validate.notEmpty(key);  attributeSet.add(AttributeKey.valueOf(key));  }  [BUGGY]  if  (attributes.containsKey(tagName))  {    java.util.Set<org.jsoup.safety.Whitelist.AttributeKey>  currentSet  =  attributes.get(tagName);  currentSet.addAll(attributeSet);        }  return  this;        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addAttributes  [RETURN_TYPE]  Whitelist      String  tag    keys  [VARIABLES]  Set    attributeSet    currentSet    tagNames    String    key    tag    tagName    value    String[]    keys    boolean    TagName    tagName    Map    attributes    enforcedAttributes    protocols    
if  (  attributes.containsKey  (  tagName  )  )  {  Set<AttributeKey>  currentSet  =  attributes.get  (  tagName  )  ;  currentSet.addAll  (  attributeSet  )  ;  }  else  {  attributes.put  (  tagName,  attributeSet  )  ;  }	[BUGGY]    [CONTEXT]  public  Whitelist  addAttributes(String  tag,  String...  keys)  {  Validate.notEmpty(tag);  Validate.notNull(keys);    TagName  tagName  =  TagName.valueOf(tag);  Set<AttributeKey>  attributeSet  =  new  HashSet<AttributeKey>();  for  (String  key  :  keys)  {  Validate.notEmpty(key);  attributeSet.add(AttributeKey.valueOf(key));  }  [BUGGY]  if  (attributes.containsKey(tagName))  {            }  return  this;        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addAttributes  [RETURN_TYPE]  Whitelist      String  tag    keys  [VARIABLES]  Set    attributeSet    currentSet    tagNames    String    key    tag    tagName    value    String[]    keys    boolean    TagName    tagName    Map    attributes    enforcedAttributes    protocols    
attributes.put  (  tagName,  attributeSet  )  ;	[BUGGY]  attributes.put(  attributeSet,  tagName);  [CONTEXT]  public  Whitelist  addAttributes(String  tag,  String...  keys)  {  Validate.notEmpty(tag);  Validate.notNull(keys);    TagName  tagName  =  TagName.valueOf(tag);  Set<AttributeKey>  attributeSet  =  new  HashSet<AttributeKey>();  for  (String  key  :  keys)  {  Validate.notEmpty(key);  attributeSet.add(AttributeKey.valueOf(key));  }  if  (attributes.containsKey(tagName))  {  Set<AttributeKey>  currentSet  =  attributes.get(tagName);  currentSet.addAll(attributeSet);  }  else  {  [BUGGY]  attributes.put  (  attributeSet,  tagName  )  ;  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addAttributes  [RETURN_TYPE]  Whitelist      String  tag    keys  [VARIABLES]  Set    attributeSet    currentSet    tagNames    String    key    tag    tagName    value    String[]    keys    boolean    TagName    tagName    Map    attributes    enforcedAttributes    protocols    
attributes.put  (  tagName,  attributeSet  )  ;	[BUGGY]  attributes.put(    attributeSet);  [CONTEXT]  public  Whitelist  addAttributes(String  tag,  String...  keys)  {  Validate.notEmpty(tag);  Validate.notNull(keys);    TagName  tagName  =  TagName.valueOf(tag);  Set<AttributeKey>  attributeSet  =  new  HashSet<AttributeKey>();  for  (String  key  :  keys)  {  Validate.notEmpty(key);  attributeSet.add(AttributeKey.valueOf(key));  }  if  (attributes.containsKey(tagName))  {  Set<AttributeKey>  currentSet  =  attributes.get(tagName);  currentSet.addAll(attributeSet);  }  else  {  [BUGGY]  attributes.put  (attributeSet  )  ;  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addAttributes  [RETURN_TYPE]  Whitelist      String  tag    keys  [VARIABLES]  Set    attributeSet    currentSet    tagNames    String    key    tag    tagName    value    String[]    keys    boolean    TagName    tagName    Map    attributes    enforcedAttributes    protocols    
attributes.put  (  tagName,  attributeSet  )  ;	[BUGGY]  attributes.put(  tagName);  [CONTEXT]  public  Whitelist  addAttributes(String  tag,  String...  keys)  {  Validate.notEmpty(tag);  Validate.notNull(keys);    TagName  tagName  =  TagName.valueOf(tag);  Set<AttributeKey>  attributeSet  =  new  HashSet<AttributeKey>();  for  (String  key  :  keys)  {  Validate.notEmpty(key);  attributeSet.add(AttributeKey.valueOf(key));  }  if  (attributes.containsKey(tagName))  {  Set<AttributeKey>  currentSet  =  attributes.get(tagName);  currentSet.addAll(attributeSet);  }  else  {  [BUGGY]  attributes.put  (  tagName  )  ;  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addAttributes  [RETURN_TYPE]  Whitelist      String  tag    keys  [VARIABLES]  Set    attributeSet    currentSet    tagNames    String    key    tag    tagName    value    String[]    keys    boolean    TagName    tagName    Map    attributes    enforcedAttributes    protocols    
attributes.put  (  tagName,  attributeSet  )  ;	[BUGGY]  attributes  .put(  )  ;  [CONTEXT]  public  Whitelist  addAttributes(String  tag,  String...  keys)  {  Validate.notEmpty(tag);  Validate.notNull(keys);    TagName  tagName  =  TagName.valueOf(tag);  Set<AttributeKey>  attributeSet  =  new  HashSet<AttributeKey>();  for  (String  key  :  keys)  {  Validate.notEmpty(key);  attributeSet.add(AttributeKey.valueOf(key));  }  if  (attributes.containsKey(tagName))  {  Set<AttributeKey>  currentSet  =  attributes.get(tagName);  currentSet.addAll(attributeSet);  }  else  {  [BUGGY]  attributes  .put  ();  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addAttributes  [RETURN_TYPE]  Whitelist      String  tag    keys  [VARIABLES]  Set    attributeSet    currentSet    tagNames    String    key    tag    tagName    value    String[]    keys    boolean    TagName    tagName    Map    attributes    enforcedAttributes    protocols    
attributes.put  (  tagName,  attributeSet  )  ;	[BUGGY]  attributes.put(  tagName,  null);  [CONTEXT]  public  Whitelist  addAttributes(String  tag,  String...  keys)  {  Validate.notEmpty(tag);  Validate.notNull(keys);    TagName  tagName  =  TagName.valueOf(tag);  Set<AttributeKey>  attributeSet  =  new  HashSet<AttributeKey>();  for  (String  key  :  keys)  {  Validate.notEmpty(key);  attributeSet.add(AttributeKey.valueOf(key));  }  if  (attributes.containsKey(tagName))  {  Set<AttributeKey>  currentSet  =  attributes.get(tagName);  currentSet.addAll(attributeSet);  }  else  {  [BUGGY]  attributes.put  (  tagName,  null  )  ;  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addAttributes  [RETURN_TYPE]  Whitelist      String  tag    keys  [VARIABLES]  Set    attributeSet    currentSet    tagNames    String    key    tag    tagName    value    String[]    keys    boolean    TagName    tagName    Map    attributes    enforcedAttributes    protocols    
attributes.put  (  tagName,  attributeSet  )  ;	[BUGGY]    [CONTEXT]  public  Whitelist  addAttributes(String  tag,  String...  keys)  {  Validate.notEmpty(tag);  Validate.notNull(keys);    TagName  tagName  =  TagName.valueOf(tag);  Set<AttributeKey>  attributeSet  =  new  HashSet<AttributeKey>();  for  (String  key  :  keys)  {  Validate.notEmpty(key);  attributeSet.add(AttributeKey.valueOf(key));  }  if  (attributes.containsKey(tagName))  {  Set<AttributeKey>  currentSet  =  attributes.get(tagName);  currentSet.addAll(attributeSet);  }  else  {  [BUGGY]  attributes.put(tagName,  attributeSet);    }  return  this;        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addAttributes  [RETURN_TYPE]  Whitelist      String  tag    keys  [VARIABLES]  Set    attributeSet    currentSet    tagNames    String    key    tag    tagName    value    String[]    keys    boolean    TagName    tagName    Map    attributes    enforcedAttributes    protocols    
Set<AttributeKey>  currentSet  =  attributes.get  (  tagName  )  ;	[BUGGY]  Set<AttributeKey>  currentSet  =  tagName.get(  attributes);  [CONTEXT]  public  Whitelist  addAttributes(String  tag,  String...  keys)  {  Validate.notEmpty(tag);  Validate.notNull(keys);    TagName  tagName  =  TagName.valueOf(tag);  Set<AttributeKey>  attributeSet  =  new  HashSet<AttributeKey>();  for  (String  key  :  keys)  {  Validate.notEmpty(key);  attributeSet.add(AttributeKey.valueOf(key));  }  if  (attributes.containsKey(tagName))  {  [BUGGY]  Set<AttributeKey>  currentSet  =  tagName.get  (  attributes  )  ;  currentSet.addAll(attributeSet);  }  else  {  attributes.put(tagName,  attributeSet);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addAttributes  [RETURN_TYPE]  Whitelist      String  tag    keys  [VARIABLES]  Set    attributeSet    currentSet    tagNames    String    key    tag    tagName    value    String[]    keys    boolean    TagName    tagName    Map    attributes    enforcedAttributes    protocols    
Set<AttributeKey>  currentSet  =  attributes.get  (  tagName  )  ;	[BUGGY]  Set<AttributeKey>  currentSet  =  attributes.containsKey(  tagName);  [CONTEXT]  public  Whitelist  addAttributes(String  tag,  String...  keys)  {  Validate.notEmpty(tag);  Validate.notNull(keys);    TagName  tagName  =  TagName.valueOf(tag);  Set<AttributeKey>  attributeSet  =  new  HashSet<AttributeKey>();  for  (String  key  :  keys)  {  Validate.notEmpty(key);  attributeSet.add(AttributeKey.valueOf(key));  }  if  (attributes.containsKey(tagName))  {  [BUGGY]  Set<AttributeKey>  currentSet  =  attributes.containsKey  (  tagName  )  ;  currentSet.addAll(attributeSet);  }  else  {  attributes.put(tagName,  attributeSet);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addAttributes  [RETURN_TYPE]  Whitelist      String  tag    keys  [VARIABLES]  Set    attributeSet    currentSet    tagNames    String    key    tag    tagName    value    String[]    keys    boolean    TagName    tagName    Map    attributes    enforcedAttributes    protocols    
Set<AttributeKey>  currentSet  =  attributes.get  (  tagName  )  ;	[BUGGY]  currentSet.addAll(  attributeSet);  Set<AttributeKey>  currentSet  =  attributes.get(  tagName);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addAttributes  [RETURN_TYPE]  Whitelist      String  tag    keys  [VARIABLES]  Set    attributeSet    currentSet    tagNames    String    key    tag    tagName    value    String[]    keys    boolean    TagName    tagName    Map    attributes    enforcedAttributes    protocols    
Set<AttributeKey>  currentSet  =  attributes.get  (  tagName  )  ;	[BUGGY]  AttributeKey  attrKey  =  AttributeKey.valueOf(  key);Set<AttributeKey>  currentSet  =  attributes.get(  tagName);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addAttributes  [RETURN_TYPE]  Whitelist      String  tag    keys  [VARIABLES]  Set    attributeSet    currentSet    tagNames    String    key    tag    tagName    value    String[]    keys    boolean    TagName    tagName    Map    attributes    enforcedAttributes    protocols    
Set<AttributeKey>  currentSet  =  attributes.get  (  tagName  )  ;	[BUGGY]  Map<AttributeKey,  AttributeValue>  keyVals  =  enforcedAttributes.get(  tag);Set<AttributeKey>  currentSet  =  attributes.get(  tagName);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addAttributes  [RETURN_TYPE]  Whitelist      String  tag    keys  [VARIABLES]  Set    attributeSet    currentSet    tagNames    String    key    tag    tagName    value    String[]    keys    boolean    TagName    tagName    Map    attributes    enforcedAttributes    protocols    
Set<AttributeKey>  currentSet  =  attributes.get  (  tagName  )  ;	[BUGGY]  Set<AttributeKey>  attributeSet  =  new  HashSet<AttributeKey>(  );Set<AttributeKey>  currentSet  =  attributes.get(  tagName);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addAttributes  [RETURN_TYPE]  Whitelist      String  tag    keys  [VARIABLES]  Set    attributeSet    currentSet    tagNames    String    key    tag    tagName    value    String[]    keys    boolean    TagName    tagName    Map    attributes    enforcedAttributes    protocols    
Set<AttributeKey>  currentSet  =  attributes.get  (  tagName  )  ;	[BUGGY]    [CONTEXT]  public  Whitelist  addAttributes(String  tag,  String...  keys)  {  Validate.notEmpty(tag);  Validate.notNull(keys);    TagName  tagName  =  TagName.valueOf(tag);  Set<AttributeKey>  attributeSet  =  new  HashSet<AttributeKey>();  for  (String  key  :  keys)  {  Validate.notEmpty(key);  attributeSet.add(AttributeKey.valueOf(key));  }  if  (attributes.containsKey(tagName))  {  [BUGGY]  Set<AttributeKey>  currentSet  =  attributes.get(tagName);    currentSet.addAll(attributeSet);  }  else  {  attributes.put(tagName,  attributeSet);  }  return  this;        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addAttributes  [RETURN_TYPE]  Whitelist      String  tag    keys  [VARIABLES]  Set    attributeSet    currentSet    tagNames    String    key    tag    tagName    value    String[]    keys    boolean    TagName    tagName    Map    attributes    enforcedAttributes    protocols    
Set<AttributeKey>  currentSet  =  attributes.get  (  tagName  )  ;  currentSet.addAll  (  attributeSet  )  ;	[BUGGY]  currentSet.addAll(  attributeSet);  Set<AttributeKey>  currentSet  =  attributes.get(  tagName);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addAttributes  [RETURN_TYPE]  Whitelist      String  tag    keys  [VARIABLES]  Set    attributeSet    currentSet    tagNames    String    key    tag    tagName    value    String[]    keys    boolean    TagName    tagName    Map    attributes    enforcedAttributes    protocols    
Set<AttributeKey>  currentSet  =  attributes.get  (  tagName  )  ;  currentSet.addAll  (  attributeSet  )  ;	[BUGGY]  Set<AttributeKey>  currentSet  =  attributes.get(  tagName);Set<AttributeKey>  currentSet  =  attributes.get(  tagName);  currentSet.addAll(  attributeSet);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addAttributes  [RETURN_TYPE]  Whitelist      String  tag    keys  [VARIABLES]  Set    attributeSet    currentSet    tagNames    String    key    tag    tagName    value    String[]    keys    boolean    TagName    tagName    Map    attributes    enforcedAttributes    protocols    
currentSet.addAll  (  attributeSet  )  ;	[BUGGY]  currentSet.addAll(  null);  [CONTEXT]  public  Whitelist  addAttributes(String  tag,  String...  keys)  {  Validate.notEmpty(tag);  Validate.notNull(keys);    TagName  tagName  =  TagName.valueOf(tag);  Set<AttributeKey>  attributeSet  =  new  HashSet<AttributeKey>();  for  (String  key  :  keys)  {  Validate.notEmpty(key);  attributeSet.add(AttributeKey.valueOf(key));  }  if  (attributes.containsKey(tagName))  {  Set<AttributeKey>  currentSet  =  attributes.get(tagName);  [BUGGY]  currentSet.addAll  (  null  )  ;  }  else  {  attributes.put(tagName,  attributeSet);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addAttributes  [RETURN_TYPE]  Whitelist      String  tag    keys  [VARIABLES]  Set    attributeSet    currentSet    tagNames    String    key    tag    tagName    value    String[]    keys    boolean    TagName    tagName    Map    attributes    enforcedAttributes    protocols    
currentSet.addAll  (  attributeSet  )  ;	[BUGGY]  currentSet  .add(  )  ;  [CONTEXT]  public  Whitelist  addAttributes(String  tag,  String...  keys)  {  Validate.notEmpty(tag);  Validate.notNull(keys);    TagName  tagName  =  TagName.valueOf(tag);  Set<AttributeKey>  attributeSet  =  new  HashSet<AttributeKey>();  for  (String  key  :  keys)  {  Validate.notEmpty(key);  attributeSet.add(AttributeKey.valueOf(key));  }  if  (attributes.containsKey(tagName))  {  Set<AttributeKey>  currentSet  =  attributes.get(tagName);  [BUGGY]  currentSet  .add  ();  }  else  {  attributes.put(tagName,  attributeSet);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addAttributes  [RETURN_TYPE]  Whitelist      String  tag    keys  [VARIABLES]  Set    attributeSet    currentSet    tagNames    String    key    tag    tagName    value    String[]    keys    boolean    TagName    tagName    Map    attributes    enforcedAttributes    protocols    
currentSet.addAll  (  attributeSet  )  ;	[BUGGY]    [CONTEXT]  public  Whitelist  addAttributes(String  tag,  String...  keys)  {  Validate.notEmpty(tag);  Validate.notNull(keys);    TagName  tagName  =  TagName.valueOf(tag);  Set<AttributeKey>  attributeSet  =  new  HashSet<AttributeKey>();  for  (String  key  :  keys)  {  Validate.notEmpty(key);  attributeSet.add(AttributeKey.valueOf(key));  }  if  (attributes.containsKey(tagName))  {  Set<AttributeKey>  currentSet  =  attributes.get(tagName);  [BUGGY]  currentSet.addAll(attributeSet);    }  else  {  attributes.put(tagName,  attributeSet);  }  return  this;        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addAttributes  [RETURN_TYPE]  Whitelist      String  tag    keys  [VARIABLES]  Set    attributeSet    currentSet    tagNames    String    key    tag    tagName    value    String[]    keys    boolean    TagName    tagName    Map    attributes    enforcedAttributes    protocols    
Set<AttributeKey>  currentSet  =  attributes.get  (  tagName  )  ;	[BUGGY]    else  {  Set<AttributeKey>  currentSet  =  attributes.get(  tagName);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addAttributes  [RETURN_TYPE]  Whitelist      String  tag    keys  [VARIABLES]  Set    attributeSet    currentSet    tagNames    String    key    tag    tagName    value    String[]    keys    boolean    TagName    tagName    Map    attributes    enforcedAttributes    protocols    
if  (  attributes.containsKey  (  tagName  )  )  {	[BUGGY]  if  (  tagName.containsKey(  attributes))  {  [CONTEXT]  public  Whitelist  addAttributes(String  tag,  String...  keys)  {  Validate.notEmpty(tag);  Validate.notNull(keys);    TagName  tagName  =  TagName.valueOf(tag);  Set<AttributeKey>  attributeSet  =  new  HashSet<AttributeKey>();  for  (String  key  :  keys)  {  Validate.notEmpty(key);  attributeSet.add(AttributeKey.valueOf(key));  }  [BUGGY]  if(  tagName.containsKey  (  attributes  )){  Set<AttributeKey>  currentSet  =  attributes.get(tagName);  currentSet.addAll(attributeSet);  }  else  {  attributes.put(tagName,  attributeSet);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addAttributes  [RETURN_TYPE]  Whitelist      String  tag    keys  [VARIABLES]  Set    attributeSet    currentSet    tagNames    String    key    tag    tagName    value    String[]    keys    boolean    TagName    tagName    Map    attributes    enforcedAttributes    protocols    
Set<AttributeKey>  currentSet  =  attributes.get  (  tagName  )  ;  currentSet.addAll  (  attributeSet  )  ;	[BUGGY]    [CONTEXT]  public  Whitelist  addAttributes(String  tag,  String...  keys)  {  Validate.notEmpty(tag);  Validate.notNull(keys);    TagName  tagName  =  TagName.valueOf(tag);  Set<AttributeKey>  attributeSet  =  new  HashSet<AttributeKey>();  for  (String  key  :  keys)  {  Validate.notEmpty(key);  attributeSet.add(AttributeKey.valueOf(key));  }  if  (attributes.containsKey(tagName))  {  [BUGGY]  Set<AttributeKey>  currentSet  =  attributes.get(tagName);      }  else  {  attributes.put(tagName,  attributeSet);  }  return  this;        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addAttributes  [RETURN_TYPE]  Whitelist      String  tag    keys  [VARIABLES]  Set    attributeSet    currentSet    tagNames    String    key    tag    tagName    value    String[]    keys    boolean    TagName    tagName    Map    attributes    enforcedAttributes    protocols    
return  this;	[BUGGY]  return  null;  [CONTEXT]  public  Whitelist  addAttributes(String  tag,  String...  keys)  {  Validate.notEmpty(tag);  Validate.notNull(keys);    TagName  tagName  =  TagName.valueOf(tag);  Set<AttributeKey>  attributeSet  =  new  HashSet<AttributeKey>();  for  (String  key  :  keys)  {  Validate.notEmpty(key);  attributeSet.add(AttributeKey.valueOf(key));  }  if  (attributes.containsKey(tagName))  {  Set<AttributeKey>  currentSet  =  attributes.get(tagName);  currentSet.addAll(attributeSet);  }  else  {  attributes.put(tagName,  attributeSet);  }  [BUGGY]  return  null;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addAttributes  [RETURN_TYPE]  Whitelist      String  tag    keys  [VARIABLES]  Set    attributeSet    currentSet    tagNames    String    key    tag    tagName    value    String[]    keys    boolean    TagName    tagName    Map    attributes    enforcedAttributes    protocols    
Validate.notEmpty  (  tag  )  ;	[BUGGY]  Validate.notEmpty(  value);  [CONTEXT]  public  Whitelist  addEnforcedAttribute(String  tag,  String  key,  String  value)  {  [BUGGY]  Validate.notEmpty  (  value  )  ;  Validate.notEmpty(key);  Validate.notEmpty(value);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  AttributeValue  attrVal  =  AttributeValue.valueOf(value);    if  (enforcedAttributes.containsKey(tagName))  {  enforcedAttributes.get(tagName).put(attrKey,  attrVal);  }  else  {  Map<AttributeKey,  AttributeValue>  attrMap  =  new  HashMap<AttributeKey,  AttributeValue>();  attrMap.put(attrKey,  attrVal);  enforcedAttributes.put(tagName,  attrMap);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addEnforcedAttribute  [RETURN_TYPE]  Whitelist      String  tag  String  key  String  value  [VARIABLES]  AttributeKey    attrKey    AttributeValue    attrVal    Set    attributeSet    currentSet    tagNames    boolean    TagName    tagName    String    key    tag    tagName    value    Map    attrMap    attributes    enforcedAttributes    protocols    
Validate.notEmpty  (  tag  )  ;	[BUGGY]  Validate.notNull(  tag);  [CONTEXT]  public  Whitelist  addEnforcedAttribute(String  tag,  String  key,  String  value)  {  [BUGGY]  Validate.notNull  (  tag  )  ;  Validate.notEmpty(key);  Validate.notEmpty(value);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  AttributeValue  attrVal  =  AttributeValue.valueOf(value);    if  (enforcedAttributes.containsKey(tagName))  {  enforcedAttributes.get(tagName).put(attrKey,  attrVal);  }  else  {  Map<AttributeKey,  AttributeValue>  attrMap  =  new  HashMap<AttributeKey,  AttributeValue>();  attrMap.put(attrKey,  attrVal);  enforcedAttributes.put(tagName,  attrMap);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addEnforcedAttribute  [RETURN_TYPE]  Whitelist      String  tag  String  key  String  value  [VARIABLES]  AttributeKey    attrKey    AttributeValue    attrVal    Set    attributeSet    currentSet    tagNames    boolean    TagName    tagName    String    key    tag    tagName    value    Map    attrMap    attributes    enforcedAttributes    protocols    
Validate.notEmpty  (  tag  )  ;	[BUGGY]    [CONTEXT]  public  Whitelist  addEnforcedAttribute(String  tag,  String  key,  String  value)  {  [BUGGY]  Validate.notEmpty(tag);    Validate.notEmpty(key);  Validate.notEmpty(value);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  AttributeValue  attrVal  =  AttributeValue.valueOf(value);    if  (enforcedAttributes.containsKey(tagName))  {  enforcedAttributes.get(tagName).put(attrKey,  attrVal);  }  else  {  Map<AttributeKey,  AttributeValue>  attrMap  =  new  HashMap<AttributeKey,  AttributeValue>();  attrMap.put(attrKey,  attrVal);  enforcedAttributes.put(tagName,  attrMap);  }  return  this;        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addEnforcedAttribute  [RETURN_TYPE]  Whitelist      String  tag  String  key  String  value  [VARIABLES]  AttributeKey    attrKey    AttributeValue    attrVal    Set    attributeSet    currentSet    tagNames    boolean    TagName    tagName    String    key    tag    tagName    value    Map    attrMap    attributes    enforcedAttributes    protocols    
Validate.notEmpty  (  tag  )  ;	[BUGGY]  Validate.notNull(  value);Validate.notEmpty(  tag);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addEnforcedAttribute  [RETURN_TYPE]  Whitelist      String  tag  String  key  String  value  [VARIABLES]  AttributeKey    attrKey    AttributeValue    attrVal    Set    attributeSet    currentSet    tagNames    boolean    TagName    tagName    String    key    tag    tagName    value    Map    attrMap    attributes    enforcedAttributes    protocols    
Validate.notEmpty  (  tag  )  ;	[BUGGY]  Validate.notNull(  tags);Validate.notEmpty(  tag);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addEnforcedAttribute  [RETURN_TYPE]  Whitelist      String  tag  String  key  String  value  [VARIABLES]  AttributeKey    attrKey    AttributeValue    attrVal    Set    attributeSet    currentSet    tagNames    boolean    TagName    tagName    String    key    tag    tagName    value    Map    attrMap    attributes    enforcedAttributes    protocols    
Validate.notEmpty  (  tag  )  ;	[BUGGY]  Validate.notNull(  keys);Validate.notEmpty(  tag);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addEnforcedAttribute  [RETURN_TYPE]  Whitelist      String  tag  String  key  String  value  [VARIABLES]  AttributeKey    attrKey    AttributeValue    attrVal    Set    attributeSet    currentSet    tagNames    boolean    TagName    tagName    String    key    tag    tagName    value    Map    attrMap    attributes    enforcedAttributes    protocols    
Validate.notEmpty  (  tag  )  ;	[BUGGY]  Validate.notEmpty(  key);Validate.notEmpty(  tag);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addEnforcedAttribute  [RETURN_TYPE]  Whitelist      String  tag  String  key  String  value  [VARIABLES]  AttributeKey    attrKey    AttributeValue    attrVal    Set    attributeSet    currentSet    tagNames    boolean    TagName    tagName    String    key    tag    tagName    value    Map    attrMap    attributes    enforcedAttributes    protocols    
Validate.notEmpty  (  tag  )  ;	[BUGGY]  Validate.notEmpty(  value);Validate.notEmpty(  tag);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addEnforcedAttribute  [RETURN_TYPE]  Whitelist      String  tag  String  key  String  value  [VARIABLES]  AttributeKey    attrKey    AttributeValue    attrVal    Set    attributeSet    currentSet    tagNames    boolean    TagName    tagName    String    key    tag    tagName    value    Map    attrMap    attributes    enforcedAttributes    protocols    
Validate.notEmpty  (  tag  )  ;	[BUGGY]  Validate.notNull(  protocols);Validate.notEmpty(  tag);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addEnforcedAttribute  [RETURN_TYPE]  Whitelist      String  tag  String  key  String  value  [VARIABLES]  AttributeKey    attrKey    AttributeValue    attrVal    Set    attributeSet    currentSet    tagNames    boolean    TagName    tagName    String    key    tag    tagName    value    Map    attrMap    attributes    enforcedAttributes    protocols    
Validate.notEmpty  (  tag  )  ;	[BUGGY]  Validate.notEmpty(  tagName);Validate.notEmpty(  tag);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addEnforcedAttribute  [RETURN_TYPE]  Whitelist      String  tag  String  key  String  value  [VARIABLES]  AttributeKey    attrKey    AttributeValue    attrVal    Set    attributeSet    currentSet    tagNames    boolean    TagName    tagName    String    key    tag    tagName    value    Map    attrMap    attributes    enforcedAttributes    protocols    
Validate.notEmpty  (  tag  )  ;	[BUGGY]  Validate.notEmpty(  protocol);Validate.notEmpty(  tag);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addEnforcedAttribute  [RETURN_TYPE]  Whitelist      String  tag  String  key  String  value  [VARIABLES]  AttributeKey    attrKey    AttributeValue    attrVal    Set    attributeSet    currentSet    tagNames    boolean    TagName    tagName    String    key    tag    tagName    value    Map    attrMap    attributes    enforcedAttributes    protocols    
Validate.notEmpty  (  key  )  ;	[BUGGY]  Validate.notEmpty(  value);  [CONTEXT]  public  Whitelist  addEnforcedAttribute(String  tag,  String  key,  String  value)  {  Validate.notEmpty(tag);  [BUGGY]  Validate.notEmpty  (  value  )  ;  Validate.notEmpty(value);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  AttributeValue  attrVal  =  AttributeValue.valueOf(value);    if  (enforcedAttributes.containsKey(tagName))  {  enforcedAttributes.get(tagName).put(attrKey,  attrVal);  }  else  {  Map<AttributeKey,  AttributeValue>  attrMap  =  new  HashMap<AttributeKey,  AttributeValue>();  attrMap.put(attrKey,  attrVal);  enforcedAttributes.put(tagName,  attrMap);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addEnforcedAttribute  [RETURN_TYPE]  Whitelist      String  tag  String  key  String  value  [VARIABLES]  AttributeKey    attrKey    AttributeValue    attrVal    Set    attributeSet    currentSet    tagNames    boolean    TagName    tagName    String    key    tag    tagName    value    Map    attrMap    attributes    enforcedAttributes    protocols    
Validate.notEmpty  (  key  )  ;	[BUGGY]  Validate.notNull(  key);  [CONTEXT]  public  Whitelist  addEnforcedAttribute(String  tag,  String  key,  String  value)  {  Validate.notEmpty(tag);  [BUGGY]  Validate.notNull  (  key  )  ;  Validate.notEmpty(value);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  AttributeValue  attrVal  =  AttributeValue.valueOf(value);    if  (enforcedAttributes.containsKey(tagName))  {  enforcedAttributes.get(tagName).put(attrKey,  attrVal);  }  else  {  Map<AttributeKey,  AttributeValue>  attrMap  =  new  HashMap<AttributeKey,  AttributeValue>();  attrMap.put(attrKey,  attrVal);  enforcedAttributes.put(tagName,  attrMap);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addEnforcedAttribute  [RETURN_TYPE]  Whitelist      String  tag  String  key  String  value  [VARIABLES]  AttributeKey    attrKey    AttributeValue    attrVal    Set    attributeSet    currentSet    tagNames    boolean    TagName    tagName    String    key    tag    tagName    value    Map    attrMap    attributes    enforcedAttributes    protocols    
Validate.notEmpty  (  key  )  ;  Validate.notEmpty  (  value  )  ;	[BUGGY]    [CONTEXT]  public  Whitelist  addEnforcedAttribute(String  tag,  String  key,  String  value)  {  Validate.notEmpty(tag);  [BUGGY]  Validate.notEmpty(key);        TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  AttributeValue  attrVal  =  AttributeValue.valueOf(value);    if  (enforcedAttributes.containsKey(tagName))  {  enforcedAttributes.get(tagName).put(attrKey,  attrVal);  }  else  {  Map<AttributeKey,  AttributeValue>  attrMap  =  new  HashMap<AttributeKey,  AttributeValue>();  attrMap.put(attrKey,  attrVal);  enforcedAttributes.put(tagName,  attrMap);  }  return  this;        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addEnforcedAttribute  [RETURN_TYPE]  Whitelist      String  tag  String  key  String  value  [VARIABLES]  AttributeKey    attrKey    AttributeValue    attrVal    Set    attributeSet    currentSet    tagNames    boolean    TagName    tagName    String    key    tag    tagName    value    Map    attrMap    attributes    enforcedAttributes    protocols    
Validate.notEmpty  (  key  )  ;	[BUGGY]  Validate.notNull(  value);Validate.notEmpty(  key);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addEnforcedAttribute  [RETURN_TYPE]  Whitelist      String  tag  String  key  String  value  [VARIABLES]  AttributeKey    attrKey    AttributeValue    attrVal    Set    attributeSet    currentSet    tagNames    boolean    TagName    tagName    String    key    tag    tagName    value    Map    attrMap    attributes    enforcedAttributes    protocols    
Validate.notEmpty  (  key  )  ;	[BUGGY]  Validate.notNull(  tags);Validate.notEmpty(  key);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addEnforcedAttribute  [RETURN_TYPE]  Whitelist      String  tag  String  key  String  value  [VARIABLES]  AttributeKey    attrKey    AttributeValue    attrVal    Set    attributeSet    currentSet    tagNames    boolean    TagName    tagName    String    key    tag    tagName    value    Map    attrMap    attributes    enforcedAttributes    protocols    
Validate.notEmpty  (  key  )  ;	[BUGGY]  Validate.notEmpty(  tag);Validate.notEmpty(  key);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addEnforcedAttribute  [RETURN_TYPE]  Whitelist      String  tag  String  key  String  value  [VARIABLES]  AttributeKey    attrKey    AttributeValue    attrVal    Set    attributeSet    currentSet    tagNames    boolean    TagName    tagName    String    key    tag    tagName    value    Map    attrMap    attributes    enforcedAttributes    protocols    
Validate.notEmpty  (  key  )  ;	[BUGGY]  Validate.notNull(  keys);Validate.notEmpty(  key);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addEnforcedAttribute  [RETURN_TYPE]  Whitelist      String  tag  String  key  String  value  [VARIABLES]  AttributeKey    attrKey    AttributeValue    attrVal    Set    attributeSet    currentSet    tagNames    boolean    TagName    tagName    String    key    tag    tagName    value    Map    attrMap    attributes    enforcedAttributes    protocols    
Validate.notEmpty  (  key  )  ;	[BUGGY]  Validate.notEmpty(  value);Validate.notEmpty(  key);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addEnforcedAttribute  [RETURN_TYPE]  Whitelist      String  tag  String  key  String  value  [VARIABLES]  AttributeKey    attrKey    AttributeValue    attrVal    Set    attributeSet    currentSet    tagNames    boolean    TagName    tagName    String    key    tag    tagName    value    Map    attrMap    attributes    enforcedAttributes    protocols    
Validate.notEmpty  (  key  )  ;	[BUGGY]  Validate.notNull(  protocols);Validate.notEmpty(  key);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addEnforcedAttribute  [RETURN_TYPE]  Whitelist      String  tag  String  key  String  value  [VARIABLES]  AttributeKey    attrKey    AttributeValue    attrVal    Set    attributeSet    currentSet    tagNames    boolean    TagName    tagName    String    key    tag    tagName    value    Map    attrMap    attributes    enforcedAttributes    protocols    
Validate.notEmpty  (  key  )  ;	[BUGGY]  Validate.notEmpty(  tagName);Validate.notEmpty(  key);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addEnforcedAttribute  [RETURN_TYPE]  Whitelist      String  tag  String  key  String  value  [VARIABLES]  AttributeKey    attrKey    AttributeValue    attrVal    Set    attributeSet    currentSet    tagNames    boolean    TagName    tagName    String    key    tag    tagName    value    Map    attrMap    attributes    enforcedAttributes    protocols    
Validate.notEmpty  (  key  )  ;	[BUGGY]  Validate.notEmpty(  protocol);Validate.notEmpty(  key);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addEnforcedAttribute  [RETURN_TYPE]  Whitelist      String  tag  String  key  String  value  [VARIABLES]  AttributeKey    attrKey    AttributeValue    attrVal    Set    attributeSet    currentSet    tagNames    boolean    TagName    tagName    String    key    tag    tagName    value    Map    attrMap    attributes    enforcedAttributes    protocols    
Validate.notEmpty  (  value  )  ;	[BUGGY]  Validate.notEmpty(  tagName);  [CONTEXT]  public  Whitelist  addEnforcedAttribute(String  tag,  String  key,  String  value)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  [BUGGY]  Validate.notEmpty  (  tagName  )  ;    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  AttributeValue  attrVal  =  AttributeValue.valueOf(value);    if  (enforcedAttributes.containsKey(tagName))  {  enforcedAttributes.get(tagName).put(attrKey,  attrVal);  }  else  {  Map<AttributeKey,  AttributeValue>  attrMap  =  new  HashMap<AttributeKey,  AttributeValue>();  attrMap.put(attrKey,  attrVal);  enforcedAttributes.put(tagName,  attrMap);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addEnforcedAttribute  [RETURN_TYPE]  Whitelist      String  tag  String  key  String  value  [VARIABLES]  AttributeKey    attrKey    AttributeValue    attrVal    Set    attributeSet    currentSet    tagNames    boolean    TagName    tagName    String    key    tag    tagName    value    Map    attrMap    attributes    enforcedAttributes    protocols    
Validate.notEmpty  (  value  )  ;	[BUGGY]  Validate.notNull(  value);  [CONTEXT]  public  Whitelist  addEnforcedAttribute(String  tag,  String  key,  String  value)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  [BUGGY]  Validate.notNull  (  value  )  ;    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  AttributeValue  attrVal  =  AttributeValue.valueOf(value);    if  (enforcedAttributes.containsKey(tagName))  {  enforcedAttributes.get(tagName).put(attrKey,  attrVal);  }  else  {  Map<AttributeKey,  AttributeValue>  attrMap  =  new  HashMap<AttributeKey,  AttributeValue>();  attrMap.put(attrKey,  attrVal);  enforcedAttributes.put(tagName,  attrMap);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addEnforcedAttribute  [RETURN_TYPE]  Whitelist      String  tag  String  key  String  value  [VARIABLES]  AttributeKey    attrKey    AttributeValue    attrVal    Set    attributeSet    currentSet    tagNames    boolean    TagName    tagName    String    key    tag    tagName    value    Map    attrMap    attributes    enforcedAttributes    protocols    
Validate.notEmpty  (  value  )  ;	[BUGGY]    [CONTEXT]  public  Whitelist  addEnforcedAttribute(String  tag,  String  key,  String  value)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  [BUGGY]  Validate.notEmpty(value);      TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  AttributeValue  attrVal  =  AttributeValue.valueOf(value);    if  (enforcedAttributes.containsKey(tagName))  {  enforcedAttributes.get(tagName).put(attrKey,  attrVal);  }  else  {  Map<AttributeKey,  AttributeValue>  attrMap  =  new  HashMap<AttributeKey,  AttributeValue>();  attrMap.put(attrKey,  attrVal);  enforcedAttributes.put(tagName,  attrMap);  }  return  this;        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addEnforcedAttribute  [RETURN_TYPE]  Whitelist      String  tag  String  key  String  value  [VARIABLES]  AttributeKey    attrKey    AttributeValue    attrVal    Set    attributeSet    currentSet    tagNames    boolean    TagName    tagName    String    key    tag    tagName    value    Map    attrMap    attributes    enforcedAttributes    protocols    
TagName  tagName  =  TagName.valueOf  (  tag  )  ;	[BUGGY]  TagName  valueName  =  TagName.valueOf(  tag);  [CONTEXT]  public  Whitelist  addEnforcedAttribute(String  tag,  String  key,  String  value)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notEmpty(value);    [BUGGY]  TagName  valueName  =  TagName.valueOf  (  tag  )  ;  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  AttributeValue  attrVal  =  AttributeValue.valueOf(value);    if  (enforcedAttributes.containsKey(tagName))  {  enforcedAttributes.get(tagName).put(attrKey,  attrVal);  }  else  {  Map<AttributeKey,  AttributeValue>  attrMap  =  new  HashMap<AttributeKey,  AttributeValue>();  attrMap.put(attrKey,  attrVal);  enforcedAttributes.put(tagName,  attrMap);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addEnforcedAttribute  [RETURN_TYPE]  Whitelist      String  tag  String  key  String  value  [VARIABLES]  AttributeKey    attrKey    AttributeValue    attrVal    Set    attributeSet    currentSet    tagNames    boolean    TagName    tagName    String    key    tag    tagName    value    Map    attrMap    attributes    enforcedAttributes    protocols    
TagName  tagName  =  TagName.valueOf  (  tag  )  ;	[BUGGY]  TagName  tagName  =  TagName.TagName(  tag);  [CONTEXT]  public  Whitelist  addEnforcedAttribute(String  tag,  String  key,  String  value)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notEmpty(value);    [BUGGY]  TagName  tagName  =  TagName.TagName  (  tag  )  ;  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  AttributeValue  attrVal  =  AttributeValue.valueOf(value);    if  (enforcedAttributes.containsKey(tagName))  {  enforcedAttributes.get(tagName).put(attrKey,  attrVal);  }  else  {  Map<AttributeKey,  AttributeValue>  attrMap  =  new  HashMap<AttributeKey,  AttributeValue>();  attrMap.put(attrKey,  attrVal);  enforcedAttributes.put(tagName,  attrMap);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addEnforcedAttribute  [RETURN_TYPE]  Whitelist      String  tag  String  key  String  value  [VARIABLES]  AttributeKey    attrKey    AttributeValue    attrVal    Set    attributeSet    currentSet    tagNames    boolean    TagName    tagName    String    key    tag    tagName    value    Map    attrMap    attributes    enforcedAttributes    protocols    
TagName  tagName  =  TagName.valueOf  (  tag  )  ;	[BUGGY]  TagName  tagName  =  TagName  .TagName(  tagName)  ;  [CONTEXT]  public  Whitelist  addEnforcedAttribute(String  tag,  String  key,  String  value)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notEmpty(value);    [BUGGY]  TagName  tagName  =  TagName  .TagName  (  tagName  );  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  AttributeValue  attrVal  =  AttributeValue.valueOf(value);    if  (enforcedAttributes.containsKey(tagName))  {  enforcedAttributes.get(tagName).put(attrKey,  attrVal);  }  else  {  Map<AttributeKey,  AttributeValue>  attrMap  =  new  HashMap<AttributeKey,  AttributeValue>();  attrMap.put(attrKey,  attrVal);  enforcedAttributes.put(tagName,  attrMap);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addEnforcedAttribute  [RETURN_TYPE]  Whitelist      String  tag  String  key  String  value  [VARIABLES]  AttributeKey    attrKey    AttributeValue    attrVal    Set    attributeSet    currentSet    tagNames    boolean    TagName    tagName    String    key    tag    tagName    value    Map    attrMap    attributes    enforcedAttributes    protocols    
TagName  tagName  =  TagName.valueOf  (  tag  )  ;  AttributeKey  attrKey  =  AttributeKey.valueOf  (  key  )  ;	[BUGGY]  AttributeKey  attrKey  =  AttributeKey.valueOf(  key);  TagName  tagName  =  TagName.valueOf(  tag);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addEnforcedAttribute  [RETURN_TYPE]  Whitelist      String  tag  String  key  String  value  [VARIABLES]  AttributeKey    attrKey    AttributeValue    attrVal    Set    attributeSet    currentSet    tagNames    boolean    TagName    tagName    String    key    tag    tagName    value    Map    attrMap    attributes    enforcedAttributes    protocols    
TagName  tagName  =  TagName.valueOf  (  tag  )  ;  AttributeKey  attrKey  =  AttributeKey.valueOf  (  key  )  ;	[BUGGY]  AttributeKey  attrKey  =  AttributeKey.valueOf(  key);TagName  tagName  =  TagName.valueOf(  tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(  key);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addEnforcedAttribute  [RETURN_TYPE]  Whitelist      String  tag  String  key  String  value  [VARIABLES]  AttributeKey    attrKey    AttributeValue    attrVal    Set    attributeSet    currentSet    tagNames    boolean    TagName    tagName    String    key    tag    tagName    value    Map    attrMap    attributes    enforcedAttributes    protocols    
TagName  tagName  =  TagName.valueOf  (  tag  )  ;	[BUGGY]    [CONTEXT]  public  Whitelist  addEnforcedAttribute(String  tag,  String  key,  String  value)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notEmpty(value);    [BUGGY]  TagName  tagName  =  TagName.valueOf(tag);    AttributeKey  attrKey  =  AttributeKey.valueOf(key);  AttributeValue  attrVal  =  AttributeValue.valueOf(value);    if  (enforcedAttributes.containsKey(tagName))  {  enforcedAttributes.get(tagName).put(attrKey,  attrVal);  }  else  {  Map<AttributeKey,  AttributeValue>  attrMap  =  new  HashMap<AttributeKey,  AttributeValue>();  attrMap.put(attrKey,  attrVal);  enforcedAttributes.put(tagName,  attrMap);  }  return  this;        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addEnforcedAttribute  [RETURN_TYPE]  Whitelist      String  tag  String  key  String  value  [VARIABLES]  AttributeKey    attrKey    AttributeValue    attrVal    Set    attributeSet    currentSet    tagNames    boolean    TagName    tagName    String    key    tag    tagName    value    Map    attrMap    attributes    enforcedAttributes    protocols    
TagName  tagName  =  TagName.valueOf  (  tag  )  ;	[BUGGY]  TagName  tag  =  TagName.valueOf(  tagName);TagName  tagName  =  TagName.valueOf(  tag);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addEnforcedAttribute  [RETURN_TYPE]  Whitelist      String  tag  String  key  String  value  [VARIABLES]  AttributeKey    attrKey    AttributeValue    attrVal    Set    attributeSet    currentSet    tagNames    boolean    TagName    tagName    String    key    tag    tagName    value    Map    attrMap    attributes    enforcedAttributes    protocols    
TagName  tagName  =  TagName.valueOf  (  tag  )  ;	[BUGGY]  tagNames.add(  TagName.valueOf(  tagName));TagName  tagName  =  TagName.valueOf(  tag);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addEnforcedAttribute  [RETURN_TYPE]  Whitelist      String  tag  String  key  String  value  [VARIABLES]  AttributeKey    attrKey    AttributeValue    attrVal    Set    attributeSet    currentSet    tagNames    boolean    TagName    tagName    String    key    tag    tagName    value    Map    attrMap    attributes    enforcedAttributes    protocols    
TagName  tagName  =  TagName.valueOf  (  tag  )  ;	[BUGGY]  return  tagNames.contains(  TagName.valueOf(  tag));TagName  tagName  =  TagName.valueOf(  tag);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addEnforcedAttribute  [RETURN_TYPE]  Whitelist      String  tag  String  key  String  value  [VARIABLES]  AttributeKey    attrKey    AttributeValue    attrVal    Set    attributeSet    currentSet    tagNames    boolean    TagName    tagName    String    key    tag    tagName    value    Map    attrMap    attributes    enforcedAttributes    protocols    
AttributeKey  attrKey  =  AttributeKey.valueOf  (  key  )  ;	[BUGGY]  AttributeKey  attrKey  =  AttributeKey.valueOf(  value);  [CONTEXT]  public  Whitelist  addEnforcedAttribute(String  tag,  String  key,  String  value)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notEmpty(value);    TagName  tagName  =  TagName.valueOf(tag);  [BUGGY]  AttributeKey  attrKey  =  AttributeKey.valueOf  (  value  )  ;  AttributeValue  attrVal  =  AttributeValue.valueOf(value);    if  (enforcedAttributes.containsKey(tagName))  {  enforcedAttributes.get(tagName).put(attrKey,  attrVal);  }  else  {  Map<AttributeKey,  AttributeValue>  attrMap  =  new  HashMap<AttributeKey,  AttributeValue>();  attrMap.put(attrKey,  attrVal);  enforcedAttributes.put(tagName,  attrMap);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addEnforcedAttribute  [RETURN_TYPE]  Whitelist      String  tag  String  key  String  value  [VARIABLES]  AttributeKey    attrKey    AttributeValue    attrVal    Set    attributeSet    currentSet    tagNames    boolean    TagName    tagName    String    key    tag    tagName    value    Map    attrMap    attributes    enforcedAttributes    protocols    
AttributeKey  attrKey  =  AttributeKey.valueOf  (  key  )  ;	[BUGGY]  AttributeKey  attrKey  =  AttributeKey.AttributeKey(  key);  [CONTEXT]  public  Whitelist  addEnforcedAttribute(String  tag,  String  key,  String  value)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notEmpty(value);    TagName  tagName  =  TagName.valueOf(tag);  [BUGGY]  AttributeKey  attrKey  =  AttributeKey.AttributeKey  (  key  )  ;  AttributeValue  attrVal  =  AttributeValue.valueOf(value);    if  (enforcedAttributes.containsKey(tagName))  {  enforcedAttributes.get(tagName).put(attrKey,  attrVal);  }  else  {  Map<AttributeKey,  AttributeValue>  attrMap  =  new  HashMap<AttributeKey,  AttributeValue>();  attrMap.put(attrKey,  attrVal);  enforcedAttributes.put(tagName,  attrMap);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addEnforcedAttribute  [RETURN_TYPE]  Whitelist      String  tag  String  key  String  value  [VARIABLES]  AttributeKey    attrKey    AttributeValue    attrVal    Set    attributeSet    currentSet    tagNames    boolean    TagName    tagName    String    key    tag    tagName    value    Map    attrMap    attributes    enforcedAttributes    protocols    
AttributeKey  attrKey  =  AttributeKey.valueOf  (  key  )  ;	[BUGGY]  Attributes  attrs  =  new  Attributes(  );AttributeKey  attrKey  =  AttributeKey.valueOf(  key);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addEnforcedAttribute  [RETURN_TYPE]  Whitelist      String  tag  String  key  String  value  [VARIABLES]  AttributeKey    attrKey    AttributeValue    attrVal    Set    attributeSet    currentSet    tagNames    boolean    TagName    tagName    String    key    tag    tagName    value    Map    attrMap    attributes    enforcedAttributes    protocols    
AttributeKey  attrKey  =  AttributeKey.valueOf  (  key  )  ;	[BUGGY]  AttributeKey  key  =  AttributeKey.valueOf(  attr.getKey(  ));AttributeKey  attrKey  =  AttributeKey.valueOf(  key);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addEnforcedAttribute  [RETURN_TYPE]  Whitelist      String  tag  String  key  String  value  [VARIABLES]  AttributeKey    attrKey    AttributeValue    attrVal    Set    attributeSet    currentSet    tagNames    boolean    TagName    tagName    String    key    tag    tagName    value    Map    attrMap    attributes    enforcedAttributes    protocols    
AttributeKey  attrKey  =  AttributeKey.valueOf  (  key  )  ;	[BUGGY]  Set<AttributeKey>  currentSet  =  attributes.get(  tagName);AttributeKey  attrKey  =  AttributeKey.valueOf(  key);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addEnforcedAttribute  [RETURN_TYPE]  Whitelist      String  tag  String  key  String  value  [VARIABLES]  AttributeKey    attrKey    AttributeValue    attrVal    Set    attributeSet    currentSet    tagNames    boolean    TagName    tagName    String    key    tag    tagName    value    Map    attrMap    attributes    enforcedAttributes    protocols    
AttributeKey  attrKey  =  AttributeKey.valueOf  (  key  )  ;	[BUGGY]  AttributeValue  attrVal  =  AttributeValue.valueOf(  value);AttributeKey  attrKey  =  AttributeKey.valueOf(  key);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addEnforcedAttribute  [RETURN_TYPE]  Whitelist      String  tag  String  key  String  value  [VARIABLES]  AttributeKey    attrKey    AttributeValue    attrVal    Set    attributeSet    currentSet    tagNames    boolean    TagName    tagName    String    key    tag    tagName    value    Map    attrMap    attributes    enforcedAttributes    protocols    
AttributeKey  attrKey  =  AttributeKey.valueOf  (  key  )  ;	[BUGGY]  AttributeKey  attrKey  =  AttributeKey.AttributeKey(  value);  [CONTEXT]  public  Whitelist  addEnforcedAttribute(String  tag,  String  key,  String  value)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notEmpty(value);    TagName  tagName  =  TagName.valueOf(tag);  [BUGGY]  AttributeKey  attrKey  =  AttributeKey.AttributeKey  (  value  )  ;  AttributeValue  attrVal  =  AttributeValue.valueOf(value);    if  (enforcedAttributes.containsKey(tagName))  {  enforcedAttributes.get(tagName).put(attrKey,  attrVal);  }  else  {  Map<AttributeKey,  AttributeValue>  attrMap  =  new  HashMap<AttributeKey,  AttributeValue>();  attrMap.put(attrKey,  attrVal);  enforcedAttributes.put(tagName,  attrMap);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addEnforcedAttribute  [RETURN_TYPE]  Whitelist      String  tag  String  key  String  value  [VARIABLES]  AttributeKey    attrKey    AttributeValue    attrVal    Set    attributeSet    currentSet    tagNames    boolean    TagName    tagName    String    key    tag    tagName    value    Map    attrMap    attributes    enforcedAttributes    protocols    
AttributeKey  attrKey  =  AttributeKey.valueOf  (  key  )  ;  AttributeValue  attrVal  =  AttributeValue.valueOf  (  value  )  ;	[BUGGY]    [CONTEXT]  public  Whitelist  addEnforcedAttribute(String  tag,  String  key,  String  value)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notEmpty(value);    TagName  tagName  =  TagName.valueOf(tag);  [BUGGY]  AttributeKey  attrKey  =  AttributeKey.valueOf(key);        if  (enforcedAttributes.containsKey(tagName))  {  enforcedAttributes.get(tagName).put(attrKey,  attrVal);  }  else  {  Map<AttributeKey,  AttributeValue>  attrMap  =  new  HashMap<AttributeKey,  AttributeValue>();  attrMap.put(attrKey,  attrVal);  enforcedAttributes.put(tagName,  attrMap);  }  return  this;        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addEnforcedAttribute  [RETURN_TYPE]  Whitelist      String  tag  String  key  String  value  [VARIABLES]  AttributeKey    attrKey    AttributeValue    attrVal    Set    attributeSet    currentSet    tagNames    boolean    TagName    tagName    String    key    tag    tagName    value    Map    attrMap    attributes    enforcedAttributes    protocols    
AttributeKey  attrKey  =  AttributeKey.valueOf  (  key  )  ;	[BUGGY]  attributeSet.add(  AttributeKey.valueOf(  key));AttributeKey  attrKey  =  AttributeKey.valueOf(  key);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addEnforcedAttribute  [RETURN_TYPE]  Whitelist      String  tag  String  key  String  value  [VARIABLES]  AttributeKey    attrKey    AttributeValue    attrVal    Set    attributeSet    currentSet    tagNames    boolean    TagName    tagName    String    key    tag    tagName    value    Map    attrMap    attributes    enforcedAttributes    protocols    
AttributeValue  attrVal  =  AttributeValue.valueOf  (  value  )  ;	[BUGGY]  AttributeValue  attrVal  =  AttributeValue.valueOf(  tagName);  [CONTEXT]  public  Whitelist  addEnforcedAttribute(String  tag,  String  key,  String  value)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notEmpty(value);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  [BUGGY]  AttributeValue  attrVal  =  AttributeValue.valueOf  (  tagName  )  ;    if  (enforcedAttributes.containsKey(tagName))  {  enforcedAttributes.get(tagName).put(attrKey,  attrVal);  }  else  {  Map<AttributeKey,  AttributeValue>  attrMap  =  new  HashMap<AttributeKey,  AttributeValue>();  attrMap.put(attrKey,  attrVal);  enforcedAttributes.put(tagName,  attrMap);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addEnforcedAttribute  [RETURN_TYPE]  Whitelist      String  tag  String  key  String  value  [VARIABLES]  AttributeKey    attrKey    AttributeValue    attrVal    Set    attributeSet    currentSet    tagNames    boolean    TagName    tagName    String    key    tag    tagName    value    Map    attrMap    attributes    enforcedAttributes    protocols    
AttributeValue  attrVal  =  AttributeValue.valueOf  (  value  )  ;	[BUGGY]  AttributeValue  attrVal  =  AttributeValue.AttributeValue(  value);  [CONTEXT]  public  Whitelist  addEnforcedAttribute(String  tag,  String  key,  String  value)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notEmpty(value);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  [BUGGY]  AttributeValue  attrVal  =  AttributeValue.AttributeValue  (  value  )  ;    if  (enforcedAttributes.containsKey(tagName))  {  enforcedAttributes.get(tagName).put(attrKey,  attrVal);  }  else  {  Map<AttributeKey,  AttributeValue>  attrMap  =  new  HashMap<AttributeKey,  AttributeValue>();  attrMap.put(attrKey,  attrVal);  enforcedAttributes.put(tagName,  attrMap);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addEnforcedAttribute  [RETURN_TYPE]  Whitelist      String  tag  String  key  String  value  [VARIABLES]  AttributeKey    attrKey    AttributeValue    attrVal    Set    attributeSet    currentSet    tagNames    boolean    TagName    tagName    String    key    tag    tagName    value    Map    attrMap    attributes    enforcedAttributes    protocols    
AttributeValue  attrVal  =  AttributeValue.valueOf  (  value  )  ;	[BUGGY]  AttributeValue  attrVal  =  AttributeValue  .TagName(  tagName)  ;  [CONTEXT]  public  Whitelist  addEnforcedAttribute(String  tag,  String  key,  String  value)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notEmpty(value);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  [BUGGY]  AttributeValue  attrVal  =  AttributeValue  .TagName  (  tagName  );    if  (enforcedAttributes.containsKey(tagName))  {  enforcedAttributes.get(tagName).put(attrKey,  attrVal);  }  else  {  Map<AttributeKey,  AttributeValue>  attrMap  =  new  HashMap<AttributeKey,  AttributeValue>();  attrMap.put(attrKey,  attrVal);  enforcedAttributes.put(tagName,  attrMap);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addEnforcedAttribute  [RETURN_TYPE]  Whitelist      String  tag  String  key  String  value  [VARIABLES]  AttributeKey    attrKey    AttributeValue    attrVal    Set    attributeSet    currentSet    tagNames    boolean    TagName    tagName    String    key    tag    tagName    value    Map    attrMap    attributes    enforcedAttributes    protocols    
AttributeValue  attrVal  =  AttributeValue.valueOf  (  value  )  ;	[BUGGY]    [CONTEXT]  public  Whitelist  addEnforcedAttribute(String  tag,  String  key,  String  value)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notEmpty(value);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  [BUGGY]  AttributeValue  attrVal  =  AttributeValue.valueOf(value);      if  (enforcedAttributes.containsKey(tagName))  {  enforcedAttributes.get(tagName).put(attrKey,  attrVal);  }  else  {  Map<AttributeKey,  AttributeValue>  attrMap  =  new  HashMap<AttributeKey,  AttributeValue>();  attrMap.put(attrKey,  attrVal);  enforcedAttributes.put(tagName,  attrMap);  }  return  this;        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addEnforcedAttribute  [RETURN_TYPE]  Whitelist      String  tag  String  key  String  value  [VARIABLES]  AttributeKey    attrKey    AttributeValue    attrVal    Set    attributeSet    currentSet    tagNames    boolean    TagName    tagName    String    key    tag    tagName    value    Map    attrMap    attributes    enforcedAttributes    protocols    
if  (  enforcedAttributes.containsKey  (  tagName  )  )  {	[BUGGY]  if  (  tagName.containsKey(  enforcedAttributes))  {  [CONTEXT]  public  Whitelist  addEnforcedAttribute(String  tag,  String  key,  String  value)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notEmpty(value);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  AttributeValue  attrVal  =  AttributeValue.valueOf(value);    [BUGGY]  if(  tagName.containsKey  (  enforcedAttributes  )){  enforcedAttributes.get(tagName).put(attrKey,  attrVal);  }  else  {  Map<AttributeKey,  AttributeValue>  attrMap  =  new  HashMap<AttributeKey,  AttributeValue>();  attrMap.put(attrKey,  attrVal);  enforcedAttributes.put(tagName,  attrMap);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addEnforcedAttribute  [RETURN_TYPE]  Whitelist      String  tag  String  key  String  value  [VARIABLES]  AttributeKey    attrKey    AttributeValue    attrVal    Set    attributeSet    currentSet    tagNames    boolean    TagName    tagName    String    key    tag    tagName    value    Map    attrMap    attributes    enforcedAttributes    protocols    
if  (  enforcedAttributes.containsKey  (  tagName  )  )  {	[BUGGY]  if  (  attributes.containsKey(  tag))  {  [CONTEXT]  public  Whitelist  addEnforcedAttribute(String  tag,  String  key,  String  value)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notEmpty(value);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  AttributeValue  attrVal  =  AttributeValue.valueOf(value);    [BUGGY]  if(  attributes.containsKey  (  tag  )){  enforcedAttributes.get(tagName).put(attrKey,  attrVal);  }  else  {  Map<AttributeKey,  AttributeValue>  attrMap  =  new  HashMap<AttributeKey,  AttributeValue>();  attrMap.put(attrKey,  attrVal);  enforcedAttributes.put(tagName,  attrMap);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addEnforcedAttribute  [RETURN_TYPE]  Whitelist      String  tag  String  key  String  value  [VARIABLES]  AttributeKey    attrKey    AttributeValue    attrVal    Set    attributeSet    currentSet    tagNames    boolean    TagName    tagName    String    key    tag    tagName    value    Map    attrMap    attributes    enforcedAttributes    protocols    
if  (  enforcedAttributes.containsKey  (  tagName  )  )  {	[BUGGY]  if  (  enforcedAttributes.containsKey(  tag))  {  [CONTEXT]  public  Whitelist  addEnforcedAttribute(String  tag,  String  key,  String  value)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notEmpty(value);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  AttributeValue  attrVal  =  AttributeValue.valueOf(value);    [BUGGY]  if(  enforcedAttributes.containsKey  (  tag  )){  enforcedAttributes.get(tagName).put(attrKey,  attrVal);  }  else  {  Map<AttributeKey,  AttributeValue>  attrMap  =  new  HashMap<AttributeKey,  AttributeValue>();  attrMap.put(attrKey,  attrVal);  enforcedAttributes.put(tagName,  attrMap);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addEnforcedAttribute  [RETURN_TYPE]  Whitelist      String  tag  String  key  String  value  [VARIABLES]  AttributeKey    attrKey    AttributeValue    attrVal    Set    attributeSet    currentSet    tagNames    boolean    TagName    tagName    String    key    tag    tagName    value    Map    attrMap    attributes    enforcedAttributes    protocols    
if  (  enforcedAttributes.containsKey  (  tagName  )  )  {	[BUGGY]  if  (  attributes.containsKey(  tagName))  {  [CONTEXT]  public  Whitelist  addEnforcedAttribute(String  tag,  String  key,  String  value)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notEmpty(value);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  AttributeValue  attrVal  =  AttributeValue.valueOf(value);    [BUGGY]  if(  attributes.containsKey  (  tagName  )){  enforcedAttributes.get(tagName).put(attrKey,  attrVal);  }  else  {  Map<AttributeKey,  AttributeValue>  attrMap  =  new  HashMap<AttributeKey,  AttributeValue>();  attrMap.put(attrKey,  attrVal);  enforcedAttributes.put(tagName,  attrMap);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addEnforcedAttribute  [RETURN_TYPE]  Whitelist      String  tag  String  key  String  value  [VARIABLES]  AttributeKey    attrKey    AttributeValue    attrVal    Set    attributeSet    currentSet    tagNames    boolean    TagName    tagName    String    key    tag    tagName    value    Map    attrMap    attributes    enforcedAttributes    protocols    
if  (  enforcedAttributes.containsKey  (  tagName  )  )  {	[BUGGY]  if  (  this.protocols.containsKey(  tagName))  {  [CONTEXT]  public  Whitelist  addEnforcedAttribute(String  tag,  String  key,  String  value)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notEmpty(value);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  AttributeValue  attrVal  =  AttributeValue.valueOf(value);    [BUGGY]  if(  this.protocols.containsKey  (  tagName  )){  enforcedAttributes.get(tagName).put(attrKey,  attrVal);  }  else  {  Map<AttributeKey,  AttributeValue>  attrMap  =  new  HashMap<AttributeKey,  AttributeValue>();  attrMap.put(attrKey,  attrVal);  enforcedAttributes.put(tagName,  attrMap);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addEnforcedAttribute  [RETURN_TYPE]  Whitelist      String  tag  String  key  String  value  [VARIABLES]  AttributeKey    attrKey    AttributeValue    attrVal    Set    attributeSet    currentSet    tagNames    boolean    TagName    tagName    String    key    tag    tagName    value    Map    attrMap    attributes    enforcedAttributes    protocols    
Map<AttributeKey,  AttributeValue>  attrMap  =  new  HashMap<AttributeKey,  AttributeValue>  (  )  ;	[BUGGY]  Map<AttributeKey,  AttributeValue>  attrMap  =  Map<AttributeKey,  AttributeValue>  attrMap  =    new  AttributeKey,  Protocol>>(  )  ;  [CONTEXT]  public  Whitelist  addEnforcedAttribute(String  tag,  String  key,  String  value)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notEmpty(value);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  AttributeValue  attrVal  =  AttributeValue.valueOf(value);    if  (enforcedAttributes.containsKey(tagName))  {  enforcedAttributes.get(tagName).put(attrKey,  attrVal);  }  else  {  [BUGGY]  Map<AttributeKey,  AttributeValue>  attrMap  =  Map<AttributeKey,  AttributeValue>  attrMap  =new  AttributeKey,  Protocol>>  ();  attrMap.put(attrKey,  attrVal);  enforcedAttributes.put(tagName,  attrMap);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addEnforcedAttribute  [RETURN_TYPE]  Whitelist      String  tag  String  key  String  value  [VARIABLES]  AttributeKey    attrKey    AttributeValue    attrVal    Set    attributeSet    currentSet    tagNames    boolean    TagName    tagName    String    key    tag    tagName    value    Map    attrMap    attributes    enforcedAttributes    protocols    
Map<AttributeKey,  AttributeValue>  attrMap  =  new  HashMap<AttributeKey,  AttributeValue>  (  )  ;	[BUGGY]  attrMap.put(  attrKey,  attrVal);  Map<AttributeKey,  AttributeValue>  attrMap  =  new  HashMap<AttributeKey,  AttributeValue>(  );  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addEnforcedAttribute  [RETURN_TYPE]  Whitelist      String  tag  String  key  String  value  [VARIABLES]  AttributeKey    attrKey    AttributeValue    attrVal    Set    attributeSet    currentSet    tagNames    boolean    TagName    tagName    String    key    tag    tagName    value    Map    attrMap    attributes    enforcedAttributes    protocols    
Map<AttributeKey,  AttributeValue>  attrMap  =  new  HashMap<AttributeKey,  AttributeValue>  (  )  ;	[BUGGY]  Map<AttributeKey,  AttributeValue>  keyVals  =  enforcedAttributes.get(  tag);Map<AttributeKey,  AttributeValue>  attrMap  =  new  HashMap<AttributeKey,  AttributeValue>(  );  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addEnforcedAttribute  [RETURN_TYPE]  Whitelist      String  tag  String  key  String  value  [VARIABLES]  AttributeKey    attrKey    AttributeValue    attrVal    Set    attributeSet    currentSet    tagNames    boolean    TagName    tagName    String    key    tag    tagName    value    Map    attrMap    attributes    enforcedAttributes    protocols    
Map<AttributeKey,  AttributeValue>  attrMap  =  new  HashMap<AttributeKey,  AttributeValue>  (  )  ;	[BUGGY]  Set<AttributeKey>  attributeSet  =  new  HashSet<AttributeKey>(  );Map<AttributeKey,  AttributeValue>  attrMap  =  new  HashMap<AttributeKey,  AttributeValue>(  );  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addEnforcedAttribute  [RETURN_TYPE]  Whitelist      String  tag  String  key  String  value  [VARIABLES]  AttributeKey    attrKey    AttributeValue    attrVal    Set    attributeSet    currentSet    tagNames    boolean    TagName    tagName    String    key    tag    tagName    value    Map    attrMap    attributes    enforcedAttributes    protocols    
[Delete]	[BUGGY]  if  (  enforcedAttributes.containsKey(  tagName))  {          enforcedAttributes.get(  tagName).put(  attrKey,  attrVal);  }else  {          AttributeKey,  AttributeValue>  attrMap  =  new  AttributeKey,  AttributeValue>(  );          attrMap.put(  attrKey,  attrVal);          enforcedAttributes.put(  tagName,  attrMap);  }  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addEnforcedAttribute  [RETURN_TYPE]  Whitelist      String  tag  String  key  String  value  [VARIABLES]  AttributeKey    attrKey    AttributeValue    attrVal    Set    attributeSet    currentSet    tagNames    boolean    TagName    tagName    String    key    tag    tagName    value    Map    attrMap    attributes    enforcedAttributes    protocols    
attrMap.put  (  attrKey,  attrVal  )  ;	[BUGGY]  attrMap.put(    attrVal);  [CONTEXT]  public  Whitelist  addEnforcedAttribute(String  tag,  String  key,  String  value)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notEmpty(value);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  AttributeValue  attrVal  =  AttributeValue.valueOf(value);    if  (enforcedAttributes.containsKey(tagName))  {  enforcedAttributes.get(tagName).put(attrKey,  attrVal);  }  else  {  Map<AttributeKey,  AttributeValue>  attrMap  =  new  HashMap<AttributeKey,  AttributeValue>();  [BUGGY]  attrMap.put  (attrVal  )  ;  enforcedAttributes.put(tagName,  attrMap);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addEnforcedAttribute  [RETURN_TYPE]  Whitelist      String  tag  String  key  String  value  [VARIABLES]  AttributeKey    attrKey    AttributeValue    attrVal    Set    attributeSet    currentSet    tagNames    boolean    TagName    tagName    String    key    tag    tagName    value    Map    attrMap    attributes    enforcedAttributes    protocols    
attrMap.put  (  attrKey,  attrVal  )  ;	[BUGGY]  attrMap.put(  attrVal,  attrKey);  [CONTEXT]  public  Whitelist  addEnforcedAttribute(String  tag,  String  key,  String  value)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notEmpty(value);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  AttributeValue  attrVal  =  AttributeValue.valueOf(value);    if  (enforcedAttributes.containsKey(tagName))  {  enforcedAttributes.get(tagName).put(attrKey,  attrVal);  }  else  {  Map<AttributeKey,  AttributeValue>  attrMap  =  new  HashMap<AttributeKey,  AttributeValue>();  [BUGGY]  attrMap.put  (  attrVal,  attrKey  )  ;  enforcedAttributes.put(tagName,  attrMap);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addEnforcedAttribute  [RETURN_TYPE]  Whitelist      String  tag  String  key  String  value  [VARIABLES]  AttributeKey    attrKey    AttributeValue    attrVal    Set    attributeSet    currentSet    tagNames    boolean    TagName    tagName    String    key    tag    tagName    value    Map    attrMap    attributes    enforcedAttributes    protocols    
attrMap.put  (  attrKey,  attrVal  )  ;	[BUGGY]  attrMap.put(  attrKey);  [CONTEXT]  public  Whitelist  addEnforcedAttribute(String  tag,  String  key,  String  value)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notEmpty(value);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  AttributeValue  attrVal  =  AttributeValue.valueOf(value);    if  (enforcedAttributes.containsKey(tagName))  {  enforcedAttributes.get(tagName).put(attrKey,  attrVal);  }  else  {  Map<AttributeKey,  AttributeValue>  attrMap  =  new  HashMap<AttributeKey,  AttributeValue>();  [BUGGY]  attrMap.put  (  attrKey  )  ;  enforcedAttributes.put(tagName,  attrMap);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addEnforcedAttribute  [RETURN_TYPE]  Whitelist      String  tag  String  key  String  value  [VARIABLES]  AttributeKey    attrKey    AttributeValue    attrVal    Set    attributeSet    currentSet    tagNames    boolean    TagName    tagName    String    key    tag    tagName    value    Map    attrMap    attributes    enforcedAttributes    protocols    
attrMap.put  (  attrKey,  attrVal  )  ;  enforcedAttributes.put  (  tagName,  attrMap  )  ;	[BUGGY]    [CONTEXT]  public  Whitelist  addEnforcedAttribute(String  tag,  String  key,  String  value)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notEmpty(value);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  AttributeValue  attrVal  =  AttributeValue.valueOf(value);    if  (enforcedAttributes.containsKey(tagName))  {  enforcedAttributes.get(tagName).put(attrKey,  attrVal);  }  else  {  Map<AttributeKey,  AttributeValue>  attrMap  =  new  HashMap<AttributeKey,  AttributeValue>();  [BUGGY]  attrMap.put(attrKey,  attrVal);      }  return  this;        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addEnforcedAttribute  [RETURN_TYPE]  Whitelist      String  tag  String  key  String  value  [VARIABLES]  AttributeKey    attrKey    AttributeValue    attrVal    Set    attributeSet    currentSet    tagNames    boolean    TagName    tagName    String    key    tag    tagName    value    Map    attrMap    attributes    enforcedAttributes    protocols    
attrMap.put  (  attrKey,  attrVal  )  ;  enforcedAttributes.put  (  tagName,  attrMap  )  ;	[BUGGY]  enforcedAttributes.put(  tagName,  attrMap);  attrMap.put(  attrKey,  attrVal);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addEnforcedAttribute  [RETURN_TYPE]  Whitelist      String  tag  String  key  String  value  [VARIABLES]  AttributeKey    attrKey    AttributeValue    attrVal    Set    attributeSet    currentSet    tagNames    boolean    TagName    tagName    String    key    tag    tagName    value    Map    attrMap    attributes    enforcedAttributes    protocols    
attrMap.put  (  attrKey,  attrVal  )  ;  enforcedAttributes.put  (  tagName,  attrMap  )  ;	[BUGGY]  enforcedAttributes.put(  tagName,  attrMap);attrMap.put(  attrKey,  attrVal);  enforcedAttributes.put(  tagName,  attrMap);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addEnforcedAttribute  [RETURN_TYPE]  Whitelist      String  tag  String  key  String  value  [VARIABLES]  AttributeKey    attrKey    AttributeValue    attrVal    Set    attributeSet    currentSet    tagNames    boolean    TagName    tagName    String    key    tag    tagName    value    Map    attrMap    attributes    enforcedAttributes    protocols    
enforcedAttributes.put  (  tagName,  attrMap  )  ;	[BUGGY]  enforcedAttributes.put(  attrMap,  tagName);  [CONTEXT]  public  Whitelist  addEnforcedAttribute(String  tag,  String  key,  String  value)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notEmpty(value);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  AttributeValue  attrVal  =  AttributeValue.valueOf(value);    if  (enforcedAttributes.containsKey(tagName))  {  enforcedAttributes.get(tagName).put(attrKey,  attrVal);  }  else  {  Map<AttributeKey,  AttributeValue>  attrMap  =  new  HashMap<AttributeKey,  AttributeValue>();  attrMap.put(attrKey,  attrVal);  [BUGGY]  enforcedAttributes.put  (  attrMap,  tagName  )  ;  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addEnforcedAttribute  [RETURN_TYPE]  Whitelist      String  tag  String  key  String  value  [VARIABLES]  AttributeKey    attrKey    AttributeValue    attrVal    Set    attributeSet    currentSet    tagNames    boolean    TagName    tagName    String    key    tag    tagName    value    Map    attrMap    attributes    enforcedAttributes    protocols    
enforcedAttributes.put  (  tagName,  attrMap  )  ;	[BUGGY]  enforcedAttributes.put(    attrMap);  [CONTEXT]  public  Whitelist  addEnforcedAttribute(String  tag,  String  key,  String  value)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notEmpty(value);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  AttributeValue  attrVal  =  AttributeValue.valueOf(value);    if  (enforcedAttributes.containsKey(tagName))  {  enforcedAttributes.get(tagName).put(attrKey,  attrVal);  }  else  {  Map<AttributeKey,  AttributeValue>  attrMap  =  new  HashMap<AttributeKey,  AttributeValue>();  attrMap.put(attrKey,  attrVal);  [BUGGY]  enforcedAttributes.put  (attrMap  )  ;  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addEnforcedAttribute  [RETURN_TYPE]  Whitelist      String  tag  String  key  String  value  [VARIABLES]  AttributeKey    attrKey    AttributeValue    attrVal    Set    attributeSet    currentSet    tagNames    boolean    TagName    tagName    String    key    tag    tagName    value    Map    attrMap    attributes    enforcedAttributes    protocols    
enforcedAttributes.put  (  tagName,  attrMap  )  ;	[BUGGY]  enforcedAttributes.put(  tagName);  [CONTEXT]  public  Whitelist  addEnforcedAttribute(String  tag,  String  key,  String  value)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notEmpty(value);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  AttributeValue  attrVal  =  AttributeValue.valueOf(value);    if  (enforcedAttributes.containsKey(tagName))  {  enforcedAttributes.get(tagName).put(attrKey,  attrVal);  }  else  {  Map<AttributeKey,  AttributeValue>  attrMap  =  new  HashMap<AttributeKey,  AttributeValue>();  attrMap.put(attrKey,  attrVal);  [BUGGY]  enforcedAttributes.put  (  tagName  )  ;  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addEnforcedAttribute  [RETURN_TYPE]  Whitelist      String  tag  String  key  String  value  [VARIABLES]  AttributeKey    attrKey    AttributeValue    attrVal    Set    attributeSet    currentSet    tagNames    boolean    TagName    tagName    String    key    tag    tagName    value    Map    attrMap    attributes    enforcedAttributes    protocols    
enforcedAttributes.put  (  tagName,  attrMap  )  ;  }	[BUGGY]    [CONTEXT]  public  Whitelist  addEnforcedAttribute(String  tag,  String  key,  String  value)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notEmpty(value);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  AttributeValue  attrVal  =  AttributeValue.valueOf(value);    if  (enforcedAttributes.containsKey(tagName))  {  enforcedAttributes.get(tagName).put(attrKey,  attrVal);  }  else  {  Map<AttributeKey,  AttributeValue>  attrMap  =  new  HashMap<AttributeKey,  AttributeValue>();  attrMap.put(attrKey,  attrVal);  [BUGGY]  enforcedAttributes.put(tagName,  attrMap);      return  this;        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addEnforcedAttribute  [RETURN_TYPE]  Whitelist      String  tag  String  key  String  value  [VARIABLES]  AttributeKey    attrKey    AttributeValue    attrVal    Set    attributeSet    currentSet    tagNames    boolean    TagName    tagName    String    key    tag    tagName    value    Map    attrMap    attributes    enforcedAttributes    protocols    
enforcedAttributes.put  (  tagName,  attrMap  )  ;	[BUGGY]  if  (  enforcedAttributes.containsKey(  tagName))  {  enforcedAttributes.put(  tagName,  attrMap);  }  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addEnforcedAttribute  [RETURN_TYPE]  Whitelist      String  tag  String  key  String  value  [VARIABLES]  AttributeKey    attrKey    AttributeValue    attrVal    Set    attributeSet    currentSet    tagNames    boolean    TagName    tagName    String    key    tag    tagName    value    Map    attrMap    attributes    enforcedAttributes    protocols    
enforcedAttributes.get  (  tagName  )  .put  (  attrKey,  attrVal  )  ;	[BUGGY]  enforcedAttributes.get(  attrVal).put(  attrKey,  tagName);  [CONTEXT]  public  Whitelist  addEnforcedAttribute(String  tag,  String  key,  String  value)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notEmpty(value);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  AttributeValue  attrVal  =  AttributeValue.valueOf(value);    if  (enforcedAttributes.containsKey(tagName))  {  [BUGGY]  enforcedAttributes.get  (  attrVal  )  .put  (  attrKey,  tagName  )  ;  }  else  {  Map<AttributeKey,  AttributeValue>  attrMap  =  new  HashMap<AttributeKey,  AttributeValue>();  attrMap.put(attrKey,  attrVal);  enforcedAttributes.put(tagName,  attrMap);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addEnforcedAttribute  [RETURN_TYPE]  Whitelist      String  tag  String  key  String  value  [VARIABLES]  AttributeKey    attrKey    AttributeValue    attrVal    Set    attributeSet    currentSet    tagNames    boolean    TagName    tagName    String    key    tag    tagName    value    Map    attrMap    attributes    enforcedAttributes    protocols    
enforcedAttributes.get  (  tagName  )  .put  (  attrKey,  attrVal  )  ;	[BUGGY]  enforcedAttributes.get(  attrKey).put(  tagName,  attrVal);  [CONTEXT]  public  Whitelist  addEnforcedAttribute(String  tag,  String  key,  String  value)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notEmpty(value);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  AttributeValue  attrVal  =  AttributeValue.valueOf(value);    if  (enforcedAttributes.containsKey(tagName))  {  [BUGGY]  enforcedAttributes.get  (  attrKey  )  .put  (  tagName,  attrVal  )  ;  }  else  {  Map<AttributeKey,  AttributeValue>  attrMap  =  new  HashMap<AttributeKey,  AttributeValue>();  attrMap.put(attrKey,  attrVal);  enforcedAttributes.put(tagName,  attrMap);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addEnforcedAttribute  [RETURN_TYPE]  Whitelist      String  tag  String  key  String  value  [VARIABLES]  AttributeKey    attrKey    AttributeValue    attrVal    Set    attributeSet    currentSet    tagNames    boolean    TagName    tagName    String    key    tag    tagName    value    Map    attrMap    attributes    enforcedAttributes    protocols    
enforcedAttributes.get  (  tagName  )  .put  (  attrKey,  attrVal  )  ;	[BUGGY]  enforcedAttributes.get(  tagName).put(    attrVal);  [CONTEXT]  public  Whitelist  addEnforcedAttribute(String  tag,  String  key,  String  value)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notEmpty(value);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  AttributeValue  attrVal  =  AttributeValue.valueOf(value);    if  (enforcedAttributes.containsKey(tagName))  {  [BUGGY]  enforcedAttributes.get  (  tagName  )  .put  (attrVal  )  ;  }  else  {  Map<AttributeKey,  AttributeValue>  attrMap  =  new  HashMap<AttributeKey,  AttributeValue>();  attrMap.put(attrKey,  attrVal);  enforcedAttributes.put(tagName,  attrMap);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addEnforcedAttribute  [RETURN_TYPE]  Whitelist      String  tag  String  key  String  value  [VARIABLES]  AttributeKey    attrKey    AttributeValue    attrVal    Set    attributeSet    currentSet    tagNames    boolean    TagName    tagName    String    key    tag    tagName    value    Map    attrMap    attributes    enforcedAttributes    protocols    
enforcedAttributes.get  (  tagName  )  .put  (  attrKey,  attrVal  )  ;	[BUGGY]  enforcedAttributes.get(  tagName).put(  attrVal,  attrKey);  [CONTEXT]  public  Whitelist  addEnforcedAttribute(String  tag,  String  key,  String  value)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notEmpty(value);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  AttributeValue  attrVal  =  AttributeValue.valueOf(value);    if  (enforcedAttributes.containsKey(tagName))  {  [BUGGY]  enforcedAttributes.get  (  tagName  )  .put  (  attrVal,  attrKey  )  ;  }  else  {  Map<AttributeKey,  AttributeValue>  attrMap  =  new  HashMap<AttributeKey,  AttributeValue>();  attrMap.put(attrKey,  attrVal);  enforcedAttributes.put(tagName,  attrMap);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addEnforcedAttribute  [RETURN_TYPE]  Whitelist      String  tag  String  key  String  value  [VARIABLES]  AttributeKey    attrKey    AttributeValue    attrVal    Set    attributeSet    currentSet    tagNames    boolean    TagName    tagName    String    key    tag    tagName    value    Map    attrMap    attributes    enforcedAttributes    protocols    
enforcedAttributes.get  (  tagName  )  .put  (  attrKey,  attrVal  )  ;	[BUGGY]  enforcedAttributes.get(  tagName).put(  attrKey);  [CONTEXT]  public  Whitelist  addEnforcedAttribute(String  tag,  String  key,  String  value)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notEmpty(value);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  AttributeValue  attrVal  =  AttributeValue.valueOf(value);    if  (enforcedAttributes.containsKey(tagName))  {  [BUGGY]  enforcedAttributes.get  (  tagName  )  .put  (  attrKey  )  ;  }  else  {  Map<AttributeKey,  AttributeValue>  attrMap  =  new  HashMap<AttributeKey,  AttributeValue>();  attrMap.put(attrKey,  attrVal);  enforcedAttributes.put(tagName,  attrMap);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addEnforcedAttribute  [RETURN_TYPE]  Whitelist      String  tag  String  key  String  value  [VARIABLES]  AttributeKey    attrKey    AttributeValue    attrVal    Set    attributeSet    currentSet    tagNames    boolean    TagName    tagName    String    key    tag    tagName    value    Map    attrMap    attributes    enforcedAttributes    protocols    
enforcedAttributes.get  (  tagName  )  .put  (  attrKey,  attrVal  )  ;	[BUGGY]  enforcedAttributes.get(  tagName).addAttributes(  attrKey,  attrVal);  [CONTEXT]  public  Whitelist  addEnforcedAttribute(String  tag,  String  key,  String  value)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notEmpty(value);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  AttributeValue  attrVal  =  AttributeValue.valueOf(value);    if  (enforcedAttributes.containsKey(tagName))  {  [BUGGY]  enforcedAttributes.get  (  tagName  )  .addAttributes  (  attrKey,  attrVal  )  ;  }  else  {  Map<AttributeKey,  AttributeValue>  attrMap  =  new  HashMap<AttributeKey,  AttributeValue>();  attrMap.put(attrKey,  attrVal);  enforcedAttributes.put(tagName,  attrMap);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addEnforcedAttribute  [RETURN_TYPE]  Whitelist      String  tag  String  key  String  value  [VARIABLES]  AttributeKey    attrKey    AttributeValue    attrVal    Set    attributeSet    currentSet    tagNames    boolean    TagName    tagName    String    key    tag    tagName    value    Map    attrMap    attributes    enforcedAttributes    protocols    
enforcedAttributes.get  (  tagName  )  .put  (  attrKey,  attrVal  )  ;	[BUGGY]  enforcedAttributes.containsKey(  tagName).put(  attrKey,  attrVal);  [CONTEXT]  public  Whitelist  addEnforcedAttribute(String  tag,  String  key,  String  value)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notEmpty(value);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  AttributeValue  attrVal  =  AttributeValue.valueOf(value);    if  (enforcedAttributes.containsKey(tagName))  {  [BUGGY]  enforcedAttributes.containsKey  (  tagName  )  .put  (  attrKey,  attrVal  )  ;  }  else  {  Map<AttributeKey,  AttributeValue>  attrMap  =  new  HashMap<AttributeKey,  AttributeValue>();  attrMap.put(attrKey,  attrVal);  enforcedAttributes.put(tagName,  attrMap);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addEnforcedAttribute  [RETURN_TYPE]  Whitelist      String  tag  String  key  String  value  [VARIABLES]  AttributeKey    attrKey    AttributeValue    attrVal    Set    attributeSet    currentSet    tagNames    boolean    TagName    tagName    String    key    tag    tagName    value    Map    attrMap    attributes    enforcedAttributes    protocols    
enforcedAttributes.get  (  tagName  )  .put  (  attrKey,  attrVal  )  ;  }  else  {  Map<AttributeKey,  AttributeValue>  attrMap  =  new  HashMap<AttributeKey,  AttributeValue>  (  )  ;  attrMap.put  (  attrKey,  attrVal  )  ;  enforcedAttributes.put  (  tagName,  attrMap  )  ;  }	[BUGGY]    [CONTEXT]  public  Whitelist  addEnforcedAttribute(String  tag,  String  key,  String  value)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notEmpty(value);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  AttributeValue  attrVal  =  AttributeValue.valueOf(value);    if  (enforcedAttributes.containsKey(tagName))  {  [BUGGY]  enforcedAttributes.get(tagName).put(attrKey,  attrVal);            }  return  this;        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addEnforcedAttribute  [RETURN_TYPE]  Whitelist      String  tag  String  key  String  value  [VARIABLES]  AttributeKey    attrKey    AttributeValue    attrVal    Set    attributeSet    currentSet    tagNames    boolean    TagName    tagName    String    key    tag    tagName    value    Map    attrMap    attributes    enforcedAttributes    protocols    
if  (  enforcedAttributes.containsKey  (  tagName  )  )  {	[BUGGY]  if  (  enforcedAttributes  .entrySet(  )  )  {  [CONTEXT]  public  Whitelist  addEnforcedAttribute(String  tag,  String  key,  String  value)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notEmpty(value);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  AttributeValue  attrVal  =  AttributeValue.valueOf(value);    [BUGGY]  if(  enforcedAttributes  .entrySet  ()  ){  enforcedAttributes.get(tagName).put(attrKey,  attrVal);  }  else  {  Map<AttributeKey,  AttributeValue>  attrMap  =  new  HashMap<AttributeKey,  AttributeValue>();  attrMap.put(attrKey,  attrVal);  enforcedAttributes.put(tagName,  attrMap);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addEnforcedAttribute  [RETURN_TYPE]  Whitelist      String  tag  String  key  String  value  [VARIABLES]  AttributeKey    attrKey    AttributeValue    attrVal    Set    attributeSet    currentSet    tagNames    boolean    TagName    tagName    String    key    tag    tagName    value    Map    attrMap    attributes    enforcedAttributes    protocols    
attrMap.put  (  attrKey,  attrVal  )  ;	[BUGGY]    [CONTEXT]  public  Whitelist  addEnforcedAttribute(String  tag,  String  key,  String  value)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notEmpty(value);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  AttributeValue  attrVal  =  AttributeValue.valueOf(value);    if  (enforcedAttributes.containsKey(tagName))  {  enforcedAttributes.get(tagName).put(attrKey,  attrVal);  }  else  {  Map<AttributeKey,  AttributeValue>  attrMap  =  new  HashMap<AttributeKey,  AttributeValue>();  [BUGGY]  attrMap.put(attrKey,  attrVal);    enforcedAttributes.put(tagName,  attrMap);  }  return  this;        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addEnforcedAttribute  [RETURN_TYPE]  Whitelist      String  tag  String  key  String  value  [VARIABLES]  AttributeKey    attrKey    AttributeValue    attrVal    Set    attributeSet    currentSet    tagNames    boolean    TagName    tagName    String    key    tag    tagName    value    Map    attrMap    attributes    enforcedAttributes    protocols    
attrMap.put  (  attrKey,  attrVal  )  ;	[BUGGY]    attrMap.put(  attrKey,  attrVal);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addEnforcedAttribute  [RETURN_TYPE]  Whitelist      String  tag  String  key  String  value  [VARIABLES]  AttributeKey    attrKey    AttributeValue    attrVal    Set    attributeSet    currentSet    tagNames    boolean    TagName    tagName    String    key    tag    tagName    value    Map    attrMap    attributes    enforcedAttributes    protocols    
attrMap.put  (  attrKey,  attrVal  )  ;	[BUGGY]  attributes.put(  tagName,  attributeSet);attrMap.put(  attrKey,  attrVal);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addEnforcedAttribute  [RETURN_TYPE]  Whitelist      String  tag  String  key  String  value  [VARIABLES]  AttributeKey    attrKey    AttributeValue    attrVal    Set    attributeSet    currentSet    tagNames    boolean    TagName    tagName    String    key    tag    tagName    value    Map    attrMap    attributes    enforcedAttributes    protocols    
attrMap.put  (  attrKey,  attrVal  )  ;	[BUGGY]  enforcedAttributes.put(  tagName,  attrMap);attrMap.put(  attrKey,  attrVal);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addEnforcedAttribute  [RETURN_TYPE]  Whitelist      String  tag  String  key  String  value  [VARIABLES]  AttributeKey    attrKey    AttributeValue    attrVal    Set    attributeSet    currentSet    tagNames    boolean    TagName    tagName    String    key    tag    tagName    value    Map    attrMap    attributes    enforcedAttributes    protocols    
attrMap.put  (  attrKey,  attrVal  )  ;	[BUGGY]  enforcedAttributes.get(  tagName).put(  attrKey,  attrVal);attrMap.put(  attrKey,  attrVal);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addEnforcedAttribute  [RETURN_TYPE]  Whitelist      String  tag  String  key  String  value  [VARIABLES]  AttributeKey    attrKey    AttributeValue    attrVal    Set    attributeSet    currentSet    tagNames    boolean    TagName    tagName    String    key    tag    tagName    value    Map    attrMap    attributes    enforcedAttributes    protocols    
attrMap.put  (  attrKey,  attrVal  )  ;	[BUGGY]  attrMap.put(  attrKey,  protSet);attrMap.put(  attrKey,  attrVal);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addEnforcedAttribute  [RETURN_TYPE]  Whitelist      String  tag  String  key  String  value  [VARIABLES]  AttributeKey    attrKey    AttributeValue    attrVal    Set    attributeSet    currentSet    tagNames    boolean    TagName    tagName    String    key    tag    tagName    value    Map    attrMap    attributes    enforcedAttributes    protocols    
enforcedAttributes.put  (  tagName,  attrMap  )  ;	[BUGGY]  enforcedAttributes  .put(  )  ;  [CONTEXT]  public  Whitelist  addEnforcedAttribute(String  tag,  String  key,  String  value)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notEmpty(value);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  AttributeValue  attrVal  =  AttributeValue.valueOf(value);    if  (enforcedAttributes.containsKey(tagName))  {  enforcedAttributes.get(tagName).put(attrKey,  attrVal);  }  else  {  Map<AttributeKey,  AttributeValue>  attrMap  =  new  HashMap<AttributeKey,  AttributeValue>();  attrMap.put(attrKey,  attrVal);  [BUGGY]  enforcedAttributes  .put  ();  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addEnforcedAttribute  [RETURN_TYPE]  Whitelist      String  tag  String  key  String  value  [VARIABLES]  AttributeKey    attrKey    AttributeValue    attrVal    Set    attributeSet    currentSet    tagNames    boolean    TagName    tagName    String    key    tag    tagName    value    Map    attrMap    attributes    enforcedAttributes    protocols    
return  this;	[BUGGY]  return  null;  [CONTEXT]  public  Whitelist  addEnforcedAttribute(String  tag,  String  key,  String  value)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notEmpty(value);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  AttributeValue  attrVal  =  AttributeValue.valueOf(value);    if  (enforcedAttributes.containsKey(tagName))  {  enforcedAttributes.get(tagName).put(attrKey,  attrVal);  }  else  {  Map<AttributeKey,  AttributeValue>  attrMap  =  new  HashMap<AttributeKey,  AttributeValue>();  attrMap.put(attrKey,  attrVal);  enforcedAttributes.put(tagName,  attrMap);  }  [BUGGY]  return  null;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addEnforcedAttribute  [RETURN_TYPE]  Whitelist      String  tag  String  key  String  value  [VARIABLES]  AttributeKey    attrKey    AttributeValue    attrVal    Set    attributeSet    currentSet    tagNames    boolean    TagName    tagName    String    key    tag    tagName    value    Map    attrMap    attributes    enforcedAttributes    protocols    
Validate.notEmpty  (  tag  )  ;	[BUGGY]  Validate.notEmpty(  value);  [CONTEXT]  public  Whitelist  addProtocols(String  tag,  String  key,  String...  protocols)  {  [BUGGY]  Validate.notEmpty  (  value  )  ;  Validate.notEmpty(key);  Validate.notNull(protocols);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  Map<AttributeKey,  Set<Protocol>>  attrMap;  Set<Protocol>  protSet;    if  (this.protocols.containsKey(tagName))  {  attrMap  =  this.protocols.get(tagName);  }  else  {  attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>();  this.protocols.put(tagName,  attrMap);  }  if  (attrMap.containsKey(attrKey))  {  protSet  =  attrMap.get(attrKey);  }  else  {  protSet  =  new  HashSet<Protocol>();  attrMap.put(attrKey,  protSet);  }  for  (String  protocol  :  protocols)  {  Validate.notEmpty(protocol);  Protocol  prot  =  Protocol.valueOf(protocol);  protSet.add(prot);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
Validate.notEmpty  (  tag  )  ;	[BUGGY]  Validate.notNull(  tag);  [CONTEXT]  public  Whitelist  addProtocols(String  tag,  String  key,  String...  protocols)  {  [BUGGY]  Validate.notNull  (  tag  )  ;  Validate.notEmpty(key);  Validate.notNull(protocols);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  Map<AttributeKey,  Set<Protocol>>  attrMap;  Set<Protocol>  protSet;    if  (this.protocols.containsKey(tagName))  {  attrMap  =  this.protocols.get(tagName);  }  else  {  attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>();  this.protocols.put(tagName,  attrMap);  }  if  (attrMap.containsKey(attrKey))  {  protSet  =  attrMap.get(attrKey);  }  else  {  protSet  =  new  HashSet<Protocol>();  attrMap.put(attrKey,  protSet);  }  for  (String  protocol  :  protocols)  {  Validate.notEmpty(protocol);  Protocol  prot  =  Protocol.valueOf(protocol);  protSet.add(prot);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
Validate.notEmpty  (  tag  )  ;	[BUGGY]  Validate.notEmpty(  tagName);  [CONTEXT]  public  Whitelist  addProtocols(String  tag,  String  key,  String...  protocols)  {  [BUGGY]  Validate.notEmpty  (  tagName  )  ;  Validate.notEmpty(key);  Validate.notNull(protocols);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  Map<AttributeKey,  Set<Protocol>>  attrMap;  Set<Protocol>  protSet;    if  (this.protocols.containsKey(tagName))  {  attrMap  =  this.protocols.get(tagName);  }  else  {  attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>();  this.protocols.put(tagName,  attrMap);  }  if  (attrMap.containsKey(attrKey))  {  protSet  =  attrMap.get(attrKey);  }  else  {  protSet  =  new  HashSet<Protocol>();  attrMap.put(attrKey,  protSet);  }  for  (String  protocol  :  protocols)  {  Validate.notEmpty(protocol);  Protocol  prot  =  Protocol.valueOf(protocol);  protSet.add(prot);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
Validate.notEmpty  (  tag  )  ;  Validate.notEmpty  (  key  )  ;	[BUGGY]    [CONTEXT]  public  Whitelist  addProtocols(String  tag,  String  key,  String...  protocols)  {  [BUGGY]  Validate.notEmpty(tag);      Validate.notNull(protocols);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  Map<AttributeKey,  Set<Protocol>>  attrMap;  Set<Protocol>  protSet;    if  (this.protocols.containsKey(tagName))  {  attrMap  =  this.protocols.get(tagName);  }  else  {  attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>();  this.protocols.put(tagName,  attrMap);  }  if  (attrMap.containsKey(attrKey))  {  protSet  =  attrMap.get(attrKey);  }  else  {  protSet  =  new  HashSet<Protocol>();  attrMap.put(attrKey,  protSet);  }  for  (String  protocol  :  protocols)  {  Validate.notEmpty(protocol);  Protocol  prot  =  Protocol.valueOf(protocol);  protSet.add(prot);  }  return  this;        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
Validate.notEmpty  (  tag  )  ;	[BUGGY]  Validate.notNull(  value);Validate.notEmpty(  tag);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
Validate.notEmpty  (  tag  )  ;	[BUGGY]  Validate.notNull(  tags);Validate.notEmpty(  tag);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
Validate.notEmpty  (  tag  )  ;	[BUGGY]  Validate.notNull(  keys);Validate.notEmpty(  tag);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
Validate.notEmpty  (  tag  )  ;	[BUGGY]  Validate.notEmpty(  key);Validate.notEmpty(  tag);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
Validate.notEmpty  (  tag  )  ;	[BUGGY]  Validate.notEmpty(  value);Validate.notEmpty(  tag);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
Validate.notEmpty  (  tag  )  ;	[BUGGY]  Validate.notNull(  protocols);Validate.notEmpty(  tag);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
Validate.notEmpty  (  tag  )  ;	[BUGGY]  Validate.notEmpty(  tagName);Validate.notEmpty(  tag);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
Validate.notEmpty  (  tag  )  ;	[BUGGY]  Validate.notEmpty(  protocol);Validate.notEmpty(  tag);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
Validate.notEmpty  (  key  )  ;	[BUGGY]  Validate.notNull(  key);  [CONTEXT]  public  Whitelist  addProtocols(String  tag,  String  key,  String...  protocols)  {  Validate.notEmpty(tag);  [BUGGY]  Validate.notNull  (  key  )  ;  Validate.notNull(protocols);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  Map<AttributeKey,  Set<Protocol>>  attrMap;  Set<Protocol>  protSet;    if  (this.protocols.containsKey(tagName))  {  attrMap  =  this.protocols.get(tagName);  }  else  {  attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>();  this.protocols.put(tagName,  attrMap);  }  if  (attrMap.containsKey(attrKey))  {  protSet  =  attrMap.get(attrKey);  }  else  {  protSet  =  new  HashSet<Protocol>();  attrMap.put(attrKey,  protSet);  }  for  (String  protocol  :  protocols)  {  Validate.notEmpty(protocol);  Protocol  prot  =  Protocol.valueOf(protocol);  protSet.add(prot);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
Validate.notEmpty  (  key  )  ;	[BUGGY]  Validate.notEmpty(  value);  [CONTEXT]  public  Whitelist  addProtocols(String  tag,  String  key,  String...  protocols)  {  Validate.notEmpty(tag);  [BUGGY]  Validate.notEmpty  (  value  )  ;  Validate.notNull(protocols);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  Map<AttributeKey,  Set<Protocol>>  attrMap;  Set<Protocol>  protSet;    if  (this.protocols.containsKey(tagName))  {  attrMap  =  this.protocols.get(tagName);  }  else  {  attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>();  this.protocols.put(tagName,  attrMap);  }  if  (attrMap.containsKey(attrKey))  {  protSet  =  attrMap.get(attrKey);  }  else  {  protSet  =  new  HashSet<Protocol>();  attrMap.put(attrKey,  protSet);  }  for  (String  protocol  :  protocols)  {  Validate.notEmpty(protocol);  Protocol  prot  =  Protocol.valueOf(protocol);  protSet.add(prot);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
Validate.notEmpty  (  key  )  ;  Validate.notNull  (  protocols  )  ;	[BUGGY]    [CONTEXT]  public  Whitelist  addProtocols(String  tag,  String  key,  String...  protocols)  {  Validate.notEmpty(tag);  [BUGGY]  Validate.notEmpty(key);        TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  Map<AttributeKey,  Set<Protocol>>  attrMap;  Set<Protocol>  protSet;    if  (this.protocols.containsKey(tagName))  {  attrMap  =  this.protocols.get(tagName);  }  else  {  attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>();  this.protocols.put(tagName,  attrMap);  }  if  (attrMap.containsKey(attrKey))  {  protSet  =  attrMap.get(attrKey);  }  else  {  protSet  =  new  HashSet<Protocol>();  attrMap.put(attrKey,  protSet);  }  for  (String  protocol  :  protocols)  {  Validate.notEmpty(protocol);  Protocol  prot  =  Protocol.valueOf(protocol);  protSet.add(prot);  }  return  this;        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
Validate.notEmpty  (  key  )  ;	[BUGGY]  Validate.notNull(  value);Validate.notEmpty(  key);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
Validate.notEmpty  (  key  )  ;	[BUGGY]  Validate.notNull(  tags);Validate.notEmpty(  key);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
Validate.notEmpty  (  key  )  ;	[BUGGY]  Validate.notEmpty(  tag);Validate.notEmpty(  key);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
Validate.notEmpty  (  key  )  ;	[BUGGY]  Validate.notNull(  keys);Validate.notEmpty(  key);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
Validate.notEmpty  (  key  )  ;	[BUGGY]  Validate.notEmpty(  value);Validate.notEmpty(  key);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
Validate.notEmpty  (  key  )  ;	[BUGGY]  Validate.notNull(  protocols);Validate.notEmpty(  key);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
Validate.notEmpty  (  key  )  ;	[BUGGY]  Validate.notEmpty(  tagName);Validate.notEmpty(  key);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
Validate.notEmpty  (  key  )  ;	[BUGGY]  Validate.notEmpty(  protocol);Validate.notEmpty(  key);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
Validate.notNull  (  protocols  )  ;	[BUGGY]  Validate  .notEmpty(  key)  ;  [CONTEXT]  public  Whitelist  addProtocols(String  tag,  String  key,  String...  protocols)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  [BUGGY]  Validate  .notEmpty  (  key  );    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  Map<AttributeKey,  Set<Protocol>>  attrMap;  Set<Protocol>  protSet;    if  (this.protocols.containsKey(tagName))  {  attrMap  =  this.protocols.get(tagName);  }  else  {  attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>();  this.protocols.put(tagName,  attrMap);  }  if  (attrMap.containsKey(attrKey))  {  protSet  =  attrMap.get(attrKey);  }  else  {  protSet  =  new  HashSet<Protocol>();  attrMap.put(attrKey,  protSet);  }  for  (String  protocol  :  protocols)  {  Validate.notEmpty(protocol);  Protocol  prot  =  Protocol.valueOf(protocol);  protSet.add(prot);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
Validate.notNull  (  protocols  )  ;	[BUGGY]    [CONTEXT]  public  Whitelist  addProtocols(String  tag,  String  key,  String...  protocols)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  [BUGGY]  Validate.notNull(protocols);      TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  Map<AttributeKey,  Set<Protocol>>  attrMap;  Set<Protocol>  protSet;    if  (this.protocols.containsKey(tagName))  {  attrMap  =  this.protocols.get(tagName);  }  else  {  attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>();  this.protocols.put(tagName,  attrMap);  }  if  (attrMap.containsKey(attrKey))  {  protSet  =  attrMap.get(attrKey);  }  else  {  protSet  =  new  HashSet<Protocol>();  attrMap.put(attrKey,  protSet);  }  for  (String  protocol  :  protocols)  {  Validate.notEmpty(protocol);  Protocol  prot  =  Protocol.valueOf(protocol);  protSet.add(prot);  }  return  this;        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
TagName  tagName  =  TagName.valueOf  (  tag  )  ;	[BUGGY]  TagName  valueName  =  TagName.valueOf(  tag);  [CONTEXT]  public  Whitelist  addProtocols(String  tag,  String  key,  String...  protocols)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notNull(protocols);    [BUGGY]  TagName  valueName  =  TagName.valueOf  (  tag  )  ;  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  Map<AttributeKey,  Set<Protocol>>  attrMap;  Set<Protocol>  protSet;    if  (this.protocols.containsKey(tagName))  {  attrMap  =  this.protocols.get(tagName);  }  else  {  attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>();  this.protocols.put(tagName,  attrMap);  }  if  (attrMap.containsKey(attrKey))  {  protSet  =  attrMap.get(attrKey);  }  else  {  protSet  =  new  HashSet<Protocol>();  attrMap.put(attrKey,  protSet);  }  for  (String  protocol  :  protocols)  {  Validate.notEmpty(protocol);  Protocol  prot  =  Protocol.valueOf(protocol);  protSet.add(prot);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
TagName  tagName  =  TagName.valueOf  (  tag  )  ;	[BUGGY]  TagName  tagName  =  TagName.TagName(  tag);  [CONTEXT]  public  Whitelist  addProtocols(String  tag,  String  key,  String...  protocols)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notNull(protocols);    [BUGGY]  TagName  tagName  =  TagName.TagName  (  tag  )  ;  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  Map<AttributeKey,  Set<Protocol>>  attrMap;  Set<Protocol>  protSet;    if  (this.protocols.containsKey(tagName))  {  attrMap  =  this.protocols.get(tagName);  }  else  {  attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>();  this.protocols.put(tagName,  attrMap);  }  if  (attrMap.containsKey(attrKey))  {  protSet  =  attrMap.get(attrKey);  }  else  {  protSet  =  new  HashSet<Protocol>();  attrMap.put(attrKey,  protSet);  }  for  (String  protocol  :  protocols)  {  Validate.notEmpty(protocol);  Protocol  prot  =  Protocol.valueOf(protocol);  protSet.add(prot);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
TagName  tagName  =  TagName.valueOf  (  tag  )  ;	[BUGGY]  TagName  tagName  =  TagName  .TagName(  key)  ;  [CONTEXT]  public  Whitelist  addProtocols(String  tag,  String  key,  String...  protocols)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notNull(protocols);    [BUGGY]  TagName  tagName  =  TagName  .TagName  (  key  );  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  Map<AttributeKey,  Set<Protocol>>  attrMap;  Set<Protocol>  protSet;    if  (this.protocols.containsKey(tagName))  {  attrMap  =  this.protocols.get(tagName);  }  else  {  attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>();  this.protocols.put(tagName,  attrMap);  }  if  (attrMap.containsKey(attrKey))  {  protSet  =  attrMap.get(attrKey);  }  else  {  protSet  =  new  HashSet<Protocol>();  attrMap.put(attrKey,  protSet);  }  for  (String  protocol  :  protocols)  {  Validate.notEmpty(protocol);  Protocol  prot  =  Protocol.valueOf(protocol);  protSet.add(prot);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
TagName  tagName  =  TagName.valueOf  (  tag  )  ;	[BUGGY]  TagName  valueName  =  TagName.TagName(  tag);  [CONTEXT]  public  Whitelist  addProtocols(String  tag,  String  key,  String...  protocols)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notNull(protocols);    [BUGGY]  TagName  valueName  =  TagName.TagName  (  tag  )  ;  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  Map<AttributeKey,  Set<Protocol>>  attrMap;  Set<Protocol>  protSet;    if  (this.protocols.containsKey(tagName))  {  attrMap  =  this.protocols.get(tagName);  }  else  {  attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>();  this.protocols.put(tagName,  attrMap);  }  if  (attrMap.containsKey(attrKey))  {  protSet  =  attrMap.get(attrKey);  }  else  {  protSet  =  new  HashSet<Protocol>();  attrMap.put(attrKey,  protSet);  }  for  (String  protocol  :  protocols)  {  Validate.notEmpty(protocol);  Protocol  prot  =  Protocol.valueOf(protocol);  protSet.add(prot);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
TagName  tagName  =  TagName.valueOf  (  tag  )  ;  AttributeKey  attrKey  =  AttributeKey.valueOf  (  key  )  ;	[BUGGY]  AttributeKey  attrKey  =  AttributeKey.valueOf(  key);  TagName  tagName  =  TagName.valueOf(  tag);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
TagName  tagName  =  TagName.valueOf  (  tag  )  ;  AttributeKey  attrKey  =  AttributeKey.valueOf  (  key  )  ;	[BUGGY]  AttributeKey  attrKey  =  AttributeKey.valueOf(  key);TagName  tagName  =  TagName.valueOf(  tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(  key);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
TagName  tagName  =  TagName.valueOf  (  tag  )  ;	[BUGGY]  TagName  tagName  =  TagName  .TagName(  value)  ;  [CONTEXT]  public  Whitelist  addProtocols(String  tag,  String  key,  String...  protocols)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notNull(protocols);    [BUGGY]  TagName  tagName  =  TagName  .TagName  (  value  );  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  Map<AttributeKey,  Set<Protocol>>  attrMap;  Set<Protocol>  protSet;    if  (this.protocols.containsKey(tagName))  {  attrMap  =  this.protocols.get(tagName);  }  else  {  attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>();  this.protocols.put(tagName,  attrMap);  }  if  (attrMap.containsKey(attrKey))  {  protSet  =  attrMap.get(attrKey);  }  else  {  protSet  =  new  HashSet<Protocol>();  attrMap.put(attrKey,  protSet);  }  for  (String  protocol  :  protocols)  {  Validate.notEmpty(protocol);  Protocol  prot  =  Protocol.valueOf(protocol);  protSet.add(prot);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
TagName  tagName  =  TagName.valueOf  (  tag  )  ;	[BUGGY]    [CONTEXT]  public  Whitelist  addProtocols(String  tag,  String  key,  String...  protocols)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notNull(protocols);    [BUGGY]  TagName  tagName  =  TagName.valueOf(tag);    AttributeKey  attrKey  =  AttributeKey.valueOf(key);  Map<AttributeKey,  Set<Protocol>>  attrMap;  Set<Protocol>  protSet;    if  (this.protocols.containsKey(tagName))  {  attrMap  =  this.protocols.get(tagName);  }  else  {  attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>();  this.protocols.put(tagName,  attrMap);  }  if  (attrMap.containsKey(attrKey))  {  protSet  =  attrMap.get(attrKey);  }  else  {  protSet  =  new  HashSet<Protocol>();  attrMap.put(attrKey,  protSet);  }  for  (String  protocol  :  protocols)  {  Validate.notEmpty(protocol);  Protocol  prot  =  Protocol.valueOf(protocol);  protSet.add(prot);  }  return  this;        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
TagName  tagName  =  TagName.valueOf  (  tag  )  ;	[BUGGY]  AttributeKey  attrKey  =  AttributeKey.valueOf(  key);  TagName  tagName  =  TagName.valueOf(  tag);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
TagName  tagName  =  TagName.valueOf  (  tag  )  ;	[BUGGY]  TagName  tag  =  TagName.valueOf(  tagName);TagName  tagName  =  TagName.valueOf(  tag);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
TagName  tagName  =  TagName.valueOf  (  tag  )  ;	[BUGGY]  tagNames.add(  TagName.valueOf(  tagName));TagName  tagName  =  TagName.valueOf(  tag);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
TagName  tagName  =  TagName.valueOf  (  tag  )  ;	[BUGGY]  return  tagNames.contains(  TagName.valueOf(  tag));TagName  tagName  =  TagName.valueOf(  tag);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
AttributeKey  attrKey  =  AttributeKey.valueOf  (  key  )  ;	[BUGGY]  AttributeKey  attrKey  =  AttributeKey.valueOf(  value);  [CONTEXT]  public  Whitelist  addProtocols(String  tag,  String  key,  String...  protocols)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notNull(protocols);    TagName  tagName  =  TagName.valueOf(tag);  [BUGGY]  AttributeKey  attrKey  =  AttributeKey.valueOf  (  value  )  ;  Map<AttributeKey,  Set<Protocol>>  attrMap;  Set<Protocol>  protSet;    if  (this.protocols.containsKey(tagName))  {  attrMap  =  this.protocols.get(tagName);  }  else  {  attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>();  this.protocols.put(tagName,  attrMap);  }  if  (attrMap.containsKey(attrKey))  {  protSet  =  attrMap.get(attrKey);  }  else  {  protSet  =  new  HashSet<Protocol>();  attrMap.put(attrKey,  protSet);  }  for  (String  protocol  :  protocols)  {  Validate.notEmpty(protocol);  Protocol  prot  =  Protocol.valueOf(protocol);  protSet.add(prot);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
AttributeKey  attrKey  =  AttributeKey.valueOf  (  key  )  ;	[BUGGY]  AttributeKey  attrKey  =  AttributeKey.AttributeKey(  key);  [CONTEXT]  public  Whitelist  addProtocols(String  tag,  String  key,  String...  protocols)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notNull(protocols);    TagName  tagName  =  TagName.valueOf(tag);  [BUGGY]  AttributeKey  attrKey  =  AttributeKey.AttributeKey  (  key  )  ;  Map<AttributeKey,  Set<Protocol>>  attrMap;  Set<Protocol>  protSet;    if  (this.protocols.containsKey(tagName))  {  attrMap  =  this.protocols.get(tagName);  }  else  {  attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>();  this.protocols.put(tagName,  attrMap);  }  if  (attrMap.containsKey(attrKey))  {  protSet  =  attrMap.get(attrKey);  }  else  {  protSet  =  new  HashSet<Protocol>();  attrMap.put(attrKey,  protSet);  }  for  (String  protocol  :  protocols)  {  Validate.notEmpty(protocol);  Protocol  prot  =  Protocol.valueOf(protocol);  protSet.add(prot);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
AttributeKey  attrKey  =  AttributeKey.valueOf  (  key  )  ;	[BUGGY]  AttributeKey  attrKey  =  AttributeKey  .TagName(  value)  ;  [CONTEXT]  public  Whitelist  addProtocols(String  tag,  String  key,  String...  protocols)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notNull(protocols);    TagName  tagName  =  TagName.valueOf(tag);  [BUGGY]  AttributeKey  attrKey  =  AttributeKey  .TagName  (  value  );  Map<AttributeKey,  Set<Protocol>>  attrMap;  Set<Protocol>  protSet;    if  (this.protocols.containsKey(tagName))  {  attrMap  =  this.protocols.get(tagName);  }  else  {  attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>();  this.protocols.put(tagName,  attrMap);  }  if  (attrMap.containsKey(attrKey))  {  protSet  =  attrMap.get(attrKey);  }  else  {  protSet  =  new  HashSet<Protocol>();  attrMap.put(attrKey,  protSet);  }  for  (String  protocol  :  protocols)  {  Validate.notEmpty(protocol);  Protocol  prot  =  Protocol.valueOf(protocol);  protSet.add(prot);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
AttributeKey  attrKey  =  AttributeKey.valueOf  (  key  )  ;	[BUGGY]  AttributeKey  attrKey  =  AttributeKey.valueOf(  tagName);  [CONTEXT]  public  Whitelist  addProtocols(String  tag,  String  key,  String...  protocols)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notNull(protocols);    TagName  tagName  =  TagName.valueOf(tag);  [BUGGY]  AttributeKey  attrKey  =  AttributeKey.valueOf  (  tagName  )  ;  Map<AttributeKey,  Set<Protocol>>  attrMap;  Set<Protocol>  protSet;    if  (this.protocols.containsKey(tagName))  {  attrMap  =  this.protocols.get(tagName);  }  else  {  attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>();  this.protocols.put(tagName,  attrMap);  }  if  (attrMap.containsKey(attrKey))  {  protSet  =  attrMap.get(attrKey);  }  else  {  protSet  =  new  HashSet<Protocol>();  attrMap.put(attrKey,  protSet);  }  for  (String  protocol  :  protocols)  {  Validate.notEmpty(protocol);  Protocol  prot  =  Protocol.valueOf(protocol);  protSet.add(prot);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
AttributeKey  attrKey  =  AttributeKey.valueOf  (  key  )  ;	[BUGGY]  Attributes  attrs  =  new  Attributes(  );AttributeKey  attrKey  =  AttributeKey.valueOf(  key);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
AttributeKey  attrKey  =  AttributeKey.valueOf  (  key  )  ;	[BUGGY]  AttributeKey  key  =  AttributeKey.valueOf(  attr.getKey(  ));AttributeKey  attrKey  =  AttributeKey.valueOf(  key);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
AttributeKey  attrKey  =  AttributeKey.valueOf  (  key  )  ;	[BUGGY]  Set<AttributeKey>  currentSet  =  attributes.get(  tagName);AttributeKey  attrKey  =  AttributeKey.valueOf(  key);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
AttributeKey  attrKey  =  AttributeKey.valueOf  (  key  )  ;	[BUGGY]  AttributeValue  attrVal  =  AttributeValue.valueOf(  value);AttributeKey  attrKey  =  AttributeKey.valueOf(  key);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
AttributeKey  attrKey  =  AttributeKey.valueOf  (  key  )  ;	[BUGGY]    [CONTEXT]  public  Whitelist  addProtocols(String  tag,  String  key,  String...  protocols)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notNull(protocols);    TagName  tagName  =  TagName.valueOf(tag);  [BUGGY]  AttributeKey  attrKey  =  AttributeKey.valueOf(key);    Map<AttributeKey,  Set<Protocol>>  attrMap;  Set<Protocol>  protSet;    if  (this.protocols.containsKey(tagName))  {  attrMap  =  this.protocols.get(tagName);  }  else  {  attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>();  this.protocols.put(tagName,  attrMap);  }  if  (attrMap.containsKey(attrKey))  {  protSet  =  attrMap.get(attrKey);  }  else  {  protSet  =  new  HashSet<Protocol>();  attrMap.put(attrKey,  protSet);  }  for  (String  protocol  :  protocols)  {  Validate.notEmpty(protocol);  Protocol  prot  =  Protocol.valueOf(protocol);  protSet.add(prot);  }  return  this;        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
AttributeKey  attrKey  =  AttributeKey.valueOf  (  key  )  ;	[BUGGY]  Map<AttributeKey,  Set<Protocol>>  attrMap;  AttributeKey  attrKey  =  AttributeKey.valueOf(  key);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
AttributeKey  attrKey  =  AttributeKey.valueOf  (  key  )  ;	[BUGGY]  attributeSet.add(  AttributeKey.valueOf(  key));AttributeKey  attrKey  =  AttributeKey.valueOf(  key);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
Map<AttributeKey,  Set<Protocol>>  attrMap;	[BUGGY]  Set<Protocol>  protSet;  Map<AttributeKey,  Set<Protocol>>  attrMap;  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
Map<AttributeKey,  Set<Protocol>>  attrMap;	[BUGGY]  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get(  tag);Map<AttributeKey,  Set<Protocol>>  attrMap;  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
if  (  this.protocols.containsKey  (  tagName  )  )  {	[BUGGY]  if  (  this.protocols  .entrySet(  )  )  {  [CONTEXT]  public  Whitelist  addProtocols(String  tag,  String  key,  String...  protocols)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notNull(protocols);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  Map<AttributeKey,  Set<Protocol>>  attrMap;  Set<Protocol>  protSet;    [BUGGY]  if(  this.protocols  .entrySet  ()  ){  attrMap  =  this.protocols.get(tagName);  }  else  {  attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>();  this.protocols.put(tagName,  attrMap);  }  if  (attrMap.containsKey(attrKey))  {  protSet  =  attrMap.get(attrKey);  }  else  {  protSet  =  new  HashSet<Protocol>();  attrMap.put(attrKey,  protSet);  }  for  (String  protocol  :  protocols)  {  Validate.notEmpty(protocol);  Protocol  prot  =  Protocol.valueOf(protocol);  protSet.add(prot);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
if  (  this.protocols.containsKey  (  tagName  )  )  {	[BUGGY]  if  (  enforcedAttributes.containsKey(  tagName))  {  [CONTEXT]  public  Whitelist  addProtocols(String  tag,  String  key,  String...  protocols)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notNull(protocols);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  Map<AttributeKey,  Set<Protocol>>  attrMap;  Set<Protocol>  protSet;    [BUGGY]  if(  enforcedAttributes.containsKey  (  tagName  )){  attrMap  =  this.protocols.get(tagName);  }  else  {  attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>();  this.protocols.put(tagName,  attrMap);  }  if  (attrMap.containsKey(attrKey))  {  protSet  =  attrMap.get(attrKey);  }  else  {  protSet  =  new  HashSet<Protocol>();  attrMap.put(attrKey,  protSet);  }  for  (String  protocol  :  protocols)  {  Validate.notEmpty(protocol);  Protocol  prot  =  Protocol.valueOf(protocol);  protSet.add(prot);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
if  (  this.protocols.containsKey  (  tagName  )  )  {	[BUGGY]  if  (  attributes.containsKey(  tag))  {  [CONTEXT]  public  Whitelist  addProtocols(String  tag,  String  key,  String...  protocols)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notNull(protocols);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  Map<AttributeKey,  Set<Protocol>>  attrMap;  Set<Protocol>  protSet;    [BUGGY]  if(  attributes.containsKey  (  tag  )){  attrMap  =  this.protocols.get(tagName);  }  else  {  attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>();  this.protocols.put(tagName,  attrMap);  }  if  (attrMap.containsKey(attrKey))  {  protSet  =  attrMap.get(attrKey);  }  else  {  protSet  =  new  HashSet<Protocol>();  attrMap.put(attrKey,  protSet);  }  for  (String  protocol  :  protocols)  {  Validate.notEmpty(protocol);  Protocol  prot  =  Protocol.valueOf(protocol);  protSet.add(prot);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
if  (  this.protocols.containsKey  (  tagName  )  )  {	[BUGGY]  if  (  attributes.containsKey(  tagName))  {  [CONTEXT]  public  Whitelist  addProtocols(String  tag,  String  key,  String...  protocols)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notNull(protocols);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  Map<AttributeKey,  Set<Protocol>>  attrMap;  Set<Protocol>  protSet;    [BUGGY]  if(  attributes.containsKey  (  tagName  )){  attrMap  =  this.protocols.get(tagName);  }  else  {  attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>();  this.protocols.put(tagName,  attrMap);  }  if  (attrMap.containsKey(attrKey))  {  protSet  =  attrMap.get(attrKey);  }  else  {  protSet  =  new  HashSet<Protocol>();  attrMap.put(attrKey,  protSet);  }  for  (String  protocol  :  protocols)  {  Validate.notEmpty(protocol);  Protocol  prot  =  Protocol.valueOf(protocol);  protSet.add(prot);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
if  (  this.protocols.containsKey  (  tagName  )  )  {	[BUGGY]  if  (  protocols.containsKey(  tag))  {  [CONTEXT]  public  Whitelist  addProtocols(String  tag,  String  key,  String...  protocols)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notNull(protocols);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  Map<AttributeKey,  Set<Protocol>>  attrMap;  Set<Protocol>  protSet;    [BUGGY]  if(  protocols.containsKey  (  tag  )){  attrMap  =  this.protocols.get(tagName);  }  else  {  attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>();  this.protocols.put(tagName,  attrMap);  }  if  (attrMap.containsKey(attrKey))  {  protSet  =  attrMap.get(attrKey);  }  else  {  protSet  =  new  HashSet<Protocol>();  attrMap.put(attrKey,  protSet);  }  for  (String  protocol  :  protocols)  {  Validate.notEmpty(protocol);  Protocol  prot  =  Protocol.valueOf(protocol);  protSet.add(prot);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
if  (  this.protocols.containsKey  (  tagName  )  )  {  attrMap  =  this.protocols.get  (  tagName  )  ;  }  else  {  attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>  (  )  ;  this.protocols.put  (  tagName,  attrMap  )  ;  }	[BUGGY]  attrMap  =  this.protocols.get(tagName);  [CONTEXT]  public  Whitelist  addProtocols(String  tag,  String  key,  String...  protocols)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notNull(protocols);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  Map<AttributeKey,  Set<Protocol>>  attrMap;  Set<Protocol>  protSet;    [BUGGY]  if  (this.protocols.containsKey(tagName))  {    attrMap  =  this.protocols.get(tagName);        }  if  (attrMap.containsKey(attrKey))  {  protSet  =  attrMap.get(attrKey);  }  else  {  protSet  =  new  HashSet<Protocol>();  attrMap.put(attrKey,  protSet);  }  for  (String  protocol  :  protocols)  {  Validate.notEmpty(protocol);  Protocol  prot  =  Protocol.valueOf(protocol);  protSet.add(prot);  }  return  this;        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
if  (  this.protocols.containsKey  (  tagName  )  )  {  attrMap  =  this.protocols.get  (  tagName  )  ;  }  else  {  attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>  (  )  ;  this.protocols.put  (  tagName,  attrMap  )  ;  }	[BUGGY]    [CONTEXT]  public  Whitelist  addProtocols(String  tag,  String  key,  String...  protocols)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notNull(protocols);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  Map<AttributeKey,  Set<Protocol>>  attrMap;  Set<Protocol>  protSet;    [BUGGY]  if  (this.protocols.containsKey(tagName))  {            }  if  (attrMap.containsKey(attrKey))  {  protSet  =  attrMap.get(attrKey);  }  else  {  protSet  =  new  HashSet<Protocol>();  attrMap.put(attrKey,  protSet);  }  for  (String  protocol  :  protocols)  {  Validate.notEmpty(protocol);  Protocol  prot  =  Protocol.valueOf(protocol);  protSet.add(prot);  }  return  this;        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
[Delete]	[BUGGY]  if  (  attrMap.containsKey(  attrKey))  {          protSet  =  attrMap.get(  attrKey);  }else  {          protSet  =  new  Protocol>(  );          attrMap.put(  attrKey,  protSet);  }  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>  (  )  ;	[BUGGY]  attrMap  =  attrMap  =    new  AttributeKey,  AttributeValue>(  )  ;  [CONTEXT]  if  (this.protocols.containsKey(tagName))  {  attrMap  =  this.protocols.get(tagName);  }  else  {  [BUGGY]  attrMap  =  attrMap  =new  AttributeKey,  AttributeValue>  ();  this.protocols.put(tagName,  attrMap);  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>  (  )  ;	[BUGGY]  attrMap  =    new  AttributeKey,  AttributeValue>(  )  ;  [CONTEXT]  if  (this.protocols.containsKey(tagName))  {  attrMap  =  this.protocols.get(tagName);  }  else  {  [BUGGY]  attrMap  =new  AttributeKey,  AttributeValue>  ();  this.protocols.put(tagName,  attrMap);  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>  (  )  ;	[BUGGY]    attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>(  );  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>  (  )  ;	[BUGGY]  protSet  =  new  HashSet<Protocol>(  );attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>(  );  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>  (  )  ;	[BUGGY]  attributes  =  new  HashMap<TagName,  Set<AttributeKey>>(  );attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>(  );  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>  (  )  ;	[BUGGY]  enforcedAttributes  =  new  HashMap<TagName,  Map<AttributeKey,  AttributeValue>>(  );attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>(  );  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>  (  )  ;	[BUGGY]  protocols  =  new  HashMap<TagName,  Map<AttributeKey,  Set<Protocol>>>(  );attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>(  );  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
this.protocols.put  (  tagName,  attrMap  )  ;	[BUGGY]  this.protocols.put(  attrMap,  tagName);  [CONTEXT]  if  (this.protocols.containsKey(tagName))  {  attrMap  =  this.protocols.get(tagName);  }  else  {  attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>();  [BUGGY]  this.protocols.put  (  attrMap,  tagName  )  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
this.protocols.put  (  tagName,  attrMap  )  ;	[BUGGY]  this.protocols.put(    attrMap);  [CONTEXT]  if  (this.protocols.containsKey(tagName))  {  attrMap  =  this.protocols.get(tagName);  }  else  {  attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>();  [BUGGY]  this.protocols.put  (attrMap  )  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
this.protocols.put  (  tagName,  attrMap  )  ;	[BUGGY]  this.protocols.put(  tagName);  [CONTEXT]  if  (this.protocols.containsKey(tagName))  {  attrMap  =  this.protocols.get(tagName);  }  else  {  attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>();  [BUGGY]  this.protocols.put  (  tagName  )  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
this.protocols.put  (  tagName,  attrMap  )  ;	[BUGGY]    [CONTEXT]  if  (this.protocols.containsKey(tagName))  {  attrMap  =  this.protocols.get(tagName);  }  else  {  attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>();  [BUGGY]  this.protocols.put(tagName,  attrMap);          [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
attrMap  =  this.protocols.get  (  tagName  )  ;	[BUGGY]  attrMap  =  tagName.get(  this.protocols);  [CONTEXT]  public  Whitelist  addProtocols(String  tag,  String  key,  String...  protocols)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notNull(protocols);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  Map<AttributeKey,  Set<Protocol>>  attrMap;  Set<Protocol>  protSet;    if  (this.protocols.containsKey(tagName))  {  [BUGGY]  attrMap  =  tagName.get  (  this.protocols  )  ;  }  else  {  attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>();  this.protocols.put(tagName,  attrMap);  }  if  (attrMap.containsKey(attrKey))  {  protSet  =  attrMap.get(attrKey);  }  else  {  protSet  =  new  HashSet<Protocol>();  attrMap.put(attrKey,  protSet);  }  for  (String  protocol  :  protocols)  {  Validate.notEmpty(protocol);  Protocol  prot  =  Protocol.valueOf(protocol);  protSet.add(prot);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
attrMap  =  this.protocols.get  (  tagName  )  ;	[BUGGY]  attrMap  =  this.protocols.containsKey(  tagName);  [CONTEXT]  public  Whitelist  addProtocols(String  tag,  String  key,  String...  protocols)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notNull(protocols);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  Map<AttributeKey,  Set<Protocol>>  attrMap;  Set<Protocol>  protSet;    if  (this.protocols.containsKey(tagName))  {  [BUGGY]  attrMap  =  this.protocols.containsKey  (  tagName  )  ;  }  else  {  attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>();  this.protocols.put(tagName,  attrMap);  }  if  (attrMap.containsKey(attrKey))  {  protSet  =  attrMap.get(attrKey);  }  else  {  protSet  =  new  HashSet<Protocol>();  attrMap.put(attrKey,  protSet);  }  for  (String  protocol  :  protocols)  {  Validate.notEmpty(protocol);  Protocol  prot  =  Protocol.valueOf(protocol);  protSet.add(prot);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
attrMap  =  this.protocols.get  (  tagName  )  ;	[BUGGY]  attrMap  =    this.protocols.get(  null);  [CONTEXT]  public  Whitelist  addProtocols(String  tag,  String  key,  String...  protocols)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notNull(protocols);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  Map<AttributeKey,  Set<Protocol>>  attrMap;  Set<Protocol>  protSet;    if  (this.protocols.containsKey(tagName))  {  [BUGGY]  attrMap  =this.protocols.get  (  null  )  ;  }  else  {  attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>();  this.protocols.put(tagName,  attrMap);  }  if  (attrMap.containsKey(attrKey))  {  protSet  =  attrMap.get(attrKey);  }  else  {  protSet  =  new  HashSet<Protocol>();  attrMap.put(attrKey,  protSet);  }  for  (String  protocol  :  protocols)  {  Validate.notEmpty(protocol);  Protocol  prot  =  Protocol.valueOf(protocol);  protSet.add(prot);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
attrMap  =  this.protocols.get  (  tagName  )  ;	[BUGGY]  if  (  this.protocols.containsKey(  tagName))  {  attrMap  =  this.protocols.get(  tagName);  }  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
attrMap  =  this.protocols.get  (  tagName  )  ;	[BUGGY]    [CONTEXT]  public  Whitelist  addProtocols(String  tag,  String  key,  String...  protocols)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notNull(protocols);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  Map<AttributeKey,  Set<Protocol>>  attrMap;  Set<Protocol>  protSet;    if  (this.protocols.containsKey(tagName))  {  [BUGGY]  attrMap  =  this.protocols.get(tagName);    }  else  {  attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>();  this.protocols.put(tagName,  attrMap);  }  if  (attrMap.containsKey(attrKey))  {  protSet  =  attrMap.get(attrKey);  }  else  {  protSet  =  new  HashSet<Protocol>();  attrMap.put(attrKey,  protSet);  }  for  (String  protocol  :  protocols)  {  Validate.notEmpty(protocol);  Protocol  prot  =  Protocol.valueOf(protocol);  protSet.add(prot);  }  return  this;        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>  (  )  ;	[BUGGY]  attrMap  =  attrMap  =    new  AttributeKey,  AttributeValue>(  )  ;  [CONTEXT]  public  Whitelist  addProtocols(String  tag,  String  key,  String...  protocols)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notNull(protocols);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  Map<AttributeKey,  Set<Protocol>>  attrMap;  Set<Protocol>  protSet;    if  (this.protocols.containsKey(tagName))  {  attrMap  =  this.protocols.get(tagName);  }  else  {  [BUGGY]  attrMap  =  attrMap  =new  AttributeKey,  AttributeValue>  ();  this.protocols.put(tagName,  attrMap);  }  if  (attrMap.containsKey(attrKey))  {  protSet  =  attrMap.get(attrKey);  }  else  {  protSet  =  new  HashSet<Protocol>();  attrMap.put(attrKey,  protSet);  }  for  (String  protocol  :  protocols)  {  Validate.notEmpty(protocol);  Protocol  prot  =  Protocol.valueOf(protocol);  protSet.add(prot);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>  (  )  ;	[BUGGY]  attrMap  =    new  AttributeKey,  AttributeValue>(  )  ;  [CONTEXT]  public  Whitelist  addProtocols(String  tag,  String  key,  String...  protocols)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notNull(protocols);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  Map<AttributeKey,  Set<Protocol>>  attrMap;  Set<Protocol>  protSet;    if  (this.protocols.containsKey(tagName))  {  attrMap  =  this.protocols.get(tagName);  }  else  {  [BUGGY]  attrMap  =new  AttributeKey,  AttributeValue>  ();  this.protocols.put(tagName,  attrMap);  }  if  (attrMap.containsKey(attrKey))  {  protSet  =  attrMap.get(attrKey);  }  else  {  protSet  =  new  HashSet<Protocol>();  attrMap.put(attrKey,  protSet);  }  for  (String  protocol  :  protocols)  {  Validate.notEmpty(protocol);  Protocol  prot  =  Protocol.valueOf(protocol);  protSet.add(prot);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>  (  )  ;	[BUGGY]    attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>(  );  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>  (  )  ;	[BUGGY]  protSet  =  new  HashSet<Protocol>(  );attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>(  );  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>  (  )  ;	[BUGGY]  attributes  =  new  HashMap<TagName,  Set<AttributeKey>>(  );attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>(  );  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>  (  )  ;	[BUGGY]  enforcedAttributes  =  new  HashMap<TagName,  Map<AttributeKey,  AttributeValue>>(  );attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>(  );  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>  (  )  ;	[BUGGY]  protocols  =  new  HashMap<TagName,  Map<AttributeKey,  Set<Protocol>>>(  );attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>(  );  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
if  (  this.protocols.containsKey  (  tagName  )  )  {	[BUGGY]  if  (  tagName.containsKey(  this.protocols))  {  [CONTEXT]  public  Whitelist  addProtocols(String  tag,  String  key,  String...  protocols)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notNull(protocols);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  Map<AttributeKey,  Set<Protocol>>  attrMap;  Set<Protocol>  protSet;    [BUGGY]  if(  tagName.containsKey  (  this.protocols  )){  attrMap  =  this.protocols.get(tagName);  }  else  {  attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>();  this.protocols.put(tagName,  attrMap);  }  if  (attrMap.containsKey(attrKey))  {  protSet  =  attrMap.get(attrKey);  }  else  {  protSet  =  new  HashSet<Protocol>();  attrMap.put(attrKey,  protSet);  }  for  (String  protocol  :  protocols)  {  Validate.notEmpty(protocol);  Protocol  prot  =  Protocol.valueOf(protocol);  protSet.add(prot);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
this.protocols.put  (  tagName,  attrMap  )  ;	[BUGGY]  this.protocols.put(  tagName,  null);  [CONTEXT]  public  Whitelist  addProtocols(String  tag,  String  key,  String...  protocols)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notNull(protocols);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  Map<AttributeKey,  Set<Protocol>>  attrMap;  Set<Protocol>  protSet;    if  (this.protocols.containsKey(tagName))  {  attrMap  =  this.protocols.get(tagName);  }  else  {  attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>();  [BUGGY]  this.protocols.put  (  tagName,  null  )  ;  }  if  (attrMap.containsKey(attrKey))  {  protSet  =  attrMap.get(attrKey);  }  else  {  protSet  =  new  HashSet<Protocol>();  attrMap.put(attrKey,  protSet);  }  for  (String  protocol  :  protocols)  {  Validate.notEmpty(protocol);  Protocol  prot  =  Protocol.valueOf(protocol);  protSet.add(prot);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
this.protocols.put  (  tagName,  attrMap  )  ;	[BUGGY]  this.protocols.put(    attrMap);  [CONTEXT]  public  Whitelist  addProtocols(String  tag,  String  key,  String...  protocols)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notNull(protocols);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  Map<AttributeKey,  Set<Protocol>>  attrMap;  Set<Protocol>  protSet;    if  (this.protocols.containsKey(tagName))  {  attrMap  =  this.protocols.get(tagName);  }  else  {  attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>();  [BUGGY]  this.protocols.put  (attrMap  )  ;  }  if  (attrMap.containsKey(attrKey))  {  protSet  =  attrMap.get(attrKey);  }  else  {  protSet  =  new  HashSet<Protocol>();  attrMap.put(attrKey,  protSet);  }  for  (String  protocol  :  protocols)  {  Validate.notEmpty(protocol);  Protocol  prot  =  Protocol.valueOf(protocol);  protSet.add(prot);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
this.protocols.put  (  tagName,  attrMap  )  ;	[BUGGY]  this.protocols.put(  attrMap,  tagName);  [CONTEXT]  public  Whitelist  addProtocols(String  tag,  String  key,  String...  protocols)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notNull(protocols);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  Map<AttributeKey,  Set<Protocol>>  attrMap;  Set<Protocol>  protSet;    if  (this.protocols.containsKey(tagName))  {  attrMap  =  this.protocols.get(tagName);  }  else  {  attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>();  [BUGGY]  this.protocols.put  (  attrMap,  tagName  )  ;  }  if  (attrMap.containsKey(attrKey))  {  protSet  =  attrMap.get(attrKey);  }  else  {  protSet  =  new  HashSet<Protocol>();  attrMap.put(attrKey,  protSet);  }  for  (String  protocol  :  protocols)  {  Validate.notEmpty(protocol);  Protocol  prot  =  Protocol.valueOf(protocol);  protSet.add(prot);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
this.protocols.put  (  tagName,  attrMap  )  ;	[BUGGY]  this.protocols.put(  tagName);  [CONTEXT]  public  Whitelist  addProtocols(String  tag,  String  key,  String...  protocols)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notNull(protocols);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  Map<AttributeKey,  Set<Protocol>>  attrMap;  Set<Protocol>  protSet;    if  (this.protocols.containsKey(tagName))  {  attrMap  =  this.protocols.get(tagName);  }  else  {  attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>();  [BUGGY]  this.protocols.put  (  tagName  )  ;  }  if  (attrMap.containsKey(attrKey))  {  protSet  =  attrMap.get(attrKey);  }  else  {  protSet  =  new  HashSet<Protocol>();  attrMap.put(attrKey,  protSet);  }  for  (String  protocol  :  protocols)  {  Validate.notEmpty(protocol);  Protocol  prot  =  Protocol.valueOf(protocol);  protSet.add(prot);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
this.protocols.put  (  tagName,  attrMap  )  ;	[BUGGY]  this.protocols  .put(  )  ;  [CONTEXT]  public  Whitelist  addProtocols(String  tag,  String  key,  String...  protocols)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notNull(protocols);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  Map<AttributeKey,  Set<Protocol>>  attrMap;  Set<Protocol>  protSet;    if  (this.protocols.containsKey(tagName))  {  attrMap  =  this.protocols.get(tagName);  }  else  {  attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>();  [BUGGY]  this.protocols  .put  ();  }  if  (attrMap.containsKey(attrKey))  {  protSet  =  attrMap.get(attrKey);  }  else  {  protSet  =  new  HashSet<Protocol>();  attrMap.put(attrKey,  protSet);  }  for  (String  protocol  :  protocols)  {  Validate.notEmpty(protocol);  Protocol  prot  =  Protocol.valueOf(protocol);  protSet.add(prot);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
this.protocols.put  (  tagName,  attrMap  )  ;	[BUGGY]    [CONTEXT]  public  Whitelist  addProtocols(String  tag,  String  key,  String...  protocols)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notNull(protocols);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  Map<AttributeKey,  Set<Protocol>>  attrMap;  Set<Protocol>  protSet;    if  (this.protocols.containsKey(tagName))  {  attrMap  =  this.protocols.get(tagName);  }  else  {  attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>();  [BUGGY]  this.protocols.put(tagName,  attrMap);    }  if  (attrMap.containsKey(attrKey))  {  protSet  =  attrMap.get(attrKey);  }  else  {  protSet  =  new  HashSet<Protocol>();  attrMap.put(attrKey,  protSet);  }  for  (String  protocol  :  protocols)  {  Validate.notEmpty(protocol);  Protocol  prot  =  Protocol.valueOf(protocol);  protSet.add(prot);  }  return  this;        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
if  (  attrMap.containsKey  (  attrKey  )  )  {	[BUGGY]  if  (  attrMap.put(  attrKey))  {  [CONTEXT]  public  Whitelist  addProtocols(String  tag,  String  key,  String...  protocols)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notNull(protocols);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  Map<AttributeKey,  Set<Protocol>>  attrMap;  Set<Protocol>  protSet;    if  (this.protocols.containsKey(tagName))  {  attrMap  =  this.protocols.get(tagName);  }  else  {  attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>();  this.protocols.put(tagName,  attrMap);  }  [BUGGY]  if(  attrMap.put  (  attrKey  )){  protSet  =  attrMap.get(attrKey);  }  else  {  protSet  =  new  HashSet<Protocol>();  attrMap.put(attrKey,  protSet);  }  for  (String  protocol  :  protocols)  {  Validate.notEmpty(protocol);  Protocol  prot  =  Protocol.valueOf(protocol);  protSet.add(prot);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
if  (  attrMap.containsKey  (  attrKey  )  )  {	[BUGGY]  if  (  attrMap  .containsKey(  tagName)  )  {  [CONTEXT]  public  Whitelist  addProtocols(String  tag,  String  key,  String...  protocols)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notNull(protocols);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  Map<AttributeKey,  Set<Protocol>>  attrMap;  Set<Protocol>  protSet;    if  (this.protocols.containsKey(tagName))  {  attrMap  =  this.protocols.get(tagName);  }  else  {  attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>();  this.protocols.put(tagName,  attrMap);  }  [BUGGY]  if(  attrMap  .containsKey  (  tagName  )  ){  protSet  =  attrMap.get(attrKey);  }  else  {  protSet  =  new  HashSet<Protocol>();  attrMap.put(attrKey,  protSet);  }  for  (String  protocol  :  protocols)  {  Validate.notEmpty(protocol);  Protocol  prot  =  Protocol.valueOf(protocol);  protSet.add(prot);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
if  (  attrMap.containsKey  (  attrKey  )  )  {	[BUGGY]  if  (  attributes.containsKey(  tag))  {  [CONTEXT]  public  Whitelist  addProtocols(String  tag,  String  key,  String...  protocols)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notNull(protocols);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  Map<AttributeKey,  Set<Protocol>>  attrMap;  Set<Protocol>  protSet;    if  (this.protocols.containsKey(tagName))  {  attrMap  =  this.protocols.get(tagName);  }  else  {  attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>();  this.protocols.put(tagName,  attrMap);  }  [BUGGY]  if(  attributes.containsKey  (  tag  )){  protSet  =  attrMap.get(attrKey);  }  else  {  protSet  =  new  HashSet<Protocol>();  attrMap.put(attrKey,  protSet);  }  for  (String  protocol  :  protocols)  {  Validate.notEmpty(protocol);  Protocol  prot  =  Protocol.valueOf(protocol);  protSet.add(prot);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
if  (  attrMap.containsKey  (  attrKey  )  )  {	[BUGGY]  if  (  attributes.containsKey(  tagName))  {  [CONTEXT]  public  Whitelist  addProtocols(String  tag,  String  key,  String...  protocols)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notNull(protocols);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  Map<AttributeKey,  Set<Protocol>>  attrMap;  Set<Protocol>  protSet;    if  (this.protocols.containsKey(tagName))  {  attrMap  =  this.protocols.get(tagName);  }  else  {  attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>();  this.protocols.put(tagName,  attrMap);  }  [BUGGY]  if(  attributes.containsKey  (  tagName  )){  protSet  =  attrMap.get(attrKey);  }  else  {  protSet  =  new  HashSet<Protocol>();  attrMap.put(attrKey,  protSet);  }  for  (String  protocol  :  protocols)  {  Validate.notEmpty(protocol);  Protocol  prot  =  Protocol.valueOf(protocol);  protSet.add(prot);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
if  (  attrMap.containsKey  (  attrKey  )  )  {	[BUGGY]  if  (  protocols.containsKey(  tag))  {  [CONTEXT]  public  Whitelist  addProtocols(String  tag,  String  key,  String...  protocols)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notNull(protocols);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  Map<AttributeKey,  Set<Protocol>>  attrMap;  Set<Protocol>  protSet;    if  (this.protocols.containsKey(tagName))  {  attrMap  =  this.protocols.get(tagName);  }  else  {  attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>();  this.protocols.put(tagName,  attrMap);  }  [BUGGY]  if(  protocols.containsKey  (  tag  )){  protSet  =  attrMap.get(attrKey);  }  else  {  protSet  =  new  HashSet<Protocol>();  attrMap.put(attrKey,  protSet);  }  for  (String  protocol  :  protocols)  {  Validate.notEmpty(protocol);  Protocol  prot  =  Protocol.valueOf(protocol);  protSet.add(prot);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
if  (  attrMap.containsKey  (  attrKey  )  )  {  protSet  =  attrMap.get  (  attrKey  )  ;  }  else  {  protSet  =  new  HashSet<Protocol>  (  )  ;  attrMap.put  (  attrKey,  protSet  )  ;  }	[BUGGY]  protSet  =  attrMap.get(attrKey);  [CONTEXT]  public  Whitelist  addProtocols(String  tag,  String  key,  String...  protocols)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notNull(protocols);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  Map<AttributeKey,  Set<Protocol>>  attrMap;  Set<Protocol>  protSet;    if  (this.protocols.containsKey(tagName))  {  attrMap  =  this.protocols.get(tagName);  }  else  {  attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>();  this.protocols.put(tagName,  attrMap);  }  [BUGGY]  if  (attrMap.containsKey(attrKey))  {    protSet  =  attrMap.get(attrKey);        }  for  (String  protocol  :  protocols)  {  Validate.notEmpty(protocol);  Protocol  prot  =  Protocol.valueOf(protocol);  protSet.add(prot);  }  return  this;        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
if  (  attrMap.containsKey  (  attrKey  )  )  {  protSet  =  attrMap.get  (  attrKey  )  ;  }  else  {  protSet  =  new  HashSet<Protocol>  (  )  ;  attrMap.put  (  attrKey,  protSet  )  ;  }	[BUGGY]    [CONTEXT]  public  Whitelist  addProtocols(String  tag,  String  key,  String...  protocols)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notNull(protocols);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  Map<AttributeKey,  Set<Protocol>>  attrMap;  Set<Protocol>  protSet;    if  (this.protocols.containsKey(tagName))  {  attrMap  =  this.protocols.get(tagName);  }  else  {  attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>();  this.protocols.put(tagName,  attrMap);  }  [BUGGY]  if  (attrMap.containsKey(attrKey))  {            }  for  (String  protocol  :  protocols)  {  Validate.notEmpty(protocol);  Protocol  prot  =  Protocol.valueOf(protocol);  protSet.add(prot);  }  return  this;        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
[Delete]	[BUGGY]  if  (  containsKey(  tagName))  {          attrMap  =  get(  tagName);  }else  {          attrMap  =  new  AttributeKey,  Protocol>>(  );          put(  tagName,  attrMap);  }  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
protSet  =  new  HashSet<Protocol>  (  )  ;	[BUGGY]  protSet  =  protSet  =    new  TagName>(  )  ;  [CONTEXT]  if  (attrMap.containsKey(attrKey))  {  protSet  =  attrMap.get(attrKey);  }  else  {  [BUGGY]  protSet  =  protSet  =new  TagName>  ();  attrMap.put(attrKey,  protSet);  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
protSet  =  new  HashSet<Protocol>  (  )  ;	[BUGGY]  protSet  =    new  TagName>(  )  ;  [CONTEXT]  if  (attrMap.containsKey(attrKey))  {  protSet  =  attrMap.get(attrKey);  }  else  {  [BUGGY]  protSet  =new  TagName>  ();  attrMap.put(attrKey,  protSet);  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
protSet  =  new  HashSet<Protocol>  (  )  ;	[BUGGY]    protSet  =  new  HashSet<Protocol>(  );  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
protSet  =  new  HashSet<Protocol>  (  )  ;	[BUGGY]  tagNames  =  new  HashSet<TagName>(  );protSet  =  new  HashSet<Protocol>(  );  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
protSet  =  new  HashSet<Protocol>  (  )  ;	[BUGGY]  attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>(  );protSet  =  new  HashSet<Protocol>(  );  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
attrMap.put  (  attrKey,  protSet  )  ;	[BUGGY]  attrMap.put(    protSet);  [CONTEXT]  if  (attrMap.containsKey(attrKey))  {  protSet  =  attrMap.get(attrKey);  }  else  {  protSet  =  new  HashSet<Protocol>();  [BUGGY]  attrMap.put  (protSet  )  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
attrMap.put  (  attrKey,  protSet  )  ;	[BUGGY]  attrMap.put(  attrKey);  [CONTEXT]  if  (attrMap.containsKey(attrKey))  {  protSet  =  attrMap.get(attrKey);  }  else  {  protSet  =  new  HashSet<Protocol>();  [BUGGY]  attrMap.put  (  attrKey  )  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
attrMap.put  (  attrKey,  protSet  )  ;	[BUGGY]    [CONTEXT]  if  (attrMap.containsKey(attrKey))  {  protSet  =  attrMap.get(attrKey);  }  else  {  protSet  =  new  HashSet<Protocol>();  [BUGGY]  attrMap.put(attrKey,  protSet);          [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
protSet  =  attrMap.get  (  attrKey  )  ;	[BUGGY]  protSet  =  attrKey.get(  attrMap);  [CONTEXT]  public  Whitelist  addProtocols(String  tag,  String  key,  String...  protocols)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notNull(protocols);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  Map<AttributeKey,  Set<Protocol>>  attrMap;  Set<Protocol>  protSet;    if  (this.protocols.containsKey(tagName))  {  attrMap  =  this.protocols.get(tagName);  }  else  {  attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>();  this.protocols.put(tagName,  attrMap);  }  if  (attrMap.containsKey(attrKey))  {  [BUGGY]  protSet  =  attrKey.get  (  attrMap  )  ;  }  else  {  protSet  =  new  HashSet<Protocol>();  attrMap.put(attrKey,  protSet);  }  for  (String  protocol  :  protocols)  {  Validate.notEmpty(protocol);  Protocol  prot  =  Protocol.valueOf(protocol);  protSet.add(prot);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
protSet  =  attrMap.get  (  attrKey  )  ;	[BUGGY]  protSet  =  attrMap.put(  attrKey);  [CONTEXT]  public  Whitelist  addProtocols(String  tag,  String  key,  String...  protocols)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notNull(protocols);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  Map<AttributeKey,  Set<Protocol>>  attrMap;  Set<Protocol>  protSet;    if  (this.protocols.containsKey(tagName))  {  attrMap  =  this.protocols.get(tagName);  }  else  {  attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>();  this.protocols.put(tagName,  attrMap);  }  if  (attrMap.containsKey(attrKey))  {  [BUGGY]  protSet  =  attrMap.put  (  attrKey  )  ;  }  else  {  protSet  =  new  HashSet<Protocol>();  attrMap.put(attrKey,  protSet);  }  for  (String  protocol  :  protocols)  {  Validate.notEmpty(protocol);  Protocol  prot  =  Protocol.valueOf(protocol);  protSet.add(prot);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
protSet  =  attrMap.get  (  attrKey  )  ;	[BUGGY]  protSet  =    null.get(  attrKey);  [CONTEXT]  public  Whitelist  addProtocols(String  tag,  String  key,  String...  protocols)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notNull(protocols);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  Map<AttributeKey,  Set<Protocol>>  attrMap;  Set<Protocol>  protSet;    if  (this.protocols.containsKey(tagName))  {  attrMap  =  this.protocols.get(tagName);  }  else  {  attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>();  this.protocols.put(tagName,  attrMap);  }  if  (attrMap.containsKey(attrKey))  {  [BUGGY]  protSet  =null.get  (  attrKey  )  ;  }  else  {  protSet  =  new  HashSet<Protocol>();  attrMap.put(attrKey,  protSet);  }  for  (String  protocol  :  protocols)  {  Validate.notEmpty(protocol);  Protocol  prot  =  Protocol.valueOf(protocol);  protSet.add(prot);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
protSet  =  attrMap.get  (  attrKey  )  ;	[BUGGY]  protSet  =  attrMap  .get(  tagName)  ;  [CONTEXT]  public  Whitelist  addProtocols(String  tag,  String  key,  String...  protocols)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notNull(protocols);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  Map<AttributeKey,  Set<Protocol>>  attrMap;  Set<Protocol>  protSet;    if  (this.protocols.containsKey(tagName))  {  attrMap  =  this.protocols.get(tagName);  }  else  {  attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>();  this.protocols.put(tagName,  attrMap);  }  if  (attrMap.containsKey(attrKey))  {  [BUGGY]  protSet  =  attrMap  .get  (  tagName  );  }  else  {  protSet  =  new  HashSet<Protocol>();  attrMap.put(attrKey,  protSet);  }  for  (String  protocol  :  protocols)  {  Validate.notEmpty(protocol);  Protocol  prot  =  Protocol.valueOf(protocol);  protSet.add(prot);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
protSet  =  attrMap.get  (  attrKey  )  ;	[BUGGY]  protSet  =  null.put(  attrKey);  [CONTEXT]  public  Whitelist  addProtocols(String  tag,  String  key,  String...  protocols)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notNull(protocols);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  Map<AttributeKey,  Set<Protocol>>  attrMap;  Set<Protocol>  protSet;    if  (this.protocols.containsKey(tagName))  {  attrMap  =  this.protocols.get(tagName);  }  else  {  attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>();  this.protocols.put(tagName,  attrMap);  }  if  (attrMap.containsKey(attrKey))  {  [BUGGY]  protSet  =  null.put  (  attrKey  )  ;  }  else  {  protSet  =  new  HashSet<Protocol>();  attrMap.put(attrKey,  protSet);  }  for  (String  protocol  :  protocols)  {  Validate.notEmpty(protocol);  Protocol  prot  =  Protocol.valueOf(protocol);  protSet.add(prot);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
protSet  =  attrMap.get  (  attrKey  )  ;	[BUGGY]    [CONTEXT]  public  Whitelist  addProtocols(String  tag,  String  key,  String...  protocols)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notNull(protocols);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  Map<AttributeKey,  Set<Protocol>>  attrMap;  Set<Protocol>  protSet;    if  (this.protocols.containsKey(tagName))  {  attrMap  =  this.protocols.get(tagName);  }  else  {  attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>();  this.protocols.put(tagName,  attrMap);  }  if  (attrMap.containsKey(attrKey))  {  [BUGGY]  protSet  =  attrMap.get(attrKey);    }  else  {  protSet  =  new  HashSet<Protocol>();  attrMap.put(attrKey,  protSet);  }  for  (String  protocol  :  protocols)  {  Validate.notEmpty(protocol);  Protocol  prot  =  Protocol.valueOf(protocol);  protSet.add(prot);  }  return  this;        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
protSet  =  new  HashSet<Protocol>  (  )  ;	[BUGGY]  protSet  =  protSet  =    new  TagName>(  )  ;  [CONTEXT]  public  Whitelist  addProtocols(String  tag,  String  key,  String...  protocols)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notNull(protocols);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  Map<AttributeKey,  Set<Protocol>>  attrMap;  Set<Protocol>  protSet;    if  (this.protocols.containsKey(tagName))  {  attrMap  =  this.protocols.get(tagName);  }  else  {  attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>();  this.protocols.put(tagName,  attrMap);  }  if  (attrMap.containsKey(attrKey))  {  protSet  =  attrMap.get(attrKey);  }  else  {  [BUGGY]  protSet  =  protSet  =new  TagName>  ();  attrMap.put(attrKey,  protSet);  }  for  (String  protocol  :  protocols)  {  Validate.notEmpty(protocol);  Protocol  prot  =  Protocol.valueOf(protocol);  protSet.add(prot);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
protSet  =  new  HashSet<Protocol>  (  )  ;	[BUGGY]  protSet  =    new  TagName>(  )  ;  [CONTEXT]  public  Whitelist  addProtocols(String  tag,  String  key,  String...  protocols)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notNull(protocols);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  Map<AttributeKey,  Set<Protocol>>  attrMap;  Set<Protocol>  protSet;    if  (this.protocols.containsKey(tagName))  {  attrMap  =  this.protocols.get(tagName);  }  else  {  attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>();  this.protocols.put(tagName,  attrMap);  }  if  (attrMap.containsKey(attrKey))  {  protSet  =  attrMap.get(attrKey);  }  else  {  [BUGGY]  protSet  =new  TagName>  ();  attrMap.put(attrKey,  protSet);  }  for  (String  protocol  :  protocols)  {  Validate.notEmpty(protocol);  Protocol  prot  =  Protocol.valueOf(protocol);  protSet.add(prot);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
protSet  =  new  HashSet<Protocol>  (  )  ;	[BUGGY]    protSet  =  new  HashSet<Protocol>(  );  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
protSet  =  new  HashSet<Protocol>  (  )  ;	[BUGGY]  tagNames  =  new  HashSet<TagName>(  );protSet  =  new  HashSet<Protocol>(  );  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
protSet  =  new  HashSet<Protocol>  (  )  ;	[BUGGY]  attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>(  );protSet  =  new  HashSet<Protocol>(  );  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
if  (  attrMap.containsKey  (  attrKey  )  )  {	[BUGGY]  if  (  attrKey.containsKey(  attrMap))  {  [CONTEXT]  public  Whitelist  addProtocols(String  tag,  String  key,  String...  protocols)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notNull(protocols);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  Map<AttributeKey,  Set<Protocol>>  attrMap;  Set<Protocol>  protSet;    if  (this.protocols.containsKey(tagName))  {  attrMap  =  this.protocols.get(tagName);  }  else  {  attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>();  this.protocols.put(tagName,  attrMap);  }  [BUGGY]  if(  attrKey.containsKey  (  attrMap  )){  protSet  =  attrMap.get(attrKey);  }  else  {  protSet  =  new  HashSet<Protocol>();  attrMap.put(attrKey,  protSet);  }  for  (String  protocol  :  protocols)  {  Validate.notEmpty(protocol);  Protocol  prot  =  Protocol.valueOf(protocol);  protSet.add(prot);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
attrMap.put  (  attrKey,  protSet  )  ;	[BUGGY]  attrMap.put(    protSet);  [CONTEXT]  public  Whitelist  addProtocols(String  tag,  String  key,  String...  protocols)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notNull(protocols);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  Map<AttributeKey,  Set<Protocol>>  attrMap;  Set<Protocol>  protSet;    if  (this.protocols.containsKey(tagName))  {  attrMap  =  this.protocols.get(tagName);  }  else  {  attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>();  this.protocols.put(tagName,  attrMap);  }  if  (attrMap.containsKey(attrKey))  {  protSet  =  attrMap.get(attrKey);  }  else  {  protSet  =  new  HashSet<Protocol>();  [BUGGY]  attrMap.put  (protSet  )  ;  }  for  (String  protocol  :  protocols)  {  Validate.notEmpty(protocol);  Protocol  prot  =  Protocol.valueOf(protocol);  protSet.add(prot);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
attrMap.put  (  attrKey,  protSet  )  ;	[BUGGY]  attrMap.put(  attrKey);  [CONTEXT]  public  Whitelist  addProtocols(String  tag,  String  key,  String...  protocols)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notNull(protocols);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  Map<AttributeKey,  Set<Protocol>>  attrMap;  Set<Protocol>  protSet;    if  (this.protocols.containsKey(tagName))  {  attrMap  =  this.protocols.get(tagName);  }  else  {  attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>();  this.protocols.put(tagName,  attrMap);  }  if  (attrMap.containsKey(attrKey))  {  protSet  =  attrMap.get(attrKey);  }  else  {  protSet  =  new  HashSet<Protocol>();  [BUGGY]  attrMap.put  (  attrKey  )  ;  }  for  (String  protocol  :  protocols)  {  Validate.notEmpty(protocol);  Protocol  prot  =  Protocol.valueOf(protocol);  protSet.add(prot);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
attrMap.put  (  attrKey,  protSet  )  ;	[BUGGY]  attrMap  .put(  tagName  ,  4)  ;  [CONTEXT]  public  Whitelist  addProtocols(String  tag,  String  key,  String...  protocols)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notNull(protocols);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  Map<AttributeKey,  Set<Protocol>>  attrMap;  Set<Protocol>  protSet;    if  (this.protocols.containsKey(tagName))  {  attrMap  =  this.protocols.get(tagName);  }  else  {  attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>();  this.protocols.put(tagName,  attrMap);  }  if  (attrMap.containsKey(attrKey))  {  protSet  =  attrMap.get(attrKey);  }  else  {  protSet  =  new  HashSet<Protocol>();  [BUGGY]  attrMap  .put  (  tagName  ,  4  );  }  for  (String  protocol  :  protocols)  {  Validate.notEmpty(protocol);  Protocol  prot  =  Protocol.valueOf(protocol);  protSet.add(prot);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
attrMap.put  (  attrKey,  protSet  )  ;	[BUGGY]    [CONTEXT]  public  Whitelist  addProtocols(String  tag,  String  key,  String...  protocols)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notNull(protocols);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  Map<AttributeKey,  Set<Protocol>>  attrMap;  Set<Protocol>  protSet;    if  (this.protocols.containsKey(tagName))  {  attrMap  =  this.protocols.get(tagName);  }  else  {  attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>();  this.protocols.put(tagName,  attrMap);  }  if  (attrMap.containsKey(attrKey))  {  protSet  =  attrMap.get(attrKey);  }  else  {  protSet  =  new  HashSet<Protocol>();  [BUGGY]  attrMap.put(attrKey,  protSet);    }  for  (String  protocol  :  protocols)  {  Validate.notEmpty(protocol);  Protocol  prot  =  Protocol.valueOf(protocol);  protSet.add(prot);  }  return  this;        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
for  (  String  protocol  :  protocols  )  {	[BUGGY]  for  (  char  protocol  :  protocols)  {  [CONTEXT]  public  Whitelist  addProtocols(String  tag,  String  key,  String...  protocols)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notNull(protocols);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  Map<AttributeKey,  Set<Protocol>>  attrMap;  Set<Protocol>  protSet;    if  (this.protocols.containsKey(tagName))  {  attrMap  =  this.protocols.get(tagName);  }  else  {  attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>();  this.protocols.put(tagName,  attrMap);  }  if  (attrMap.containsKey(attrKey))  {  protSet  =  attrMap.get(attrKey);  }  else  {  protSet  =  new  HashSet<Protocol>();  attrMap.put(attrKey,  protSet);  }  [BUGGY]  for(  char  protocol  :  protocols  ){  Validate.notEmpty(protocol);  Protocol  prot  =  Protocol.valueOf(protocol);  protSet.add(prot);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
Protocol  prot  =  Protocol.valueOf  (  protocol  )  ;	[BUGGY]  Protocol  prot  =  Protocol.valueOf(  value);  [CONTEXT]  public  Whitelist  addProtocols(String  tag,  String  key,  String...  protocols)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notNull(protocols);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  Map<AttributeKey,  Set<Protocol>>  attrMap;  Set<Protocol>  protSet;    if  (this.protocols.containsKey(tagName))  {  attrMap  =  this.protocols.get(tagName);  }  else  {  attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>();  this.protocols.put(tagName,  attrMap);  }  if  (attrMap.containsKey(attrKey))  {  protSet  =  attrMap.get(attrKey);  }  else  {  protSet  =  new  HashSet<Protocol>();  attrMap.put(attrKey,  protSet);  }  for  (String  protocol  :  protocols)  {  Validate.notEmpty(protocol);  [BUGGY]  Protocol  prot  =  Protocol.valueOf  (  value  )  ;  protSet.add(prot);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
Protocol  prot  =  Protocol.valueOf  (  protocol  )  ;	[BUGGY]  Protocol  prot  =  Protocol.Protocol(  protocol);  [CONTEXT]  public  Whitelist  addProtocols(String  tag,  String  key,  String...  protocols)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notNull(protocols);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  Map<AttributeKey,  Set<Protocol>>  attrMap;  Set<Protocol>  protSet;    if  (this.protocols.containsKey(tagName))  {  attrMap  =  this.protocols.get(tagName);  }  else  {  attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>();  this.protocols.put(tagName,  attrMap);  }  if  (attrMap.containsKey(attrKey))  {  protSet  =  attrMap.get(attrKey);  }  else  {  protSet  =  new  HashSet<Protocol>();  attrMap.put(attrKey,  protSet);  }  for  (String  protocol  :  protocols)  {  Validate.notEmpty(protocol);  [BUGGY]  Protocol  prot  =  Protocol.Protocol  (  protocol  )  ;  protSet.add(prot);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
Protocol  prot  =  Protocol.valueOf  (  protocol  )  ;	[BUGGY]  Protocol  prot  =  Protocol.valueOf(  tagName);  [CONTEXT]  public  Whitelist  addProtocols(String  tag,  String  key,  String...  protocols)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notNull(protocols);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  Map<AttributeKey,  Set<Protocol>>  attrMap;  Set<Protocol>  protSet;    if  (this.protocols.containsKey(tagName))  {  attrMap  =  this.protocols.get(tagName);  }  else  {  attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>();  this.protocols.put(tagName,  attrMap);  }  if  (attrMap.containsKey(attrKey))  {  protSet  =  attrMap.get(attrKey);  }  else  {  protSet  =  new  HashSet<Protocol>();  attrMap.put(attrKey,  protSet);  }  for  (String  protocol  :  protocols)  {  Validate.notEmpty(protocol);  [BUGGY]  Protocol  prot  =  Protocol.valueOf  (  tagName  )  ;  protSet.add(prot);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
Validate.notEmpty  (  protocol  )  ;	[BUGGY]  Validate.notEmpty(  tagName);  [CONTEXT]  public  Whitelist  addProtocols(String  tag,  String  key,  String...  protocols)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notNull(protocols);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  Map<AttributeKey,  Set<Protocol>>  attrMap;  Set<Protocol>  protSet;    if  (this.protocols.containsKey(tagName))  {  attrMap  =  this.protocols.get(tagName);  }  else  {  attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>();  this.protocols.put(tagName,  attrMap);  }  if  (attrMap.containsKey(attrKey))  {  protSet  =  attrMap.get(attrKey);  }  else  {  protSet  =  new  HashSet<Protocol>();  attrMap.put(attrKey,  protSet);  }  for  (String  protocol  :  protocols)  {  [BUGGY]  Validate.notEmpty  (  tagName  )  ;  Protocol  prot  =  Protocol.valueOf(protocol);  protSet.add(prot);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
Validate.notEmpty  (  protocol  )  ;	[BUGGY]  Validate.notEmpty(  value);  [CONTEXT]  public  Whitelist  addProtocols(String  tag,  String  key,  String...  protocols)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notNull(protocols);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  Map<AttributeKey,  Set<Protocol>>  attrMap;  Set<Protocol>  protSet;    if  (this.protocols.containsKey(tagName))  {  attrMap  =  this.protocols.get(tagName);  }  else  {  attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>();  this.protocols.put(tagName,  attrMap);  }  if  (attrMap.containsKey(attrKey))  {  protSet  =  attrMap.get(attrKey);  }  else  {  protSet  =  new  HashSet<Protocol>();  attrMap.put(attrKey,  protSet);  }  for  (String  protocol  :  protocols)  {  [BUGGY]  Validate.notEmpty  (  value  )  ;  Protocol  prot  =  Protocol.valueOf(protocol);  protSet.add(prot);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
Validate.notEmpty  (  protocol  )  ;	[BUGGY]    [CONTEXT]  public  Whitelist  addProtocols(String  tag,  String  key,  String...  protocols)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notNull(protocols);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  Map<AttributeKey,  Set<Protocol>>  attrMap;  Set<Protocol>  protSet;    if  (this.protocols.containsKey(tagName))  {  attrMap  =  this.protocols.get(tagName);  }  else  {  attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>();  this.protocols.put(tagName,  attrMap);  }  if  (attrMap.containsKey(attrKey))  {  protSet  =  attrMap.get(attrKey);  }  else  {  protSet  =  new  HashSet<Protocol>();  attrMap.put(attrKey,  protSet);  }  for  (String  protocol  :  protocols)  {  [BUGGY]  Validate.notEmpty(protocol);    Protocol  prot  =  Protocol.valueOf(protocol);  protSet.add(prot);  }  return  this;        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
Validate.notEmpty  (  protocol  )  ;	[BUGGY]  Protocol  prot  =  Protocol.valueOf(  protocol);  Validate.notEmpty(  protocol);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
Validate.notEmpty  (  protocol  )  ;	[BUGGY]  Validate.notNull(  value);Validate.notEmpty(  protocol);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
Validate.notEmpty  (  protocol  )  ;	[BUGGY]  Validate.notNull(  tags);Validate.notEmpty(  protocol);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
Validate.notEmpty  (  protocol  )  ;	[BUGGY]  Validate.notEmpty(  tag);Validate.notEmpty(  protocol);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
Validate.notEmpty  (  protocol  )  ;	[BUGGY]  Validate.notNull(  keys);Validate.notEmpty(  protocol);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
Validate.notEmpty  (  protocol  )  ;	[BUGGY]  Validate.notEmpty(  key);Validate.notEmpty(  protocol);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
Validate.notEmpty  (  protocol  )  ;	[BUGGY]  Validate.notEmpty(  value);Validate.notEmpty(  protocol);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
Validate.notEmpty  (  protocol  )  ;	[BUGGY]  Validate.notNull(  protocols);Validate.notEmpty(  protocol);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
Validate.notEmpty  (  protocol  )  ;	[BUGGY]  Validate.notEmpty(  tagName);Validate.notEmpty(  protocol);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
Protocol  prot  =  Protocol.valueOf  (  protocol  )  ;	[BUGGY]  Protocol  prot  =  Protocol  .TagName(  tagName)  ;  [CONTEXT]  public  Whitelist  addProtocols(String  tag,  String  key,  String...  protocols)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notNull(protocols);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  Map<AttributeKey,  Set<Protocol>>  attrMap;  Set<Protocol>  protSet;    if  (this.protocols.containsKey(tagName))  {  attrMap  =  this.protocols.get(tagName);  }  else  {  attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>();  this.protocols.put(tagName,  attrMap);  }  if  (attrMap.containsKey(attrKey))  {  protSet  =  attrMap.get(attrKey);  }  else  {  protSet  =  new  HashSet<Protocol>();  attrMap.put(attrKey,  protSet);  }  for  (String  protocol  :  protocols)  {  Validate.notEmpty(protocol);  [BUGGY]  Protocol  prot  =  Protocol  .TagName  (  tagName  );  protSet.add(prot);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
Protocol  prot  =  Protocol.valueOf  (  protocol  )  ;	[BUGGY]  Protocol  prot  =  Protocol.Protocol(  value);  [CONTEXT]  public  Whitelist  addProtocols(String  tag,  String  key,  String...  protocols)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notNull(protocols);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  Map<AttributeKey,  Set<Protocol>>  attrMap;  Set<Protocol>  protSet;    if  (this.protocols.containsKey(tagName))  {  attrMap  =  this.protocols.get(tagName);  }  else  {  attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>();  this.protocols.put(tagName,  attrMap);  }  if  (attrMap.containsKey(attrKey))  {  protSet  =  attrMap.get(attrKey);  }  else  {  protSet  =  new  HashSet<Protocol>();  attrMap.put(attrKey,  protSet);  }  for  (String  protocol  :  protocols)  {  Validate.notEmpty(protocol);  [BUGGY]  Protocol  prot  =  Protocol.Protocol  (  value  )  ;  protSet.add(prot);  }  return  this;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
Protocol  prot  =  Protocol.valueOf  (  protocol  )  ;	[BUGGY]    [CONTEXT]  public  Whitelist  addProtocols(String  tag,  String  key,  String...  protocols)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notNull(protocols);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  Map<AttributeKey,  Set<Protocol>>  attrMap;  Set<Protocol>  protSet;    if  (this.protocols.containsKey(tagName))  {  attrMap  =  this.protocols.get(tagName);  }  else  {  attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>();  this.protocols.put(tagName,  attrMap);  }  if  (attrMap.containsKey(attrKey))  {  protSet  =  attrMap.get(attrKey);  }  else  {  protSet  =  new  HashSet<Protocol>();  attrMap.put(attrKey,  protSet);  }  for  (String  protocol  :  protocols)  {  Validate.notEmpty(protocol);  [BUGGY]  Protocol  prot  =  Protocol.valueOf(protocol);    protSet.add(prot);  }  return  this;        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
protSet.add  (  prot  )  ;	[BUGGY]    [CONTEXT]  public  Whitelist  addProtocols(String  tag,  String  key,  String...  protocols)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notNull(protocols);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  Map<AttributeKey,  Set<Protocol>>  attrMap;  Set<Protocol>  protSet;    if  (this.protocols.containsKey(tagName))  {  attrMap  =  this.protocols.get(tagName);  }  else  {  attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>();  this.protocols.put(tagName,  attrMap);  }  if  (attrMap.containsKey(attrKey))  {  protSet  =  attrMap.get(attrKey);  }  else  {  protSet  =  new  HashSet<Protocol>();  attrMap.put(attrKey,  protSet);  }  for  (String  protocol  :  protocols)  {  Validate.notEmpty(protocol);  Protocol  prot  =  Protocol.valueOf(protocol);  [BUGGY]  protSet.add(prot);    }  return  this;        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
return  this;	[BUGGY]  return  null;  [CONTEXT]  public  Whitelist  addProtocols(String  tag,  String  key,  String...  protocols)  {  Validate.notEmpty(tag);  Validate.notEmpty(key);  Validate.notNull(protocols);    TagName  tagName  =  TagName.valueOf(tag);  AttributeKey  attrKey  =  AttributeKey.valueOf(key);  Map<AttributeKey,  Set<Protocol>>  attrMap;  Set<Protocol>  protSet;    if  (this.protocols.containsKey(tagName))  {  attrMap  =  this.protocols.get(tagName);  }  else  {  attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>();  this.protocols.put(tagName,  attrMap);  }  if  (attrMap.containsKey(attrKey))  {  protSet  =  attrMap.get(attrKey);  }  else  {  protSet  =  new  HashSet<Protocol>();  attrMap.put(attrKey,  protSet);  }  for  (String  protocol  :  protocols)  {  Validate.notEmpty(protocol);  Protocol  prot  =  Protocol.valueOf(protocol);  protSet.add(prot);  }  [BUGGY]  return  null;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  addProtocols  [RETURN_TYPE]  Whitelist      String  tag  String  key    protocols  [VARIABLES]  AttributeKey    attrKey    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tagName    String    key    protocol    tag    tagName    value    String[]    protocols    Protocol    prot    Map    attrMap    attributes    enforcedAttributes    protocols    
return  tagNames.contains  (  TagName.valueOf  (  tag  )  )  ;	[BUGGY]  return  tagNameNames.contains(  TagName.valueOf(  tag));  [CONTEXT]  boolean  isSafeTag(String  tag)  {  [BUGGY]  return  tagNameNames.contains  (  TagName.valueOf  (  tag  ))  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeTag  [RETURN_TYPE]  boolean      String  tag  [VARIABLES]  Set    attributeSet    currentSet    protSet    tagNames    String    key    protocol    tag    tagName    value    boolean    Map    attrMap    attributes    enforcedAttributes    protocols    
return  tagNames.contains  (  TagName.valueOf  (  tag  )  )  ;	[BUGGY]  return  tagNamesNames.contains(  TagName.valueOf(  tag));  [CONTEXT]  boolean  isSafeTag(String  tag)  {  [BUGGY]  return  tagNamesNames.contains  (  TagName.valueOf  (  tag  ))  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeTag  [RETURN_TYPE]  boolean      String  tag  [VARIABLES]  Set    attributeSet    currentSet    protSet    tagNames    String    key    protocol    tag    tagName    value    boolean    Map    attrMap    attributes    enforcedAttributes    protocols    
return  tagNames.contains  (  TagName.valueOf  (  tag  )  )  ;	[BUGGY]  return  tag.contains(  TagName.valueOf(  tagNames));  [CONTEXT]  boolean  isSafeTag(String  tag)  {  [BUGGY]  return  tag.contains  (  TagName.valueOf  (  tagNames  ))  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeTag  [RETURN_TYPE]  boolean      String  tag  [VARIABLES]  Set    attributeSet    currentSet    protSet    tagNames    String    key    protocol    tag    tagName    value    boolean    Map    attrMap    attributes    enforcedAttributes    protocols    
return  tagNames.contains  (  TagName.valueOf  (  tag  )  )  ;	[BUGGY]  return  tagNames.addAll(  TagName.valueOf(  tag));  [CONTEXT]  boolean  isSafeTag(String  tag)  {  [BUGGY]  return  tagNames.addAll  (  TagName.valueOf  (  tag  ))  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeTag  [RETURN_TYPE]  boolean      String  tag  [VARIABLES]  Set    attributeSet    currentSet    protSet    tagNames    String    key    protocol    tag    tagName    value    boolean    Map    attrMap    attributes    enforcedAttributes    protocols    
return  tagNames.contains  (  TagName.valueOf  (  tag  )  )  ;	[BUGGY]  return  tagNames  .add(  )  ;  [CONTEXT]  boolean  isSafeTag(String  tag)  {  [BUGGY]  return  tagNames  .add  ();  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeTag  [RETURN_TYPE]  boolean      String  tag  [VARIABLES]  Set    attributeSet    currentSet    protSet    tagNames    String    key    protocol    tag    tagName    value    boolean    Map    attrMap    attributes    enforcedAttributes    protocols    
return  tagNames.contains  (  TagName.valueOf  (  tag  )  )  ;	[BUGGY]  return  tagNames.contains(  TagName.TagName(  tag));  [CONTEXT]  boolean  isSafeTag(String  tag)  {  [BUGGY]  return  tagNames.contains  (  TagName.TagName  (  tag  ))  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeTag  [RETURN_TYPE]  boolean      String  tag  [VARIABLES]  Set    attributeSet    currentSet    protSet    tagNames    String    key    protocol    tag    tagName    value    boolean    Map    attrMap    attributes    enforcedAttributes    protocols    
return  tagNames.contains  (  TagName.valueOf  (  tag  )  )  ;	[BUGGY]  return  valueNames.contains(  TagName.valueOf(  tag));  [CONTEXT]  boolean  isSafeTag(String  tag)  {  [BUGGY]  return  valueNames.contains  (  TagName.valueOf  (  tag  ))  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeTag  [RETURN_TYPE]  boolean      String  tag  [VARIABLES]  Set    attributeSet    currentSet    protSet    tagNames    String    key    protocol    tag    tagName    value    boolean    Map    attrMap    attributes    enforcedAttributes    protocols    
return  tagNames.contains  (  TagName.valueOf  (  tag  )  )  ;	[BUGGY]  return  3.contains(  TagName.valueOf(  tag));  [CONTEXT]  boolean  isSafeTag(String  tag)  {  [BUGGY]  return  3.contains  (  TagName.valueOf  (  tag  ))  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeTag  [RETURN_TYPE]  boolean      String  tag  [VARIABLES]  Set    attributeSet    currentSet    protSet    tagNames    String    key    protocol    tag    tagName    value    boolean    Map    attrMap    attributes    enforcedAttributes    protocols    
return  tagNames.contains  (  TagName.valueOf  (  tag  )  )  ;	[BUGGY]    [CONTEXT]  boolean  isSafeTag(String  tag)  {  [BUGGY]  return  tagNames.contains(TagName.valueOf(tag));          [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeTag  [RETURN_TYPE]  boolean      String  tag  [VARIABLES]  Set    attributeSet    currentSet    protSet    tagNames    String    key    protocol    tag    tagName    value    boolean    Map    attrMap    attributes    enforcedAttributes    protocols    
TagName  tag  =  TagName.valueOf  (  tagName  )  ;	[BUGGY]  TagName  tag  =  TagName.valueOf(  value);  [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  [BUGGY]  TagName  tag  =  TagName.valueOf  (  value  )  ;  AttributeKey  key  =  AttributeKey.valueOf(attr.getKey());    if  (attributes.containsKey(tag))  {  if  (attributes.get(tag).contains(key))  {  if  (protocols.containsKey(tag))  {  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get(tag);      return  !attrProts.containsKey(key)  ||  testValidProtocol(el,  attr,  attrProts.get(key));  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  return  !tagName.equals( ":all ")  &&  isSafeAttribute( ":all ",  el,  attr);  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
TagName  tag  =  TagName.valueOf  (  tagName  )  ;	[BUGGY]  TagName  tag  =  TagName.TagName(  tagName);  [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  [BUGGY]  TagName  tag  =  TagName.TagName  (  tagName  )  ;  AttributeKey  key  =  AttributeKey.valueOf(attr.getKey());    if  (attributes.containsKey(tag))  {  if  (attributes.get(tag).contains(key))  {  if  (protocols.containsKey(tag))  {  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get(tag);      return  !attrProts.containsKey(key)  ||  testValidProtocol(el,  attr,  attrProts.get(key));  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  return  !tagName.equals( ":all ")  &&  isSafeAttribute( ":all ",  el,  attr);  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
TagName  tag  =  TagName.valueOf  (  tagName  )  ;	[BUGGY]  TagName  tagName  =  TagName.valueOf(  tag);TagName  tag  =  TagName.valueOf(  tagName);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
TagName  tag  =  TagName.valueOf  (  tagName  )  ;  AttributeKey  key  =  AttributeKey.valueOf  (  attr.getKey  (  )  )  ;	[BUGGY]    [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  [BUGGY]  TagName  tag  =  TagName.valueOf(tagName);        if  (attributes.containsKey(tag))  {  if  (attributes.get(tag).contains(key))  {  if  (protocols.containsKey(tag))  {  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get(tag);      return  !attrProts.containsKey(key)  ||  testValidProtocol(el,  attr,  attrProts.get(key));  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  return  !tagName.equals( ":all ")  &&  isSafeAttribute( ":all ",  el,  attr);  }  return  false;        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
TagName  tag  =  TagName.valueOf  (  tagName  )  ;	[BUGGY]  AttributeKey  key  =  AttributeKey.valueOf(  attr.getKey(  ));  TagName  tag  =  TagName.valueOf(  tagName);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
TagName  tag  =  TagName.valueOf  (  tagName  )  ;	[BUGGY]  tagNames.add(  TagName.valueOf(  tagName));TagName  tag  =  TagName.valueOf(  tagName);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
TagName  tag  =  TagName.valueOf  (  tagName  )  ;	[BUGGY]  return  tagNames.contains(  TagName.valueOf(  tag));TagName  tag  =  TagName.valueOf(  tagName);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
AttributeKey  key  =  AttributeKey.valueOf  (  attr.getKey  (  )  )  ;	[BUGGY]  AttributeKey  key  =  AttributeKey.AttributeKey(  attr.getKey(  ));  [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  [BUGGY]  AttributeKey  key  =  AttributeKey.AttributeKey  (  attr.getKey  ())  ;    if  (attributes.containsKey(tag))  {  if  (attributes.get(tag).contains(key))  {  if  (protocols.containsKey(tag))  {  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get(tag);      return  !attrProts.containsKey(key)  ||  testValidProtocol(el,  attr,  attrProts.get(key));  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  return  !tagName.equals( ":all ")  &&  isSafeAttribute( ":all ",  el,  attr);  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
AttributeKey  key  =  AttributeKey.valueOf  (  attr.getKey  (  )  )  ;	[BUGGY]  AttributeKey  key  =  AttributeKey  .TagName(  key)  ;  [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  [BUGGY]  AttributeKey  key  =  AttributeKey  .TagName  (  key  );    if  (attributes.containsKey(tag))  {  if  (attributes.get(tag).contains(key))  {  if  (protocols.containsKey(tag))  {  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get(tag);      return  !attrProts.containsKey(key)  ||  testValidProtocol(el,  attr,  attrProts.get(key));  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  return  !tagName.equals( ":all ")  &&  isSafeAttribute( ":all ",  el,  attr);  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
AttributeKey  key  =  AttributeKey.valueOf  (  attr.getKey  (  )  )  ;	[BUGGY]  AttributeKey  key  =  AttributeKey.valueOf(  attr.setValue(  ));  [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  [BUGGY]  AttributeKey  key  =  AttributeKey.valueOf  (  attr.setValue  ())  ;    if  (attributes.containsKey(tag))  {  if  (attributes.get(tag).contains(key))  {  if  (protocols.containsKey(tag))  {  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get(tag);      return  !attrProts.containsKey(key)  ||  testValidProtocol(el,  attr,  attrProts.get(key));  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  return  !tagName.equals( ":all ")  &&  isSafeAttribute( ":all ",  el,  attr);  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
AttributeKey  key  =  AttributeKey.valueOf  (  attr.getKey  (  )  )  ;	[BUGGY]  AttributeKey  key  =  AttributeKey.valueOf(  attr  .setValue(  protocol)  );  [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  [BUGGY]  AttributeKey  key  =  AttributeKey.valueOf  (  attr  .setValue  (  protocol  )  )  ;    if  (attributes.containsKey(tag))  {  if  (attributes.get(tag).contains(key))  {  if  (protocols.containsKey(tag))  {  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get(tag);      return  !attrProts.containsKey(key)  ||  testValidProtocol(el,  attr,  attrProts.get(key));  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  return  !tagName.equals( ":all ")  &&  isSafeAttribute( ":all ",  el,  attr);  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
AttributeKey  key  =  AttributeKey.valueOf  (  attr.getKey  (  )  )  ;	[BUGGY]  AttributeKey  key  =  AttributeKey  .TagName(  protocol)  ;  [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  [BUGGY]  AttributeKey  key  =  AttributeKey  .TagName  (  protocol  );    if  (attributes.containsKey(tag))  {  if  (attributes.get(tag).contains(key))  {  if  (protocols.containsKey(tag))  {  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get(tag);      return  !attrProts.containsKey(key)  ||  testValidProtocol(el,  attr,  attrProts.get(key));  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  return  !tagName.equals( ":all ")  &&  isSafeAttribute( ":all ",  el,  attr);  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
AttributeKey  key  =  AttributeKey.valueOf  (  attr.getKey  (  )  )  ;	[BUGGY]  AttributeKey  key  =  AttributeKey.valueOf(  attr  .setValue(  value)  );  [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  [BUGGY]  AttributeKey  key  =  AttributeKey.valueOf  (  attr  .setValue  (  value  )  )  ;    if  (attributes.containsKey(tag))  {  if  (attributes.get(tag).contains(key))  {  if  (protocols.containsKey(tag))  {  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get(tag);      return  !attrProts.containsKey(key)  ||  testValidProtocol(el,  attr,  attrProts.get(key));  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  return  !tagName.equals( ":all ")  &&  isSafeAttribute( ":all ",  el,  attr);  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
AttributeKey  key  =  AttributeKey.valueOf  (  attr.getKey  (  )  )  ;	[BUGGY]  AttributeKey  key  =  AttributeKey.valueOf(  attr  .setValue(  key)  );  [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  [BUGGY]  AttributeKey  key  =  AttributeKey.valueOf  (  attr  .setValue  (  key  )  )  ;    if  (attributes.containsKey(tag))  {  if  (attributes.get(tag).contains(key))  {  if  (protocols.containsKey(tag))  {  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get(tag);      return  !attrProts.containsKey(key)  ||  testValidProtocol(el,  attr,  attrProts.get(key));  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  return  !tagName.equals( ":all ")  &&  isSafeAttribute( ":all ",  el,  attr);  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
AttributeKey  key  =  AttributeKey.valueOf  (  attr.getKey  (  )  )  ;	[BUGGY]    [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  [BUGGY]  AttributeKey  key  =  AttributeKey.valueOf(attr.getKey());      if  (attributes.containsKey(tag))  {  if  (attributes.get(tag).contains(key))  {  if  (protocols.containsKey(tag))  {  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get(tag);      return  !attrProts.containsKey(key)  ||  testValidProtocol(el,  attr,  attrProts.get(key));  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  return  !tagName.equals( ":all ")  &&  isSafeAttribute( ":all ",  el,  attr);  }  return  false;        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
if  (  attributes.containsKey  (  tag  )  )  {	[BUGGY]  if  (  attr.containsKey(  tag))  {  [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  AttributeKey  key  =  AttributeKey.valueOf(attr.getKey());    [BUGGY]  if(  attr.containsKey  (  tag  )){  if  (attributes.get(tag).contains(key))  {  if  (protocols.containsKey(tag))  {  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get(tag);      return  !attrProts.containsKey(key)  ||  testValidProtocol(el,  attr,  attrProts.get(key));  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  return  !tagName.equals( ":all ")  &&  isSafeAttribute( ":all ",  el,  attr);  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
if  (  attributes.containsKey  (  tag  )  )  {	[BUGGY]  if  (  !(tagName.equals( ":all "))  &&  isSafeAttribute( ":all ",  el,  attr))  {  [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  AttributeKey  key  =  AttributeKey.valueOf(attr.getKey());    [BUGGY]  if(  !(tagName.equals( ":all "))  &&  isSafeAttribute( ":all ",  el,  attr)  ){  if  (attributes.get(tag).contains(key))  {  if  (protocols.containsKey(tag))  {  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get(tag);      return  !attrProts.containsKey(key)  ||  testValidProtocol(el,  attr,  attrProts.get(key));  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  return  !tagName.equals( ":all ")  &&  isSafeAttribute( ":all ",  el,  attr);  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
if  (  attributes.containsKey  (  tag  )  )  {	[BUGGY]  if  (  attributes.putKey(  tag))  {  [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  AttributeKey  key  =  AttributeKey.valueOf(attr.getKey());    [BUGGY]  if(  attributes.putKey  (  tag  )){  if  (attributes.get(tag).contains(key))  {  if  (protocols.containsKey(tag))  {  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get(tag);      return  !attrProts.containsKey(key)  ||  testValidProtocol(el,  attr,  attrProts.get(key));  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  return  !tagName.equals( ":all ")  &&  isSafeAttribute( ":all ",  el,  attr);  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
if  (  attributes.containsKey  (  tag  )  )  {	[BUGGY]  if  (  attributes  .contains(  )    {  [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  AttributeKey  key  =  AttributeKey.valueOf(attr.getKey());    [BUGGY]  if(  attributes  .contains  ()  {  if  (attributes.get(tag).contains(key))  {  if  (protocols.containsKey(tag))  {  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get(tag);      return  !attrProts.containsKey(key)  ||  testValidProtocol(el,  attr,  attrProts.get(key));  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  return  !tagName.equals( ":all ")  &&  isSafeAttribute( ":all ",  el,  attr);  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
if  (  attributes.containsKey  (  tag  )  )  {	[BUGGY]  if  (  attributes  .entrySet(  )  )  {  [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  AttributeKey  key  =  AttributeKey.valueOf(attr.getKey());    [BUGGY]  if(  attributes  .entrySet  ()  ){  if  (attributes.get(tag).contains(key))  {  if  (protocols.containsKey(tag))  {  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get(tag);      return  !attrProts.containsKey(key)  ||  testValidProtocol(el,  attr,  attrProts.get(key));  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  return  !tagName.equals( ":all ")  &&  isSafeAttribute( ":all ",  el,  attr);  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
if  (  attributes.containsKey  (  tag  )  )  {	[BUGGY]  if  (  attributes.put(  tag))  {  [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  AttributeKey  key  =  AttributeKey.valueOf(attr.getKey());    [BUGGY]  if(  attributes.put  (  tag  )){  if  (attributes.get(tag).contains(key))  {  if  (protocols.containsKey(tag))  {  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get(tag);      return  !attrProts.containsKey(key)  ||  testValidProtocol(el,  attr,  attrProts.get(key));  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  return  !tagName.equals( ":all ")  &&  isSafeAttribute( ":all ",  el,  attr);  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
if  (  attributes.containsKey  (  tag  )  )  {	[BUGGY]  if  (  attributes  .containsKey(  tag)  )  {  [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  AttributeKey  key  =  AttributeKey.valueOf(attr.getKey());    [BUGGY]  if(  attributes  .containsKey  (  tag  )  ){  if  (attributes.get(tag).contains(key))  {  if  (protocols.containsKey(tag))  {  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get(tag);      return  !attrProts.containsKey(key)  ||  testValidProtocol(el,  attr,  attrProts.get(key));  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  return  !tagName.equals( ":all ")  &&  isSafeAttribute( ":all ",  el,  attr);  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
if  (  attributes.containsKey  (  tag  )  )  {	[BUGGY]  if  (  attrMap.containsKey(  attrKey))  {  [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  AttributeKey  key  =  AttributeKey.valueOf(attr.getKey());    [BUGGY]  if(  attrMap.containsKey  (  attrKey  )){  if  (attributes.get(tag).contains(key))  {  if  (protocols.containsKey(tag))  {  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get(tag);      return  !attrProts.containsKey(key)  ||  testValidProtocol(el,  attr,  attrProts.get(key));  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  return  !tagName.equals( ":all ")  &&  isSafeAttribute( ":all ",  el,  attr);  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
if  (  attributes.containsKey  (  tag  )  )  {	[BUGGY]  if  (  enforcedAttributes.containsKey(  tagName))  {  [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  AttributeKey  key  =  AttributeKey.valueOf(attr.getKey());    [BUGGY]  if(  enforcedAttributes.containsKey  (  tagName  )){  if  (attributes.get(tag).contains(key))  {  if  (protocols.containsKey(tag))  {  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get(tag);      return  !attrProts.containsKey(key)  ||  testValidProtocol(el,  attr,  attrProts.get(key));  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  return  !tagName.equals( ":all ")  &&  isSafeAttribute( ":all ",  el,  attr);  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
if  (  attributes.containsKey  (  tag  )  )  {	[BUGGY]  if  (  enforcedAttributes.containsKey(  tag))  {  [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  AttributeKey  key  =  AttributeKey.valueOf(attr.getKey());    [BUGGY]  if(  enforcedAttributes.containsKey  (  tag  )){  if  (attributes.get(tag).contains(key))  {  if  (protocols.containsKey(tag))  {  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get(tag);      return  !attrProts.containsKey(key)  ||  testValidProtocol(el,  attr,  attrProts.get(key));  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  return  !tagName.equals( ":all ")  &&  isSafeAttribute( ":all ",  el,  attr);  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
if  (  attributes.containsKey  (  tag  )  )  {	[BUGGY]  if  (  attributes.containsKey(  tagName))  {  [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  AttributeKey  key  =  AttributeKey.valueOf(attr.getKey());    [BUGGY]  if(  attributes.containsKey  (  tagName  )){  if  (attributes.get(tag).contains(key))  {  if  (protocols.containsKey(tag))  {  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get(tag);      return  !attrProts.containsKey(key)  ||  testValidProtocol(el,  attr,  attrProts.get(key));  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  return  !tagName.equals( ":all ")  &&  isSafeAttribute( ":all ",  el,  attr);  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
if  (  attributes.containsKey  (  tag  )  )  {	[BUGGY]  if  (  this.protocols.containsKey(  tagName))  {  [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  AttributeKey  key  =  AttributeKey.valueOf(attr.getKey());    [BUGGY]  if(  this.protocols.containsKey  (  tagName  )){  if  (attributes.get(tag).contains(key))  {  if  (protocols.containsKey(tag))  {  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get(tag);      return  !attrProts.containsKey(key)  ||  testValidProtocol(el,  attr,  attrProts.get(key));  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  return  !tagName.equals( ":all ")  &&  isSafeAttribute( ":all ",  el,  attr);  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
if  (  attributes.containsKey  (  tag  )  )  {	[BUGGY]  if  (  protocols.containsKey(  tag))  {  [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  AttributeKey  key  =  AttributeKey.valueOf(attr.getKey());    [BUGGY]  if(  protocols.containsKey  (  tag  )){  if  (attributes.get(tag).contains(key))  {  if  (protocols.containsKey(tag))  {  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get(tag);      return  !attrProts.containsKey(key)  ||  testValidProtocol(el,  attr,  attrProts.get(key));  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  return  !tagName.equals( ":all ")  &&  isSafeAttribute( ":all ",  el,  attr);  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
return  !tagName.equals  (   ":all "  )  &&  isSafeAttribute  (   ":all ",  el,  attr  )  ;	[BUGGY]  return  !tagName.equals(   ":all ")  ||  isSafeAttribute(   ":all ",  el,  attr);  [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  AttributeKey  key  =  AttributeKey.valueOf(attr.getKey());    if  (attributes.containsKey(tag))  {  if  (attributes.get(tag).contains(key))  {  if  (protocols.containsKey(tag))  {  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get(tag);      return  !attrProts.containsKey(key)  ||  testValidProtocol(el,  attr,  attrProts.get(key));  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  [BUGGY]  return  !tagName.equals  (   ":all "  )||  isSafeAttribute  (   ":all ",  el,  attr  )  ;  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
return  !tagName.equals  (   ":all "  )  &&  isSafeAttribute  (   ":all ",  el,  attr  )  ;	[BUGGY]  return  !tagName.equals(   ": ")  &&  isSafeAttribute(   ": ",  el,  attr);  [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  AttributeKey  key  =  AttributeKey.valueOf(attr.getKey());    if  (attributes.containsKey(tag))  {  if  (attributes.get(tag).contains(key))  {  if  (protocols.containsKey(tag))  {  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get(tag);      return  !attrProts.containsKey(key)  ||  testValidProtocol(el,  attr,  attrProts.get(key));  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  [BUGGY]  return  !tagName.equals  (   ": "  )&&  isSafeAttribute  (   ": ",  el,  attr  )  ;  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
return  !tagName.equals  (   ":all "  )  &&  isSafeAttribute  (   ":all ",  el,  attr  )  ;	[BUGGY]  return  !tagName.equals(   " ")  &&  isSafeAttribute(   " ",  el,  attr);  [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  AttributeKey  key  =  AttributeKey.valueOf(attr.getKey());    if  (attributes.containsKey(tag))  {  if  (attributes.get(tag).contains(key))  {  if  (protocols.containsKey(tag))  {  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get(tag);      return  !attrProts.containsKey(key)  ||  testValidProtocol(el,  attr,  attrProts.get(key));  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  [BUGGY]  return  !tagName.equals  (   " "  )&&  isSafeAttribute  (   " ",  el,  attr  )  ;  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
return  !tagName.equals  (   ":all "  )  &&  isSafeAttribute  (   ":all ",  el,  attr  )  ;	[BUGGY]  return  !tagName.equals(   ":all ")  &&  isSafeAttribute(   ":all ",  attr,  el);  [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  AttributeKey  key  =  AttributeKey.valueOf(attr.getKey());    if  (attributes.containsKey(tag))  {  if  (attributes.get(tag).contains(key))  {  if  (protocols.containsKey(tag))  {  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get(tag);      return  !attrProts.containsKey(key)  ||  testValidProtocol(el,  attr,  attrProts.get(key));  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  [BUGGY]  return  !tagName.equals  (   ":all "  )&&  isSafeAttribute  (   ":all ",  attr,  el  )  ;  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
return  !tagName.equals  (   ":all "  )  &&  isSafeAttribute  (   ":all ",  el,  attr  )  ;	[BUGGY]  return  !tagName.equals(   ":all ")  &&  isSafeAttribute(   ":all ",    attr);  [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  AttributeKey  key  =  AttributeKey.valueOf(attr.getKey());    if  (attributes.containsKey(tag))  {  if  (attributes.get(tag).contains(key))  {  if  (protocols.containsKey(tag))  {  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get(tag);      return  !attrProts.containsKey(key)  ||  testValidProtocol(el,  attr,  attrProts.get(key));  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  [BUGGY]  return  !tagName.equals  (   ":all "  )&&  isSafeAttribute  (   ":all ",attr  )  ;  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
return  !tagName.equals  (   ":all "  )  &&  isSafeAttribute  (   ":all ",  el,  attr  )  ;	[BUGGY]  return  !tagName.equals(   ":all ")  &&  isSafeAttribute(   ":all ",  el);  [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  AttributeKey  key  =  AttributeKey.valueOf(attr.getKey());    if  (attributes.containsKey(tag))  {  if  (attributes.get(tag).contains(key))  {  if  (protocols.containsKey(tag))  {  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get(tag);      return  !attrProts.containsKey(key)  ||  testValidProtocol(el,  attr,  attrProts.get(key));  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  [BUGGY]  return  !tagName.equals  (   ":all "  )&&  isSafeAttribute  (   ":all ",  el  )  ;  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
return  !tagName.equals  (   ":all "  )  &&  isSafeAttribute  (   ":all ",  el,  attr  )  ;	[BUGGY]  return  !tagName  .equals(  key)    &&  isSafeAttribute(   ":all ",  el,  attr);  [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  AttributeKey  key  =  AttributeKey.valueOf(attr.getKey());    if  (attributes.containsKey(tag))  {  if  (attributes.get(tag).contains(key))  {  if  (protocols.containsKey(tag))  {  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get(tag);      return  !attrProts.containsKey(key)  ||  testValidProtocol(el,  attr,  attrProts.get(key));  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  [BUGGY]  return  !tagName  .equals  (  key  )  &&  isSafeAttribute  (   ":all ",  el,  attr  )  ;  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
return  !tagName.equals  (   ":all "  )  &&  isSafeAttribute  (   ":all ",  el,  attr  )  ;	[BUGGY]  return  !tagName.equals(   ":all ")  &&  addEnforcedAttribute(   ":all ",  el,  attr);  [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  AttributeKey  key  =  AttributeKey.valueOf(attr.getKey());    if  (attributes.containsKey(tag))  {  if  (attributes.get(tag).contains(key))  {  if  (protocols.containsKey(tag))  {  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get(tag);      return  !attrProts.containsKey(key)  ||  testValidProtocol(el,  attr,  attrProts.get(key));  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  [BUGGY]  return  !tagName.equals  (   ":all "  )&&  addEnforcedAttribute  (   ":all ",  el,  attr  )  ;  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
return  !tagName.equals  (   ":all "  )  &&  isSafeAttribute  (   ":all ",  el,  attr  )  ;	[BUGGY]  return  !tagName  .equals(  value)    &&  isSafeAttribute(   ":all ",  el,  attr);  [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  AttributeKey  key  =  AttributeKey.valueOf(attr.getKey());    if  (attributes.containsKey(tag))  {  if  (attributes.get(tag).contains(key))  {  if  (protocols.containsKey(tag))  {  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get(tag);      return  !attrProts.containsKey(key)  ||  testValidProtocol(el,  attr,  attrProts.get(key));  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  [BUGGY]  return  !tagName  .equals  (  value  )  &&  isSafeAttribute  (   ":all ",  el,  attr  )  ;  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
return  !tagName.equals  (   ":all "  )  &&  isSafeAttribute  (   ":all ",  el,  attr  )  ;	[BUGGY]  return  !tagName.equals(   "all ")  &&  isSafeAttribute(   "all ",  el,  attr);  [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  AttributeKey  key  =  AttributeKey.valueOf(attr.getKey());    if  (attributes.containsKey(tag))  {  if  (attributes.get(tag).contains(key))  {  if  (protocols.containsKey(tag))  {  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get(tag);      return  !attrProts.containsKey(key)  ||  testValidProtocol(el,  attr,  attrProts.get(key));  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  [BUGGY]  return  !tagName.equals  (   "all "  )&&  isSafeAttribute  (   "all ",  el,  attr  )  ;  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
return  !tagName.equals  (   ":all "  )  &&  isSafeAttribute  (   ":all ",  el,  attr  )  ;	[BUGGY]    [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  AttributeKey  key  =  AttributeKey.valueOf(attr.getKey());    if  (attributes.containsKey(tag))  {  if  (attributes.get(tag).contains(key))  {  if  (protocols.containsKey(tag))  {  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get(tag);      return  !attrProts.containsKey(key)  ||  testValidProtocol(el,  attr,  attrProts.get(key));  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  [BUGGY]  return  !tagName.equals( ":all ")  &&  isSafeAttribute( ":all ",  el,  attr);    }  return  false;        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
return  !tagName.equals  (   ":all "  )  &&  isSafeAttribute  (   ":all ",  el,  attr  )  ;	[BUGGY]  return  !tagName.equals(   ":all:al ")  &&  isSafeAttribute(   ":all:al ",  el,  attr);  [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  AttributeKey  key  =  AttributeKey.valueOf(attr.getKey());    if  (attributes.containsKey(tag))  {  if  (attributes.get(tag).contains(key))  {  if  (protocols.containsKey(tag))  {  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get(tag);      return  !attrProts.containsKey(key)  ||  testValidProtocol(el,  attr,  attrProts.get(key));  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  [BUGGY]  return  !tagName.equals  (   ":all:al "  )&&  isSafeAttribute  (   ":all:al ",  el,  attr  )  ;  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
if  (  attributes.get  (  tag  )  .contains  (  key  )  )  {	[BUGGY]  if  (  attr.get(  tag).contains(  key))  {  [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  AttributeKey  key  =  AttributeKey.valueOf(attr.getKey());    if  (attributes.containsKey(tag))  {  [BUGGY]  if(  attr.get  (  tag  )  .contains  (  key  )){  if  (protocols.containsKey(tag))  {  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get(tag);      return  !attrProts.containsKey(key)  ||  testValidProtocol(el,  attr,  attrProts.get(key));  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  return  !tagName.equals( ":all ")  &&  isSafeAttribute( ":all ",  el,  attr);  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
if  (  attributes.get  (  tag  )  .contains  (  key  )  )  {	[BUGGY]  if  (  attributes.get(  tag).put(  key))  {  [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  AttributeKey  key  =  AttributeKey.valueOf(attr.getKey());    if  (attributes.containsKey(tag))  {  [BUGGY]  if(  attributes.get  (  tag  )  .put  (  key  )){  if  (protocols.containsKey(tag))  {  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get(tag);      return  !attrProts.containsKey(key)  ||  testValidProtocol(el,  attr,  attrProts.get(key));  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  return  !tagName.equals( ":all ")  &&  isSafeAttribute( ":all ",  el,  attr);  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
if  (  attributes.get  (  tag  )  .contains  (  key  )  )  {	[BUGGY]  if  (  attributes.get(  tag)  .contains(  )  )  {  [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  AttributeKey  key  =  AttributeKey.valueOf(attr.getKey());    if  (attributes.containsKey(tag))  {  [BUGGY]  if(  attributes.get  (  tag  ).contains  ()  ){  if  (protocols.containsKey(tag))  {  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get(tag);      return  !attrProts.containsKey(key)  ||  testValidProtocol(el,  attr,  attrProts.get(key));  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  return  !tagName.equals( ":all ")  &&  isSafeAttribute( ":all ",  el,  attr);  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
if  (  attributes.get  (  tag  )  .contains  (  key  )  )  {	[BUGGY]  if  (  attributes.containsKey(  tag).contains(  key))  {  [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  AttributeKey  key  =  AttributeKey.valueOf(attr.getKey());    if  (attributes.containsKey(tag))  {  [BUGGY]  if(  attributes.containsKey  (  tag  )  .contains  (  key  )){  if  (protocols.containsKey(tag))  {  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get(tag);      return  !attrProts.containsKey(key)  ||  testValidProtocol(el,  attr,  attrProts.get(key));  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  return  !tagName.equals( ":all ")  &&  isSafeAttribute( ":all ",  el,  attr);  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
if  (  attributes.get  (  tag  )  .contains  (  key  )  )  {	[BUGGY]  if  (  attributes.put(  tag).contains(  key))  {  [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  AttributeKey  key  =  AttributeKey.valueOf(attr.getKey());    if  (attributes.containsKey(tag))  {  [BUGGY]  if(  attributes.put  (  tag  )  .contains  (  key  )){  if  (protocols.containsKey(tag))  {  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get(tag);      return  !attrProts.containsKey(key)  ||  testValidProtocol(el,  attr,  attrProts.get(key));  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  return  !tagName.equals( ":all ")  &&  isSafeAttribute( ":all ",  el,  attr);  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
if  (  protocols.containsKey  (  tag  )  )  {	[BUGGY]  if  (  protocols.put(  tag))  {  [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  AttributeKey  key  =  AttributeKey.valueOf(attr.getKey());    if  (attributes.containsKey(tag))  {  if  (attributes.get(tag).contains(key))  {  [BUGGY]  if(  protocols.put  (  tag  )){  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get(tag);      return  !attrProts.containsKey(key)  ||  testValidProtocol(el,  attr,  attrProts.get(key));  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  return  !tagName.equals( ":all ")  &&  isSafeAttribute( ":all ",  el,  attr);  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
if  (  protocols.containsKey  (  tag  )  )  {	[BUGGY]  if  (  protocols  .containsKey(  tag)  )  {  [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  AttributeKey  key  =  AttributeKey.valueOf(attr.getKey());    if  (attributes.containsKey(tag))  {  if  (attributes.get(tag).contains(key))  {  [BUGGY]  if(  protocols  .containsKey  (  tag  )  ){  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get(tag);      return  !attrProts.containsKey(key)  ||  testValidProtocol(el,  attr,  attrProts.get(key));  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  return  !tagName.equals( ":all ")  &&  isSafeAttribute( ":all ",  el,  attr);  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
if  (  protocols.containsKey  (  tag  )  )  {	[BUGGY]  if  (  attrMap.containsKey(  attrKey))  {  [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  AttributeKey  key  =  AttributeKey.valueOf(attr.getKey());    if  (attributes.containsKey(tag))  {  if  (attributes.get(tag).contains(key))  {  [BUGGY]  if(  attrMap.containsKey  (  attrKey  )){  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get(tag);      return  !attrProts.containsKey(key)  ||  testValidProtocol(el,  attr,  attrProts.get(key));  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  return  !tagName.equals( ":all ")  &&  isSafeAttribute( ":all ",  el,  attr);  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
if  (  protocols.containsKey  (  tag  )  )  {	[BUGGY]  if  (  attributes.containsKey(  tag))  {  [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  AttributeKey  key  =  AttributeKey.valueOf(attr.getKey());    if  (attributes.containsKey(tag))  {  if  (attributes.get(tag).contains(key))  {  [BUGGY]  if(  attributes.containsKey  (  tag  )){  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get(tag);      return  !attrProts.containsKey(key)  ||  testValidProtocol(el,  attr,  attrProts.get(key));  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  return  !tagName.equals( ":all ")  &&  isSafeAttribute( ":all ",  el,  attr);  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
if  (  protocols.containsKey  (  tag  )  )  {	[BUGGY]  if  (  enforcedAttributes.containsKey(  tag))  {  [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  AttributeKey  key  =  AttributeKey.valueOf(attr.getKey());    if  (attributes.containsKey(tag))  {  if  (attributes.get(tag).contains(key))  {  [BUGGY]  if(  enforcedAttributes.containsKey  (  tag  )){  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get(tag);      return  !attrProts.containsKey(key)  ||  testValidProtocol(el,  attr,  attrProts.get(key));  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  return  !tagName.equals( ":all ")  &&  isSafeAttribute( ":all ",  el,  attr);  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
if  (  protocols.containsKey  (  tag  )  )  {	[BUGGY]  if  (  attributes.containsKey(  tagName))  {  [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  AttributeKey  key  =  AttributeKey.valueOf(attr.getKey());    if  (attributes.containsKey(tag))  {  if  (attributes.get(tag).contains(key))  {  [BUGGY]  if(  attributes.containsKey  (  tagName  )){  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get(tag);      return  !attrProts.containsKey(key)  ||  testValidProtocol(el,  attr,  attrProts.get(key));  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  return  !tagName.equals( ":all ")  &&  isSafeAttribute( ":all ",  el,  attr);  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
if  (  protocols.containsKey  (  tag  )  )  {	[BUGGY]  if  (  this.protocols.containsKey(  tagName))  {  [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  AttributeKey  key  =  AttributeKey.valueOf(attr.getKey());    if  (attributes.containsKey(tag))  {  if  (attributes.get(tag).contains(key))  {  [BUGGY]  if(  this.protocols.containsKey  (  tagName  )){  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get(tag);      return  !attrProts.containsKey(key)  ||  testValidProtocol(el,  attr,  attrProts.get(key));  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  return  !tagName.equals( ":all ")  &&  isSafeAttribute( ":all ",  el,  attr);  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
return  true;	[BUGGY]  return  false;  [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  AttributeKey  key  =  AttributeKey.valueOf(attr.getKey());    if  (attributes.containsKey(tag))  {  if  (attributes.get(tag).contains(key))  {  if  (protocols.containsKey(tag))  {  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get(tag);      return  !attrProts.containsKey(key)  ||  testValidProtocol(el,  attr,  attrProts.get(key));  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  [BUGGY]  return  false;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  return  !tagName.equals( ":all ")  &&  isSafeAttribute( ":all ",  el,  attr);  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
return  !attrProts.containsKey  (  key  )  ||  testValidProtocol  (  el,  attr,  attrProts.get  (  key  )  )  ;	[BUGGY]  return  !attrProts.containsKey(  key)  &&  testValidProtocol(  el,  attr,  attrProts.get(  key));  [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  AttributeKey  key  =  AttributeKey.valueOf(attr.getKey());    if  (attributes.containsKey(tag))  {  if  (attributes.get(tag).contains(key))  {  if  (protocols.containsKey(tag))  {  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get(tag);      [BUGGY]  return  !attrProts.containsKey  (  key  )&&  testValidProtocol  (  el,  attr,  attrProts.get  (  key  ))  ;  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  return  !tagName.equals( ":all ")  &&  isSafeAttribute( ":all ",  el,  attr);  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
return  !attrProts.containsKey  (  key  )  ||  testValidProtocol  (  el,  attr,  attrProts.get  (  key  )  )  ;	[BUGGY]  return  !attrProts.containsKey(  key)  ||  testValidProtocol(  el,  attrProts,  attr.get(  key));  [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  AttributeKey  key  =  AttributeKey.valueOf(attr.getKey());    if  (attributes.containsKey(tag))  {  if  (attributes.get(tag).contains(key))  {  if  (protocols.containsKey(tag))  {  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get(tag);      [BUGGY]  return  !attrProts.containsKey  (  key  )||  testValidProtocol  (  el,  attrProts,  attr.get  (  key  ))  ;  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  return  !tagName.equals( ":all ")  &&  isSafeAttribute( ":all ",  el,  attr);  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
return  !attrProts.containsKey  (  key  )  ||  testValidProtocol  (  el,  attr,  attrProts.get  (  key  )  )  ;	[BUGGY]  return  !attrProts.containsKey(  key)  ||  testValidProtocol(  el,  attr.get(  key));  [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  AttributeKey  key  =  AttributeKey.valueOf(attr.getKey());    if  (attributes.containsKey(tag))  {  if  (attributes.get(tag).contains(key))  {  if  (protocols.containsKey(tag))  {  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get(tag);      [BUGGY]  return  !attrProts.containsKey  (  key  )||  testValidProtocol  (  el,  attr.get  (  key  ))  ;  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  return  !tagName.equals( ":all ")  &&  isSafeAttribute( ":all ",  el,  attr);  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
return  !attrProts.containsKey  (  key  )  ||  testValidProtocol  (  el,  attr,  attrProts.get  (  key  )  )  ;	[BUGGY]  return  !attrProts.containsKey(  attr)  ||  testValidProtocol(  el,  key,  attrProts.get(  key));  [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  AttributeKey  key  =  AttributeKey.valueOf(attr.getKey());    if  (attributes.containsKey(tag))  {  if  (attributes.get(tag).contains(key))  {  if  (protocols.containsKey(tag))  {  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get(tag);      [BUGGY]  return  !attrProts.containsKey  (  attr  )||  testValidProtocol  (  el,  key,  attrProts.get  (  key  ))  ;  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  return  !tagName.equals( ":all ")  &&  isSafeAttribute( ":all ",  el,  attr);  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
return  !attrProts.containsKey  (  key  )  ||  testValidProtocol  (  el,  attr,  attrProts.get  (  key  )  )  ;	[BUGGY]  return  !attrProts.containsKey(  key)  ||  testValidProtocol(  attr,  el,  attrProts.get(  key));  [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  AttributeKey  key  =  AttributeKey.valueOf(attr.getKey());    if  (attributes.containsKey(tag))  {  if  (attributes.get(tag).contains(key))  {  if  (protocols.containsKey(tag))  {  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get(tag);      [BUGGY]  return  !attrProts.containsKey  (  key  )||  testValidProtocol  (  attr,  el,  attrProts.get  (  key  ))  ;  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  return  !tagName.equals( ":all ")  &&  isSafeAttribute( ":all ",  el,  attr);  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
return  !attrProts.containsKey  (  key  )  ||  testValidProtocol  (  el,  attr,  attrProts.get  (  key  )  )  ;	[BUGGY]  return  !attrProts.containsKey(  key)  ||  testValidProtocol(    attr,  attrProts.get(  key));  [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  AttributeKey  key  =  AttributeKey.valueOf(attr.getKey());    if  (attributes.containsKey(tag))  {  if  (attributes.get(tag).contains(key))  {  if  (protocols.containsKey(tag))  {  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get(tag);      [BUGGY]  return  !attrProts.containsKey  (  key  )||  testValidProtocol  (attr,  attrProts.get  (  key  ))  ;  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  return  !tagName.equals( ":all ")  &&  isSafeAttribute( ":all ",  el,  attr);  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
return  !attrProts.containsKey  (  key  )  ||  testValidProtocol  (  el,  attr,  attrProts.get  (  key  )  )  ;	[BUGGY]  return  !attrProts.containsKey(  key)  ||  testValidProtocol(  el,    attrProts.get(  key));  [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  AttributeKey  key  =  AttributeKey.valueOf(attr.getKey());    if  (attributes.containsKey(tag))  {  if  (attributes.get(tag).contains(key))  {  if  (protocols.containsKey(tag))  {  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get(tag);      [BUGGY]  return  !attrProts.containsKey  (  key  )||  testValidProtocol  (  el,attrProts.get  (  key  ))  ;  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  return  !tagName.equals( ":all ")  &&  isSafeAttribute( ":all ",  el,  attr);  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
return  !attrProts.containsKey  (  key  )  ||  testValidProtocol  (  el,  attr,  attrProts.get  (  key  )  )  ;	[BUGGY]  return  !attrProts.put(  key)  ||  testValidProtocol(  el,  attr,  attrProts.get(  key));  [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  AttributeKey  key  =  AttributeKey.valueOf(attr.getKey());    if  (attributes.containsKey(tag))  {  if  (attributes.get(tag).contains(key))  {  if  (protocols.containsKey(tag))  {  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get(tag);      [BUGGY]  return  !attrProts.put  (  key  )||  testValidProtocol  (  el,  attr,  attrProts.get  (  key  ))  ;  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  return  !tagName.equals( ":all ")  &&  isSafeAttribute( ":all ",  el,  attr);  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
return  !attrProts.containsKey  (  key  )  ||  testValidProtocol  (  el,  attr,  attrProts.get  (  key  )  )  ;	[BUGGY]  return  !attrProts  .containsKey(  tag)    ||  testValidProtocol(  el,  attr,  attrProts.get(  key));  [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  AttributeKey  key  =  AttributeKey.valueOf(attr.getKey());    if  (attributes.containsKey(tag))  {  if  (attributes.get(tag).contains(key))  {  if  (protocols.containsKey(tag))  {  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get(tag);      [BUGGY]  return  !attrProts  .containsKey  (  tag  )  ||  testValidProtocol  (  el,  attr,  attrProts.get  (  key  ))  ;  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  return  !tagName.equals( ":all ")  &&  isSafeAttribute( ":all ",  el,  attr);  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
return  !attrProts.containsKey  (  key  )  ||  testValidProtocol  (  el,  attr,  attrProts.get  (  key  )  )  ;	[BUGGY]  return  !attrProts.containsKey(  key)  ||  testValidProtocol(  el,  attr,  attrProts.put(  key));  [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  AttributeKey  key  =  AttributeKey.valueOf(attr.getKey());    if  (attributes.containsKey(tag))  {  if  (attributes.get(tag).contains(key))  {  if  (protocols.containsKey(tag))  {  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get(tag);      [BUGGY]  return  !attrProts.containsKey  (  key  )||  testValidProtocol  (  el,  attr,  attrProts.put  (  key  ))  ;  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  return  !tagName.equals( ":all ")  &&  isSafeAttribute( ":all ",  el,  attr);  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
return  !attrProts.containsKey  (  key  )  ||  testValidProtocol  (  el,  attr,  attrProts.get  (  key  )  )  ;	[BUGGY]  return  !attrProts.containsKey(  key)  ;  [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  AttributeKey  key  =  AttributeKey.valueOf(attr.getKey());    if  (attributes.containsKey(tag))  {  if  (attributes.get(tag).contains(key))  {  if  (protocols.containsKey(tag))  {  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get(tag);      [BUGGY]  return  !attrProts.containsKey  (  key  );  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  return  !tagName.equals( ":all ")  &&  isSafeAttribute( ":all ",  el,  attr);  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get  (  tag  )  ;	[BUGGY]  Map<AttributeKey,  Set<Protocol>>  attrProts  =  tag.get(  protocols);  [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  AttributeKey  key  =  AttributeKey.valueOf(attr.getKey());    if  (attributes.containsKey(tag))  {  if  (attributes.get(tag).contains(key))  {  if  (protocols.containsKey(tag))  {  [BUGGY]  Map<AttributeKey,  Set<Protocol>>  attrProts  =  tag.get  (  protocols  )  ;      return  !attrProts.containsKey(key)  ||  testValidProtocol(el,  attr,  attrProts.get(key));  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  return  !tagName.equals( ":all ")  &&  isSafeAttribute( ":all ",  el,  attr);  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get  (  tag  )  ;	[BUGGY]  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.containsKey(  tag);  [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  AttributeKey  key  =  AttributeKey.valueOf(attr.getKey());    if  (attributes.containsKey(tag))  {  if  (attributes.get(tag).contains(key))  {  if  (protocols.containsKey(tag))  {  [BUGGY]  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.containsKey  (  tag  )  ;      return  !attrProts.containsKey(key)  ||  testValidProtocol(el,  attr,  attrProts.get(key));  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  return  !tagName.equals( ":all ")  &&  isSafeAttribute( ":all ",  el,  attr);  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get  (  tag  )  ;	[BUGGY]    [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  AttributeKey  key  =  AttributeKey.valueOf(attr.getKey());    if  (attributes.containsKey(tag))  {  if  (attributes.get(tag).contains(key))  {  if  (protocols.containsKey(tag))  {  [BUGGY]  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get(tag);        return  !attrProts.containsKey(key)  ||  testValidProtocol(el,  attr,  attrProts.get(key));  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  return  !tagName.equals( ":all ")  &&  isSafeAttribute( ":all ",  el,  attr);  }  return  false;        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
return  !attrProts.containsKey  (  key  )  ||  testValidProtocol  (  el,  attr,  attrProts.get  (  key  )  )  ;	[BUGGY]  return  !attrProts.containsKey(  attrProts)  ||  testValidProtocol(  el,  attr,  key.get(  key));  [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  AttributeKey  key  =  AttributeKey.valueOf(attr.getKey());    if  (attributes.containsKey(tag))  {  if  (attributes.get(tag).contains(key))  {  if  (protocols.containsKey(tag))  {  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get(tag);      [BUGGY]  return  !attrProts.containsKey  (  attrProts  )||  testValidProtocol  (  el,  attr,  key.get  (  key  ))  ;  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  return  !tagName.equals( ":all ")  &&  isSafeAttribute( ":all ",  el,  attr);  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
return  !attrProts.containsKey  (  key  )  ||  testValidProtocol  (  el,  attr,  attrProts.get  (  key  )  )  ;	[BUGGY]    [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  AttributeKey  key  =  AttributeKey.valueOf(attr.getKey());    if  (attributes.containsKey(tag))  {  if  (attributes.get(tag).contains(key))  {  if  (protocols.containsKey(tag))  {  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get(tag);      [BUGGY]  return  !attrProts.containsKey(key)  ||  testValidProtocol(el,  attr,  attrProts.get(key));    }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  return  !tagName.equals( ":all ")  &&  isSafeAttribute( ":all ",  el,  attr);  }  return  false;        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
return  !attrProts.containsKey  (  key  )  ||  testValidProtocol  (  el,  attr,  attrProts.get  (  key  )  )  ;	[BUGGY]  return  !attrProts.containsKey(  key)  ||  testValidProtocol(  attrProts,  attr,  el.get(  key));  [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  AttributeKey  key  =  AttributeKey.valueOf(attr.getKey());    if  (attributes.containsKey(tag))  {  if  (attributes.get(tag).contains(key))  {  if  (protocols.containsKey(tag))  {  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get(tag);      [BUGGY]  return  !attrProts.containsKey  (  key  )||  testValidProtocol  (  attrProts,  attr,  el.get  (  key  ))  ;  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  return  !tagName.equals( ":all ")  &&  isSafeAttribute( ":all ",  el,  attr);  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
return  !attrProts.containsKey  (  key  )  ||  testValidProtocol  (  el,  attr,  attrProts.get  (  key  )  )  ;	[BUGGY]  return  !attrProts.containsKey(  key)  ||  testValidProtocol(  el,  attr,  attrProts  .get(  tag)  );  [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  AttributeKey  key  =  AttributeKey.valueOf(attr.getKey());    if  (attributes.containsKey(tag))  {  if  (attributes.get(tag).contains(key))  {  if  (protocols.containsKey(tag))  {  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get(tag);      [BUGGY]  return  !attrProts.containsKey  (  key  )||  testValidProtocol  (  el,  attr,  attrProts  .get  (  tag  )  )  ;  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  return  !tagName.equals( ":all ")  &&  isSafeAttribute( ":all ",  el,  attr);  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
if  (  protocols.containsKey  (  tag  )  )  {	[BUGGY]  if  (  tag.containsKey(  protocols))  {  [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  AttributeKey  key  =  AttributeKey.valueOf(attr.getKey());    if  (attributes.containsKey(tag))  {  if  (attributes.get(tag).contains(key))  {  [BUGGY]  if(  tag.containsKey  (  protocols  )){  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get(tag);      return  !attrProts.containsKey(key)  ||  testValidProtocol(el,  attr,  attrProts.get(key));  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  return  !tagName.equals( ":all ")  &&  isSafeAttribute( ":all ",  el,  attr);  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
if  (  protocols.containsKey  (  tag  )  )  {	[BUGGY]  if  (  protocols  .entrySet(  )  )  {  [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  AttributeKey  key  =  AttributeKey.valueOf(attr.getKey());    if  (attributes.containsKey(tag))  {  if  (attributes.get(tag).contains(key))  {  [BUGGY]  if(  protocols  .entrySet  ()  ){  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get(tag);      return  !attrProts.containsKey(key)  ||  testValidProtocol(el,  attr,  attrProts.get(key));  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  return  !tagName.equals( ":all ")  &&  isSafeAttribute( ":all ",  el,  attr);  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
return  !attrProts.containsKey  (  key  )  ||  testValidProtocol  (  el,  attr,  attrProts.get  (  key  )  )  ;	[BUGGY]  return  !attrProts.containsKey(  el)  ||  testValidProtocol(  key,  attr,  attrProts.get(  key));  [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  AttributeKey  key  =  AttributeKey.valueOf(attr.getKey());    if  (attributes.containsKey(tag))  {  if  (attributes.get(tag).contains(key))  {  if  (protocols.containsKey(tag))  {  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get(tag);      [BUGGY]  return  !attrProts.containsKey  (  el  )||  testValidProtocol  (  key,  attr,  attrProts.get  (  key  ))  ;  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  return  !tagName.equals( ":all ")  &&  isSafeAttribute( ":all ",  el,  attr);  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
return  !attrProts.containsKey  (  key  )  ||  testValidProtocol  (  el,  attr,  attrProts.get  (  key  )  )  ;	[BUGGY]  return  !attrProts.containsKey(  key)  ||  testValidProtocol(  el,  attr,  1.get(  key));  [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  AttributeKey  key  =  AttributeKey.valueOf(attr.getKey());    if  (attributes.containsKey(tag))  {  if  (attributes.get(tag).contains(key))  {  if  (protocols.containsKey(tag))  {  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get(tag);      [BUGGY]  return  !attrProts.containsKey  (  key  )||  testValidProtocol  (  el,  attr,  1.get  (  key  ))  ;  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  return  !tagName.equals( ":all ")  &&  isSafeAttribute( ":all ",  el,  attr);  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
return  !attrProts.containsKey  (  key  )  ||  testValidProtocol  (  el,  attr,  attrProts.get  (  key  )  )  ;	[BUGGY]  return  !attrProts.put(  key)  ;  [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  AttributeKey  key  =  AttributeKey.valueOf(attr.getKey());    if  (attributes.containsKey(tag))  {  if  (attributes.get(tag).contains(key))  {  if  (protocols.containsKey(tag))  {  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get(tag);      [BUGGY]  return  !attrProts.put  (  key  );  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  return  !tagName.equals( ":all ")  &&  isSafeAttribute( ":all ",  el,  attr);  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
return  !attrProts.containsKey  (  key  )  ||  testValidProtocol  (  el,  attr,  attrProts.get  (  key  )  )  ;	[BUGGY]  return  !attrProts.containsKey(  key)  ||  testValidProtocol(  el,  attr,  this.get(  key));  [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  AttributeKey  key  =  AttributeKey.valueOf(attr.getKey());    if  (attributes.containsKey(tag))  {  if  (attributes.get(tag).contains(key))  {  if  (protocols.containsKey(tag))  {  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get(tag);      [BUGGY]  return  !attrProts.containsKey  (  key  )||  testValidProtocol  (  el,  attr,  this.get  (  key  ))  ;  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  return  !tagName.equals( ":all ")  &&  isSafeAttribute( ":all ",  el,  attr);  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
if  (  attributes.get  (  tag  )  .contains  (  key  )  )  {	[BUGGY]  if  (  tag.get(  attributes).contains(  key))  {  [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  AttributeKey  key  =  AttributeKey.valueOf(attr.getKey());    if  (attributes.containsKey(tag))  {  [BUGGY]  if(  tag.get  (  attributes  )  .contains  (  key  )){  if  (protocols.containsKey(tag))  {  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get(tag);      return  !attrProts.containsKey(key)  ||  testValidProtocol(el,  attr,  attrProts.get(key));  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  return  !tagName.equals( ":all ")  &&  isSafeAttribute( ":all ",  el,  attr);  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
if  (  attributes.get  (  tag  )  .contains  (  key  )  )  {	[BUGGY]  if  (  key.get(  tag).contains(  attributes))  {  [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  AttributeKey  key  =  AttributeKey.valueOf(attr.getKey());    if  (attributes.containsKey(tag))  {  [BUGGY]  if(  key.get  (  tag  )  .contains  (  attributes  )){  if  (protocols.containsKey(tag))  {  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get(tag);      return  !attrProts.containsKey(key)  ||  testValidProtocol(el,  attr,  attrProts.get(key));  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  return  !tagName.equals( ":all ")  &&  isSafeAttribute( ":all ",  el,  attr);  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
if  (  protocols.containsKey  (  tag  )  )  {	[BUGGY]  if  (  null.containsKey(  tag))  {  [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  AttributeKey  key  =  AttributeKey.valueOf(attr.getKey());    if  (attributes.containsKey(tag))  {  if  (attributes.get(tag).contains(key))  {  [BUGGY]  if(  null.containsKey  (  tag  )){  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get(tag);      return  !attrProts.containsKey(key)  ||  testValidProtocol(el,  attr,  attrProts.get(key));  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  return  !tagName.equals( ":all ")  &&  isSafeAttribute( ":all ",  el,  attr);  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get  (  tag  )  ;	[BUGGY]  Map<AttributeKey,  Set<Protocol>>  attrProts  =  null.get(  tag);  [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  AttributeKey  key  =  AttributeKey.valueOf(attr.getKey());    if  (attributes.containsKey(tag))  {  if  (attributes.get(tag).contains(key))  {  if  (protocols.containsKey(tag))  {  [BUGGY]  Map<AttributeKey,  Set<Protocol>>  attrProts  =  null.get  (  tag  )  ;      return  !attrProts.containsKey(key)  ||  testValidProtocol(el,  attr,  attrProts.get(key));  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  return  !tagName.equals( ":all ")  &&  isSafeAttribute( ":all ",  el,  attr);  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
if  (  attributes.get  (  tag  )  .contains  (  key  )  )  {	[BUGGY]  if  (  attributes.get(  key).contains(  tag))  {  [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  AttributeKey  key  =  AttributeKey.valueOf(attr.getKey());    if  (attributes.containsKey(tag))  {  [BUGGY]  if(  attributes.get  (  key  )  .contains  (  tag  )){  if  (protocols.containsKey(tag))  {  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get(tag);      return  !attrProts.containsKey(key)  ||  testValidProtocol(el,  attr,  attrProts.get(key));  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  return  !tagName.equals( ":all ")  &&  isSafeAttribute( ":all ",  el,  attr);  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
if  (  attributes.get  (  tag  )  .contains  (  key  )  )  {	[BUGGY]  if  (  keyibutes.get(  tag).contains(  attr))  {  [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  AttributeKey  key  =  AttributeKey.valueOf(attr.getKey());    if  (attributes.containsKey(tag))  {  [BUGGY]  if(  keyibutes.get  (  tag  )  .contains  (  attr  )){  if  (protocols.containsKey(tag))  {  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get(tag);      return  !attrProts.containsKey(key)  ||  testValidProtocol(el,  attr,  attrProts.get(key));  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  return  !tagName.equals( ":all ")  &&  isSafeAttribute( ":all ",  el,  attr);  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
if  (  attributes.get  (  tag  )  .contains  (  key  )  )  {	[BUGGY]  if  (  attributes  .get(  tag)  .contains(  key))  {  [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  AttributeKey  key  =  AttributeKey.valueOf(attr.getKey());    if  (attributes.containsKey(tag))  {  [BUGGY]  if(  attributes  .get  (  tag  ).contains  (  key  )){  if  (protocols.containsKey(tag))  {  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get(tag);      return  !attrProts.containsKey(key)  ||  testValidProtocol(el,  attr,  attrProts.get(key));  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  return  !tagName.equals( ":all ")  &&  isSafeAttribute( ":all ",  el,  attr);  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
return  !attrProts.containsKey  (  key  )  ||  testValidProtocol  (  el,  attr,  attrProts.get  (  key  )  )  ;	[BUGGY]  return  !attrProts.containsKey(  key)  ||  testValidProtocol(  el,  attr,  null.get(  key));  [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  AttributeKey  key  =  AttributeKey.valueOf(attr.getKey());    if  (attributes.containsKey(tag))  {  if  (attributes.get(tag).contains(key))  {  if  (protocols.containsKey(tag))  {  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get(tag);      [BUGGY]  return  !attrProts.containsKey  (  key  )||  testValidProtocol  (  el,  attr,  null.get  (  key  ))  ;  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  return  !tagName.equals( ":all ")  &&  isSafeAttribute( ":all ",  el,  attr);  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get  (  tag  )  ;	[BUGGY]  Map<AttributeKey,  Set<Protocol>>  attrProts  =  this.get(  tag);  [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  AttributeKey  key  =  AttributeKey.valueOf(attr.getKey());    if  (attributes.containsKey(tag))  {  if  (attributes.get(tag).contains(key))  {  if  (protocols.containsKey(tag))  {  [BUGGY]  Map<AttributeKey,  Set<Protocol>>  attrProts  =  this.get  (  tag  )  ;      return  !attrProts.containsKey(key)  ||  testValidProtocol(el,  attr,  attrProts.get(key));  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  return  !tagName.equals( ":all ")  &&  isSafeAttribute( ":all ",  el,  attr);  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
return  !attrProts.containsKey  (  key  )  ||  testValidProtocol  (  el,  attr,  attrProts.get  (  key  )  )  ;	[BUGGY]  return  !attrProts.containsKey(  key)  ||  testValidProtocol(  el,  attr,  0.get(  key));  [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  AttributeKey  key  =  AttributeKey.valueOf(attr.getKey());    if  (attributes.containsKey(tag))  {  if  (attributes.get(tag).contains(key))  {  if  (protocols.containsKey(tag))  {  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get(tag);      [BUGGY]  return  !attrProts.containsKey  (  key  )||  testValidProtocol  (  el,  attr,  0.get  (  key  ))  ;  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  return  !tagName.equals( ":all ")  &&  isSafeAttribute( ":all ",  el,  attr);  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
return  !tagName.equals  (   ":all "  )  &&  isSafeAttribute  (   ":all ",  el,  attr  )  ;	[BUGGY]  return  !tagName  .equals(  protocol)    &&  isSafeAttribute(   ":all ",  el,  attr);  [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  AttributeKey  key  =  AttributeKey.valueOf(attr.getKey());    if  (attributes.containsKey(tag))  {  if  (attributes.get(tag).contains(key))  {  if  (protocols.containsKey(tag))  {  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get(tag);      return  !attrProts.containsKey(key)  ||  testValidProtocol(el,  attr,  attrProts.get(key));  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  [BUGGY]  return  !tagName  .equals  (  protocol  )  &&  isSafeAttribute  (   ":all ",  el,  attr  )  ;  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
return  !tagName.equals  (   ":all "  )  &&  isSafeAttribute  (   ":all ",  el,  attr  )  ;	[BUGGY]  return      addEnforcedAttribute(   ":all ",  el,  attr);  [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  AttributeKey  key  =  AttributeKey.valueOf(attr.getKey());    if  (attributes.containsKey(tag))  {  if  (attributes.get(tag).contains(key))  {  if  (protocols.containsKey(tag))  {  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get(tag);      return  !attrProts.containsKey(key)  ||  testValidProtocol(el,  attr,  attrProts.get(key));  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  [BUGGY]  return  addEnforcedAttribute  (   ":all ",  el,  attr  )  ;  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
if  (  attributes.containsKey  (  tag  )  )  {	[BUGGY]  if  (  tag.containsKey(  attributes))  {  [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  AttributeKey  key  =  AttributeKey.valueOf(attr.getKey());    [BUGGY]  if(  tag.containsKey  (  attributes  )){  if  (attributes.get(tag).contains(key))  {  if  (protocols.containsKey(tag))  {  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get(tag);      return  !attrProts.containsKey(key)  ||  testValidProtocol(el,  attr,  attrProts.get(key));  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  return  !tagName.equals( ":all ")  &&  isSafeAttribute( ":all ",  el,  attr);  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get  (  tag  )  ;	[BUGGY]  Map<AttributeKey,  Set<Protocol>>  attrProts  =  1.get(  tag);  [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  AttributeKey  key  =  AttributeKey.valueOf(attr.getKey());    if  (attributes.containsKey(tag))  {  if  (attributes.get(tag).contains(key))  {  if  (protocols.containsKey(tag))  {  [BUGGY]  Map<AttributeKey,  Set<Protocol>>  attrProts  =  1.get  (  tag  )  ;      return  !attrProts.containsKey(key)  ||  testValidProtocol(el,  attr,  attrProts.get(key));  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  return  !tagName.equals( ":all ")  &&  isSafeAttribute( ":all ",  el,  attr);  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
return  !attrProts.containsKey  (  key  )  ||  testValidProtocol  (  el,  attr,  attrProts.get  (  key  )  )  ;	[BUGGY]  return  !attrProts.containsKey(  key)  ||  testValidProtocol(  el,  attr,  3.get(  key));  [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  AttributeKey  key  =  AttributeKey.valueOf(attr.getKey());    if  (attributes.containsKey(tag))  {  if  (attributes.get(tag).contains(key))  {  if  (protocols.containsKey(tag))  {  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get(tag);      [BUGGY]  return  !attrProts.containsKey  (  key  )||  testValidProtocol  (  el,  attr,  3.get  (  key  ))  ;  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  return  !tagName.equals( ":all ")  &&  isSafeAttribute( ":all ",  el,  attr);  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
return  !tagName.equals  (   ":all "  )  &&  isSafeAttribute  (   ":all ",  el,  attr  )  ;	[BUGGY]  return  !tagName.equals(   ":alla ")  &&  isSafeAttribute(   ":alla ",  el,  attr);  [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  AttributeKey  key  =  AttributeKey.valueOf(attr.getKey());    if  (attributes.containsKey(tag))  {  if  (attributes.get(tag).contains(key))  {  if  (protocols.containsKey(tag))  {  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get(tag);      return  !attrProts.containsKey(key)  ||  testValidProtocol(el,  attr,  attrProts.get(key));  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  [BUGGY]  return  !tagName.equals  (   ":alla "  )&&  isSafeAttribute  (   ":alla ",  el,  attr  )  ;  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
return  false;	[BUGGY]  return  true;  [CONTEXT]  boolean  isSafeAttribute(String  tagName,  Element  el,  Attribute  attr)  {  TagName  tag  =  TagName.valueOf(tagName);  AttributeKey  key  =  AttributeKey.valueOf(attr.getKey());    if  (attributes.containsKey(tag))  {  if  (attributes.get(tag).contains(key))  {  if  (protocols.containsKey(tag))  {  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols.get(tag);      return  !attrProts.containsKey(key)  ||  testValidProtocol(el,  attr,  attrProts.get(key));  }  else  {  //  attribute  found,  no  protocols  defined,  so  OK  return  true;  }  }  }  else  {  //  no  attributes  defined  for  tag,  try  :all  tag  return  !tagName.equals( ":all ")  &&  isSafeAttribute( ":all ",  el,  attr);  }  [BUGGY]  return  true;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  isSafeAttribute  [RETURN_TYPE]  boolean      String  tagName  Element  el  Attribute  attr  [VARIABLES]  AttributeKey    key    Set    attributeSet    currentSet    protSet    tagNames    boolean    TagName    tag    Attribute    attr    Element    el    String    key    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
String  value  =  el.absUrl  (  attr.getKey  (  )  )  ;	[BUGGY]  char  value  =  el.absUrl(  attr.getKey(  ));  [CONTEXT]  private  boolean  testValidProtocol(Element  el,  Attribute  attr,  Set<Protocol>  protocols)  {          [BUGGY]  char  value  =  el.absUrl  (  attr.getKey  ())  ;  attr.setValue(value);    for  (Protocol  protocol  :  protocols)  {  String  prot  =  protocol.toString()  +   ": ";  if  (value.toString().toLowerCase().startsWith(prot))  {  return  true;  }  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  testValidProtocol  [RETURN_TYPE]  boolean      Element  el  Attribute  attr  Protocol>  protocols  [VARIABLES]  Set    attributeSet    currentSet    protSet    protocols    tagNames    boolean    Attribute    attr    Element    el    String    key    prot    protocol    tag    tagName    value    Protocol    protocol    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
String  value  =  el.absUrl  (  attr.getKey  (  )  )  ;	[BUGGY]  String  value  =  attr.absUrl(  el.getKey(  ));  [CONTEXT]  private  boolean  testValidProtocol(Element  el,  Attribute  attr,  Set<Protocol>  protocols)  {          [BUGGY]  String  value  =  attr.absUrl  (  el.getKey  ())  ;  attr.setValue(value);    for  (Protocol  protocol  :  protocols)  {  String  prot  =  protocol.toString()  +   ": ";  if  (value.toString().toLowerCase().startsWith(prot))  {  return  true;  }  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  testValidProtocol  [RETURN_TYPE]  boolean      Element  el  Attribute  attr  Protocol>  protocols  [VARIABLES]  Set    attributeSet    currentSet    protSet    protocols    tagNames    boolean    Attribute    attr    Element    el    String    key    prot    protocol    tag    tagName    value    Protocol    protocol    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
String  value  =  el.absUrl  (  attr.getKey  (  )  )  ;	[BUGGY]  String  value  =  el.absUrl(  attr.setValue(  ));  [CONTEXT]  private  boolean  testValidProtocol(Element  el,  Attribute  attr,  Set<Protocol>  protocols)  {          [BUGGY]  String  value  =  el.absUrl  (  attr.setValue  ())  ;  attr.setValue(value);    for  (Protocol  protocol  :  protocols)  {  String  prot  =  protocol.toString()  +   ": ";  if  (value.toString().toLowerCase().startsWith(prot))  {  return  true;  }  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  testValidProtocol  [RETURN_TYPE]  boolean      Element  el  Attribute  attr  Protocol>  protocols  [VARIABLES]  Set    attributeSet    currentSet    protSet    protocols    tagNames    boolean    Attribute    attr    Element    el    String    key    prot    protocol    tag    tagName    value    Protocol    protocol    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
String  value  =  el.absUrl  (  attr.getKey  (  )  )  ;	[BUGGY]  String  value  =  el.absUrl(  attr  .setValue(  key)  );  [CONTEXT]  private  boolean  testValidProtocol(Element  el,  Attribute  attr,  Set<Protocol>  protocols)  {          [BUGGY]  String  value  =  el.absUrl  (  attr  .setValue  (  key  )  )  ;  attr.setValue(value);    for  (Protocol  protocol  :  protocols)  {  String  prot  =  protocol.toString()  +   ": ";  if  (value.toString().toLowerCase().startsWith(prot))  {  return  true;  }  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  testValidProtocol  [RETURN_TYPE]  boolean      Element  el  Attribute  attr  Protocol>  protocols  [VARIABLES]  Set    attributeSet    currentSet    protSet    protocols    tagNames    boolean    Attribute    attr    Element    el    String    key    prot    protocol    tag    tagName    value    Protocol    protocol    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
String  value  =  el.absUrl  (  attr.getKey  (  )  )  ;	[BUGGY]  AttributeKey  key  =  AttributeKey.valueOf(  attr.getKey(  ));String  value  =  el.absUrl(  attr.getKey(  ));  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  testValidProtocol  [RETURN_TYPE]  boolean      Element  el  Attribute  attr  Protocol>  protocols  [VARIABLES]  Set    attributeSet    currentSet    protSet    protocols    tagNames    boolean    Attribute    attr    Element    el    String    key    prot    protocol    tag    tagName    value    Protocol    protocol    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
String  value  =  el.absUrl  (  attr.getKey  (  )  )  ;  attr.setValue  (  value  )  ;	[BUGGY]    [CONTEXT]  private  boolean  testValidProtocol(Element  el,  Attribute  attr,  Set<Protocol>  protocols)  {          [BUGGY]  String  value  =  el.absUrl(attr.getKey());        for  (Protocol  protocol  :  protocols)  {  String  prot  =  protocol.toString()  +   ": ";  if  (value.toString().toLowerCase().startsWith(prot))  {  return  true;  }  }  return  false;        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  testValidProtocol  [RETURN_TYPE]  boolean      Element  el  Attribute  attr  Protocol>  protocols  [VARIABLES]  Set    attributeSet    currentSet    protSet    protocols    tagNames    boolean    Attribute    attr    Element    el    String    key    prot    protocol    tag    tagName    value    Protocol    protocol    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
String  value  =  el.absUrl  (  attr.getKey  (  )  )  ;  attr.setValue  (  value  )  ;	[BUGGY]  attr.setValue(  value);  String  value  =  el.absUrl(  attr.getKey(  ));  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  testValidProtocol  [RETURN_TYPE]  boolean      Element  el  Attribute  attr  Protocol>  protocols  [VARIABLES]  Set    attributeSet    currentSet    protSet    protocols    tagNames    boolean    Attribute    attr    Element    el    String    key    prot    protocol    tag    tagName    value    Protocol    protocol    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
String  value  =  el.absUrl  (  attr.getKey  (  )  )  ;  attr.setValue  (  value  )  ;	[BUGGY]  String  value  =  el.absUrl(  attr.getKey(  ));String  value  =  el.absUrl(  attr.getKey(  ));  attr.setValue(  value);  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  testValidProtocol  [RETURN_TYPE]  boolean      Element  el  Attribute  attr  Protocol>  protocols  [VARIABLES]  Set    attributeSet    currentSet    protSet    protocols    tagNames    boolean    Attribute    attr    Element    el    String    key    prot    protocol    tag    tagName    value    Protocol    protocol    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
String  value  =  el.absUrl  (  attr.getKey  (  )  )  ;	[BUGGY]    [CONTEXT]  private  boolean  testValidProtocol(Element  el,  Attribute  attr,  Set<Protocol>  protocols)  {          [BUGGY]  String  value  =  el.absUrl(attr.getKey());    attr.setValue(value);    for  (Protocol  protocol  :  protocols)  {  String  prot  =  protocol.toString()  +   ": ";  if  (value.toString().toLowerCase().startsWith(prot))  {  return  true;  }  }  return  false;        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  testValidProtocol  [RETURN_TYPE]  boolean      Element  el  Attribute  attr  Protocol>  protocols  [VARIABLES]  Set    attributeSet    currentSet    protSet    protocols    tagNames    boolean    Attribute    attr    Element    el    String    key    prot    protocol    tag    tagName    value    Protocol    protocol    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
attr.setValue  (  value  )  ;	[BUGGY]  attr.setValue(  tag);  [CONTEXT]  private  boolean  testValidProtocol(Element  el,  Attribute  attr,  Set<Protocol>  protocols)  {          String  value  =  el.absUrl(attr.getKey());  [BUGGY]  attr.setValue  (  tag  )  ;    for  (Protocol  protocol  :  protocols)  {  String  prot  =  protocol.toString()  +   ": ";  if  (value.toString().toLowerCase().startsWith(prot))  {  return  true;  }  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  testValidProtocol  [RETURN_TYPE]  boolean      Element  el  Attribute  attr  Protocol>  protocols  [VARIABLES]  Set    attributeSet    currentSet    protSet    protocols    tagNames    boolean    Attribute    attr    Element    el    String    key    prot    protocol    tag    tagName    value    Protocol    protocol    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
attr.setValue  (  value  )  ;	[BUGGY]  attr.setValue(  tagName);  [CONTEXT]  private  boolean  testValidProtocol(Element  el,  Attribute  attr,  Set<Protocol>  protocols)  {          String  value  =  el.absUrl(attr.getKey());  [BUGGY]  attr.setValue  (  tagName  )  ;    for  (Protocol  protocol  :  protocols)  {  String  prot  =  protocol.toString()  +   ": ";  if  (value.toString().toLowerCase().startsWith(prot))  {  return  true;  }  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  testValidProtocol  [RETURN_TYPE]  boolean      Element  el  Attribute  attr  Protocol>  protocols  [VARIABLES]  Set    attributeSet    currentSet    protSet    protocols    tagNames    boolean    Attribute    attr    Element    el    String    key    prot    protocol    tag    tagName    value    Protocol    protocol    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
attr.setValue  (  value  )  ;	[BUGGY]    [CONTEXT]  private  boolean  testValidProtocol(Element  el,  Attribute  attr,  Set<Protocol>  protocols)  {          String  value  =  el.absUrl(attr.getKey());  [BUGGY]  attr.setValue(value);      for  (Protocol  protocol  :  protocols)  {  String  prot  =  protocol.toString()  +   ": ";  if  (value.toString().toLowerCase().startsWith(prot))  {  return  true;  }  }  return  false;        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  testValidProtocol  [RETURN_TYPE]  boolean      Element  el  Attribute  attr  Protocol>  protocols  [VARIABLES]  Set    attributeSet    currentSet    protSet    protocols    tagNames    boolean    Attribute    attr    Element    el    String    key    prot    protocol    tag    tagName    value    Protocol    protocol    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
if  (  value.toString  (  )  .toLowerCase  (  )  .startsWith  (  prot  )  )  {	[BUGGY]  if  (  value.tochar(  ).toLowerCase(  ).startsWith(  prot))  {  [CONTEXT]  private  boolean  testValidProtocol(Element  el,  Attribute  attr,  Set<Protocol>  protocols)  {          String  value  =  el.absUrl(attr.getKey());  attr.setValue(value);    for  (Protocol  protocol  :  protocols)  {  String  prot  =  protocol.toString()  +   ": ";  [BUGGY]  if(  value.tochar  ()  .toLowerCase  ()  .startsWith  (  prot  )){  return  true;  }  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  testValidProtocol  [RETURN_TYPE]  boolean      Element  el  Attribute  attr  Protocol>  protocols  [VARIABLES]  Set    attributeSet    currentSet    protSet    protocols    tagNames    boolean    Attribute    attr    Element    el    String    key    prot    protocol    tag    tagName    value    Protocol    protocol    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
if  (  value.toString  (  )  .toLowerCase  (  )  .startsWith  (  prot  )  )  {	[BUGGY]  if  (  tagName.toString(  ).toLowerCase(  ).startsWith(  prot))  {  [CONTEXT]  private  boolean  testValidProtocol(Element  el,  Attribute  attr,  Set<Protocol>  protocols)  {          String  value  =  el.absUrl(attr.getKey());  attr.setValue(value);    for  (Protocol  protocol  :  protocols)  {  String  prot  =  protocol.toString()  +   ": ";  [BUGGY]  if(  tagName.toString  ()  .toLowerCase  ()  .startsWith  (  prot  )){  return  true;  }  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  testValidProtocol  [RETURN_TYPE]  boolean      Element  el  Attribute  attr  Protocol>  protocols  [VARIABLES]  Set    attributeSet    currentSet    protSet    protocols    tagNames    boolean    Attribute    attr    Element    el    String    key    prot    protocol    tag    tagName    value    Protocol    protocol    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
if  (  value.toString  (  )  .toLowerCase  (  )  .startsWith  (  prot  )  )  {	[BUGGY]  if  (  value.toString(  ).toLowerCase(  ).startsWith(  tagName))  {  [CONTEXT]  private  boolean  testValidProtocol(Element  el,  Attribute  attr,  Set<Protocol>  protocols)  {          String  value  =  el.absUrl(attr.getKey());  attr.setValue(value);    for  (Protocol  protocol  :  protocols)  {  String  prot  =  protocol.toString()  +   ": ";  [BUGGY]  if(  value.toString  ()  .toLowerCase  ()  .startsWith  (  tagName  )){  return  true;  }  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  testValidProtocol  [RETURN_TYPE]  boolean      Element  el  Attribute  attr  Protocol>  protocols  [VARIABLES]  Set    attributeSet    currentSet    protSet    protocols    tagNames    boolean    Attribute    attr    Element    el    String    key    prot    protocol    tag    tagName    value    Protocol    protocol    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
if  (  value.toString  (  )  .toLowerCase  (  )  .startsWith  (  prot  )  )  {	[BUGGY]  if  (  prot.toString(  ).toLowerCase(  ).startsWith(  value))  {  [CONTEXT]  private  boolean  testValidProtocol(Element  el,  Attribute  attr,  Set<Protocol>  protocols)  {          String  value  =  el.absUrl(attr.getKey());  attr.setValue(value);    for  (Protocol  protocol  :  protocols)  {  String  prot  =  protocol.toString()  +   ": ";  [BUGGY]  if(  prot.toString  ()  .toLowerCase  ()  .startsWith  (  value  )){  return  true;  }  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  testValidProtocol  [RETURN_TYPE]  boolean      Element  el  Attribute  attr  Protocol>  protocols  [VARIABLES]  Set    attributeSet    currentSet    protSet    protocols    tagNames    boolean    Attribute    attr    Element    el    String    key    prot    protocol    tag    tagName    value    Protocol    protocol    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
if  (  value.toString  (  )  .toLowerCase  (  )  .startsWith  (  prot  )  )  {	[BUGGY]  if  (  value.toString(  ).toLowerCase(  ).addAttributes(  prot))  {  [CONTEXT]  private  boolean  testValidProtocol(Element  el,  Attribute  attr,  Set<Protocol>  protocols)  {          String  value  =  el.absUrl(attr.getKey());  attr.setValue(value);    for  (Protocol  protocol  :  protocols)  {  String  prot  =  protocol.toString()  +   ": ";  [BUGGY]  if(  value.toString  ()  .toLowerCase  ()  .addAttributes  (  prot  )){  return  true;  }  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  testValidProtocol  [RETURN_TYPE]  boolean      Element  el  Attribute  attr  Protocol>  protocols  [VARIABLES]  Set    attributeSet    currentSet    protSet    protocols    tagNames    boolean    Attribute    attr    Element    el    String    key    prot    protocol    tag    tagName    value    Protocol    protocol    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
if  (  value.toString  (  )  .toLowerCase  (  )  .startsWith  (  prot  )  )  {	[BUGGY]  if  (  value.toString(  ).startsWith(  ).startsWith(  prot))  {  [CONTEXT]  private  boolean  testValidProtocol(Element  el,  Attribute  attr,  Set<Protocol>  protocols)  {          String  value  =  el.absUrl(attr.getKey());  attr.setValue(value);    for  (Protocol  protocol  :  protocols)  {  String  prot  =  protocol.toString()  +   ": ";  [BUGGY]  if(  value.toString  ()  .startsWith  ()  .startsWith  (  prot  )){  return  true;  }  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  testValidProtocol  [RETURN_TYPE]  boolean      Element  el  Attribute  attr  Protocol>  protocols  [VARIABLES]  Set    attributeSet    currentSet    protSet    protocols    tagNames    boolean    Attribute    attr    Element    el    String    key    prot    protocol    tag    tagName    value    Protocol    protocol    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
if  (  value.toString  (  )  .toLowerCase  (  )  .startsWith  (  prot  )  )  {  return  true;  }	[BUGGY]  return  true;  [CONTEXT]  private  boolean  testValidProtocol(Element  el,  Attribute  attr,  Set<Protocol>  protocols)  {          String  value  =  el.absUrl(attr.getKey());  attr.setValue(value);    for  (Protocol  protocol  :  protocols)  {  String  prot  =  protocol.toString()  +   ": ";  [BUGGY]  if  (value.toString().toLowerCase().startsWith(prot))  {    return  true;    }  return  false;        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  testValidProtocol  [RETURN_TYPE]  boolean      Element  el  Attribute  attr  Protocol>  protocols  [VARIABLES]  Set    attributeSet    currentSet    protSet    protocols    tagNames    boolean    Attribute    attr    Element    el    String    key    prot    protocol    tag    tagName    value    Protocol    protocol    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
if  (  value.toString  (  )  .toLowerCase  (  )  .startsWith  (  prot  )  )  {  return  true;  }	[BUGGY]    [CONTEXT]  private  boolean  testValidProtocol(Element  el,  Attribute  attr,  Set<Protocol>  protocols)  {          String  value  =  el.absUrl(attr.getKey());  attr.setValue(value);    for  (Protocol  protocol  :  protocols)  {  String  prot  =  protocol.toString()  +   ": ";  [BUGGY]  if  (value.toString().toLowerCase().startsWith(prot))  {        }  return  false;        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  testValidProtocol  [RETURN_TYPE]  boolean      Element  el  Attribute  attr  Protocol>  protocols  [VARIABLES]  Set    attributeSet    currentSet    protSet    protocols    tagNames    boolean    Attribute    attr    Element    el    String    key    prot    protocol    tag    tagName    value    Protocol    protocol    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
return  true;	[BUGGY]  return  false;  [CONTEXT]  private  boolean  testValidProtocol(Element  el,  Attribute  attr,  Set<Protocol>  protocols)  {          String  value  =  el.absUrl(attr.getKey());  attr.setValue(value);    for  (Protocol  protocol  :  protocols)  {  String  prot  =  protocol.toString()  +   ": ";  if  (value.toString().toLowerCase().startsWith(prot))  {  [BUGGY]  return  false;  }  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  testValidProtocol  [RETURN_TYPE]  boolean      Element  el  Attribute  attr  Protocol>  protocols  [VARIABLES]  Set    attributeSet    currentSet    protSet    protocols    tagNames    boolean    Attribute    attr    Element    el    String    key    prot    protocol    tag    tagName    value    Protocol    protocol    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
for  (  Protocol  protocol  :  protocols  )  {	[BUGGY]  Protocol  prot  =  Protocol.valueOf(  protocol);for  (  Protocol  protocol  :  protocols)  {  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  testValidProtocol  [RETURN_TYPE]  boolean      Element  el  Attribute  attr  Protocol>  protocols  [VARIABLES]  Set    attributeSet    currentSet    protSet    protocols    tagNames    boolean    Attribute    attr    Element    el    String    key    prot    protocol    tag    tagName    value    Protocol    protocol    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
String  prot  =  protocol.toString  (  )  +   ": ";	[BUGGY]  char  prot  =  protocol.tochar(  )  +   ": ";  [CONTEXT]  private  boolean  testValidProtocol(Element  el,  Attribute  attr,  Set<Protocol>  protocols)  {          String  value  =  el.absUrl(attr.getKey());  attr.setValue(value);    for  (Protocol  protocol  :  protocols)  {  [BUGGY]  char  prot  =  protocol.tochar  ()+   ": ";  if  (value.toString().toLowerCase().startsWith(prot))  {  return  true;  }  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  testValidProtocol  [RETURN_TYPE]  boolean      Element  el  Attribute  attr  Protocol>  protocols  [VARIABLES]  Set    attributeSet    currentSet    protSet    protocols    tagNames    boolean    Attribute    attr    Element    el    String    key    prot    protocol    tag    tagName    value    Protocol    protocol    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
String  prot  =  protocol.toString  (  )  +   ": ";	[BUGGY]  String  prot  =  protocol.toString(    >>  )  +   ": ";  [CONTEXT]  private  boolean  testValidProtocol(Element  el,  Attribute  attr,  Set<Protocol>  protocols)  {          String  value  =  el.absUrl(attr.getKey());  attr.setValue(value);    for  (Protocol  protocol  :  protocols)  {  [BUGGY]  String  prot  =  protocol.toString  (>>)+   ": ";  if  (value.toString().toLowerCase().startsWith(prot))  {  return  true;  }  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  testValidProtocol  [RETURN_TYPE]  boolean      Element  el  Attribute  attr  Protocol>  protocols  [VARIABLES]  Set    attributeSet    currentSet    protSet    protocols    tagNames    boolean    Attribute    attr    Element    el    String    key    prot    protocol    tag    tagName    value    Protocol    protocol    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
String  prot  =  protocol.toString  (  )  +   ": ";	[BUGGY]  String  prot  =  protocol.toString(  )  +   " ";  [CONTEXT]  private  boolean  testValidProtocol(Element  el,  Attribute  attr,  Set<Protocol>  protocols)  {          String  value  =  el.absUrl(attr.getKey());  attr.setValue(value);    for  (Protocol  protocol  :  protocols)  {  [BUGGY]  String  prot  =  protocol.toString  ()+   " ";  if  (value.toString().toLowerCase().startsWith(prot))  {  return  true;  }  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  testValidProtocol  [RETURN_TYPE]  boolean      Element  el  Attribute  attr  Protocol>  protocols  [VARIABLES]  Set    attributeSet    currentSet    protSet    protocols    tagNames    boolean    Attribute    attr    Element    el    String    key    prot    protocol    tag    tagName    value    Protocol    protocol    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
String  prot  =  protocol.toString  (  )  +   ": ";	[BUGGY]  String  prot  =  protocol.equals(  )  +   ": ";  [CONTEXT]  private  boolean  testValidProtocol(Element  el,  Attribute  attr,  Set<Protocol>  protocols)  {          String  value  =  el.absUrl(attr.getKey());  attr.setValue(value);    for  (Protocol  protocol  :  protocols)  {  [BUGGY]  String  prot  =  protocol.equals  ()+   ": ";  if  (value.toString().toLowerCase().startsWith(prot))  {  return  true;  }  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  testValidProtocol  [RETURN_TYPE]  boolean      Element  el  Attribute  attr  Protocol>  protocols  [VARIABLES]  Set    attributeSet    currentSet    protSet    protocols    tagNames    boolean    Attribute    attr    Element    el    String    key    prot    protocol    tag    tagName    value    Protocol    protocol    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
String  prot  =  protocol.toString  (  )  +   ": ";	[BUGGY]  String  prot  =  protocol  .TypedValue(  tag)    +   ": ";  [CONTEXT]  private  boolean  testValidProtocol(Element  el,  Attribute  attr,  Set<Protocol>  protocols)  {          String  value  =  el.absUrl(attr.getKey());  attr.setValue(value);    for  (Protocol  protocol  :  protocols)  {  [BUGGY]  String  prot  =  protocol  .TypedValue  (  tag  )  +   ": ";  if  (value.toString().toLowerCase().startsWith(prot))  {  return  true;  }  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  testValidProtocol  [RETURN_TYPE]  boolean      Element  el  Attribute  attr  Protocol>  protocols  [VARIABLES]  Set    attributeSet    currentSet    protSet    protocols    tagNames    boolean    Attribute    attr    Element    el    String    key    prot    protocol    tag    tagName    value    Protocol    protocol    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
String  prot  =  protocol.toString  (  )  +   ": ";	[BUGGY]    [CONTEXT]  private  boolean  testValidProtocol(Element  el,  Attribute  attr,  Set<Protocol>  protocols)  {          String  value  =  el.absUrl(attr.getKey());  attr.setValue(value);    for  (Protocol  protocol  :  protocols)  {  [BUGGY]  String  prot  =  protocol.toString()  +   ": ";    if  (value.toString().toLowerCase().startsWith(prot))  {  return  true;  }  }  return  false;        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  testValidProtocol  [RETURN_TYPE]  boolean      Element  el  Attribute  attr  Protocol>  protocols  [VARIABLES]  Set    attributeSet    currentSet    protSet    protocols    tagNames    boolean    Attribute    attr    Element    el    String    key    prot    protocol    tag    tagName    value    Protocol    protocol    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
[Delete]	[BUGGY]  if  (  value.toString(  ).toLowerCase(  ).startsWith(  prot))  {          return  true;  }  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  testValidProtocol  [RETURN_TYPE]  boolean      Element  el  Attribute  attr  Protocol>  protocols  [VARIABLES]  Set    attributeSet    currentSet    protSet    protocols    tagNames    boolean    Attribute    attr    Element    el    String    key    prot    protocol    tag    tagName    value    Protocol    protocol    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
if  (  value.toString  (  )  .toLowerCase  (  )  .startsWith  (  prot  )  )  {	[BUGGY]  if  (  value.toString(  )  .toString(  )  .startsWith(  prot))  {  [CONTEXT]  private  boolean  testValidProtocol(Element  el,  Attribute  attr,  Set<Protocol>  protocols)  {          String  value  =  el.absUrl(attr.getKey());  attr.setValue(value);    for  (Protocol  protocol  :  protocols)  {  String  prot  =  protocol.toString()  +   ": ";  [BUGGY]  if(  value.toString  ().toString  ().startsWith  (  prot  )){  return  true;  }  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  testValidProtocol  [RETURN_TYPE]  boolean      Element  el  Attribute  attr  Protocol>  protocols  [VARIABLES]  Set    attributeSet    currentSet    protSet    protocols    tagNames    boolean    Attribute    attr    Element    el    String    key    prot    protocol    tag    tagName    value    Protocol    protocol    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
if  (  value.toString  (  )  .toLowerCase  (  )  .startsWith  (  prot  )  )  {	[BUGGY]  if  (  tag.toString(  ).toLowerCase(  ).startsWith(  prot))  {  [CONTEXT]  private  boolean  testValidProtocol(Element  el,  Attribute  attr,  Set<Protocol>  protocols)  {          String  value  =  el.absUrl(attr.getKey());  attr.setValue(value);    for  (Protocol  protocol  :  protocols)  {  String  prot  =  protocol.toString()  +   ": ";  [BUGGY]  if(  tag.toString  ()  .toLowerCase  ()  .startsWith  (  prot  )){  return  true;  }  }  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  testValidProtocol  [RETURN_TYPE]  boolean      Element  el  Attribute  attr  Protocol>  protocols  [VARIABLES]  Set    attributeSet    currentSet    protSet    protocols    tagNames    boolean    Attribute    attr    Element    el    String    key    prot    protocol    tag    tagName    value    Protocol    protocol    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
return  false;	[BUGGY]  return  true;  [CONTEXT]  private  boolean  testValidProtocol(Element  el,  Attribute  attr,  Set<Protocol>  protocols)  {          String  value  =  el.absUrl(attr.getKey());  attr.setValue(value);    for  (Protocol  protocol  :  protocols)  {  String  prot  =  protocol.toString()  +   ": ";  if  (value.toString().toLowerCase().startsWith(prot))  {  return  true;  }  }  [BUGGY]  return  true;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  testValidProtocol  [RETURN_TYPE]  boolean      Element  el  Attribute  attr  Protocol>  protocols  [VARIABLES]  Set    attributeSet    currentSet    protSet    protocols    tagNames    boolean    Attribute    attr    Element    el    String    key    prot    protocol    tag    tagName    value    Protocol    protocol    Map    attrMap    attrProts    attributes    enforcedAttributes    protocols    
Attributes  attrs  =  new  Attributes  (  )  ;	[BUGGY]  if  (  enforcedAttributes.containsKey(  tag))  {  Attributes  attrs  =  new  Attributes(  );  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  getEnforcedAttributes  [RETURN_TYPE]  Attributes      String  tagName  [VARIABLES]  Entry    entry    Set    attributeSet    currentSet    protSet    protocols    tagNames    boolean    TagName    tag    Attributes    attrs    String    key    prot    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    
Attributes  attrs  =  new  Attributes  (  )  ;	[BUGGY]  AttributeKey  attrKey  =  AttributeKey.valueOf(  key);Attributes  attrs  =  new  Attributes(  );  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  getEnforcedAttributes  [RETURN_TYPE]  Attributes      String  tagName  [VARIABLES]  Entry    entry    Set    attributeSet    currentSet    protSet    protocols    tagNames    boolean    TagName    tag    Attributes    attrs    String    key    prot    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    
Attributes  attrs  =  new  Attributes  (  )  ;	[BUGGY]  Set<AttributeKey>  attributeSet  =  new  HashSet<AttributeKey>(  );Attributes  attrs  =  new  Attributes(  );  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  getEnforcedAttributes  [RETURN_TYPE]  Attributes      String  tagName  [VARIABLES]  Entry    entry    Set    attributeSet    currentSet    protSet    protocols    tagNames    boolean    TagName    tag    Attributes    attrs    String    key    prot    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    
Attributes  attrs  =  new  Attributes  (  )  ;	[BUGGY]  AttributeValue  attrVal  =  AttributeValue.valueOf(  value);Attributes  attrs  =  new  Attributes(  );  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  getEnforcedAttributes  [RETURN_TYPE]  Attributes      String  tagName  [VARIABLES]  Entry    entry    Set    attributeSet    currentSet    protSet    protocols    tagNames    boolean    TagName    tag    Attributes    attrs    String    key    prot    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    
TagName  tag  =  TagName.valueOf  (  tagName  )  ;	[BUGGY]  TagName  tag  =  TagName.valueOf(  value);  [CONTEXT]  Attributes  getEnforcedAttributes(String  tagName)  {  Attributes  attrs  =  new  Attributes();  [BUGGY]  TagName  tag  =  TagName.valueOf  (  value  )  ;  if  (enforcedAttributes.containsKey(tag))  {  Map<AttributeKey,  AttributeValue>  keyVals  =  enforcedAttributes.get(tag);  for  (Map.Entry<AttributeKey,  AttributeValue>  entry  :  keyVals.entrySet())  {  attrs.put(entry.getKey().toString(),  entry.getValue().toString());  }  }  return  attrs;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  getEnforcedAttributes  [RETURN_TYPE]  Attributes      String  tagName  [VARIABLES]  Entry    entry    Set    attributeSet    currentSet    protSet    protocols    tagNames    boolean    TagName    tag    Attributes    attrs    String    key    prot    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    
TagName  tag  =  TagName.valueOf  (  tagName  )  ;	[BUGGY]  TagName  tag  =  TagName.TagName(  tagName);  [CONTEXT]  Attributes  getEnforcedAttributes(String  tagName)  {  Attributes  attrs  =  new  Attributes();  [BUGGY]  TagName  tag  =  TagName.TagName  (  tagName  )  ;  if  (enforcedAttributes.containsKey(tag))  {  Map<AttributeKey,  AttributeValue>  keyVals  =  enforcedAttributes.get(tag);  for  (Map.Entry<AttributeKey,  AttributeValue>  entry  :  keyVals.entrySet())  {  attrs.put(entry.getKey().toString(),  entry.getValue().toString());  }  }  return  attrs;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  getEnforcedAttributes  [RETURN_TYPE]  Attributes      String  tagName  [VARIABLES]  Entry    entry    Set    attributeSet    currentSet    protSet    protocols    tagNames    boolean    TagName    tag    Attributes    attrs    String    key    prot    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    
TagName  tag  =  TagName.valueOf  (  tagName  )  ;	[BUGGY]  TagName  tag  =  TagName  .TagName(  tag)  ;  [CONTEXT]  Attributes  getEnforcedAttributes(String  tagName)  {  Attributes  attrs  =  new  Attributes();  [BUGGY]  TagName  tag  =  TagName  .TagName  (  tag  );  if  (enforcedAttributes.containsKey(tag))  {  Map<AttributeKey,  AttributeValue>  keyVals  =  enforcedAttributes.get(tag);  for  (Map.Entry<AttributeKey,  AttributeValue>  entry  :  keyVals.entrySet())  {  attrs.put(entry.getKey().toString(),  entry.getValue().toString());  }  }  return  attrs;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  getEnforcedAttributes  [RETURN_TYPE]  Attributes      String  tagName  [VARIABLES]  Entry    entry    Set    attributeSet    currentSet    protSet    protocols    tagNames    boolean    TagName    tag    Attributes    attrs    String    key    prot    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    
TagName  tag  =  TagName.valueOf  (  tagName  )  ;	[BUGGY]    [CONTEXT]  Attributes  getEnforcedAttributes(String  tagName)  {  Attributes  attrs  =  new  Attributes();  [BUGGY]  TagName  tag  =  TagName.valueOf(tagName);    if  (enforcedAttributes.containsKey(tag))  {  Map<AttributeKey,  AttributeValue>  keyVals  =  enforcedAttributes.get(tag);  for  (Map.Entry<AttributeKey,  AttributeValue>  entry  :  keyVals.entrySet())  {  attrs.put(entry.getKey().toString(),  entry.getValue().toString());  }  }  return  attrs;        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  getEnforcedAttributes  [RETURN_TYPE]  Attributes      String  tagName  [VARIABLES]  Entry    entry    Set    attributeSet    currentSet    protSet    protocols    tagNames    boolean    TagName    tag    Attributes    attrs    String    key    prot    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    
if  (  enforcedAttributes.containsKey  (  tag  )  )  {	[BUGGY]  if  (  enforcedAttributes  .entrySet(  )  )  {  [CONTEXT]  Attributes  getEnforcedAttributes(String  tagName)  {  Attributes  attrs  =  new  Attributes();  TagName  tag  =  TagName.valueOf(tagName);  [BUGGY]  if(  enforcedAttributes  .entrySet  ()  ){  Map<AttributeKey,  AttributeValue>  keyVals  =  enforcedAttributes.get(tag);  for  (Map.Entry<AttributeKey,  AttributeValue>  entry  :  keyVals.entrySet())  {  attrs.put(entry.getKey().toString(),  entry.getValue().toString());  }  }  return  attrs;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  getEnforcedAttributes  [RETURN_TYPE]  Attributes      String  tagName  [VARIABLES]  Entry    entry    Set    attributeSet    currentSet    protSet    protocols    tagNames    boolean    TagName    tag    Attributes    attrs    String    key    prot    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    
if  (  enforcedAttributes.containsKey  (  tag  )  )  {	[BUGGY]  if  (  enforcedAttributes.containsKey(  tagName))  {  [CONTEXT]  Attributes  getEnforcedAttributes(String  tagName)  {  Attributes  attrs  =  new  Attributes();  TagName  tag  =  TagName.valueOf(tagName);  [BUGGY]  if(  enforcedAttributes.containsKey  (  tagName  )){  Map<AttributeKey,  AttributeValue>  keyVals  =  enforcedAttributes.get(tag);  for  (Map.Entry<AttributeKey,  AttributeValue>  entry  :  keyVals.entrySet())  {  attrs.put(entry.getKey().toString(),  entry.getValue().toString());  }  }  return  attrs;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  getEnforcedAttributes  [RETURN_TYPE]  Attributes      String  tagName  [VARIABLES]  Entry    entry    Set    attributeSet    currentSet    protSet    protocols    tagNames    boolean    TagName    tag    Attributes    attrs    String    key    prot    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    
if  (  enforcedAttributes.containsKey  (  tag  )  )  {	[BUGGY]  if  (  attributes.containsKey(  tag))  {  [CONTEXT]  Attributes  getEnforcedAttributes(String  tagName)  {  Attributes  attrs  =  new  Attributes();  TagName  tag  =  TagName.valueOf(tagName);  [BUGGY]  if(  attributes.containsKey  (  tag  )){  Map<AttributeKey,  AttributeValue>  keyVals  =  enforcedAttributes.get(tag);  for  (Map.Entry<AttributeKey,  AttributeValue>  entry  :  keyVals.entrySet())  {  attrs.put(entry.getKey().toString(),  entry.getValue().toString());  }  }  return  attrs;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  getEnforcedAttributes  [RETURN_TYPE]  Attributes      String  tagName  [VARIABLES]  Entry    entry    Set    attributeSet    currentSet    protSet    protocols    tagNames    boolean    TagName    tag    Attributes    attrs    String    key    prot    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    
if  (  enforcedAttributes.containsKey  (  tag  )  )  {	[BUGGY]  if  (  attributes.containsKey(  tagName))  {  [CONTEXT]  Attributes  getEnforcedAttributes(String  tagName)  {  Attributes  attrs  =  new  Attributes();  TagName  tag  =  TagName.valueOf(tagName);  [BUGGY]  if(  attributes.containsKey  (  tagName  )){  Map<AttributeKey,  AttributeValue>  keyVals  =  enforcedAttributes.get(tag);  for  (Map.Entry<AttributeKey,  AttributeValue>  entry  :  keyVals.entrySet())  {  attrs.put(entry.getKey().toString(),  entry.getValue().toString());  }  }  return  attrs;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  getEnforcedAttributes  [RETURN_TYPE]  Attributes      String  tagName  [VARIABLES]  Entry    entry    Set    attributeSet    currentSet    protSet    protocols    tagNames    boolean    TagName    tag    Attributes    attrs    String    key    prot    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    
if  (  enforcedAttributes.containsKey  (  tag  )  )  {	[BUGGY]  if  (  protocols.containsKey(  tag))  {  [CONTEXT]  Attributes  getEnforcedAttributes(String  tagName)  {  Attributes  attrs  =  new  Attributes();  TagName  tag  =  TagName.valueOf(tagName);  [BUGGY]  if(  protocols.containsKey  (  tag  )){  Map<AttributeKey,  AttributeValue>  keyVals  =  enforcedAttributes.get(tag);  for  (Map.Entry<AttributeKey,  AttributeValue>  entry  :  keyVals.entrySet())  {  attrs.put(entry.getKey().toString(),  entry.getValue().toString());  }  }  return  attrs;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  getEnforcedAttributes  [RETURN_TYPE]  Attributes      String  tagName  [VARIABLES]  Entry    entry    Set    attributeSet    currentSet    protSet    protocols    tagNames    boolean    TagName    tag    Attributes    attrs    String    key    prot    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    
if  (  enforcedAttributes.containsKey  (  tag  )  )  {  Map<AttributeKey,  AttributeValue>  keyVals  =  enforcedAttributes.get  (  tag  )  ;  for  (  Map.Entry<AttributeKey,  AttributeValue>  entry  :  keyVals.entrySet  (  )  )  {  attrs.put  (  entry.getKey  (  )  .toString  (  )  ,  entry.getValue  (  )  .toString  (  )  )  ;  }	[BUGGY]  java.util.Map<org.jsoup.safety.Whitelist.AttributeKey,  org.jsoup.safety.Whitelist.AttributeValue>  keyVals  =  enforcedAttributes.get(tag);  for(java.util.Map.Entry<org.jsoup.safety.Whitelist.AttributeKey,  org.jsoup.safety.Whitelist.AttributeValue>  entry  :  keyVals.entrySet())  {        attrs.put(entry.getKey().toString(),  entry.getValue().toString());};  [CONTEXT]  Attributes  getEnforcedAttributes(String  tagName)  {  Attributes  attrs  =  new  Attributes();  TagName  tag  =  TagName.valueOf(tagName);  [BUGGY]  if  (enforcedAttributes.containsKey(tag))  {    java.util.Map<org.jsoup.safety.Whitelist.AttributeKey,  org.jsoup.safety.Whitelist.AttributeValue>  keyVals  =  enforcedAttributes.get(tag);  for  (java.util.Map.Entry<org.jsoup.safety.Whitelist.AttributeKey,  org.jsoup.safety.Whitelist.AttributeValue>  entry  :  keyVals.entrySet())  {attrs.put(entry.getKey().toString(),  entry.getValue().toString());};        }  return  attrs;        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  getEnforcedAttributes  [RETURN_TYPE]  Attributes      String  tagName  [VARIABLES]  Entry    entry    Set    attributeSet    currentSet    protSet    protocols    tagNames    boolean    TagName    tag    Attributes    attrs    String    key    prot    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    
if  (  enforcedAttributes.containsKey  (  tag  )  )  {  Map<AttributeKey,  AttributeValue>  keyVals  =  enforcedAttributes.get  (  tag  )  ;  for  (  Map.Entry<AttributeKey,  AttributeValue>  entry  :  keyVals.entrySet  (  )  )  {  attrs.put  (  entry.getKey  (  )  .toString  (  )  ,  entry.getValue  (  )  .toString  (  )  )  ;  }	[BUGGY]    [CONTEXT]  Attributes  getEnforcedAttributes(String  tagName)  {  Attributes  attrs  =  new  Attributes();  TagName  tag  =  TagName.valueOf(tagName);  [BUGGY]  if  (enforcedAttributes.containsKey(tag))  {            }  return  attrs;        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  getEnforcedAttributes  [RETURN_TYPE]  Attributes      String  tagName  [VARIABLES]  Entry    entry    Set    attributeSet    currentSet    protSet    protocols    tagNames    boolean    TagName    tag    Attributes    attrs    String    key    prot    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    
[Delete]	[BUGGY]  if  (  enforcedAttributes.containsKey(  tagName))  {          enforcedAttributes.get(  tagName).put(  attrKey,  attrVal);  }else  {          AttributeKey,  AttributeValue>  attrMap  =  new  AttributeKey,  AttributeValue>(  );          attrMap.put(  attrKey,  attrVal);          enforcedAttributes.put(  tagName,  attrMap);  }  [CONTEXT]        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  getEnforcedAttributes  [RETURN_TYPE]  Attributes      String  tagName  [VARIABLES]  Entry    entry    Set    attributeSet    currentSet    protSet    protocols    tagNames    boolean    TagName    tag    Attributes    attrs    String    key    prot    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    
Map<AttributeKey,  AttributeValue>  keyVals  =  enforcedAttributes.get  (  tag  )  ;	[BUGGY]  Map<AttributeKey,  AttributeValue>  keyVals  =  tag.get(  enforcedAttributes);  [CONTEXT]  Attributes  getEnforcedAttributes(String  tagName)  {  Attributes  attrs  =  new  Attributes();  TagName  tag  =  TagName.valueOf(tagName);  if  (enforcedAttributes.containsKey(tag))  {  [BUGGY]  Map<AttributeKey,  AttributeValue>  keyVals  =  tag.get  (  enforcedAttributes  )  ;  for  (Map.Entry<AttributeKey,  AttributeValue>  entry  :  keyVals.entrySet())  {  attrs.put(entry.getKey().toString(),  entry.getValue().toString());  }  }  return  attrs;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  getEnforcedAttributes  [RETURN_TYPE]  Attributes      String  tagName  [VARIABLES]  Entry    entry    Set    attributeSet    currentSet    protSet    protocols    tagNames    boolean    TagName    tag    Attributes    attrs    String    key    prot    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    
Map<AttributeKey,  AttributeValue>  keyVals  =  enforcedAttributes.get  (  tag  )  ;	[BUGGY]  Map<AttributeKey,  AttributeValue>  keyVals  =  enforcedAttributes.containsKey(  tag);  [CONTEXT]  Attributes  getEnforcedAttributes(String  tagName)  {  Attributes  attrs  =  new  Attributes();  TagName  tag  =  TagName.valueOf(tagName);  if  (enforcedAttributes.containsKey(tag))  {  [BUGGY]  Map<AttributeKey,  AttributeValue>  keyVals  =  enforcedAttributes.containsKey  (  tag  )  ;  for  (Map.Entry<AttributeKey,  AttributeValue>  entry  :  keyVals.entrySet())  {  attrs.put(entry.getKey().toString(),  entry.getValue().toString());  }  }  return  attrs;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  getEnforcedAttributes  [RETURN_TYPE]  Attributes      String  tagName  [VARIABLES]  Entry    entry    Set    attributeSet    currentSet    protSet    protocols    tagNames    boolean    TagName    tag    Attributes    attrs    String    key    prot    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    
Map<AttributeKey,  AttributeValue>  keyVals  =  enforcedAttributes.get  (  tag  )  ;	[BUGGY]  Map<AttributeKey,  AttributeValue>  keyVals  =  2.get(  tag);  [CONTEXT]  Attributes  getEnforcedAttributes(String  tagName)  {  Attributes  attrs  =  new  Attributes();  TagName  tag  =  TagName.valueOf(tagName);  if  (enforcedAttributes.containsKey(tag))  {  [BUGGY]  Map<AttributeKey,  AttributeValue>  keyVals  =  2.get  (  tag  )  ;  for  (Map.Entry<AttributeKey,  AttributeValue>  entry  :  keyVals.entrySet())  {  attrs.put(entry.getKey().toString(),  entry.getValue().toString());  }  }  return  attrs;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  getEnforcedAttributes  [RETURN_TYPE]  Attributes      String  tagName  [VARIABLES]  Entry    entry    Set    attributeSet    currentSet    protSet    protocols    tagNames    boolean    TagName    tag    Attributes    attrs    String    key    prot    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    
Map<AttributeKey,  AttributeValue>  keyVals  =  enforcedAttributes.get  (  tag  )  ;  for  (  Map.Entry<AttributeKey,  AttributeValue>  entry  :  keyVals.entrySet  (  )  )  {  attrs.put  (  entry.getKey  (  )  .toString  (  )  ,  entry.getValue  (  )  .toString  (  )  )  ;  }	[BUGGY]    [CONTEXT]  Attributes  getEnforcedAttributes(String  tagName)  {  Attributes  attrs  =  new  Attributes();  TagName  tag  =  TagName.valueOf(tagName);  if  (enforcedAttributes.containsKey(tag))  {  [BUGGY]  Map<AttributeKey,  AttributeValue>  keyVals  =  enforcedAttributes.get(tag);          }  return  attrs;        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  getEnforcedAttributes  [RETURN_TYPE]  Attributes      String  tagName  [VARIABLES]  Entry    entry    Set    attributeSet    currentSet    protSet    protocols    tagNames    boolean    TagName    tag    Attributes    attrs    String    key    prot    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    
for  (  Map.Entry<AttributeKey,  AttributeValue>  entry  :  keyVals.entrySet  (  )  )  {	[BUGGY]  for  (  Map.Entry<AttributeKey,  AttributeValue>  entry  :  keyVals.get(  ))  {  [CONTEXT]  Attributes  getEnforcedAttributes(String  tagName)  {  Attributes  attrs  =  new  Attributes();  TagName  tag  =  TagName.valueOf(tagName);  if  (enforcedAttributes.containsKey(tag))  {  Map<AttributeKey,  AttributeValue>  keyVals  =  enforcedAttributes.get(tag);  [BUGGY]  for(  Map.Entry<AttributeKey,  AttributeValue>  entry  :  keyVals.get  ()){  attrs.put(entry.getKey().toString(),  entry.getValue().toString());  }  }  return  attrs;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  getEnforcedAttributes  [RETURN_TYPE]  Attributes      String  tagName  [VARIABLES]  Entry    entry    Set    attributeSet    currentSet    protSet    protocols    tagNames    boolean    TagName    tag    Attributes    attrs    String    key    prot    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    
for  (  Map.Entry<AttributeKey,  AttributeValue>  entry  :  keyVals.entrySet  (  )  )  {  attrs.put  (  entry.getKey  (  )  .toString  (  )  ,  entry.getValue  (  )  .toString  (  )  )  ;  }	[BUGGY]    [CONTEXT]  Attributes  getEnforcedAttributes(String  tagName)  {  Attributes  attrs  =  new  Attributes();  TagName  tag  =  TagName.valueOf(tagName);  if  (enforcedAttributes.containsKey(tag))  {  Map<AttributeKey,  AttributeValue>  keyVals  =  enforcedAttributes.get(tag);  [BUGGY]  for  (Map.Entry<AttributeKey,  AttributeValue>  entry  :  keyVals.entrySet())  {        }  return  attrs;        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  getEnforcedAttributes  [RETURN_TYPE]  Attributes      String  tagName  [VARIABLES]  Entry    entry    Set    attributeSet    currentSet    protSet    protocols    tagNames    boolean    TagName    tag    Attributes    attrs    String    key    prot    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    
attrs.put  (  entry.getKey  (  )  .toString  (  )  ,  entry.getValue  (  )  .toString  (  )  )  ;	[BUGGY]  attrs.put(  entry.getKey(  ).startsWith(  ),  entry.getValue(  ).toString(  ));  [CONTEXT]  Attributes  getEnforcedAttributes(String  tagName)  {  Attributes  attrs  =  new  Attributes();  TagName  tag  =  TagName.valueOf(tagName);  if  (enforcedAttributes.containsKey(tag))  {  Map<AttributeKey,  AttributeValue>  keyVals  =  enforcedAttributes.get(tag);  for  (Map.Entry<AttributeKey,  AttributeValue>  entry  :  keyVals.entrySet())  {  [BUGGY]  attrs.put  (  entry.getKey  ()  .startsWith  ()  ,  entry.getValue  ()  .toString  ())  ;  }  }  return  attrs;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  getEnforcedAttributes  [RETURN_TYPE]  Attributes      String  tagName  [VARIABLES]  Entry    entry    Set    attributeSet    currentSet    protSet    protocols    tagNames    boolean    TagName    tag    Attributes    attrs    String    key    prot    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    
attrs.put  (  entry.getKey  (  )  .toString  (  )  ,  entry.getValue  (  )  .toString  (  )  )  ;	[BUGGY]  attrs.put(  entry  .setValue(  tagName)  .toString(  ),  entry.getValue(  ).toString(  ));  [CONTEXT]  Attributes  getEnforcedAttributes(String  tagName)  {  Attributes  attrs  =  new  Attributes();  TagName  tag  =  TagName.valueOf(tagName);  if  (enforcedAttributes.containsKey(tag))  {  Map<AttributeKey,  AttributeValue>  keyVals  =  enforcedAttributes.get(tag);  for  (Map.Entry<AttributeKey,  AttributeValue>  entry  :  keyVals.entrySet())  {  [BUGGY]  attrs.put  (  entry  .setValue  (  tagName  ).toString  ()  ,  entry.getValue  ()  .toString  ())  ;  }  }  return  attrs;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  getEnforcedAttributes  [RETURN_TYPE]  Attributes      String  tagName  [VARIABLES]  Entry    entry    Set    attributeSet    currentSet    protSet    protocols    tagNames    boolean    TagName    tag    Attributes    attrs    String    key    prot    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    
attrs.put  (  entry.getKey  (  )  .toString  (  )  ,  entry.getValue  (  )  .toString  (  )  )  ;	[BUGGY]  attrs.put(  entry.getKey(  ).toString(  ),  entry  .getKey(  )  .toString(  ));  [CONTEXT]  Attributes  getEnforcedAttributes(String  tagName)  {  Attributes  attrs  =  new  Attributes();  TagName  tag  =  TagName.valueOf(tagName);  if  (enforcedAttributes.containsKey(tag))  {  Map<AttributeKey,  AttributeValue>  keyVals  =  enforcedAttributes.get(tag);  for  (Map.Entry<AttributeKey,  AttributeValue>  entry  :  keyVals.entrySet())  {  [BUGGY]  attrs.put  (  entry.getKey  ()  .toString  ()  ,  entry  .getKey  ().toString  ())  ;  }  }  return  attrs;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  getEnforcedAttributes  [RETURN_TYPE]  Attributes      String  tagName  [VARIABLES]  Entry    entry    Set    attributeSet    currentSet    protSet    protocols    tagNames    boolean    TagName    tag    Attributes    attrs    String    key    prot    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    
attrs.put  (  entry.getKey  (  )  .toString  (  )  ,  entry.getValue  (  )  .toString  (  )  )  ;	[BUGGY]    [CONTEXT]  Attributes  getEnforcedAttributes(String  tagName)  {  Attributes  attrs  =  new  Attributes();  TagName  tag  =  TagName.valueOf(tagName);  if  (enforcedAttributes.containsKey(tag))  {  Map<AttributeKey,  AttributeValue>  keyVals  =  enforcedAttributes.get(tag);  for  (Map.Entry<AttributeKey,  AttributeValue>  entry  :  keyVals.entrySet())  {  [BUGGY]  attrs.put(entry.getKey().toString(),  entry.getValue().toString());    }  }  return  attrs;        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  getEnforcedAttributes  [RETURN_TYPE]  Attributes      String  tagName  [VARIABLES]  Entry    entry    Set    attributeSet    currentSet    protSet    protocols    tagNames    boolean    TagName    tag    Attributes    attrs    String    key    prot    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    
attrs.put  (  entry.getKey  (  )  .toString  (  )  ,  entry.getValue  (  )  .toString  (  )  )  ;	[BUGGY]  attrs.put(  entry  .setValue(  key)  .toString(  ),  entry.getValue(  ).toString(  ));  [CONTEXT]  Attributes  getEnforcedAttributes(String  tagName)  {  Attributes  attrs  =  new  Attributes();  TagName  tag  =  TagName.valueOf(tagName);  if  (enforcedAttributes.containsKey(tag))  {  Map<AttributeKey,  AttributeValue>  keyVals  =  enforcedAttributes.get(tag);  for  (Map.Entry<AttributeKey,  AttributeValue>  entry  :  keyVals.entrySet())  {  [BUGGY]  attrs.put  (  entry  .setValue  (  key  ).toString  ()  ,  entry.getValue  ()  .toString  ())  ;  }  }  return  attrs;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  getEnforcedAttributes  [RETURN_TYPE]  Attributes      String  tagName  [VARIABLES]  Entry    entry    Set    attributeSet    currentSet    protSet    protocols    tagNames    boolean    TagName    tag    Attributes    attrs    String    key    prot    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    
attrs.put  (  entry.getKey  (  )  .toString  (  )  ,  entry.getValue  (  )  .toString  (  )  )  ;	[BUGGY]  attrs.put(  entry  .setValue(  prot)  .toString(  ),  entry.getValue(  ).toString(  ));  [CONTEXT]  Attributes  getEnforcedAttributes(String  tagName)  {  Attributes  attrs  =  new  Attributes();  TagName  tag  =  TagName.valueOf(tagName);  if  (enforcedAttributes.containsKey(tag))  {  Map<AttributeKey,  AttributeValue>  keyVals  =  enforcedAttributes.get(tag);  for  (Map.Entry<AttributeKey,  AttributeValue>  entry  :  keyVals.entrySet())  {  [BUGGY]  attrs.put  (  entry  .setValue  (  prot  ).toString  ()  ,  entry.getValue  ()  .toString  ())  ;  }  }  return  attrs;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  getEnforcedAttributes  [RETURN_TYPE]  Attributes      String  tagName  [VARIABLES]  Entry    entry    Set    attributeSet    currentSet    protSet    protocols    tagNames    boolean    TagName    tag    Attributes    attrs    String    key    prot    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    
attrs.put  (  entry.getKey  (  )  .toString  (  )  ,  entry.getValue  (  )  .toString  (  )  )  ;	[BUGGY]  attrs.put(  entry.getKey(  )  .TypedValue(  tagName)  ,  entry.getValue()  [CONTEXT]  Attributes  getEnforcedAttributes(String  tagName)  {  Attributes  attrs  =  new  Attributes();  TagName  tag  =  TagName.valueOf(tagName);  if  (enforcedAttributes.containsKey(tag))  {  Map<AttributeKey,  AttributeValue>  keyVals  =  enforcedAttributes.get(tag);  for  (Map.Entry<AttributeKey,  AttributeValue>  entry  :  keyVals.entrySet())  {  [BUGGY]  attrs.put  (  entry.getKey  ().TypedValue  (  tagName  ),  entry.getValue  ()  }  }  return  attrs;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  getEnforcedAttributes  [RETURN_TYPE]  Attributes      String  tagName  [VARIABLES]  Entry    entry    Set    attributeSet    currentSet    protSet    protocols    tagNames    boolean    TagName    tag    Attributes    attrs    String    key    prot    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    
if  (  enforcedAttributes.containsKey  (  tag  )  )  {	[BUGGY]  if  (  tag.containsKey(  enforcedAttributes))  {  [CONTEXT]  Attributes  getEnforcedAttributes(String  tagName)  {  Attributes  attrs  =  new  Attributes();  TagName  tag  =  TagName.valueOf(tagName);  [BUGGY]  if(  tag.containsKey  (  enforcedAttributes  )){  Map<AttributeKey,  AttributeValue>  keyVals  =  enforcedAttributes.get(tag);  for  (Map.Entry<AttributeKey,  AttributeValue>  entry  :  keyVals.entrySet())  {  attrs.put(entry.getKey().toString(),  entry.getValue().toString());  }  }  return  attrs;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  getEnforcedAttributes  [RETURN_TYPE]  Attributes      String  tagName  [VARIABLES]  Entry    entry    Set    attributeSet    currentSet    protSet    protocols    tagNames    boolean    TagName    tag    Attributes    attrs    String    key    prot    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    
attrs.put  (  entry.getKey  (  )  .toString  (  )  ,  entry.getValue  (  )  .toString  (  )  )  ;	[BUGGY]  attrs.put(  entry.getKey(  )  .TypedValue(  protocol)  ,  entry.getValue()  [CONTEXT]  Attributes  getEnforcedAttributes(String  tagName)  {  Attributes  attrs  =  new  Attributes();  TagName  tag  =  TagName.valueOf(tagName);  if  (enforcedAttributes.containsKey(tag))  {  Map<AttributeKey,  AttributeValue>  keyVals  =  enforcedAttributes.get(tag);  for  (Map.Entry<AttributeKey,  AttributeValue>  entry  :  keyVals.entrySet())  {  [BUGGY]  attrs.put  (  entry.getKey  ().TypedValue  (  protocol  ),  entry.getValue  ()  }  }  return  attrs;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  getEnforcedAttributes  [RETURN_TYPE]  Attributes      String  tagName  [VARIABLES]  Entry    entry    Set    attributeSet    currentSet    protSet    protocols    tagNames    boolean    TagName    tag    Attributes    attrs    String    key    prot    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    
attrs.put  (  entry.getKey  (  )  .toString  (  )  ,  entry.getValue  (  )  .toString  (  )  )  ;	[BUGGY]  attrs.put(  entry  .setValue(  tag)  .toString(  ),  entry.getValue(  ).toString(  ));  [CONTEXT]  Attributes  getEnforcedAttributes(String  tagName)  {  Attributes  attrs  =  new  Attributes();  TagName  tag  =  TagName.valueOf(tagName);  if  (enforcedAttributes.containsKey(tag))  {  Map<AttributeKey,  AttributeValue>  keyVals  =  enforcedAttributes.get(tag);  for  (Map.Entry<AttributeKey,  AttributeValue>  entry  :  keyVals.entrySet())  {  [BUGGY]  attrs.put  (  entry  .setValue  (  tag  ).toString  ()  ,  entry.getValue  ()  .toString  ())  ;  }  }  return  attrs;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  getEnforcedAttributes  [RETURN_TYPE]  Attributes      String  tagName  [VARIABLES]  Entry    entry    Set    attributeSet    currentSet    protSet    protocols    tagNames    boolean    TagName    tag    Attributes    attrs    String    key    prot    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    
attrs.put  (  entry.getKey  (  )  .toString  (  )  ,  entry.getValue  (  )  .toString  (  )  )  ;	[BUGGY]  attrs.put(  entry  .setValue(  value)  .toString(  ),  entry.getValue(  ).toString(  ));  [CONTEXT]  Attributes  getEnforcedAttributes(String  tagName)  {  Attributes  attrs  =  new  Attributes();  TagName  tag  =  TagName.valueOf(tagName);  if  (enforcedAttributes.containsKey(tag))  {  Map<AttributeKey,  AttributeValue>  keyVals  =  enforcedAttributes.get(tag);  for  (Map.Entry<AttributeKey,  AttributeValue>  entry  :  keyVals.entrySet())  {  [BUGGY]  attrs.put  (  entry  .setValue  (  value  ).toString  ()  ,  entry.getValue  ()  .toString  ())  ;  }  }  return  attrs;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  getEnforcedAttributes  [RETURN_TYPE]  Attributes      String  tagName  [VARIABLES]  Entry    entry    Set    attributeSet    currentSet    protSet    protocols    tagNames    boolean    TagName    tag    Attributes    attrs    String    key    prot    protocol    tag    tagName    value    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    
return  new  TagName  (  value  )  ;	[BUGGY]  return  return    new  Protocol(  value)  ;  [CONTEXT]  static  TagName  valueOf(String  value)  {  [BUGGY]  return  returnnew  Protocol  (  value  );  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  valueOf  [RETURN_TYPE]  Whitelist$TagName      String  value  [VARIABLES]  Set    attributeSet    currentSet    protSet    protocols    tagNames    String    key    prot    protocol    tag    tagName    value    boolean    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    
return  new  TagName  (  value  )  ;	[BUGGY]  return  new  TagName(  tagName);  [CONTEXT]  static  TagName  valueOf(String  value)  {  [BUGGY]  return  new  TagName  (  tagName  )  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  valueOf  [RETURN_TYPE]  Whitelist$TagName      String  value  [VARIABLES]  Set    attributeSet    currentSet    protSet    protocols    tagNames    String    key    prot    protocol    tag    tagName    value    boolean    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    
return  new  TagName  (  value  )  ;	[BUGGY]  return    new  Protocol(  tag)  ;  [CONTEXT]  static  TagName  valueOf(String  value)  {  [BUGGY]  returnnew  Protocol  (  tag  );  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  valueOf  [RETURN_TYPE]  Whitelist$TagName      String  value  [VARIABLES]  Set    attributeSet    currentSet    protSet    protocols    tagNames    String    key    prot    protocol    tag    tagName    value    boolean    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    
return  new  AttributeKey  (  value  )  ;	[BUGGY]  return  return    new  Protocol(  value)  ;  [CONTEXT]  static  AttributeKey  valueOf(String  value)  {  [BUGGY]  return  returnnew  Protocol  (  value  );  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  valueOf  [RETURN_TYPE]  Whitelist$AttributeKey      String  value  [VARIABLES]  Set    attributeSet    currentSet    protSet    protocols    tagNames    String    key    prot    protocol    tag    tagName    value    boolean    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    
return  new  AttributeKey  (  value  )  ;	[BUGGY]  return  new  AttributeKey(  tagName);  [CONTEXT]  static  AttributeKey  valueOf(String  value)  {  [BUGGY]  return  new  AttributeKey  (  tagName  )  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  valueOf  [RETURN_TYPE]  Whitelist$AttributeKey      String  value  [VARIABLES]  Set    attributeSet    currentSet    protSet    protocols    tagNames    String    key    prot    protocol    tag    tagName    value    boolean    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    
return  new  AttributeKey  (  value  )  ;	[BUGGY]  return    new  Protocol(  value)  ;  [CONTEXT]  static  AttributeKey  valueOf(String  value)  {  [BUGGY]  returnnew  Protocol  (  value  );  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  valueOf  [RETURN_TYPE]  Whitelist$AttributeKey      String  value  [VARIABLES]  Set    attributeSet    currentSet    protSet    protocols    tagNames    String    key    prot    protocol    tag    tagName    value    boolean    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    
return  new  AttributeKey  (  value  )  ;	[BUGGY]  return  new  AttributeKey(  tag);  [CONTEXT]  static  AttributeKey  valueOf(String  value)  {  [BUGGY]  return  new  AttributeKey  (  tag  )  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  valueOf  [RETURN_TYPE]  Whitelist$AttributeKey      String  value  [VARIABLES]  Set    attributeSet    currentSet    protSet    protocols    tagNames    String    key    prot    protocol    tag    tagName    value    boolean    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    
return  new  AttributeValue  (  value  )  ;	[BUGGY]  return  return    new  Protocol(  value)  ;  [CONTEXT]  static  AttributeValue  valueOf(String  value)  {  [BUGGY]  return  returnnew  Protocol  (  value  );  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  valueOf  [RETURN_TYPE]  Whitelist$AttributeValue      String  value  [VARIABLES]  Set    attributeSet    currentSet    protSet    protocols    tagNames    String    key    prot    protocol    tag    tagName    value    boolean    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    
return  new  AttributeValue  (  value  )  ;	[BUGGY]  return  new  AttributeValue(  tag);  [CONTEXT]  static  AttributeValue  valueOf(String  value)  {  [BUGGY]  return  new  AttributeValue  (  tag  )  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  valueOf  [RETURN_TYPE]  Whitelist$AttributeValue      String  value  [VARIABLES]  Set    attributeSet    currentSet    protSet    protocols    tagNames    String    key    prot    protocol    tag    tagName    value    boolean    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    
return  new  AttributeValue  (  value  )  ;	[BUGGY]  return    new  Protocol(  value)  ;  [CONTEXT]  static  AttributeValue  valueOf(String  value)  {  [BUGGY]  returnnew  Protocol  (  value  );  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  valueOf  [RETURN_TYPE]  Whitelist$AttributeValue      String  value  [VARIABLES]  Set    attributeSet    currentSet    protSet    protocols    tagNames    String    key    prot    protocol    tag    tagName    value    boolean    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    
return  new  AttributeValue  (  value  )  ;	[BUGGY]  return  new  AttributeValue(  tagName);  [CONTEXT]  static  AttributeValue  valueOf(String  value)  {  [BUGGY]  return  new  AttributeValue  (  tagName  )  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  valueOf  [RETURN_TYPE]  Whitelist$AttributeValue      String  value  [VARIABLES]  Set    attributeSet    currentSet    protSet    protocols    tagNames    String    key    prot    protocol    tag    tagName    value    boolean    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    
return  new  Protocol  (  value  )  ;	[BUGGY]  return  return    new  AttributeValue(  value)  ;  [CONTEXT]  static  Protocol  valueOf(String  value)  {  [BUGGY]  return  returnnew  AttributeValue  (  value  );  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  valueOf  [RETURN_TYPE]  Whitelist$Protocol      String  value  [VARIABLES]  Set    attributeSet    currentSet    protSet    protocols    tagNames    String    key    prot    protocol    tag    tagName    value    boolean    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    
return  new  Protocol  (  value  )  ;	[BUGGY]  return  new  Protocol(  tag);  [CONTEXT]  static  Protocol  valueOf(String  value)  {  [BUGGY]  return  new  Protocol  (  tag  )  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  valueOf  [RETURN_TYPE]  Whitelist$Protocol      String  value  [VARIABLES]  Set    attributeSet    currentSet    protSet    protocols    tagNames    String    key    prot    protocol    tag    tagName    value    boolean    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    
return  new  Protocol  (  value  )  ;	[BUGGY]  return    new  AttributeValue(  value)  ;  [CONTEXT]  static  Protocol  valueOf(String  value)  {  [BUGGY]  returnnew  AttributeValue  (  value  );  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  valueOf  [RETURN_TYPE]  Whitelist$Protocol      String  value  [VARIABLES]  Set    attributeSet    currentSet    protSet    protocols    tagNames    String    key    prot    protocol    tag    tagName    value    boolean    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    
return  new  Protocol  (  value  )  ;	[BUGGY]  return  new  Protocol(  tagName);  [CONTEXT]  static  Protocol  valueOf(String  value)  {  [BUGGY]  return  new  Protocol  (  tagName  )  ;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  valueOf  [RETURN_TYPE]  Whitelist$Protocol      String  value  [VARIABLES]  Set    attributeSet    currentSet    protSet    protocols    tagNames    String    key    prot    protocol    tag    tagName    value    boolean    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    
final  int  prime  =  31;	[BUGGY]  final    short    prime  =  31;  [CONTEXT]  public  int  hashCode()  {  [BUGGY]  finalshortprime  =  31;  int  result  =  1;  result  =  prime  *  result  +  ((value  ==  null)  ?  0  :  value.hashCode());  return  result;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  Set    attributeSet    currentSet    protSet    protocols    tagNames    String    key    prot    protocol    tag    tagName    value    boolean    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    int    prime    result    
final  int  prime  =  31;	[BUGGY]  final  int  prime  =  result;  [CONTEXT]  public  int  hashCode()  {  [BUGGY]  final  int  prime  =  result;  int  result  =  1;  result  =  prime  *  result  +  ((value  ==  null)  ?  0  :  value.hashCode());  return  result;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  Set    attributeSet    currentSet    protSet    protocols    tagNames    String    key    prot    protocol    tag    tagName    value    boolean    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    int    prime    result    
int  result  =  1;	[BUGGY]  short    result  =  1;  [CONTEXT]  public  int  hashCode()  {  final  int  prime  =  31;  [BUGGY]  shortresult  =  1;  result  =  prime  *  result  +  ((value  ==  null)  ?  0  :  value.hashCode());  return  result;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  Set    attributeSet    currentSet    protSet    protocols    tagNames    String    key    prot    protocol    tag    tagName    value    boolean    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    int    prime    result    
int  result  =  1;	[BUGGY]  int  result  =  -1;  [CONTEXT]  public  int  hashCode()  {  final  int  prime  =  31;  [BUGGY]  int  result  =  -1;  result  =  prime  *  result  +  ((value  ==  null)  ?  0  :  value.hashCode());  return  result;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  Set    attributeSet    currentSet    protSet    protocols    tagNames    String    key    prot    protocol    tag    tagName    value    boolean    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    int    prime    result    
result  =  prime  *  result  +  (  (  value  ==  null  )  ?  0  :  value.hashCode  (  )  )  ;	[BUGGY]  result  =  prime  *  result  +    &  (  (  value  ==  null)  ?  0  :  value.hashCode(  ));  [CONTEXT]  public  int  hashCode()  {  final  int  prime  =  31;  int  result  =  1;  [BUGGY]  result  =  prime  *  result  +&((  value  ==  null  )?  0  :  value.hashCode  ())  ;  return  result;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  Set    attributeSet    currentSet    protSet    protocols    tagNames    String    key    prot    protocol    tag    tagName    value    boolean    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    int    prime    result    
result  =  prime  *  result  +  (  (  value  ==  null  )  ?  0  :  value.hashCode  (  )  )  ;	[BUGGY]  result  =  prime  -  result  +  (  (  value  ==  null)  ?  0  :  value.hashCode(  ));  [CONTEXT]  public  int  hashCode()  {  final  int  prime  =  31;  int  result  =  1;  [BUGGY]  result  =  prime  -  result  +((  value  ==  null  )?  0  :  value.hashCode  ())  ;  return  result;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  Set    attributeSet    currentSet    protSet    protocols    tagNames    String    key    prot    protocol    tag    tagName    value    boolean    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    int    prime    result    
result  =  prime  *  result  +  (  (  value  ==  null  )  ?  0  :  value.hashCode  (  )  )  ;	[BUGGY]  result  =  prime  *  result  +  (  (  value  !=  null)  ?  0  :  value.hashCode(  ));  [CONTEXT]  public  int  hashCode()  {  final  int  prime  =  31;  int  result  =  1;  [BUGGY]  result  =  prime  *  result  +((  value  !=  null  )?  0  :  value.hashCode  ())  ;  return  result;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  Set    attributeSet    currentSet    protSet    protocols    tagNames    String    key    prot    protocol    tag    tagName    value    boolean    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    int    prime    result    
result  =  prime  *  result  +  (  (  value  ==  null  )  ?  0  :  value.hashCode  (  )  )  ;	[BUGGY]  result  =  prime  *  result  +  (  (  value  ==  null)  ?  result  :  value.hashCode(  ));  [CONTEXT]  public  int  hashCode()  {  final  int  prime  =  31;  int  result  =  1;  [BUGGY]  result  =  prime  *  result  +((  value  ==  null  )?  result  :  value.hashCode  ())  ;  return  result;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  Set    attributeSet    currentSet    protSet    protocols    tagNames    String    key    prot    protocol    tag    tagName    value    boolean    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    int    prime    result    
result  =  prime  *  result  +  (  (  value  ==  null  )  ?  0  :  value.hashCode  (  )  )  ;	[BUGGY]  result  =  prime  *  result  +  (  (  tag  ==  null)  ?  0  :  value.hashCode(  ));  [CONTEXT]  public  int  hashCode()  {  final  int  prime  =  31;  int  result  =  1;  [BUGGY]  result  =  prime  *  result  +((  tag  ==  null  )?  0  :  value.hashCode  ())  ;  return  result;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  Set    attributeSet    currentSet    protSet    protocols    tagNames    String    key    prot    protocol    tag    tagName    value    boolean    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    int    prime    result    
result  =  prime  *  result  +  (  (  value  ==  null  )  ?  0  :  value.hashCode  (  )  )  ;	[BUGGY]  result  =  result  *  prime  +  (  (  value  ==  null)  ?  0  :  value.hashCode(  ));  [CONTEXT]  public  int  hashCode()  {  final  int  prime  =  31;  int  result  =  1;  [BUGGY]  result  =  result  *  prime  +((  value  ==  null  )?  0  :  value.hashCode  ())  ;  return  result;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  Set    attributeSet    currentSet    protSet    protocols    tagNames    String    key    prot    protocol    tag    tagName    value    boolean    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    int    prime    result    
result  =  prime  *  result  +  (  (  value  ==  null  )  ?  0  :  value.hashCode  (  )  )  ;	[BUGGY]  result  =  value  *  result  +  (  (  prime  ==  null)  ?  0  :  value.hashCode(  ));  [CONTEXT]  public  int  hashCode()  {  final  int  prime  =  31;  int  result  =  1;  [BUGGY]  result  =  value  *  result  +((  prime  ==  null  )?  0  :  value.hashCode  ())  ;  return  result;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  Set    attributeSet    currentSet    protSet    protocols    tagNames    String    key    prot    protocol    tag    tagName    value    boolean    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    int    prime    result    
result  =  prime  *  result  +  (  (  value  ==  null  )  ?  0  :  value.hashCode  (  )  )  ;	[BUGGY]  result  =  prime  *  result  +  (  (  value.hashCode(  ));  [CONTEXT]  public  int  hashCode()  {  final  int  prime  =  31;  int  result  =  1;  [BUGGY]  result  =  prime  *  result  +((  value.hashCode  ())  ;  return  result;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  Set    attributeSet    currentSet    protSet    protocols    tagNames    String    key    prot    protocol    tag    tagName    value    boolean    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    int    prime    result    
result  =  prime  *  result  +  (  (  value  ==  null  )  ?  0  :  value.hashCode  (  )  )  ;	[BUGGY]  result  =  prime  *  result  +  (  (  value  ==  false)  ?  0  :  value.hashCode(  ));  [CONTEXT]  public  int  hashCode()  {  final  int  prime  =  31;  int  result  =  1;  [BUGGY]  result  =  prime  *  result  +((  value  ==  false  )?  0  :  value.hashCode  ())  ;  return  result;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  Set    attributeSet    currentSet    protSet    protocols    tagNames    String    key    prot    protocol    tag    tagName    value    boolean    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    int    prime    result    
result  =  prime  *  result  +  (  (  value  ==  null  )  ?  0  :  value.hashCode  (  )  )  ;	[BUGGY]  result  =  prime  *  result  +  (  (  tagName  ==  null)  ?  0  :  value.hashCode(  ));  [CONTEXT]  public  int  hashCode()  {  final  int  prime  =  31;  int  result  =  1;  [BUGGY]  result  =  prime  *  result  +((  tagName  ==  null  )?  0  :  value.hashCode  ())  ;  return  result;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  Set    attributeSet    currentSet    protSet    protocols    tagNames    String    key    prot    protocol    tag    tagName    value    boolean    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    int    prime    result    
result  =  prime  *  result  +  (  (  value  ==  null  )  ?  0  :  value.hashCode  (  )  )  ;	[BUGGY]    [CONTEXT]  public  int  hashCode()  {  final  int  prime  =  31;  int  result  =  1;  [BUGGY]  result  =  prime  *  result  +  ((value  ==  null)  ?  0  :  value.hashCode());    return  result;        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  Set    attributeSet    currentSet    protSet    protocols    tagNames    String    key    prot    protocol    tag    tagName    value    boolean    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    int    prime    result    
return  result;	[BUGGY]  return  prime;  [CONTEXT]  public  int  hashCode()  {  final  int  prime  =  31;  int  result  =  1;  result  =  prime  *  result  +  ((value  ==  null)  ?  0  :  value.hashCode());  [BUGGY]  return  prime;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  Set    attributeSet    currentSet    protSet    protocols    tagNames    String    key    prot    protocol    tag    tagName    value    boolean    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    int    prime    result    
if  (  this  ==  obj  )  return  true;	[BUGGY]  if  (  this  >=  obj)  return  true;  [CONTEXT]  public  boolean  equals(Object  obj)  {  [BUGGY]  if(  this  >=  obj  )return  true;  if  (obj  ==  null)  return  false;  if  (getClass()  !=  obj.getClass())  return  false;  TypedValue  other  =  (TypedValue)  obj;  if  (value  ==  null)  {  if  (other.value  !=  null)  return  false;  }  else  if  (!value.equals(other.value))  return  false;  return  true;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  obj  [VARIABLES]  Object    obj    Set    attributeSet    currentSet    protSet    protocols    tagNames    String    key    prot    protocol    tag    tagName    value    boolean    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    TypedValue    other    
if  (  this  ==  obj  )  return  true;	[BUGGY]  if  (  this  ==  obj)  return  false;  [CONTEXT]  public  boolean  equals(Object  obj)  {  [BUGGY]  if(  this  ==  obj  )return  false;  if  (obj  ==  null)  return  false;  if  (getClass()  !=  obj.getClass())  return  false;  TypedValue  other  =  (TypedValue)  obj;  if  (value  ==  null)  {  if  (other.value  !=  null)  return  false;  }  else  if  (!value.equals(other.value))  return  false;  return  true;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  obj  [VARIABLES]  Object    obj    Set    attributeSet    currentSet    protSet    protocols    tagNames    String    key    prot    protocol    tag    tagName    value    boolean    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    TypedValue    other    
if  (  obj  ==  null  )  return  false;	[BUGGY]  if  (  obj  !=  null)  return  false;  [CONTEXT]  public  boolean  equals(Object  obj)  {  if  (this  ==  obj)  return  true;  [BUGGY]  if(  obj  !=  null  )return  false;  if  (getClass()  !=  obj.getClass())  return  false;  TypedValue  other  =  (TypedValue)  obj;  if  (value  ==  null)  {  if  (other.value  !=  null)  return  false;  }  else  if  (!value.equals(other.value))  return  false;  return  true;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  obj  [VARIABLES]  Object    obj    Set    attributeSet    currentSet    protSet    protocols    tagNames    String    key    prot    protocol    tag    tagName    value    boolean    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    TypedValue    other    
if  (  obj  ==  null  )  return  false;	[BUGGY]  if  (  obj  ==  null)  return  true;  [CONTEXT]  public  boolean  equals(Object  obj)  {  if  (this  ==  obj)  return  true;  [BUGGY]  if(  obj  ==  null  )return  true;  if  (getClass()  !=  obj.getClass())  return  false;  TypedValue  other  =  (TypedValue)  obj;  if  (value  ==  null)  {  if  (other.value  !=  null)  return  false;  }  else  if  (!value.equals(other.value))  return  false;  return  true;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  obj  [VARIABLES]  Object    obj    Set    attributeSet    currentSet    protSet    protocols    tagNames    String    key    prot    protocol    tag    tagName    value    boolean    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    TypedValue    other    
if  (  obj  ==  null  )  return  false;	[BUGGY]  if  (  obj  ==  true)  return  false;  [CONTEXT]  public  boolean  equals(Object  obj)  {  if  (this  ==  obj)  return  true;  [BUGGY]  if(  obj  ==  true  )return  false;  if  (getClass()  !=  obj.getClass())  return  false;  TypedValue  other  =  (TypedValue)  obj;  if  (value  ==  null)  {  if  (other.value  !=  null)  return  false;  }  else  if  (!value.equals(other.value))  return  false;  return  true;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  obj  [VARIABLES]  Object    obj    Set    attributeSet    currentSet    protSet    protocols    tagNames    String    key    prot    protocol    tag    tagName    value    boolean    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    TypedValue    other    
if  (  getClass  (  )  !=  obj.getClass  (  )  )  return  false;	[BUGGY]  if  (  getClass(  )  <=  obj.getClass(  ))  return  false;  [CONTEXT]  public  boolean  equals(Object  obj)  {  if  (this  ==  obj)  return  true;  if  (obj  ==  null)  return  false;  [BUGGY]  if(  getClass  ()<=  obj.getClass  ())return  false;  TypedValue  other  =  (TypedValue)  obj;  if  (value  ==  null)  {  if  (other.value  !=  null)  return  false;  }  else  if  (!value.equals(other.value))  return  false;  return  true;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  obj  [VARIABLES]  Object    obj    Set    attributeSet    currentSet    protSet    protocols    tagNames    String    key    prot    protocol    tag    tagName    value    boolean    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    TypedValue    other    
if  (  getClass  (  )  !=  obj.getClass  (  )  )  return  false;	[BUGGY]  if  (  getClass(  )  !=  obj.getClass(  ))  return  true;  [CONTEXT]  public  boolean  equals(Object  obj)  {  if  (this  ==  obj)  return  true;  if  (obj  ==  null)  return  false;  [BUGGY]  if(  getClass  ()!=  obj.getClass  ())return  true;  TypedValue  other  =  (TypedValue)  obj;  if  (value  ==  null)  {  if  (other.value  !=  null)  return  false;  }  else  if  (!value.equals(other.value))  return  false;  return  true;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  obj  [VARIABLES]  Object    obj    Set    attributeSet    currentSet    protSet    protocols    tagNames    String    key    prot    protocol    tag    tagName    value    boolean    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    TypedValue    other    
if  (  getClass  (  )  !=  obj.getClass  (  )  )  return  false;	[BUGGY]  if  (  getClass(  )  !=  obj.toLowerCase(  ))  return  false;  [CONTEXT]  public  boolean  equals(Object  obj)  {  if  (this  ==  obj)  return  true;  if  (obj  ==  null)  return  false;  [BUGGY]  if(  getClass  ()!=  obj.toLowerCase  ())return  false;  TypedValue  other  =  (TypedValue)  obj;  if  (value  ==  null)  {  if  (other.value  !=  null)  return  false;  }  else  if  (!value.equals(other.value))  return  false;  return  true;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  obj  [VARIABLES]  Object    obj    Set    attributeSet    currentSet    protSet    protocols    tagNames    String    key    prot    protocol    tag    tagName    value    boolean    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    TypedValue    other    
if  (  value  ==  null  )  {	[BUGGY]  if  (  value  !=  null)  {  [CONTEXT]  public  boolean  equals(Object  obj)  {  if  (this  ==  obj)  return  true;  if  (obj  ==  null)  return  false;  if  (getClass()  !=  obj.getClass())  return  false;  TypedValue  other  =  (TypedValue)  obj;  [BUGGY]  if(  value  !=  null  ){  if  (other.value  !=  null)  return  false;  }  else  if  (!value.equals(other.value))  return  false;  return  true;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  obj  [VARIABLES]  Object    obj    Set    attributeSet    currentSet    protSet    protocols    tagNames    String    key    prot    protocol    tag    tagName    value    boolean    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    TypedValue    other    
if  (  value  ==  null  )  {	[BUGGY]  if  (  tagName  ==  null)  {  [CONTEXT]  public  boolean  equals(Object  obj)  {  if  (this  ==  obj)  return  true;  if  (obj  ==  null)  return  false;  if  (getClass()  !=  obj.getClass())  return  false;  TypedValue  other  =  (TypedValue)  obj;  [BUGGY]  if(  tagName  ==  null  ){  if  (other.value  !=  null)  return  false;  }  else  if  (!value.equals(other.value))  return  false;  return  true;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  obj  [VARIABLES]  Object    obj    Set    attributeSet    currentSet    protSet    protocols    tagNames    String    key    prot    protocol    tag    tagName    value    boolean    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    TypedValue    other    
if  (  value  ==  null  )  {	[BUGGY]  if  (  other.value  !=  null)  {  [CONTEXT]  public  boolean  equals(Object  obj)  {  if  (this  ==  obj)  return  true;  if  (obj  ==  null)  return  false;  if  (getClass()  !=  obj.getClass())  return  false;  TypedValue  other  =  (TypedValue)  obj;  [BUGGY]  if(  other.value  !=  null  ){  if  (other.value  !=  null)  return  false;  }  else  if  (!value.equals(other.value))  return  false;  return  true;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  obj  [VARIABLES]  Object    obj    Set    attributeSet    currentSet    protSet    protocols    tagNames    String    key    prot    protocol    tag    tagName    value    boolean    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    TypedValue    other    
if  (  value  ==  null  )  {	[BUGGY]  if  (  tag  ==  this)  {  [CONTEXT]  public  boolean  equals(Object  obj)  {  if  (this  ==  obj)  return  true;  if  (obj  ==  null)  return  false;  if  (getClass()  !=  obj.getClass())  return  false;  TypedValue  other  =  (TypedValue)  obj;  [BUGGY]  if(  tag  ==  this  ){  if  (other.value  !=  null)  return  false;  }  else  if  (!value.equals(other.value))  return  false;  return  true;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  obj  [VARIABLES]  Object    obj    Set    attributeSet    currentSet    protSet    protocols    tagNames    String    key    prot    protocol    tag    tagName    value    boolean    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    TypedValue    other    
if  (  value  ==  null  )  {  if  (  other.value  !=  null  )  return  false;  }  else  if  (  !value.equals  (  other.value  )  )  return  false;  return  true;  }	[BUGGY]  if((other.value)  !=  null)        return  false;;  [CONTEXT]  public  boolean  equals(Object  obj)  {  if  (this  ==  obj)  return  true;  if  (obj  ==  null)  return  false;  if  (getClass()  !=  obj.getClass())  return  false;  TypedValue  other  =  (TypedValue)  obj;  [BUGGY]  if  (value  ==  null)  {    if  ((other.value)  !=  null)return  false;;            [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  obj  [VARIABLES]  Object    obj    Set    attributeSet    currentSet    protSet    protocols    tagNames    String    key    prot    protocol    tag    tagName    value    boolean    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    TypedValue    other    
if  (  value  ==  null  )  {  if  (  other.value  !=  null  )  return  false;  }  else  if  (  !value.equals  (  other.value  )  )  return  false;  return  true;  }	[BUGGY]    [CONTEXT]  public  boolean  equals(Object  obj)  {  if  (this  ==  obj)  return  true;  if  (obj  ==  null)  return  false;  if  (getClass()  !=  obj.getClass())  return  false;  TypedValue  other  =  (TypedValue)  obj;  [BUGGY]  if  (value  ==  null)  {                [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  obj  [VARIABLES]  Object    obj    Set    attributeSet    currentSet    protSet    protocols    tagNames    String    key    prot    protocol    tag    tagName    value    boolean    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    TypedValue    other    
}  else  if  (  !value.equals  (  other.value  )  )  return  false;	[BUGGY]    else  if  (  !value.equals(  other.value))  return  true;  [CONTEXT]  public  boolean  equals(Object  obj)  {  if  (this  ==  obj)  return  true;  if  (obj  ==  null)  return  false;  if  (getClass()  !=  obj.getClass())  return  false;  TypedValue  other  =  (TypedValue)  obj;  if  (value  ==  null)  {  if  (other.value  !=  null)  return  false;  [BUGGY]  }  else  if(  !value.equals  (  other.value  ))return  true;  return  true;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  obj  [VARIABLES]  Object    obj    Set    attributeSet    currentSet    protSet    protocols    tagNames    String    key    prot    protocol    tag    tagName    value    boolean    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    TypedValue    other    
}  else  if  (  !value.equals  (  other.value  )  )  return  false;	[BUGGY]    else  if  (  !value.equals(  other.tagName))  return  false;  [CONTEXT]  public  boolean  equals(Object  obj)  {  if  (this  ==  obj)  return  true;  if  (obj  ==  null)  return  false;  if  (getClass()  !=  obj.getClass())  return  false;  TypedValue  other  =  (TypedValue)  obj;  if  (value  ==  null)  {  if  (other.value  !=  null)  return  false;  [BUGGY]  }  else  if(  !value.equals  (  other.tagName  ))return  false;  return  true;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  obj  [VARIABLES]  Object    obj    Set    attributeSet    currentSet    protSet    protocols    tagNames    String    key    prot    protocol    tag    tagName    value    boolean    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    TypedValue    other    
}  else  if  (  !value.equals  (  other.value  )  )  return  false;	[BUGGY]    else  if  (  !value.equals(  tag))  return  false;  [CONTEXT]  public  boolean  equals(Object  obj)  {  if  (this  ==  obj)  return  true;  if  (obj  ==  null)  return  false;  if  (getClass()  !=  obj.getClass())  return  false;  TypedValue  other  =  (TypedValue)  obj;  if  (value  ==  null)  {  if  (other.value  !=  null)  return  false;  [BUGGY]  }  else  if(  !value.equals  (  tag  ))return  false;  return  true;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  obj  [VARIABLES]  Object    obj    Set    attributeSet    currentSet    protSet    protocols    tagNames    String    key    prot    protocol    tag    tagName    value    boolean    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    TypedValue    other    
}  else  if  (  !value.equals  (  other.value  )  )  return  false;	[BUGGY]      if  (  !value.equals(  other.value))  return  true;  [CONTEXT]  public  boolean  equals(Object  obj)  {  if  (this  ==  obj)  return  true;  if  (obj  ==  null)  return  false;  if  (getClass()  !=  obj.getClass())  return  false;  TypedValue  other  =  (TypedValue)  obj;  if  (value  ==  null)  {  if  (other.value  !=  null)  return  false;  [BUGGY]  }if(  !value.equals  (  other.value  ))return  true;  return  true;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  obj  [VARIABLES]  Object    obj    Set    attributeSet    currentSet    protSet    protocols    tagNames    String    key    prot    protocol    tag    tagName    value    boolean    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    TypedValue    other    
}  else  if  (  !value.equals  (  other.value  )  )  return  false;  return  true;  }	[BUGGY]  return  false;  [CONTEXT]  public  boolean  equals(Object  obj)  {  if  (this  ==  obj)  return  true;  if  (obj  ==  null)  return  false;  if  (getClass()  !=  obj.getClass())  return  false;  TypedValue  other  =  (TypedValue)  obj;  if  (value  ==  null)  {  if  (other.value  !=  null)  return  false;  [BUGGY]  }  else  if  (!value.equals(other.value))  return  false;    return  false;        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  obj  [VARIABLES]  Object    obj    Set    attributeSet    currentSet    protSet    protocols    tagNames    String    key    prot    protocol    tag    tagName    value    boolean    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    TypedValue    other    
}  else  if  (  !value.equals  (  other.value  )  )  return  false;  return  true;  }	[BUGGY]    [CONTEXT]  public  boolean  equals(Object  obj)  {  if  (this  ==  obj)  return  true;  if  (obj  ==  null)  return  false;  if  (getClass()  !=  obj.getClass())  return  false;  TypedValue  other  =  (TypedValue)  obj;  if  (value  ==  null)  {  if  (other.value  !=  null)  return  false;  [BUGGY]  }  else  if  (!value.equals(other.value))  return  false;            [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  obj  [VARIABLES]  Object    obj    Set    attributeSet    currentSet    protSet    protocols    tagNames    String    key    prot    protocol    tag    tagName    value    boolean    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    TypedValue    other    
}  else  if  (  !value.equals  (  other.value  )  )  return  false;	[BUGGY]    else  if  (  !value.equals(  tagName))  return  false;  [CONTEXT]  public  boolean  equals(Object  obj)  {  if  (this  ==  obj)  return  true;  if  (obj  ==  null)  return  false;  if  (getClass()  !=  obj.getClass())  return  false;  TypedValue  other  =  (TypedValue)  obj;  if  (value  ==  null)  {  if  (other.value  !=  null)  return  false;  [BUGGY]  }  else  if(  !value.equals  (  tagName  ))return  false;  return  true;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  obj  [VARIABLES]  Object    obj    Set    attributeSet    currentSet    protSet    protocols    tagNames    String    key    prot    protocol    tag    tagName    value    boolean    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    TypedValue    other    
}  else  if  (  !value.equals  (  other.value  )  )  return  false;	[BUGGY]    else  if  (  !value.equals(  other))  return  false;  [CONTEXT]  public  boolean  equals(Object  obj)  {  if  (this  ==  obj)  return  true;  if  (obj  ==  null)  return  false;  if  (getClass()  !=  obj.getClass())  return  false;  TypedValue  other  =  (TypedValue)  obj;  if  (value  ==  null)  {  if  (other.value  !=  null)  return  false;  [BUGGY]  }  else  if(  !value.equals  (  other  ))return  false;  return  true;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  obj  [VARIABLES]  Object    obj    Set    attributeSet    currentSet    protSet    protocols    tagNames    String    key    prot    protocol    tag    tagName    value    boolean    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    TypedValue    other    
if  (  other.value  !=  null  )  return  false;	[BUGGY]  if  (  other.value  ==  null)  return  false;  [CONTEXT]  public  boolean  equals(Object  obj)  {  if  (this  ==  obj)  return  true;  if  (obj  ==  null)  return  false;  if  (getClass()  !=  obj.getClass())  return  false;  TypedValue  other  =  (TypedValue)  obj;  if  (value  ==  null)  {  [BUGGY]  if(  other.value  ==  null  )return  false;  }  else  if  (!value.equals(other.value))  return  false;  return  true;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  obj  [VARIABLES]  Object    obj    Set    attributeSet    currentSet    protSet    protocols    tagNames    String    key    prot    protocol    tag    tagName    value    boolean    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    TypedValue    other    
if  (  other.value  !=  null  )  return  false;	[BUGGY]  if  (  other.value  !=  null)  return  true;  [CONTEXT]  public  boolean  equals(Object  obj)  {  if  (this  ==  obj)  return  true;  if  (obj  ==  null)  return  false;  if  (getClass()  !=  obj.getClass())  return  false;  TypedValue  other  =  (TypedValue)  obj;  if  (value  ==  null)  {  [BUGGY]  if(  other.value  !=  null  )return  true;  }  else  if  (!value.equals(other.value))  return  false;  return  true;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  obj  [VARIABLES]  Object    obj    Set    attributeSet    currentSet    protSet    protocols    tagNames    String    key    prot    protocol    tag    tagName    value    boolean    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    TypedValue    other    
if  (  other.value  !=  null  )  return  false;	[BUGGY]  if  (  value  !=  null)  return  false;  [CONTEXT]  public  boolean  equals(Object  obj)  {  if  (this  ==  obj)  return  true;  if  (obj  ==  null)  return  false;  if  (getClass()  !=  obj.getClass())  return  false;  TypedValue  other  =  (TypedValue)  obj;  if  (value  ==  null)  {  [BUGGY]  if(  value  !=  null  )return  false;  }  else  if  (!value.equals(other.value))  return  false;  return  true;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  obj  [VARIABLES]  Object    obj    Set    attributeSet    currentSet    protSet    protocols    tagNames    String    key    prot    protocol    tag    tagName    value    boolean    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    TypedValue    other    
if  (  other.value  !=  null  )  return  false;	[BUGGY]  if  (  other.value.value  !=  null)  return  false;  [CONTEXT]  public  boolean  equals(Object  obj)  {  if  (this  ==  obj)  return  true;  if  (obj  ==  null)  return  false;  if  (getClass()  !=  obj.getClass())  return  false;  TypedValue  other  =  (TypedValue)  obj;  if  (value  ==  null)  {  [BUGGY]  if(  other.value.value  !=  null  )return  false;  }  else  if  (!value.equals(other.value))  return  false;  return  true;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  obj  [VARIABLES]  Object    obj    Set    attributeSet    currentSet    protSet    protocols    tagNames    String    key    prot    protocol    tag    tagName    value    boolean    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    TypedValue    other    
if  (  other.value  !=  null  )  return  false;	[BUGGY]  if  (  other  !=  null)  return  false;  [CONTEXT]  public  boolean  equals(Object  obj)  {  if  (this  ==  obj)  return  true;  if  (obj  ==  null)  return  false;  if  (getClass()  !=  obj.getClass())  return  false;  TypedValue  other  =  (TypedValue)  obj;  if  (value  ==  null)  {  [BUGGY]  if(  other  !=  null  )return  false;  }  else  if  (!value.equals(other.value))  return  false;  return  true;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  obj  [VARIABLES]  Object    obj    Set    attributeSet    currentSet    protSet    protocols    tagNames    String    key    prot    protocol    tag    tagName    value    boolean    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    TypedValue    other    
if  (  other.value  !=  null  )  return  false;	[BUGGY]  if  (  other.value  !=  false)  return  false;  [CONTEXT]  public  boolean  equals(Object  obj)  {  if  (this  ==  obj)  return  true;  if  (obj  ==  null)  return  false;  if  (getClass()  !=  obj.getClass())  return  false;  TypedValue  other  =  (TypedValue)  obj;  if  (value  ==  null)  {  [BUGGY]  if(  other.value  !=  false  )return  false;  }  else  if  (!value.equals(other.value))  return  false;  return  true;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  obj  [VARIABLES]  Object    obj    Set    attributeSet    currentSet    protSet    protocols    tagNames    String    key    prot    protocol    tag    tagName    value    boolean    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    TypedValue    other    
if  (  other.value  !=  null  )  return  false;  }  else  if  (  !value.equals  (  other.value  )  )  return  false;  return  true;  }	[BUGGY]  return  false;  [CONTEXT]  public  boolean  equals(Object  obj)  {  if  (this  ==  obj)  return  true;  if  (obj  ==  null)  return  false;  if  (getClass()  !=  obj.getClass())  return  false;  TypedValue  other  =  (TypedValue)  obj;  if  (value  ==  null)  {  [BUGGY]  if  (other.value  !=  null)  return  false;    return  false;          [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  obj  [VARIABLES]  Object    obj    Set    attributeSet    currentSet    protSet    protocols    tagNames    String    key    prot    protocol    tag    tagName    value    boolean    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    TypedValue    other    
if  (  other.value  !=  null  )  return  false;  }  else  if  (  !value.equals  (  other.value  )  )  return  false;  return  true;  }	[BUGGY]    [CONTEXT]  public  boolean  equals(Object  obj)  {  if  (this  ==  obj)  return  true;  if  (obj  ==  null)  return  false;  if  (getClass()  !=  obj.getClass())  return  false;  TypedValue  other  =  (TypedValue)  obj;  if  (value  ==  null)  {  [BUGGY]  if  (other.value  !=  null)  return  false;              [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  obj  [VARIABLES]  Object    obj    Set    attributeSet    currentSet    protSet    protocols    tagNames    String    key    prot    protocol    tag    tagName    value    boolean    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    TypedValue    other    
if  (  other.value  !=  null  )  return  false;	[BUGGY]  if  (  tag  !=  null)  return  false;  [CONTEXT]  public  boolean  equals(Object  obj)  {  if  (this  ==  obj)  return  true;  if  (obj  ==  null)  return  false;  if  (getClass()  !=  obj.getClass())  return  false;  TypedValue  other  =  (TypedValue)  obj;  if  (value  ==  null)  {  [BUGGY]  if(  tag  !=  null  )return  false;  }  else  if  (!value.equals(other.value))  return  false;  return  true;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  obj  [VARIABLES]  Object    obj    Set    attributeSet    currentSet    protSet    protocols    tagNames    String    key    prot    protocol    tag    tagName    value    boolean    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    TypedValue    other    
if  (  other.value  !=  null  )  return  false;	[BUGGY]  if  (  other.value  !=  true)  return  false;  [CONTEXT]  public  boolean  equals(Object  obj)  {  if  (this  ==  obj)  return  true;  if  (obj  ==  null)  return  false;  if  (getClass()  !=  obj.getClass())  return  false;  TypedValue  other  =  (TypedValue)  obj;  if  (value  ==  null)  {  [BUGGY]  if(  other.value  !=  true  )return  false;  }  else  if  (!value.equals(other.value))  return  false;  return  true;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  obj  [VARIABLES]  Object    obj    Set    attributeSet    currentSet    protSet    protocols    tagNames    String    key    prot    protocol    tag    tagName    value    boolean    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    TypedValue    other    
}  else  if  (  !value.equals  (  other.value  )  )  return  false;	[BUGGY]    else  if  (  !value.equals(  other.value.value))  return  false;  [CONTEXT]  public  boolean  equals(Object  obj)  {  if  (this  ==  obj)  return  true;  if  (obj  ==  null)  return  false;  if  (getClass()  !=  obj.getClass())  return  false;  TypedValue  other  =  (TypedValue)  obj;  if  (value  ==  null)  {  if  (other.value  !=  null)  return  false;  [BUGGY]  }  else  if(  !value.equals  (  other.value.value  ))return  false;  return  true;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  obj  [VARIABLES]  Object    obj    Set    attributeSet    currentSet    protSet    protocols    tagNames    String    key    prot    protocol    tag    tagName    value    boolean    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    TypedValue    other    
}  else  if  (  !value.equals  (  other.value  )  )  return  false;	[BUGGY]    else  if  (  !value.equals(  tag))  return  true;  [CONTEXT]  public  boolean  equals(Object  obj)  {  if  (this  ==  obj)  return  true;  if  (obj  ==  null)  return  false;  if  (getClass()  !=  obj.getClass())  return  false;  TypedValue  other  =  (TypedValue)  obj;  if  (value  ==  null)  {  if  (other.value  !=  null)  return  false;  [BUGGY]  }  else  if(  !value.equals  (  tag  ))return  true;  return  true;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  obj  [VARIABLES]  Object    obj    Set    attributeSet    currentSet    protSet    protocols    tagNames    String    key    prot    protocol    tag    tagName    value    boolean    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    TypedValue    other    
}  else  if  (  !value.equals  (  other.value  )  )  return  false;	[BUGGY]    else  if  (  !value  .equals(  obj)  )  return  false;  [CONTEXT]  public  boolean  equals(Object  obj)  {  if  (this  ==  obj)  return  true;  if  (obj  ==  null)  return  false;  if  (getClass()  !=  obj.getClass())  return  false;  TypedValue  other  =  (TypedValue)  obj;  if  (value  ==  null)  {  if  (other.value  !=  null)  return  false;  [BUGGY]  }  else  if(  !value  .equals  (  obj  )  )return  false;  return  true;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  obj  [VARIABLES]  Object    obj    Set    attributeSet    currentSet    protSet    protocols    tagNames    String    key    prot    protocol    tag    tagName    value    boolean    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    TypedValue    other    
return  true;	[BUGGY]  return  false;  [CONTEXT]  public  boolean  equals(Object  obj)  {  if  (this  ==  obj)  return  true;  if  (obj  ==  null)  return  false;  if  (getClass()  !=  obj.getClass())  return  false;  TypedValue  other  =  (TypedValue)  obj;  if  (value  ==  null)  {  if  (other.value  !=  null)  return  false;  }  else  if  (!value.equals(other.value))  return  false;  [BUGGY]  return  false;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  obj  [VARIABLES]  Object    obj    Set    attributeSet    currentSet    protSet    protocols    tagNames    String    key    prot    protocol    tag    tagName    value    boolean    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    TypedValue    other    
return  value;	[BUGGY]  return  tagName;  [CONTEXT]  public  String  toString()  {  [BUGGY]  return  tagName;  }        [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  Set    attributeSet    currentSet    protSet    protocols    tagNames    String    key    prot    protocol    tag    tagName    value    boolean    Map    attrMap    attrProts    attributes    enforcedAttributes    keyVals    protocols    
super  (  value  )  ;	[BUGGY]    [CONTEXT]  TagName(String  value)  {  [BUGGY]  super(value);          [CLASS]  TagName    [METHOD]  <init>  [RETURN_TYPE]  String)      String  value  [VARIABLES]  boolean    String    value    
super  (  value  )  ;	[BUGGY]    [CONTEXT]  AttributeKey(String  value)  {  [BUGGY]  super(value);          [CLASS]  AttributeKey    [METHOD]  <init>  [RETURN_TYPE]  String)      String  value  [VARIABLES]  boolean    String    value    
super  (  value  )  ;	[BUGGY]    [CONTEXT]  AttributeValue(String  value)  {  [BUGGY]  super(value);          [CLASS]  AttributeValue    [METHOD]  <init>  [RETURN_TYPE]  String)      String  value  [VARIABLES]  boolean    String    value    
super  (  value  )  ;	[BUGGY]    [CONTEXT]  Protocol(String  value)  {  [BUGGY]  super(value);          [CLASS]  Protocol    [METHOD]  <init>  [RETURN_TYPE]  String)      String  value  [VARIABLES]  boolean    String    value    
private  String  value;	[BUGGY]  private  char  value;  [CONTEXT]  return  new  Protocol(value);  }  }    abstract  static  class  TypedValue  {  [BUGGY]  private  char  value;    TypedValue(String  value)  {  Validate.notNull(value);  this.value  =  value;  }        [CLASS]  TypedValue    [METHOD]  valueOf  [RETURN_TYPE]  Whitelist$Protocol      String  value  [VARIABLES]  boolean    String    value    
Validate.notNull  (  value  )  ;  this.value  =  value;	[BUGGY]    [CONTEXT]  TypedValue(String  value)  {  [BUGGY]  Validate.notNull(value);            [CLASS]  TypedValue    [METHOD]  <init>  [RETURN_TYPE]  String)      String  value  [VARIABLES]  String    value    boolean    
Validate.notNull  (  value  )  ;  this.value  =  value;	[BUGGY]  this.value  =  value;  Validate.notNull(  value);  [CONTEXT]        [CLASS]  TypedValue    [METHOD]  <init>  [RETURN_TYPE]  String)      String  value  [VARIABLES]  String    value    boolean    
Validate.notNull  (  value  )  ;  this.value  =  value;	[BUGGY]  Validate.notNull(  value);Validate.notNull(  value);  this.value  =  value;  [CONTEXT]        [CLASS]  TypedValue    [METHOD]  <init>  [RETURN_TYPE]  String)      String  value  [VARIABLES]  String    value    boolean    
this.value  =  value;	[BUGGY]  this.value  =    null;  [CONTEXT]  TypedValue(String  value)  {  Validate.notNull(value);  [BUGGY]  this.value  =null;  }        [CLASS]  TypedValue    [METHOD]  <init>  [RETURN_TYPE]  String)      String  value  [VARIABLES]  String    value    boolean    
final  int  prime  =  31;	[BUGGY]  final    short    prime  =  31;  [CONTEXT]  public  int  hashCode()  {  [BUGGY]  finalshortprime  =  31;  int  result  =  1;  result  =  prime  *  result  +  ((value  ==  null)  ?  0  :  value.hashCode());  return  result;  }        [CLASS]  TypedValue    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  int    prime    result    String    value    boolean    
final  int  prime  =  31;	[BUGGY]  final  int  prime  =  prime;  [CONTEXT]  public  int  hashCode()  {  [BUGGY]  final  int  prime  =  prime;  int  result  =  1;  result  =  prime  *  result  +  ((value  ==  null)  ?  0  :  value.hashCode());  return  result;  }        [CLASS]  TypedValue    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  int    prime    result    String    value    boolean    
int  result  =  1;	[BUGGY]  short    result  =  1;  [CONTEXT]  public  int  hashCode()  {  final  int  prime  =  31;  [BUGGY]  shortresult  =  1;  result  =  prime  *  result  +  ((value  ==  null)  ?  0  :  value.hashCode());  return  result;  }        [CLASS]  TypedValue    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  int    prime    result    String    value    boolean    
int  result  =  1;	[BUGGY]  int  result  =  result;  [CONTEXT]  public  int  hashCode()  {  final  int  prime  =  31;  [BUGGY]  int  result  =  result;  result  =  prime  *  result  +  ((value  ==  null)  ?  0  :  value.hashCode());  return  result;  }        [CLASS]  TypedValue    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  int    prime    result    String    value    boolean    
result  =  prime  *  result  +  (  (  value  ==  null  )  ?  0  :  value.hashCode  (  )  )  ;	[BUGGY]  result  =  prime  *  result  +    &  (  (  value  ==  null)  ?  0  :  value.hashCode(  ));  [CONTEXT]  public  int  hashCode()  {  final  int  prime  =  31;  int  result  =  1;  [BUGGY]  result  =  prime  *  result  +&((  value  ==  null  )?  0  :  value.hashCode  ())  ;  return  result;  }        [CLASS]  TypedValue    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  int    prime    result    String    value    boolean    
result  =  prime  *  result  +  (  (  value  ==  null  )  ?  0  :  value.hashCode  (  )  )  ;	[BUGGY]  result  =  prime  +  result  +  (  (  value  ==  null)  ?  0  :  value.hashCode(  ));  [CONTEXT]  public  int  hashCode()  {  final  int  prime  =  31;  int  result  =  1;  [BUGGY]  result  =  prime  +  result  +((  value  ==  null  )?  0  :  value.hashCode  ())  ;  return  result;  }        [CLASS]  TypedValue    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  int    prime    result    String    value    boolean    
result  =  prime  *  result  +  (  (  value  ==  null  )  ?  0  :  value.hashCode  (  )  )  ;	[BUGGY]  result  =  prime  *  result  +  (  (  value  !=  null)  ?  0  :  value.hashCode(  ));  [CONTEXT]  public  int  hashCode()  {  final  int  prime  =  31;  int  result  =  1;  [BUGGY]  result  =  prime  *  result  +((  value  !=  null  )?  0  :  value.hashCode  ())  ;  return  result;  }        [CLASS]  TypedValue    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  int    prime    result    String    value    boolean    
result  =  prime  *  result  +  (  (  value  ==  null  )  ?  0  :  value.hashCode  (  )  )  ;	[BUGGY]  result  =  prime  *  result  +  (  (  value  ==  null)  ?  -9  :  value.hashCode(  ));  [CONTEXT]  public  int  hashCode()  {  final  int  prime  =  31;  int  result  =  1;  [BUGGY]  result  =  prime  *  result  +((  value  ==  null  )?  -9  :  value.hashCode  ())  ;  return  result;  }        [CLASS]  TypedValue    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  int    prime    result    String    value    boolean    
result  =  prime  *  result  +  (  (  value  ==  null  )  ?  0  :  value.hashCode  (  )  )  ;	[BUGGY]  result  =  result  *  result  +  (  (  value  ==  null)  ?  0  :  value.hashCode(  ));  [CONTEXT]  public  int  hashCode()  {  final  int  prime  =  31;  int  result  =  1;  [BUGGY]  result  =  result  *  result  +((  value  ==  null  )?  0  :  value.hashCode  ())  ;  return  result;  }        [CLASS]  TypedValue    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  int    prime    result    String    value    boolean    
result  =  prime  *  result  +  (  (  value  ==  null  )  ?  0  :  value.hashCode  (  )  )  ;	[BUGGY]  result  =  result  *  prime  +  (  (  value  ==  null)  ?  0  :  value.hashCode(  ));  [CONTEXT]  public  int  hashCode()  {  final  int  prime  =  31;  int  result  =  1;  [BUGGY]  result  =  result  *  prime  +((  value  ==  null  )?  0  :  value.hashCode  ())  ;  return  result;  }        [CLASS]  TypedValue    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  int    prime    result    String    value    boolean    
result  =  prime  *  result  +  (  (  value  ==  null  )  ?  0  :  value.hashCode  (  )  )  ;	[BUGGY]  result  =  value  *  result  +  (  (  prime  ==  null)  ?  0  :  value.hashCode(  ));  [CONTEXT]  public  int  hashCode()  {  final  int  prime  =  31;  int  result  =  1;  [BUGGY]  result  =  value  *  result  +((  prime  ==  null  )?  0  :  value.hashCode  ())  ;  return  result;  }        [CLASS]  TypedValue    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  int    prime    result    String    value    boolean    
result  =  prime  *  result  +  (  (  value  ==  null  )  ?  0  :  value.hashCode  (  )  )  ;	[BUGGY]  result  =  prime  *  result  +  (  (  value.hashCode(  ));  [CONTEXT]  public  int  hashCode()  {  final  int  prime  =  31;  int  result  =  1;  [BUGGY]  result  =  prime  *  result  +((  value.hashCode  ())  ;  return  result;  }        [CLASS]  TypedValue    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  int    prime    result    String    value    boolean    
result  =  prime  *  result  +  (  (  value  ==  null  )  ?  0  :  value.hashCode  (  )  )  ;	[BUGGY]  result  =  prime  *  result  +  (  (  value  ==  null)  ?  0  :  value  .hashCode(  )  );  [CONTEXT]  public  int  hashCode()  {  final  int  prime  =  31;  int  result  =  1;  [BUGGY]  result  =  prime  *  result  +((  value  ==  null  )?  0  :  value  .hashCode  ()  )  ;  return  result;  }        [CLASS]  TypedValue    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  int    prime    result    String    value    boolean    
result  =  prime  *  result  +  (  (  value  ==  null  )  ?  0  :  value.hashCode  (  )  )  ;	[BUGGY]  result  =  prime  *  result  +  (  (  value  ==  false)  ?  0  :  value.hashCode(  ));  [CONTEXT]  public  int  hashCode()  {  final  int  prime  =  31;  int  result  =  1;  [BUGGY]  result  =  prime  *  result  +((  value  ==  false  )?  0  :  value.hashCode  ())  ;  return  result;  }        [CLASS]  TypedValue    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  int    prime    result    String    value    boolean    
result  =  prime  *  result  +  (  (  value  ==  null  )  ?  0  :  value.hashCode  (  )  )  ;  return  result;	[BUGGY]  return  result;  result  =  prime  *  result  +  (  (  value  ==  null)  ?  0  :  value.hashCode(  ));  [CONTEXT]        [CLASS]  TypedValue    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  int    prime    result    String    value    boolean    
result  =  prime  *  result  +  (  (  value  ==  null  )  ?  0  :  value.hashCode  (  )  )  ;  return  result;	[BUGGY]  result  =  prime  *  result  +  (  (  value  ==  null)  ?  0  :  value.hashCode(  ));result  =  prime  *  result  +  (  (  value  ==  null)  ?  0  :  value.hashCode(  ));  return  result;  [CONTEXT]        [CLASS]  TypedValue    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  int    prime    result    String    value    boolean    
result  =  prime  *  result  +  (  (  value  ==  null  )  ?  0  :  value.hashCode  (  )  )  ;	[BUGGY]    [CONTEXT]  public  int  hashCode()  {  final  int  prime  =  31;  int  result  =  1;  [BUGGY]  result  =  prime  *  result  +  ((value  ==  null)  ?  0  :  value.hashCode());    return  result;        [CLASS]  TypedValue    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  int    prime    result    String    value    boolean    
return  result;	[BUGGY]  return  prime;  [CONTEXT]  public  int  hashCode()  {  final  int  prime  =  31;  int  result  =  1;  result  =  prime  *  result  +  ((value  ==  null)  ?  0  :  value.hashCode());  [BUGGY]  return  prime;  }        [CLASS]  TypedValue    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  int    prime    result    String    value    boolean    
if  (  this  ==  obj  )  return  true;	[BUGGY]  if  (  this  >=  obj)  return  true;  [CONTEXT]  public  boolean  equals(Object  obj)  {  [BUGGY]  if(  this  >=  obj  )return  true;  if  (obj  ==  null)  return  false;  if  (getClass()  !=  obj.getClass())  return  false;  TypedValue  other  =  (TypedValue)  obj;  if  (value  ==  null)  {  if  (other.value  !=  null)  return  false;  }  else  if  (!value.equals(other.value))  return  false;  return  true;  }        [CLASS]  TypedValue    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  obj  [VARIABLES]  Object    obj    String    value    boolean    TypedValue    other    
if  (  this  ==  obj  )  return  true;	[BUGGY]  if  (  this  ==  obj)  return  false;  [CONTEXT]  public  boolean  equals(Object  obj)  {  [BUGGY]  if(  this  ==  obj  )return  false;  if  (obj  ==  null)  return  false;  if  (getClass()  !=  obj.getClass())  return  false;  TypedValue  other  =  (TypedValue)  obj;  if  (value  ==  null)  {  if  (other.value  !=  null)  return  false;  }  else  if  (!value.equals(other.value))  return  false;  return  true;  }        [CLASS]  TypedValue    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  obj  [VARIABLES]  Object    obj    String    value    boolean    TypedValue    other    
if  (  obj  ==  null  )  return  false;	[BUGGY]  if  (  obj  !=  null)  return  false;  [CONTEXT]  public  boolean  equals(Object  obj)  {  if  (this  ==  obj)  return  true;  [BUGGY]  if(  obj  !=  null  )return  false;  if  (getClass()  !=  obj.getClass())  return  false;  TypedValue  other  =  (TypedValue)  obj;  if  (value  ==  null)  {  if  (other.value  !=  null)  return  false;  }  else  if  (!value.equals(other.value))  return  false;  return  true;  }        [CLASS]  TypedValue    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  obj  [VARIABLES]  Object    obj    String    value    boolean    TypedValue    other    
if  (  obj  ==  null  )  return  false;	[BUGGY]  if  (  obj  ==  null)  return  true;  [CONTEXT]  public  boolean  equals(Object  obj)  {  if  (this  ==  obj)  return  true;  [BUGGY]  if(  obj  ==  null  )return  true;  if  (getClass()  !=  obj.getClass())  return  false;  TypedValue  other  =  (TypedValue)  obj;  if  (value  ==  null)  {  if  (other.value  !=  null)  return  false;  }  else  if  (!value.equals(other.value))  return  false;  return  true;  }        [CLASS]  TypedValue    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  obj  [VARIABLES]  Object    obj    String    value    boolean    TypedValue    other    
if  (  obj  ==  null  )  return  false;	[BUGGY]  if  (  obj  ==  this)  return  false;  [CONTEXT]  public  boolean  equals(Object  obj)  {  if  (this  ==  obj)  return  true;  [BUGGY]  if(  obj  ==  this  )return  false;  if  (getClass()  !=  obj.getClass())  return  false;  TypedValue  other  =  (TypedValue)  obj;  if  (value  ==  null)  {  if  (other.value  !=  null)  return  false;  }  else  if  (!value.equals(other.value))  return  false;  return  true;  }        [CLASS]  TypedValue    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  obj  [VARIABLES]  Object    obj    String    value    boolean    TypedValue    other    
if  (  getClass  (  )  !=  obj.getClass  (  )  )  return  false;	[BUGGY]  if  (  getClass(  )  >=  obj.getClass(  ))  return  false;  [CONTEXT]  public  boolean  equals(Object  obj)  {  if  (this  ==  obj)  return  true;  if  (obj  ==  null)  return  false;  [BUGGY]  if(  getClass  ()>=  obj.getClass  ())return  false;  TypedValue  other  =  (TypedValue)  obj;  if  (value  ==  null)  {  if  (other.value  !=  null)  return  false;  }  else  if  (!value.equals(other.value))  return  false;  return  true;  }        [CLASS]  TypedValue    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  obj  [VARIABLES]  Object    obj    String    value    boolean    TypedValue    other    
if  (  getClass  (  )  !=  obj.getClass  (  )  )  return  false;	[BUGGY]  if  (  getClass(  )  !=  obj.getClass(  ))  return  true;  [CONTEXT]  public  boolean  equals(Object  obj)  {  if  (this  ==  obj)  return  true;  if  (obj  ==  null)  return  false;  [BUGGY]  if(  getClass  ()!=  obj.getClass  ())return  true;  TypedValue  other  =  (TypedValue)  obj;  if  (value  ==  null)  {  if  (other.value  !=  null)  return  false;  }  else  if  (!value.equals(other.value))  return  false;  return  true;  }        [CLASS]  TypedValue    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  obj  [VARIABLES]  Object    obj    String    value    boolean    TypedValue    other    
if  (  value  ==  null  )  {	[BUGGY]  if  (  value  !=  null)  {  [CONTEXT]  public  boolean  equals(Object  obj)  {  if  (this  ==  obj)  return  true;  if  (obj  ==  null)  return  false;  if  (getClass()  !=  obj.getClass())  return  false;  TypedValue  other  =  (TypedValue)  obj;  [BUGGY]  if(  value  !=  null  ){  if  (other.value  !=  null)  return  false;  }  else  if  (!value.equals(other.value))  return  false;  return  true;  }        [CLASS]  TypedValue    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  obj  [VARIABLES]  Object    obj    String    value    boolean    TypedValue    other    
if  (  value  ==  null  )  {	[BUGGY]  if  (  other.value  !=  null)  {  [CONTEXT]  public  boolean  equals(Object  obj)  {  if  (this  ==  obj)  return  true;  if  (obj  ==  null)  return  false;  if  (getClass()  !=  obj.getClass())  return  false;  TypedValue  other  =  (TypedValue)  obj;  [BUGGY]  if(  other.value  !=  null  ){  if  (other.value  !=  null)  return  false;  }  else  if  (!value.equals(other.value))  return  false;  return  true;  }        [CLASS]  TypedValue    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  obj  [VARIABLES]  Object    obj    String    value    boolean    TypedValue    other    
if  (  value  ==  null  )  {	[BUGGY]  if  (  value  ==  false)  {  [CONTEXT]  public  boolean  equals(Object  obj)  {  if  (this  ==  obj)  return  true;  if  (obj  ==  null)  return  false;  if  (getClass()  !=  obj.getClass())  return  false;  TypedValue  other  =  (TypedValue)  obj;  [BUGGY]  if(  value  ==  false  ){  if  (other.value  !=  null)  return  false;  }  else  if  (!value.equals(other.value))  return  false;  return  true;  }        [CLASS]  TypedValue    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  obj  [VARIABLES]  Object    obj    String    value    boolean    TypedValue    other    
if  (  value  ==  null  )  {  if  (  other.value  !=  null  )  return  false;  }  else  if  (  !value.equals  (  other.value  )  )  return  false;  return  true;  }	[BUGGY]  if((other.value)  !=  null)        return  false;;  [CONTEXT]  public  boolean  equals(Object  obj)  {  if  (this  ==  obj)  return  true;  if  (obj  ==  null)  return  false;  if  (getClass()  !=  obj.getClass())  return  false;  TypedValue  other  =  (TypedValue)  obj;  [BUGGY]  if  (value  ==  null)  {    if  ((other.value)  !=  null)return  false;;            [CLASS]  TypedValue    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  obj  [VARIABLES]  Object    obj    String    value    boolean    TypedValue    other    
if  (  value  ==  null  )  {  if  (  other.value  !=  null  )  return  false;  }  else  if  (  !value.equals  (  other.value  )  )  return  false;  return  true;  }	[BUGGY]    [CONTEXT]  public  boolean  equals(Object  obj)  {  if  (this  ==  obj)  return  true;  if  (obj  ==  null)  return  false;  if  (getClass()  !=  obj.getClass())  return  false;  TypedValue  other  =  (TypedValue)  obj;  [BUGGY]  if  (value  ==  null)  {                [CLASS]  TypedValue    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  obj  [VARIABLES]  Object    obj    String    value    boolean    TypedValue    other    
}  else  if  (  !value.equals  (  other.value  )  )  return  false;	[BUGGY]    else  if  (  !value.equals(  other.value))  return  true;  [CONTEXT]  public  boolean  equals(Object  obj)  {  if  (this  ==  obj)  return  true;  if  (obj  ==  null)  return  false;  if  (getClass()  !=  obj.getClass())  return  false;  TypedValue  other  =  (TypedValue)  obj;  if  (value  ==  null)  {  if  (other.value  !=  null)  return  false;  [BUGGY]  }  else  if(  !value.equals  (  other.value  ))return  true;  return  true;  }        [CLASS]  TypedValue    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  obj  [VARIABLES]  Object    obj    String    value    boolean    TypedValue    other    
}  else  if  (  !value.equals  (  other.value  )  )  return  false;	[BUGGY]    else  if  (  !value.equals(  other.value.value))  return  false;  [CONTEXT]  public  boolean  equals(Object  obj)  {  if  (this  ==  obj)  return  true;  if  (obj  ==  null)  return  false;  if  (getClass()  !=  obj.getClass())  return  false;  TypedValue  other  =  (TypedValue)  obj;  if  (value  ==  null)  {  if  (other.value  !=  null)  return  false;  [BUGGY]  }  else  if(  !value.equals  (  other.value.value  ))return  false;  return  true;  }        [CLASS]  TypedValue    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  obj  [VARIABLES]  Object    obj    String    value    boolean    TypedValue    other    
}  else  if  (  !value.equals  (  other.value  )  )  return  false;	[BUGGY]    else  if  (  !value  .TypedValue(  value)  )  return  false;  [CONTEXT]  public  boolean  equals(Object  obj)  {  if  (this  ==  obj)  return  true;  if  (obj  ==  null)  return  false;  if  (getClass()  !=  obj.getClass())  return  false;  TypedValue  other  =  (TypedValue)  obj;  if  (value  ==  null)  {  if  (other.value  !=  null)  return  false;  [BUGGY]  }  else  if(  !value  .TypedValue  (  value  )  )return  false;  return  true;  }        [CLASS]  TypedValue    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  obj  [VARIABLES]  Object    obj    String    value    boolean    TypedValue    other    
}  else  if  (  !value.equals  (  other.value  )  )  return  false;  return  true;  }	[BUGGY]    [CONTEXT]  public  boolean  equals(Object  obj)  {  if  (this  ==  obj)  return  true;  if  (obj  ==  null)  return  false;  if  (getClass()  !=  obj.getClass())  return  false;  TypedValue  other  =  (TypedValue)  obj;  if  (value  ==  null)  {  if  (other.value  !=  null)  return  false;  [BUGGY]  }  else  if  (!value.equals(other.value))  return  false;            [CLASS]  TypedValue    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  obj  [VARIABLES]  Object    obj    String    value    boolean    TypedValue    other    
if  (  other.value  !=  null  )  return  false;	[BUGGY]  if  (  other.value  ==  null)  return  false;  [CONTEXT]  public  boolean  equals(Object  obj)  {  if  (this  ==  obj)  return  true;  if  (obj  ==  null)  return  false;  if  (getClass()  !=  obj.getClass())  return  false;  TypedValue  other  =  (TypedValue)  obj;  if  (value  ==  null)  {  [BUGGY]  if(  other.value  ==  null  )return  false;  }  else  if  (!value.equals(other.value))  return  false;  return  true;  }        [CLASS]  TypedValue    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  obj  [VARIABLES]  Object    obj    String    value    boolean    TypedValue    other    
if  (  other.value  !=  null  )  return  false;	[BUGGY]  if  (  other.value  !=  null)  return  true;  [CONTEXT]  public  boolean  equals(Object  obj)  {  if  (this  ==  obj)  return  true;  if  (obj  ==  null)  return  false;  if  (getClass()  !=  obj.getClass())  return  false;  TypedValue  other  =  (TypedValue)  obj;  if  (value  ==  null)  {  [BUGGY]  if(  other.value  !=  null  )return  true;  }  else  if  (!value.equals(other.value))  return  false;  return  true;  }        [CLASS]  TypedValue    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  obj  [VARIABLES]  Object    obj    String    value    boolean    TypedValue    other    
if  (  other.value  !=  null  )  return  false;	[BUGGY]  if  (  value  !=  null)  return  false;  [CONTEXT]  public  boolean  equals(Object  obj)  {  if  (this  ==  obj)  return  true;  if  (obj  ==  null)  return  false;  if  (getClass()  !=  obj.getClass())  return  false;  TypedValue  other  =  (TypedValue)  obj;  if  (value  ==  null)  {  [BUGGY]  if(  value  !=  null  )return  false;  }  else  if  (!value.equals(other.value))  return  false;  return  true;  }        [CLASS]  TypedValue    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  obj  [VARIABLES]  Object    obj    String    value    boolean    TypedValue    other    
if  (  other.value  !=  null  )  return  false;	[BUGGY]  if  (  other.value.value  !=  null)  return  false;  [CONTEXT]  public  boolean  equals(Object  obj)  {  if  (this  ==  obj)  return  true;  if  (obj  ==  null)  return  false;  if  (getClass()  !=  obj.getClass())  return  false;  TypedValue  other  =  (TypedValue)  obj;  if  (value  ==  null)  {  [BUGGY]  if(  other.value.value  !=  null  )return  false;  }  else  if  (!value.equals(other.value))  return  false;  return  true;  }        [CLASS]  TypedValue    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  obj  [VARIABLES]  Object    obj    String    value    boolean    TypedValue    other    
if  (  other.value  !=  null  )  return  false;	[BUGGY]  if  (  other  !=  null)  return  false;  [CONTEXT]  public  boolean  equals(Object  obj)  {  if  (this  ==  obj)  return  true;  if  (obj  ==  null)  return  false;  if  (getClass()  !=  obj.getClass())  return  false;  TypedValue  other  =  (TypedValue)  obj;  if  (value  ==  null)  {  [BUGGY]  if(  other  !=  null  )return  false;  }  else  if  (!value.equals(other.value))  return  false;  return  true;  }        [CLASS]  TypedValue    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  obj  [VARIABLES]  Object    obj    String    value    boolean    TypedValue    other    
if  (  other.value  !=  null  )  return  false;	[BUGGY]  if  (  value  !=  this)  return  false;  [CONTEXT]  public  boolean  equals(Object  obj)  {  if  (this  ==  obj)  return  true;  if  (obj  ==  null)  return  false;  if  (getClass()  !=  obj.getClass())  return  false;  TypedValue  other  =  (TypedValue)  obj;  if  (value  ==  null)  {  [BUGGY]  if(  value  !=  this  )return  false;  }  else  if  (!value.equals(other.value))  return  false;  return  true;  }        [CLASS]  TypedValue    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  obj  [VARIABLES]  Object    obj    String    value    boolean    TypedValue    other    
if  (  other.value  !=  null  )  return  false;  }  else  if  (  !value.equals  (  other.value  )  )  return  false;  return  true;  }	[BUGGY]  return  false;  [CONTEXT]  public  boolean  equals(Object  obj)  {  if  (this  ==  obj)  return  true;  if  (obj  ==  null)  return  false;  if  (getClass()  !=  obj.getClass())  return  false;  TypedValue  other  =  (TypedValue)  obj;  if  (value  ==  null)  {  [BUGGY]  if  (other.value  !=  null)  return  false;    return  false;          [CLASS]  TypedValue    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  obj  [VARIABLES]  Object    obj    String    value    boolean    TypedValue    other    
if  (  other.value  !=  null  )  return  false;  }  else  if  (  !value.equals  (  other.value  )  )  return  false;  return  true;  }	[BUGGY]    [CONTEXT]  public  boolean  equals(Object  obj)  {  if  (this  ==  obj)  return  true;  if  (obj  ==  null)  return  false;  if  (getClass()  !=  obj.getClass())  return  false;  TypedValue  other  =  (TypedValue)  obj;  if  (value  ==  null)  {  [BUGGY]  if  (other.value  !=  null)  return  false;              [CLASS]  TypedValue    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  obj  [VARIABLES]  Object    obj    String    value    boolean    TypedValue    other    
if  (  other.value  !=  null  )  return  false;	[BUGGY]  if  (  other.value  !=  false)  return  false;  [CONTEXT]  public  boolean  equals(Object  obj)  {  if  (this  ==  obj)  return  true;  if  (obj  ==  null)  return  false;  if  (getClass()  !=  obj.getClass())  return  false;  TypedValue  other  =  (TypedValue)  obj;  if  (value  ==  null)  {  [BUGGY]  if(  other.value  !=  false  )return  false;  }  else  if  (!value.equals(other.value))  return  false;  return  true;  }        [CLASS]  TypedValue    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  obj  [VARIABLES]  Object    obj    String    value    boolean    TypedValue    other    
}  else  if  (  !value.equals  (  other.value  )  )  return  false;	[BUGGY]    else  if  (  !value.equals(  value))  return  false;  [CONTEXT]  public  boolean  equals(Object  obj)  {  if  (this  ==  obj)  return  true;  if  (obj  ==  null)  return  false;  if  (getClass()  !=  obj.getClass())  return  false;  TypedValue  other  =  (TypedValue)  obj;  if  (value  ==  null)  {  if  (other.value  !=  null)  return  false;  [BUGGY]  }  else  if(  !value.equals  (  value  ))return  false;  return  true;  }        [CLASS]  TypedValue    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  obj  [VARIABLES]  Object    obj    String    value    boolean    TypedValue    other    
}  else  if  (  !value.equals  (  other.value  )  )  return  false;	[BUGGY]      if  (  !value.equals(  other.value))  return  true;  [CONTEXT]  public  boolean  equals(Object  obj)  {  if  (this  ==  obj)  return  true;  if  (obj  ==  null)  return  false;  if  (getClass()  !=  obj.getClass())  return  false;  TypedValue  other  =  (TypedValue)  obj;  if  (value  ==  null)  {  if  (other.value  !=  null)  return  false;  [BUGGY]  }if(  !value.equals  (  other.value  ))return  true;  return  true;  }        [CLASS]  TypedValue    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  obj  [VARIABLES]  Object    obj    String    value    boolean    TypedValue    other    
}  else  if  (  !value.equals  (  other.value  )  )  return  false;  return  true;  }	[BUGGY]  return  false;  [CONTEXT]  public  boolean  equals(Object  obj)  {  if  (this  ==  obj)  return  true;  if  (obj  ==  null)  return  false;  if  (getClass()  !=  obj.getClass())  return  false;  TypedValue  other  =  (TypedValue)  obj;  if  (value  ==  null)  {  if  (other.value  !=  null)  return  false;  [BUGGY]  }  else  if  (!value.equals(other.value))  return  false;    return  false;        [CLASS]  TypedValue    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  obj  [VARIABLES]  Object    obj    String    value    boolean    TypedValue    other    
return  true;	[BUGGY]  return  false;  [CONTEXT]  public  boolean  equals(Object  obj)  {  if  (this  ==  obj)  return  true;  if  (obj  ==  null)  return  false;  if  (getClass()  !=  obj.getClass())  return  false;  TypedValue  other  =  (TypedValue)  obj;  if  (value  ==  null)  {  if  (other.value  !=  null)  return  false;  }  else  if  (!value.equals(other.value))  return  false;  [BUGGY]  return  false;  }        [CLASS]  TypedValue    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  obj  [VARIABLES]  Object    obj    String    value    boolean    TypedValue    other    
contents  =  new  ArrayList<Element>  (  )  ;	[BUGGY]  contents  =  contents  =    new  Element>(  elements)  ;  [CONTEXT]  public  Elements()  {  [BUGGY]  contents  =  contents  =new  Element>  (  elements  );  }        [CLASS]  Elements    [METHOD]  <init>  [RETURN_TYPE]  Elements()      [VARIABLES]  List    contents    boolean    
contents  =  new  ArrayList<Element>  (  )  ;	[BUGGY]  contents  =    new  Element>(  elements)  ;  [CONTEXT]  public  Elements()  {  [BUGGY]  contents  =new  Element>  (  elements  );  }        [CLASS]  Elements    [METHOD]  <init>  [RETURN_TYPE]  Elements()      [VARIABLES]  List    contents    boolean    
contents  =  new  ArrayList<Element>  (  elements  )  ;	[BUGGY]  contents  =  contents  =    new  Element>(  )  ;  [CONTEXT]  public  Elements(Collection<Element>  elements)  {  [BUGGY]  contents  =  contents  =new  Element>  ();  }        [CLASS]  Elements    [METHOD]  <init>  [RETURN_TYPE]  Collection)      Element>  elements  [VARIABLES]  Collection    elements    List    contents    boolean    
contents  =  new  ArrayList<Element>  (  elements  )  ;	[BUGGY]  contents  =    new  ArrayList<Element>(  null);  [CONTEXT]  public  Elements(Collection<Element>  elements)  {  [BUGGY]  contents  =new  ArrayList<Element>  (  null  )  ;  }        [CLASS]  Elements    [METHOD]  <init>  [RETURN_TYPE]  Collection)      Element>  elements  [VARIABLES]  Collection    elements    List    contents    boolean    
contents  =  elements;	[BUGGY]  contents  =    null;  [CONTEXT]  public  Elements(List<Element>  elements)  {  [BUGGY]  contents  =null;  }        [CLASS]  Elements    [METHOD]  <init>  [RETURN_TYPE]  List)      Element>  elements  [VARIABLES]  List    contents    elements    boolean    
this  (  Arrays.asList  (  elements  )  )  ;	[BUGGY]    [CONTEXT]  public  Elements(Element...  elements)  {  [BUGGY]  this(Arrays.asList(elements));          [CLASS]  Elements    [METHOD]  <init>  [RETURN_TYPE]  Element[])        elements  [VARIABLES]  List    contents    elements    Element[]    elements    boolean    
if  (  element.hasAttr  (  attributeKey  )  )  return  element.attr  (  attributeKey  )  ;	[BUGGY]  if  (  attributeKey.hasAttr(  element))return  element.attr(  attributeKey);  [CONTEXT]  public  String  attr(String  attributeKey)  {  for  (Element  element  :  contents)  {  [BUGGY]  if(  attributeKey.hasAttr  (  element  ))  return  element.attr  (  attributeKey  )  ;    }  return   " ";  }        [CLASS]  Elements    [METHOD]  attr  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  List    contents    elements    String    attributeKey    boolean    Element    element    
if  (  element.hasAttr  (  attributeKey  )  )  return  element.attr  (  attributeKey  )  ;	[BUGGY]  if  (  element  .attr(  attributeKey)  )return  element.attr(  attributeKey);  [CONTEXT]  public  String  attr(String  attributeKey)  {  for  (Element  element  :  contents)  {  [BUGGY]  if(  element  .attr  (  attributeKey  )  )  return  element.attr  (  attributeKey  )  ;    }  return   " ";  }        [CLASS]  Elements    [METHOD]  attr  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  List    contents    elements    String    attributeKey    boolean    Element    element    
if  (  element.hasAttr  (  attributeKey  )  )  return  element.attr  (  attributeKey  )  ;  }	[BUGGY]  return  element.attr(attributeKey);  [CONTEXT]  public  String  attr(String  attributeKey)  {  for  (Element  element  :  contents)  {  [BUGGY]  if  (element.hasAttr(attributeKey))    return  element.attr(attributeKey);    return   " ";        [CLASS]  Elements    [METHOD]  attr  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  List    contents    elements    String    attributeKey    boolean    Element    element    
if  (  element.hasAttr  (  attributeKey  )  )  return  element.attr  (  attributeKey  )  ;  }	[BUGGY]    [CONTEXT]  public  String  attr(String  attributeKey)  {  for  (Element  element  :  contents)  {  [BUGGY]  if  (element.hasAttr(attributeKey))        return   " ";        [CLASS]  Elements    [METHOD]  attr  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  List    contents    elements    String    attributeKey    boolean    Element    element    
return  element.attr  (  attributeKey  )  ;	[BUGGY]  return  attributeKey.attr(  element);  [CONTEXT]  public  String  attr(String  attributeKey)  {  for  (Element  element  :  contents)  {  if  (element.hasAttr(attributeKey))  [BUGGY]  return  attributeKey.attr  (  element  )  ;  }  return   " ";  }        [CLASS]  Elements    [METHOD]  attr  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  List    contents    elements    String    attributeKey    boolean    Element    element    
return  element.attr  (  attributeKey  )  ;	[BUGGY]  return  element  .attr(  attributeKey)  ;  [CONTEXT]  public  String  attr(String  attributeKey)  {  for  (Element  element  :  contents)  {  if  (element.hasAttr(attributeKey))  [BUGGY]  return  element  .attr  (  attributeKey  );  }  return   " ";  }        [CLASS]  Elements    [METHOD]  attr  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  List    contents    elements    String    attributeKey    boolean    Element    element    
return  element.attr  (  attributeKey  )  ;	[BUGGY]    [CONTEXT]  public  String  attr(String  attributeKey)  {  for  (Element  element  :  contents)  {  if  (element.hasAttr(attributeKey))  [BUGGY]  return  element.attr(attributeKey);    }  return   " ";        [CLASS]  Elements    [METHOD]  attr  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  List    contents    elements    String    attributeKey    boolean    Element    element    
if  (  element.hasAttr  (  attributeKey  )  )  return  true;	[BUGGY]  if  (  element.hasAttr(  attributeKey))return  false;  [CONTEXT]  public  boolean  hasAttr(String  attributeKey)  {  for  (Element  element  :  contents)  {  [BUGGY]  if(  element.hasAttr  (  attributeKey  ))  return  false;    }  return  false;  }        [CLASS]  Elements    [METHOD]  hasAttr  [RETURN_TYPE]  boolean      String  attributeKey  [VARIABLES]  List    contents    elements    String    attributeKey    boolean    Element    element    
if  (  element.hasAttr  (  attributeKey  )  )  return  true;	[BUGGY]  if  (  attributeKey.hasAttr(  element))return  true;  [CONTEXT]  public  boolean  hasAttr(String  attributeKey)  {  for  (Element  element  :  contents)  {  [BUGGY]  if(  attributeKey.hasAttr  (  element  ))  return  true;    }  return  false;  }        [CLASS]  Elements    [METHOD]  hasAttr  [RETURN_TYPE]  boolean      String  attributeKey  [VARIABLES]  List    contents    elements    String    attributeKey    boolean    Element    element    
if  (  element.hasAttr  (  attributeKey  )  )  return  true;	[BUGGY]  if  (  element  .attr(  attributeKey)  )return  true;  [CONTEXT]  public  boolean  hasAttr(String  attributeKey)  {  for  (Element  element  :  contents)  {  [BUGGY]  if(  element  .attr  (  attributeKey  )  )  return  true;    }  return  false;  }        [CLASS]  Elements    [METHOD]  hasAttr  [RETURN_TYPE]  boolean      String  attributeKey  [VARIABLES]  List    contents    elements    String    attributeKey    boolean    Element    element    
if  (  element.hasAttr  (  attributeKey  )  )  return  true;  }	[BUGGY]  return  true;  [CONTEXT]  public  boolean  hasAttr(String  attributeKey)  {  for  (Element  element  :  contents)  {  [BUGGY]  if  (element.hasAttr(attributeKey))    return  true;    return  false;        [CLASS]  Elements    [METHOD]  hasAttr  [RETURN_TYPE]  boolean      String  attributeKey  [VARIABLES]  List    contents    elements    String    attributeKey    boolean    Element    element    
if  (  element.hasAttr  (  attributeKey  )  )  return  true;  }	[BUGGY]    [CONTEXT]  public  boolean  hasAttr(String  attributeKey)  {  for  (Element  element  :  contents)  {  [BUGGY]  if  (element.hasAttr(attributeKey))        return  false;        [CLASS]  Elements    [METHOD]  hasAttr  [RETURN_TYPE]  boolean      String  attributeKey  [VARIABLES]  List    contents    elements    String    attributeKey    boolean    Element    element    
return  true;	[BUGGY]  return  false;  [CONTEXT]  public  boolean  hasAttr(String  attributeKey)  {  for  (Element  element  :  contents)  {  if  (element.hasAttr(attributeKey))  [BUGGY]  return  false;  }  return  false;  }        [CLASS]  Elements    [METHOD]  hasAttr  [RETURN_TYPE]  boolean      String  attributeKey  [VARIABLES]  List    contents    elements    String    attributeKey    boolean    Element    element    
return  false;	[BUGGY]  return  true;  [CONTEXT]  public  boolean  hasAttr(String  attributeKey)  {  for  (Element  element  :  contents)  {  if  (element.hasAttr(attributeKey))  return  true;  }  [BUGGY]  return  true;  }        [CLASS]  Elements    [METHOD]  hasAttr  [RETURN_TYPE]  boolean      String  attributeKey  [VARIABLES]  List    contents    elements    String    attributeKey    boolean    Element    element    
element.attr  (  attributeKey,  attributeValue  )  ;	[BUGGY]  element.attr(  attributeValue,  attributeValue);  [CONTEXT]  public  Elements  attr(String  attributeKey,  String  attributeValue)  {  for  (Element  element  :  contents)  {  [BUGGY]  element.attr  (  attributeValue,  attributeValue  )  ;  }  return  this;  }        [CLASS]  Elements    [METHOD]  attr  [RETURN_TYPE]  Elements      String  attributeKey  String  attributeValue  [VARIABLES]  List    contents    elements    String    attributeKey    attributeValue    boolean    Element    element    
element.attr  (  attributeKey,  attributeValue  )  ;	[BUGGY]  element.attr(  attributeValue,  attributeKey);  [CONTEXT]  public  Elements  attr(String  attributeKey,  String  attributeValue)  {  for  (Element  element  :  contents)  {  [BUGGY]  element.attr  (  attributeValue,  attributeKey  )  ;  }  return  this;  }        [CLASS]  Elements    [METHOD]  attr  [RETURN_TYPE]  Elements      String  attributeKey  String  attributeValue  [VARIABLES]  List    contents    elements    String    attributeKey    attributeValue    boolean    Element    element    
element.attr  (  attributeKey,  attributeValue  )  ;	[BUGGY]  element.attr(    attributeValue);  [CONTEXT]  public  Elements  attr(String  attributeKey,  String  attributeValue)  {  for  (Element  element  :  contents)  {  [BUGGY]  element.attr  (attributeValue  )  ;  }  return  this;  }        [CLASS]  Elements    [METHOD]  attr  [RETURN_TYPE]  Elements      String  attributeKey  String  attributeValue  [VARIABLES]  List    contents    elements    String    attributeKey    attributeValue    boolean    Element    element    
element.attr  (  attributeKey,  attributeValue  )  ;	[BUGGY]  element.attr(  attributeKey);  [CONTEXT]  public  Elements  attr(String  attributeKey,  String  attributeValue)  {  for  (Element  element  :  contents)  {  [BUGGY]  element.attr  (  attributeKey  )  ;  }  return  this;  }        [CLASS]  Elements    [METHOD]  attr  [RETURN_TYPE]  Elements      String  attributeKey  String  attributeValue  [VARIABLES]  List    contents    elements    String    attributeKey    attributeValue    boolean    Element    element    
element.attr  (  attributeKey,  attributeValue  )  ;	[BUGGY]    [CONTEXT]  public  Elements  attr(String  attributeKey,  String  attributeValue)  {  for  (Element  element  :  contents)  {  [BUGGY]  element.attr(attributeKey,  attributeValue);    }  return  this;        [CLASS]  Elements    [METHOD]  attr  [RETURN_TYPE]  Elements      String  attributeKey  String  attributeValue  [VARIABLES]  List    contents    elements    String    attributeKey    attributeValue    boolean    Element    element    
return  this;	[BUGGY]  return  null;  [CONTEXT]  public  Elements  attr(String  attributeKey,  String  attributeValue)  {  for  (Element  element  :  contents)  {  element.attr(attributeKey,  attributeValue);  }  [BUGGY]  return  null;  }        [CLASS]  Elements    [METHOD]  attr  [RETURN_TYPE]  Elements      String  attributeKey  String  attributeValue  [VARIABLES]  List    contents    elements    String    attributeKey    attributeValue    boolean    Element    element    
element.removeAttr  (  attributeKey  )  ;	[BUGGY]  element  .removeClass(  attributeKey)  ;  [CONTEXT]  public  Elements  removeAttr(String  attributeKey)  {  for  (Element  element  :  contents)  {  [BUGGY]  element  .removeClass  (  attributeKey  );  }  return  this;  }        [CLASS]  Elements    [METHOD]  removeAttr  [RETURN_TYPE]  Elements      String  attributeKey  [VARIABLES]  List    contents    elements    String    attributeKey    boolean    Element    element    
element.removeAttr  (  attributeKey  )  ;	[BUGGY]    [CONTEXT]  public  Elements  removeAttr(String  attributeKey)  {  for  (Element  element  :  contents)  {  [BUGGY]  element.removeAttr(attributeKey);    }  return  this;        [CLASS]  Elements    [METHOD]  removeAttr  [RETURN_TYPE]  Elements      String  attributeKey  [VARIABLES]  List    contents    elements    String    attributeKey    boolean    Element    element    
return  this;	[BUGGY]  return  null;  [CONTEXT]  public  Elements  removeAttr(String  attributeKey)  {  for  (Element  element  :  contents)  {  element.removeAttr(attributeKey);  }  [BUGGY]  return  null;  }        [CLASS]  Elements    [METHOD]  removeAttr  [RETURN_TYPE]  Elements      String  attributeKey  [VARIABLES]  List    contents    elements    String    attributeKey    boolean    Element    element    
element.addClass  (  className  )  ;	[BUGGY]    [CONTEXT]  public  Elements  addClass(String  className)  {  for  (Element  element  :  contents)  {  [BUGGY]  element.addClass(className);    }  return  this;        [CLASS]  Elements    [METHOD]  addClass  [RETURN_TYPE]  Elements      String  className  [VARIABLES]  List    contents    elements    String    className    boolean    Element    element    
return  this;	[BUGGY]  return  null;  [CONTEXT]  public  Elements  addClass(String  className)  {  for  (Element  element  :  contents)  {  element.addClass(className);  }  [BUGGY]  return  null;  }        [CLASS]  Elements    [METHOD]  addClass  [RETURN_TYPE]  Elements      String  className  [VARIABLES]  List    contents    elements    String    className    boolean    Element    element    
element.removeClass  (  className  )  ;	[BUGGY]    [CONTEXT]  public  Elements  removeClass(String  className)  {  for  (Element  element  :  contents)  {  [BUGGY]  element.removeClass(className);    }  return  this;        [CLASS]  Elements    [METHOD]  removeClass  [RETURN_TYPE]  Elements      String  className  [VARIABLES]  List    contents    elements    String    className    boolean    Element    element    
return  this;	[BUGGY]  return  null;  [CONTEXT]  public  Elements  removeClass(String  className)  {  for  (Element  element  :  contents)  {  element.removeClass(className);  }  [BUGGY]  return  null;  }        [CLASS]  Elements    [METHOD]  removeClass  [RETURN_TYPE]  Elements      String  className  [VARIABLES]  List    contents    elements    String    className    boolean    Element    element    
element.toggleClass  (  className  )  ;	[BUGGY]    [CONTEXT]  public  Elements  toggleClass(String  className)  {  for  (Element  element  :  contents)  {  [BUGGY]  element.toggleClass(className);    }  return  this;        [CLASS]  Elements    [METHOD]  toggleClass  [RETURN_TYPE]  Elements      String  className  [VARIABLES]  List    contents    elements    String    className    boolean    Element    element    
return  this;	[BUGGY]  return  null;  [CONTEXT]  public  Elements  toggleClass(String  className)  {  for  (Element  element  :  contents)  {  element.toggleClass(className);  }  [BUGGY]  return  null;  }        [CLASS]  Elements    [METHOD]  toggleClass  [RETURN_TYPE]  Elements      String  className  [VARIABLES]  List    contents    elements    String    className    boolean    Element    element    
if  (  element.hasClass  (  className  )  )  return  true;	[BUGGY]  if  (  element.hasClass(  className))return  false;  [CONTEXT]  public  boolean  hasClass(String  className)  {  for  (Element  element  :  contents)  {  [BUGGY]  if(  element.hasClass  (  className  ))  return  false;    }  return  false;  }        [CLASS]  Elements    [METHOD]  hasClass  [RETURN_TYPE]  boolean      String  className  [VARIABLES]  List    contents    elements    String    className    boolean    Element    element    
if  (  element.hasClass  (  className  )  )  return  true;	[BUGGY]  if  (  className.hasClass(  element))return  true;  [CONTEXT]  public  boolean  hasClass(String  className)  {  for  (Element  element  :  contents)  {  [BUGGY]  if(  className.hasClass  (  element  ))  return  true;    }  return  false;  }        [CLASS]  Elements    [METHOD]  hasClass  [RETURN_TYPE]  boolean      String  className  [VARIABLES]  List    contents    elements    String    className    boolean    Element    element    
if  (  element.hasClass  (  className  )  )  return  true;  }	[BUGGY]  return  true;  [CONTEXT]  public  boolean  hasClass(String  className)  {  for  (Element  element  :  contents)  {  [BUGGY]  if  (element.hasClass(className))    return  true;    return  false;        [CLASS]  Elements    [METHOD]  hasClass  [RETURN_TYPE]  boolean      String  className  [VARIABLES]  List    contents    elements    String    className    boolean    Element    element    
if  (  element.hasClass  (  className  )  )  return  true;  }	[BUGGY]    [CONTEXT]  public  boolean  hasClass(String  className)  {  for  (Element  element  :  contents)  {  [BUGGY]  if  (element.hasClass(className))        return  false;        [CLASS]  Elements    [METHOD]  hasClass  [RETURN_TYPE]  boolean      String  className  [VARIABLES]  List    contents    elements    String    className    boolean    Element    element    
return  true;	[BUGGY]  return  false;  [CONTEXT]  public  boolean  hasClass(String  className)  {  for  (Element  element  :  contents)  {  if  (element.hasClass(className))  [BUGGY]  return  false;  }  return  false;  }        [CLASS]  Elements    [METHOD]  hasClass  [RETURN_TYPE]  boolean      String  className  [VARIABLES]  List    contents    elements    String    className    boolean    Element    element    
if  (  element.hasClass  (  className  )  )  return  true;	[BUGGY]  if  (  element  .addClass(  className)  )return  true;  [CONTEXT]  public  boolean  hasClass(String  className)  {  for  (Element  element  :  contents)  {  [BUGGY]  if(  element  .addClass  (  className  )  )  return  true;    }  return  false;  }        [CLASS]  Elements    [METHOD]  hasClass  [RETURN_TYPE]  boolean      String  className  [VARIABLES]  List    contents    elements    String    className    boolean    Element    element    
return  false;	[BUGGY]  return  true;  [CONTEXT]  public  boolean  hasClass(String  className)  {  for  (Element  element  :  contents)  {  if  (element.hasClass(className))  return  true;  }  [BUGGY]  return  true;  }        [CLASS]  Elements    [METHOD]  hasClass  [RETURN_TYPE]  boolean      String  className  [VARIABLES]  List    contents    elements    String    className    boolean    Element    element    
if  (  size  (  )  >  0  )  return  first  (  )  .val  (  )  ;	[BUGGY]  if  (  size(  )  >=  0)return  first(  ).val(  );  [CONTEXT]  public  String  val()  {  [BUGGY]  if(  size  ()>=  0  )  return  first  ()  .val  ()  ;    else  return   " ";  }        [CLASS]  Elements    [METHOD]  val  [RETURN_TYPE]  String      [VARIABLES]  List    contents    elements    boolean    
if  (  size  (  )  >  0  )  return  first  (  )  .val  (  )  ;	[BUGGY]  if  (  size(  )  >  -8)return  first(  ).val(  );  [CONTEXT]  public  String  val()  {  [BUGGY]  if(  size  ()>  -8  )  return  first  ()  .val  ()  ;    else  return   " ";  }        [CLASS]  Elements    [METHOD]  val  [RETURN_TYPE]  String      [VARIABLES]  List    contents    elements    boolean    
if  (  size  (  )  >  0  )  return  first  (  )  .val  (  )  ;	[BUGGY]  if  (  size()  +  3    >  0)return  first(  ).val(  );  [CONTEXT]  public  String  val()  {  [BUGGY]  if(  size()  +  3>  0  )  return  first  ()  .val  ()  ;    else  return   " ";  }        [CLASS]  Elements    [METHOD]  val  [RETURN_TYPE]  String      [VARIABLES]  List    contents    elements    boolean    
if  (  size  (  )  >  0  )  return  first  (  )  .val  (  )  ;	[BUGGY]  if  (  first(  )  >  0)return  first(  ).val(  );  [CONTEXT]  public  String  val()  {  [BUGGY]  if(  first  ()>  0  )  return  first  ()  .val  ()  ;    else  return   " ";  }        [CLASS]  Elements    [METHOD]  val  [RETURN_TYPE]  String      [VARIABLES]  List    contents    elements    boolean    
if  (  size  (  )  >  0  )  return  first  (  )  .val  (  )  ;	[BUGGY]  if  (  size(  )  >  0)return  first(  ).html(  );  [CONTEXT]  public  String  val()  {  [BUGGY]  if(  size  ()>  0  )  return  first  ()  .html  ()  ;    else  return   " ";  }        [CLASS]  Elements    [METHOD]  val  [RETURN_TYPE]  String      [VARIABLES]  List    contents    elements    boolean    
if  (  size  (  )  >  0  )  return  first  (  )  .val  (  )  ;	[BUGGY]  if  (  size(  )  >  0)return  size(  ).val(  );  [CONTEXT]  public  String  val()  {  [BUGGY]  if(  size  ()>  0  )  return  size  ()  .val  ()  ;    else  return   " ";  }        [CLASS]  Elements    [METHOD]  val  [RETURN_TYPE]  String      [VARIABLES]  List    contents    elements    boolean    
if  (  size  (  )  >  0  )  return  first  (  )  .val  (  )  ;	[BUGGY]  if  (  size(  )  >  0  )return  first(  ).val(  );  [CONTEXT]  public  String  val()  {  [BUGGY]  if(  size  ()>  0)  return  first  ()  .val  ()  ;    else  return   " ";  }        [CLASS]  Elements    [METHOD]  val  [RETURN_TYPE]  String      [VARIABLES]  List    contents    elements    boolean    
if  (  size  (  )  >  0  )  return  first  (  )  .val  (  )  ;  else  return   " ";  }	[BUGGY]  return  first().val();  [CONTEXT]  public  String  val()  {  [BUGGY]  if  (size()  >  0)    return  first().val();            [CLASS]  Elements    [METHOD]  val  [RETURN_TYPE]  String      [VARIABLES]  List    contents    elements    boolean    
if  (  size  (  )  >  0  )  return  first  (  )  .val  (  )  ;  else  return   " ";  }	[BUGGY]    [CONTEXT]  public  String  val()  {  [BUGGY]  if  (size()  >  0)                [CLASS]  Elements    [METHOD]  val  [RETURN_TYPE]  String      [VARIABLES]  List    contents    elements    boolean    
return  first  (  )  .val  (  )  ;	[BUGGY]  return  first(  ).html(  );  [CONTEXT]  public  String  val()  {  if  (size()  >  0)  [BUGGY]  return  first  ()  .html  ()  ;  else  return   " ";  }        [CLASS]  Elements    [METHOD]  val  [RETURN_TYPE]  String      [VARIABLES]  List    contents    elements    boolean    
return  first  (  )  .val  (  )  ;	[BUGGY]  return  first(  )  .val(  )  ;  [CONTEXT]  public  String  val()  {  if  (size()  >  0)  [BUGGY]  return  first  ().val  ();  else  return   " ";  }        [CLASS]  Elements    [METHOD]  val  [RETURN_TYPE]  String      [VARIABLES]  List    contents    elements    boolean    
return  first  (  )  .val  (  )  ;	[BUGGY]  return  size(  ).val(  );  [CONTEXT]  public  String  val()  {  if  (size()  >  0)  [BUGGY]  return  size  ()  .val  ()  ;  else  return   " ";  }        [CLASS]  Elements    [METHOD]  val  [RETURN_TYPE]  String      [VARIABLES]  List    contents    elements    boolean    
return  first  (  )  .val  (  )  ;	[BUGGY]    [CONTEXT]  public  String  val()  {  if  (size()  >  0)  [BUGGY]  return  first().val();    else  return   " ";        [CLASS]  Elements    [METHOD]  val  [RETURN_TYPE]  String      [VARIABLES]  List    contents    elements    boolean    
if  (  size  (  )  >  0  )  return  first  (  )  .val  (  )  ;	[BUGGY]  if  (  size()  +  8    >  0)return  first(  ).val(  );  [CONTEXT]  public  String  val()  {  [BUGGY]  if(  size()  +  8>  0  )  return  first  ()  .val  ()  ;    else  return   " ";  }        [CLASS]  Elements    [METHOD]  val  [RETURN_TYPE]  String      [VARIABLES]  List    contents    elements    boolean    
element.val  (  value  )  ;	[BUGGY]  element  .val(  )  ;  [CONTEXT]  public  Elements  val(String  value)  {  for  (Element  element  :  contents)  [BUGGY]  element  .val  ();  return  this;  }        [CLASS]  Elements    [METHOD]  val  [RETURN_TYPE]  Elements      String  value  [VARIABLES]  List    contents    elements    String    value    boolean    Element    element    
element.val  (  value  )  ;  return  this;	[BUGGY]    [CONTEXT]  public  Elements  val(String  value)  {  for  (Element  element  :  contents)  [BUGGY]  element.val(value);            [CLASS]  Elements    [METHOD]  val  [RETURN_TYPE]  Elements      String  value  [VARIABLES]  List    contents    elements    String    value    boolean    Element    element    
element.val  (  value  )  ;	[BUGGY]    element.val(  value);  [CONTEXT]        [CLASS]  Elements    [METHOD]  val  [RETURN_TYPE]  Elements      String  value  [VARIABLES]  List    contents    elements    String    value    boolean    Element    element    
element.val  (  value  )  ;	[BUGGY]  element.removeAttr(  attributeKey);element.val(  value);  [CONTEXT]        [CLASS]  Elements    [METHOD]  val  [RETURN_TYPE]  Elements      String  value  [VARIABLES]  List    contents    elements    String    value    boolean    Element    element    
element.val  (  value  )  ;	[BUGGY]  element.prepend(  html);element.val(  value);  [CONTEXT]        [CLASS]  Elements    [METHOD]  val  [RETURN_TYPE]  Elements      String  value  [VARIABLES]  List    contents    elements    String    value    boolean    Element    element    
element.val  (  value  )  ;	[BUGGY]  element.wrap(  html);element.val(  value);  [CONTEXT]        [CLASS]  Elements    [METHOD]  val  [RETURN_TYPE]  Elements      String  value  [VARIABLES]  List    contents    elements    String    value    boolean    Element    element    
element.val  (  value  )  ;	[BUGGY]  element.html(  html);element.val(  value);  [CONTEXT]        [CLASS]  Elements    [METHOD]  val  [RETURN_TYPE]  Elements      String  value  [VARIABLES]  List    contents    elements    String    value    boolean    Element    element    
element.val  (  value  )  ;	[BUGGY]  element.append(  html);element.val(  value);  [CONTEXT]        [CLASS]  Elements    [METHOD]  val  [RETURN_TYPE]  Elements      String  value  [VARIABLES]  List    contents    elements    String    value    boolean    Element    element    
element.val  (  value  )  ;	[BUGGY]  element.addClass(  className);element.val(  value);  [CONTEXT]        [CLASS]  Elements    [METHOD]  val  [RETURN_TYPE]  Elements      String  value  [VARIABLES]  List    contents    elements    String    value    boolean    Element    element    
element.val  (  value  )  ;	[BUGGY]  element.toggleClass(  className);element.val(  value);  [CONTEXT]        [CLASS]  Elements    [METHOD]  val  [RETURN_TYPE]  Elements      String  value  [VARIABLES]  List    contents    elements    String    value    boolean    Element    element    
element.val  (  value  )  ;	[BUGGY]  element.removeClass(  className);element.val(  value);  [CONTEXT]        [CLASS]  Elements    [METHOD]  val  [RETURN_TYPE]  Elements      String  value  [VARIABLES]  List    contents    elements    String    value    boolean    Element    element    
return  this;	[BUGGY]  return  null;  [CONTEXT]  public  Elements  val(String  value)  {  for  (Element  element  :  contents)  element.val(value);  [BUGGY]  return  null;  }        [CLASS]  Elements    [METHOD]  val  [RETURN_TYPE]  Elements      String  value  [VARIABLES]  List    contents    elements    String    value    boolean    Element    element    
if  (  sb.length  (  )  !=  0  )  sb.append  (   "   "  )  ;	[BUGGY]  if  (  sb.length(  )  ==  0)sb.append(   "   ");  [CONTEXT]  public  String  text()  {  StringBuilder  sb  =  new  StringBuilder();  for  (Element  element  :  contents)  {  [BUGGY]  if(  sb.length  ()==  0  )  sb.append  (   "   "  )  ;    sb.append(element.text());  }  return  sb.toString();  }        [CLASS]  Elements    [METHOD]  text  [RETURN_TYPE]  String      [VARIABLES]  List    contents    elements    boolean    StringBuilder    sb    Element    element    
if  (  sb.length  (  )  !=  0  )  sb.append  (   "   "  )  ;	[BUGGY]  if  (  sb.length(  )  !=  4)sb.append(   "   ");  [CONTEXT]  public  String  text()  {  StringBuilder  sb  =  new  StringBuilder();  for  (Element  element  :  contents)  {  [BUGGY]  if(  sb.length  ()!=  4  )  sb.append  (   "   "  )  ;    sb.append(element.text());  }  return  sb.toString();  }        [CLASS]  Elements    [METHOD]  text  [RETURN_TYPE]  String      [VARIABLES]  List    contents    elements    boolean    StringBuilder    sb    Element    element    
if  (  sb.length  (  )  !=  0  )  sb.append  (   "   "  )  ;	[BUGGY]  if  (  sb.length(  )  !=  0)sb.append(   " ");  [CONTEXT]  public  String  text()  {  StringBuilder  sb  =  new  StringBuilder();  for  (Element  element  :  contents)  {  [BUGGY]  if(  sb.length  ()!=  0  )  sb.append  (   " "  )  ;    sb.append(element.text());  }  return  sb.toString();  }        [CLASS]  Elements    [METHOD]  text  [RETURN_TYPE]  String      [VARIABLES]  List    contents    elements    boolean    StringBuilder    sb    Element    element    
if  (  sb.length  (  )  !=  0  )  sb.append  (   "   "  )  ;	[BUGGY]  if  (  sb.length()  +  7    !=  0)sb.append(   "   ");  [CONTEXT]  public  String  text()  {  StringBuilder  sb  =  new  StringBuilder();  for  (Element  element  :  contents)  {  [BUGGY]  if(  sb.length()  +  7!=  0  )  sb.append  (   "   "  )  ;    sb.append(element.text());  }  return  sb.toString();  }        [CLASS]  Elements    [METHOD]  text  [RETURN_TYPE]  String      [VARIABLES]  List    contents    elements    boolean    StringBuilder    sb    Element    element    
if  (  sb.length  (  )  !=  0  )  sb.append  (   "   "  )  ;	[BUGGY]  if  (  sb.append(  )  !=  0)sb.append(   "   ");  [CONTEXT]  public  String  text()  {  StringBuilder  sb  =  new  StringBuilder();  for  (Element  element  :  contents)  {  [BUGGY]  if(  sb.append  ()!=  0  )  sb.append  (   "   "  )  ;    sb.append(element.text());  }  return  sb.toString();  }        [CLASS]  Elements    [METHOD]  text  [RETURN_TYPE]  String      [VARIABLES]  List    contents    elements    boolean    StringBuilder    sb    Element    element    
if  (  sb.length  (  )  !=  0  )  sb.append  (   "   "  )  ;  sb.append  (  element.text  (  )  )  ;  }	[BUGGY]  sb.append( "   ");  [CONTEXT]  public  String  text()  {  StringBuilder  sb  =  new  StringBuilder();  for  (Element  element  :  contents)  {  [BUGGY]  if  (sb.length()  !=  0)    sb.append( "   ");      return  sb.toString();        [CLASS]  Elements    [METHOD]  text  [RETURN_TYPE]  String      [VARIABLES]  List    contents    elements    boolean    StringBuilder    sb    Element    element    
if  (  sb.length  (  )  !=  0  )  sb.append  (   "   "  )  ;  sb.append  (  element.text  (  )  )  ;  }	[BUGGY]    [CONTEXT]  public  String  text()  {  StringBuilder  sb  =  new  StringBuilder();  for  (Element  element  :  contents)  {  [BUGGY]  if  (sb.length()  !=  0)          return  sb.toString();        [CLASS]  Elements    [METHOD]  text  [RETURN_TYPE]  String      [VARIABLES]  List    contents    elements    boolean    StringBuilder    sb    Element    element    
sb.append  (   "   "  )  ;	[BUGGY]  sb.append(   " ");  [CONTEXT]  public  String  text()  {  StringBuilder  sb  =  new  StringBuilder();  for  (Element  element  :  contents)  {  if  (sb.length()  !=  0)  [BUGGY]  sb.append  (   " "  )  ;  sb.append(element.text());  }  return  sb.toString();  }        [CLASS]  Elements    [METHOD]  text  [RETURN_TYPE]  String      [VARIABLES]  List    contents    elements    boolean    StringBuilder    sb    Element    element    
sb.append  (   "   "  )  ;	[BUGGY]    [CONTEXT]  public  String  text()  {  StringBuilder  sb  =  new  StringBuilder();  for  (Element  element  :  contents)  {  if  (sb.length()  !=  0)  [BUGGY]  sb.append( "   ");    sb.append(element.text());  }  return  sb.toString();        [CLASS]  Elements    [METHOD]  text  [RETURN_TYPE]  String      [VARIABLES]  List    contents    elements    boolean    StringBuilder    sb    Element    element    
sb.append  (   "   "  )  ;	[BUGGY]    sb.append(   "   ");  [CONTEXT]        [CLASS]  Elements    [METHOD]  text  [RETURN_TYPE]  String      [VARIABLES]  List    contents    elements    boolean    StringBuilder    sb    Element    element    
sb.append  (   "   "  )  ;	[BUGGY]  sb.append(   "\n ");sb.append(   "   ");  [CONTEXT]        [CLASS]  Elements    [METHOD]  text  [RETURN_TYPE]  String      [VARIABLES]  List    contents    elements    boolean    StringBuilder    sb    Element    element    
sb.append  (   "   "  )  ;	[BUGGY]  element.append(  html);sb.append(   "   ");  [CONTEXT]        [CLASS]  Elements    [METHOD]  text  [RETURN_TYPE]  String      [VARIABLES]  List    contents    elements    boolean    StringBuilder    sb    Element    element    
if  (  sb.length  (  )  !=  0  )  sb.append  (   "   "  )  ;	[BUGGY]  if  (  sb.length()  -  0    !=  0)sb.append(   "   ");  [CONTEXT]  public  String  text()  {  StringBuilder  sb  =  new  StringBuilder();  for  (Element  element  :  contents)  {  [BUGGY]  if(  sb.length()  -  0!=  0  )  sb.append  (   "   "  )  ;    sb.append(element.text());  }  return  sb.toString();  }        [CLASS]  Elements    [METHOD]  text  [RETURN_TYPE]  String      [VARIABLES]  List    contents    elements    boolean    StringBuilder    sb    Element    element    
sb.append  (  element.text  (  )  )  ;	[BUGGY]  sb.append(  element.attr(  ));  [CONTEXT]  public  String  text()  {  StringBuilder  sb  =  new  StringBuilder();  for  (Element  element  :  contents)  {  if  (sb.length()  !=  0)  sb.append( "   ");  [BUGGY]  sb.append  (  element.attr  ())  ;  }  return  sb.toString();  }        [CLASS]  Elements    [METHOD]  text  [RETURN_TYPE]  String      [VARIABLES]  List    contents    elements    boolean    StringBuilder    sb    Element    element    
sb.append  (  element.text  (  )  )  ;	[BUGGY]  sb.append(  element  .hasText(  )  );  [CONTEXT]  public  String  text()  {  StringBuilder  sb  =  new  StringBuilder();  for  (Element  element  :  contents)  {  if  (sb.length()  !=  0)  sb.append( "   ");  [BUGGY]  sb.append  (  element  .hasText  ()  )  ;  }  return  sb.toString();  }        [CLASS]  Elements    [METHOD]  text  [RETURN_TYPE]  String      [VARIABLES]  List    contents    elements    boolean    StringBuilder    sb    Element    element    
sb.append  (  element.text  (  )  )  ;	[BUGGY]    [CONTEXT]  public  String  text()  {  StringBuilder  sb  =  new  StringBuilder();  for  (Element  element  :  contents)  {  if  (sb.length()  !=  0)  sb.append( "   ");  [BUGGY]  sb.append(element.text());    }  return  sb.toString();        [CLASS]  Elements    [METHOD]  text  [RETURN_TYPE]  String      [VARIABLES]  List    contents    elements    boolean    StringBuilder    sb    Element    element    
return  sb.toString  (  )  ;	[BUGGY]  return  sb.append(  );  [CONTEXT]  public  String  text()  {  StringBuilder  sb  =  new  StringBuilder();  for  (Element  element  :  contents)  {  if  (sb.length()  !=  0)  sb.append( "   ");  sb.append(element.text());  }  [BUGGY]  return  sb.append  ()  ;  }        [CLASS]  Elements    [METHOD]  text  [RETURN_TYPE]  String      [VARIABLES]  List    contents    elements    boolean    StringBuilder    sb    Element    element    
return  sb.toString  (  )  ;	[BUGGY]    [CONTEXT]  public  String  text()  {  StringBuilder  sb  =  new  StringBuilder();  for  (Element  element  :  contents)  {  if  (sb.length()  !=  0)  sb.append( "   ");  sb.append(element.text());  }  [BUGGY]  return  sb.toString();          [CLASS]  Elements    [METHOD]  text  [RETURN_TYPE]  String      [VARIABLES]  List    contents    elements    boolean    StringBuilder    sb    Element    element    
if  (  element.hasText  (  )  )  return  true;	[BUGGY]  if  (  element.hasText(  ))return  false;  [CONTEXT]  public  boolean  hasText()  {  for  (Element  element:  contents)  {  [BUGGY]  if(  element.hasText  ())  return  false;    }  return  false;  }        [CLASS]  Elements    [METHOD]  hasText  [RETURN_TYPE]  boolean      [VARIABLES]  List    contents    elements    Element    element    boolean    
if  (  element.hasText  (  )  )  return  true;	[BUGGY]  if  (  element.val(  ))return  true;  [CONTEXT]  public  boolean  hasText()  {  for  (Element  element:  contents)  {  [BUGGY]  if(  element.val  ())  return  true;    }  return  false;  }        [CLASS]  Elements    [METHOD]  hasText  [RETURN_TYPE]  boolean      [VARIABLES]  List    contents    elements    Element    element    boolean    
if  (  element.hasText  (  )  )  return  true;	[BUGGY]  if  (  element  .text(  )  )return  true;  [CONTEXT]  public  boolean  hasText()  {  for  (Element  element:  contents)  {  [BUGGY]  if(  element  .text  ()  )  return  true;    }  return  false;  }        [CLASS]  Elements    [METHOD]  hasText  [RETURN_TYPE]  boolean      [VARIABLES]  List    contents    elements    Element    element    boolean    
if  (  element.hasText  (  )  )  return  true;	[BUGGY]  if  (  element  .text(  )  )return  false;  [CONTEXT]  public  boolean  hasText()  {  for  (Element  element:  contents)  {  [BUGGY]  if(  element  .text  ()  )  return  false;    }  return  false;  }        [CLASS]  Elements    [METHOD]  hasText  [RETURN_TYPE]  boolean      [VARIABLES]  List    contents    elements    Element    element    boolean    
if  (  element.hasText  (  )  )  return  true;  }	[BUGGY]  return  true;  [CONTEXT]  public  boolean  hasText()  {  for  (Element  element:  contents)  {  [BUGGY]  if  (element.hasText())    return  true;    return  false;        [CLASS]  Elements    [METHOD]  hasText  [RETURN_TYPE]  boolean      [VARIABLES]  List    contents    elements    Element    element    boolean    
if  (  element.hasText  (  )  )  return  true;  }	[BUGGY]    [CONTEXT]  public  boolean  hasText()  {  for  (Element  element:  contents)  {  [BUGGY]  if  (element.hasText())        return  false;        [CLASS]  Elements    [METHOD]  hasText  [RETURN_TYPE]  boolean      [VARIABLES]  List    contents    elements    Element    element    boolean    
return  true;	[BUGGY]  return  false;  [CONTEXT]  public  boolean  hasText()  {  for  (Element  element:  contents)  {  if  (element.hasText())  [BUGGY]  return  false;  }  return  false;  }        [CLASS]  Elements    [METHOD]  hasText  [RETURN_TYPE]  boolean      [VARIABLES]  List    contents    elements    Element    element    boolean    
return  false;	[BUGGY]  return  true;  [CONTEXT]  public  boolean  hasText()  {  for  (Element  element:  contents)  {  if  (element.hasText())  return  true;  }  [BUGGY]  return  true;  }        [CLASS]  Elements    [METHOD]  hasText  [RETURN_TYPE]  boolean      [VARIABLES]  List    contents    elements    Element    element    boolean    
if  (  sb.length  (  )  !=  0  )  sb.append  (   "\n "  )  ;	[BUGGY]  if  (  sb.length(  )  <=  0)sb.append(   "\n ");  [CONTEXT]  public  String  html()  {  StringBuilder  sb  =  new  StringBuilder();  for  (Element  element  :  contents)  {  [BUGGY]  if(  sb.length  ()<=  0  )  sb.append  (   "\n "  )  ;    sb.append(element.html());  }  return  sb.toString();  }        [CLASS]  Elements    [METHOD]  html  [RETURN_TYPE]  String      [VARIABLES]  List    contents    elements    boolean    StringBuilder    sb    Element    element    
if  (  sb.length  (  )  !=  0  )  sb.append  (   "\n "  )  ;	[BUGGY]  if  (  sb.length(  )  !=  9)sb.append(   "\n ");  [CONTEXT]  public  String  html()  {  StringBuilder  sb  =  new  StringBuilder();  for  (Element  element  :  contents)  {  [BUGGY]  if(  sb.length  ()!=  9  )  sb.append  (   "\n "  )  ;    sb.append(element.html());  }  return  sb.toString();  }        [CLASS]  Elements    [METHOD]  html  [RETURN_TYPE]  String      [VARIABLES]  List    contents    elements    boolean    StringBuilder    sb    Element    element    
if  (  sb.length  (  )  !=  0  )  sb.append  (   "\n "  )  ;	[BUGGY]  if  (  sb.length(  )  !=  0)sb.append(   "n ");  [CONTEXT]  public  String  html()  {  StringBuilder  sb  =  new  StringBuilder();  for  (Element  element  :  contents)  {  [BUGGY]  if(  sb.length  ()!=  0  )  sb.append  (   "n "  )  ;    sb.append(element.html());  }  return  sb.toString();  }        [CLASS]  Elements    [METHOD]  html  [RETURN_TYPE]  String      [VARIABLES]  List    contents    elements    boolean    StringBuilder    sb    Element    element    
if  (  sb.length  (  )  !=  0  )  sb.append  (   "\n "  )  ;	[BUGGY]  if  (  sb.length()  +  4    !=  0)sb.append(   "\n ");  [CONTEXT]  public  String  html()  {  StringBuilder  sb  =  new  StringBuilder();  for  (Element  element  :  contents)  {  [BUGGY]  if(  sb.length()  +  4!=  0  )  sb.append  (   "\n "  )  ;    sb.append(element.html());  }  return  sb.toString();  }        [CLASS]  Elements    [METHOD]  html  [RETURN_TYPE]  String      [VARIABLES]  List    contents    elements    boolean    StringBuilder    sb    Element    element    
if  (  sb.length  (  )  !=  0  )  sb.append  (   "\n "  )  ;	[BUGGY]  if  (  sb.append(  )  !=  0)sb.append(   "\n ");  [CONTEXT]  public  String  html()  {  StringBuilder  sb  =  new  StringBuilder();  for  (Element  element  :  contents)  {  [BUGGY]  if(  sb.append  ()!=  0  )  sb.append  (   "\n "  )  ;    sb.append(element.html());  }  return  sb.toString();  }        [CLASS]  Elements    [METHOD]  html  [RETURN_TYPE]  String      [VARIABLES]  List    contents    elements    boolean    StringBuilder    sb    Element    element    
if  (  sb.length  (  )  !=  0  )  sb.append  (   "\n "  )  ;	[BUGGY]  if  (  sb.length(  )  !=  0  )sb.append(   "\n ");  [CONTEXT]  public  String  html()  {  StringBuilder  sb  =  new  StringBuilder();  for  (Element  element  :  contents)  {  [BUGGY]  if(  sb.length  ()!=  0)  sb.append  (   "\n "  )  ;    sb.append(element.html());  }  return  sb.toString();  }        [CLASS]  Elements    [METHOD]  html  [RETURN_TYPE]  String      [VARIABLES]  List    contents    elements    boolean    StringBuilder    sb    Element    element    
if  (  sb.length  (  )  !=  0  )  sb.append  (   "\n "  )  ;  sb.append  (  element.html  (  )  )  ;  }	[BUGGY]  sb.append( "\n ");  [CONTEXT]  public  String  html()  {  StringBuilder  sb  =  new  StringBuilder();  for  (Element  element  :  contents)  {  [BUGGY]  if  (sb.length()  !=  0)    sb.append( "\n ");      return  sb.toString();        [CLASS]  Elements    [METHOD]  html  [RETURN_TYPE]  String      [VARIABLES]  List    contents    elements    boolean    StringBuilder    sb    Element    element    
if  (  sb.length  (  )  !=  0  )  sb.append  (   "\n "  )  ;  sb.append  (  element.html  (  )  )  ;  }	[BUGGY]    [CONTEXT]  public  String  html()  {  StringBuilder  sb  =  new  StringBuilder();  for  (Element  element  :  contents)  {  [BUGGY]  if  (sb.length()  !=  0)          return  sb.toString();        [CLASS]  Elements    [METHOD]  html  [RETURN_TYPE]  String      [VARIABLES]  List    contents    elements    boolean    StringBuilder    sb    Element    element    
sb.append  (   "\n "  )  ;	[BUGGY]  sb.append(   "\n\ ");  [CONTEXT]  public  String  html()  {  StringBuilder  sb  =  new  StringBuilder();  for  (Element  element  :  contents)  {  if  (sb.length()  !=  0)  [BUGGY]  sb.append  (   "\n\ "  )  ;  sb.append(element.html());  }  return  sb.toString();  }        [CLASS]  Elements    [METHOD]  html  [RETURN_TYPE]  String      [VARIABLES]  List    contents    elements    boolean    StringBuilder    sb    Element    element    
sb.append  (   "\n "  )  ;  sb.append  (  element.html  (  )  )  ;	[BUGGY]    [CONTEXT]  public  String  html()  {  StringBuilder  sb  =  new  StringBuilder();  for  (Element  element  :  contents)  {  if  (sb.length()  !=  0)  [BUGGY]  sb.append( "\n ");      }  return  sb.toString();        [CLASS]  Elements    [METHOD]  html  [RETURN_TYPE]  String      [VARIABLES]  List    contents    elements    boolean    StringBuilder    sb    Element    element    
sb.append  (   "\n "  )  ;  sb.append  (  element.html  (  )  )  ;	[BUGGY]  sb.append(  element.html(  ));  sb.append(   "\n ");  [CONTEXT]        [CLASS]  Elements    [METHOD]  html  [RETURN_TYPE]  String      [VARIABLES]  List    contents    elements    boolean    StringBuilder    sb    Element    element    
sb.append  (   "\n "  )  ;  sb.append  (  element.html  (  )  )  ;	[BUGGY]  sb.append(  element.text(  ));sb.append(   "\n ");  sb.append(  element.html(  ));  [CONTEXT]        [CLASS]  Elements    [METHOD]  html  [RETURN_TYPE]  String      [VARIABLES]  List    contents    elements    boolean    StringBuilder    sb    Element    element    
sb.append  (   "\n "  )  ;  sb.append  (  element.html  (  )  )  ;	[BUGGY]  sb.append(  element.html(  ));sb.append(   "\n ");  sb.append(  element.html(  ));  [CONTEXT]        [CLASS]  Elements    [METHOD]  html  [RETURN_TYPE]  String      [VARIABLES]  List    contents    elements    boolean    StringBuilder    sb    Element    element    
sb.append  (   "\n "  )  ;  sb.append  (  element.html  (  )  )  ;	[BUGGY]  sb.append(  element.outerHtml(  ));sb.append(   "\n ");  sb.append(  element.html(  ));  [CONTEXT]        [CLASS]  Elements    [METHOD]  html  [RETURN_TYPE]  String      [VARIABLES]  List    contents    elements    boolean    StringBuilder    sb    Element    element    
if  (  sb.length  (  )  !=  0  )  sb.append  (   "\n "  )  ;	[BUGGY]  if  (  sb.length()  -  6    !=  0)sb.append(   "\n ");  [CONTEXT]  public  String  html()  {  StringBuilder  sb  =  new  StringBuilder();  for  (Element  element  :  contents)  {  [BUGGY]  if(  sb.length()  -  6!=  0  )  sb.append  (   "\n "  )  ;    sb.append(element.html());  }  return  sb.toString();  }        [CLASS]  Elements    [METHOD]  html  [RETURN_TYPE]  String      [VARIABLES]  List    contents    elements    boolean    StringBuilder    sb    Element    element    
sb.append  (   "\n "  )  ;	[BUGGY]  sb.append(   "n ");  [CONTEXT]  public  String  html()  {  StringBuilder  sb  =  new  StringBuilder();  for  (Element  element  :  contents)  {  if  (sb.length()  !=  0)  [BUGGY]  sb.append  (   "n "  )  ;  sb.append(element.html());  }  return  sb.toString();  }        [CLASS]  Elements    [METHOD]  html  [RETURN_TYPE]  String      [VARIABLES]  List    contents    elements    boolean    StringBuilder    sb    Element    element    
sb.append  (   "\n "  )  ;	[BUGGY]  sb  .append(  null)  ;  [CONTEXT]  public  String  html()  {  StringBuilder  sb  =  new  StringBuilder();  for  (Element  element  :  contents)  {  if  (sb.length()  !=  0)  [BUGGY]  sb  .append  (  null  );  sb.append(element.html());  }  return  sb.toString();  }        [CLASS]  Elements    [METHOD]  html  [RETURN_TYPE]  String      [VARIABLES]  List    contents    elements    boolean    StringBuilder    sb    Element    element    
sb.append  (   "\n "  )  ;	[BUGGY]  sb.append(  element.html(  ));  sb.append(   "\n ");  [CONTEXT]        [CLASS]  Elements    [METHOD]  html  [RETURN_TYPE]  String      [VARIABLES]  List    contents    elements    boolean    StringBuilder    sb    Element    element    
sb.append  (   "\n "  )  ;	[BUGGY]  element.append(  html);sb.append(   "\n ");  [CONTEXT]        [CLASS]  Elements    [METHOD]  html  [RETURN_TYPE]  String      [VARIABLES]  List    contents    elements    boolean    StringBuilder    sb    Element    element    
sb.append  (   "\n "  )  ;	[BUGGY]  sb.append(   "   ");sb.append(   "\n ");  [CONTEXT]        [CLASS]  Elements    [METHOD]  html  [RETURN_TYPE]  String      [VARIABLES]  List    contents    elements    boolean    StringBuilder    sb    Element    element    
sb.append  (  element.html  (  )  )  ;	[BUGGY]    [CONTEXT]  public  String  html()  {  StringBuilder  sb  =  new  StringBuilder();  for  (Element  element  :  contents)  {  if  (sb.length()  !=  0)  sb.append( "\n ");  [BUGGY]  sb.append(element.html());    }  return  sb.toString();        [CLASS]  Elements    [METHOD]  html  [RETURN_TYPE]  String      [VARIABLES]  List    contents    elements    boolean    StringBuilder    sb    Element    element    
sb.append  (  element.html  (  )  )  ;	[BUGGY]  sb.append(  element  .outerHtml(  )  );  [CONTEXT]  public  String  html()  {  StringBuilder  sb  =  new  StringBuilder();  for  (Element  element  :  contents)  {  if  (sb.length()  !=  0)  sb.append( "\n ");  [BUGGY]  sb.append  (  element  .outerHtml  ()  )  ;  }  return  sb.toString();  }        [CLASS]  Elements    [METHOD]  html  [RETURN_TYPE]  String      [VARIABLES]  List    contents    elements    boolean    StringBuilder    sb    Element    element    
return  sb.toString  (  )  ;	[BUGGY]  return  sb.append(  );  [CONTEXT]  public  String  html()  {  StringBuilder  sb  =  new  StringBuilder();  for  (Element  element  :  contents)  {  if  (sb.length()  !=  0)  sb.append( "\n ");  sb.append(element.html());  }  [BUGGY]  return  sb.append  ()  ;  }        [CLASS]  Elements    [METHOD]  html  [RETURN_TYPE]  String      [VARIABLES]  List    contents    elements    boolean    StringBuilder    sb    Element    element    
return  sb.toString  (  )  ;	[BUGGY]    [CONTEXT]  public  String  html()  {  StringBuilder  sb  =  new  StringBuilder();  for  (Element  element  :  contents)  {  if  (sb.length()  !=  0)  sb.append( "\n ");  sb.append(element.html());  }  [BUGGY]  return  sb.toString();          [CLASS]  Elements    [METHOD]  html  [RETURN_TYPE]  String      [VARIABLES]  List    contents    elements    boolean    StringBuilder    sb    Element    element    
if  (  sb.length  (  )  !=  0  )  sb.append  (   "\n "  )  ;	[BUGGY]  if  (  sb.length(  )  ==  0)sb.append(   "\n ");  [CONTEXT]  public  String  outerHtml()  {  StringBuilder  sb  =  new  StringBuilder();  for  (Element  element  :  contents)  {  [BUGGY]  if(  sb.length  ()==  0  )  sb.append  (   "\n "  )  ;    sb.append(element.outerHtml());  }  return  sb.toString();  }        [CLASS]  Elements    [METHOD]  outerHtml  [RETURN_TYPE]  String      [VARIABLES]  List    contents    elements    boolean    StringBuilder    sb    Element    element    
if  (  sb.length  (  )  !=  0  )  sb.append  (   "\n "  )  ;	[BUGGY]  if  (  sb.length(  )  !=  9)sb.append(   "\n ");  [CONTEXT]  public  String  outerHtml()  {  StringBuilder  sb  =  new  StringBuilder();  for  (Element  element  :  contents)  {  [BUGGY]  if(  sb.length  ()!=  9  )  sb.append  (   "\n "  )  ;    sb.append(element.outerHtml());  }  return  sb.toString();  }        [CLASS]  Elements    [METHOD]  outerHtml  [RETURN_TYPE]  String      [VARIABLES]  List    contents    elements    boolean    StringBuilder    sb    Element    element    
if  (  sb.length  (  )  !=  0  )  sb.append  (   "\n "  )  ;	[BUGGY]  if  (  sb.length()  -  9    !=  0)sb.append(   "\n ");  [CONTEXT]  public  String  outerHtml()  {  StringBuilder  sb  =  new  StringBuilder();  for  (Element  element  :  contents)  {  [BUGGY]  if(  sb.length()  -  9!=  0  )  sb.append  (   "\n "  )  ;    sb.append(element.outerHtml());  }  return  sb.toString();  }        [CLASS]  Elements    [METHOD]  outerHtml  [RETURN_TYPE]  String      [VARIABLES]  List    contents    elements    boolean    StringBuilder    sb    Element    element    
if  (  sb.length  (  )  !=  0  )  sb.append  (   "\n "  )  ;	[BUGGY]  if  (  sb.append(  )  !=  0)sb.append(   "\n ");  [CONTEXT]  public  String  outerHtml()  {  StringBuilder  sb  =  new  StringBuilder();  for  (Element  element  :  contents)  {  [BUGGY]  if(  sb.append  ()!=  0  )  sb.append  (   "\n "  )  ;    sb.append(element.outerHtml());  }  return  sb.toString();  }        [CLASS]  Elements    [METHOD]  outerHtml  [RETURN_TYPE]  String      [VARIABLES]  List    contents    elements    boolean    StringBuilder    sb    Element    element    
if  (  sb.length  (  )  !=  0  )  sb.append  (   "\n "  )  ;	[BUGGY]  if  (  sb.length(  )  !=  0  )sb.append(   "\n ");  [CONTEXT]  public  String  outerHtml()  {  StringBuilder  sb  =  new  StringBuilder();  for  (Element  element  :  contents)  {  [BUGGY]  if(  sb.length  ()!=  0)  sb.append  (   "\n "  )  ;    sb.append(element.outerHtml());  }  return  sb.toString();  }        [CLASS]  Elements    [METHOD]  outerHtml  [RETURN_TYPE]  String      [VARIABLES]  List    contents    elements    boolean    StringBuilder    sb    Element    element    
if  (  sb.length  (  )  !=  0  )  sb.append  (   "\n "  )  ;  sb.append  (  element.outerHtml  (  )  )  ;  }	[BUGGY]  sb.append( "\n ");  [CONTEXT]  public  String  outerHtml()  {  StringBuilder  sb  =  new  StringBuilder();  for  (Element  element  :  contents)  {  [BUGGY]  if  (sb.length()  !=  0)    sb.append( "\n ");      return  sb.toString();        [CLASS]  Elements    [METHOD]  outerHtml  [RETURN_TYPE]  String      [VARIABLES]  List    contents    elements    boolean    StringBuilder    sb    Element    element    
if  (  sb.length  (  )  !=  0  )  sb.append  (   "\n "  )  ;  sb.append  (  element.outerHtml  (  )  )  ;  }	[BUGGY]    [CONTEXT]  public  String  outerHtml()  {  StringBuilder  sb  =  new  StringBuilder();  for  (Element  element  :  contents)  {  [BUGGY]  if  (sb.length()  !=  0)          return  sb.toString();        [CLASS]  Elements    [METHOD]  outerHtml  [RETURN_TYPE]  String      [VARIABLES]  List    contents    elements    boolean    StringBuilder    sb    Element    element    
sb.append  (   "\n "  )  ;	[BUGGY]    [CONTEXT]  public  String  outerHtml()  {  StringBuilder  sb  =  new  StringBuilder();  for  (Element  element  :  contents)  {  if  (sb.length()  !=  0)  [BUGGY]  sb.append( "\n ");    sb.append(element.outerHtml());  }  return  sb.toString();        [CLASS]  Elements    [METHOD]  outerHtml  [RETURN_TYPE]  String      [VARIABLES]  List    contents    elements    boolean    StringBuilder    sb    Element    element    
sb.append  (   "\n "  )  ;	[BUGGY]    sb.append(   "\n ");  [CONTEXT]        [CLASS]  Elements    [METHOD]  outerHtml  [RETURN_TYPE]  String      [VARIABLES]  List    contents    elements    boolean    StringBuilder    sb    Element    element    
sb.append  (   "\n "  )  ;	[BUGGY]  element.append(  html);sb.append(   "\n ");  [CONTEXT]        [CLASS]  Elements    [METHOD]  outerHtml  [RETURN_TYPE]  String      [VARIABLES]  List    contents    elements    boolean    StringBuilder    sb    Element    element    
sb.append  (   "\n "  )  ;	[BUGGY]  sb.append(   "   ");sb.append(   "\n ");  [CONTEXT]        [CLASS]  Elements    [METHOD]  outerHtml  [RETURN_TYPE]  String      [VARIABLES]  List    contents    elements    boolean    StringBuilder    sb    Element    element    
if  (  sb.length  (  )  !=  0  )  sb.append  (   "\n "  )  ;	[BUGGY]  if  (  sb.length()  -  1    !=  0)sb.append(   "\n ");  [CONTEXT]  public  String  outerHtml()  {  StringBuilder  sb  =  new  StringBuilder();  for  (Element  element  :  contents)  {  [BUGGY]  if(  sb.length()  -  1!=  0  )  sb.append  (   "\n "  )  ;    sb.append(element.outerHtml());  }  return  sb.toString();  }        [CLASS]  Elements    [METHOD]  outerHtml  [RETURN_TYPE]  String      [VARIABLES]  List    contents    elements    boolean    StringBuilder    sb    Element    element    
sb.append  (   "\n "  )  ;  sb.append  (  element.outerHtml  (  )  )  ;	[BUGGY]    [CONTEXT]  public  String  outerHtml()  {  StringBuilder  sb  =  new  StringBuilder();  for  (Element  element  :  contents)  {  if  (sb.length()  !=  0)  [BUGGY]  sb.append( "\n ");      }  return  sb.toString();        [CLASS]  Elements    [METHOD]  outerHtml  [RETURN_TYPE]  String      [VARIABLES]  List    contents    elements    boolean    StringBuilder    sb    Element    element    
sb.append  (  element.outerHtml  (  )  )  ;	[BUGGY]  sb.append(  element.val(  ));  [CONTEXT]  public  String  outerHtml()  {  StringBuilder  sb  =  new  StringBuilder();  for  (Element  element  :  contents)  {  if  (sb.length()  !=  0)  sb.append( "\n ");  [BUGGY]  sb.append  (  element.val  ())  ;  }  return  sb.toString();  }        [CLASS]  Elements    [METHOD]  outerHtml  [RETURN_TYPE]  String      [VARIABLES]  List    contents    elements    boolean    StringBuilder    sb    Element    element    
sb.append  (  element.outerHtml  (  )  )  ;	[BUGGY]    [CONTEXT]  public  String  outerHtml()  {  StringBuilder  sb  =  new  StringBuilder();  for  (Element  element  :  contents)  {  if  (sb.length()  !=  0)  sb.append( "\n ");  [BUGGY]  sb.append(element.outerHtml());    }  return  sb.toString();        [CLASS]  Elements    [METHOD]  outerHtml  [RETURN_TYPE]  String      [VARIABLES]  List    contents    elements    boolean    StringBuilder    sb    Element    element    
return  sb.toString  (  )  ;	[BUGGY]  return  sb.append(  );  [CONTEXT]  public  String  outerHtml()  {  StringBuilder  sb  =  new  StringBuilder();  for  (Element  element  :  contents)  {  if  (sb.length()  !=  0)  sb.append( "\n ");  sb.append(element.outerHtml());  }  [BUGGY]  return  sb.append  ()  ;  }        [CLASS]  Elements    [METHOD]  outerHtml  [RETURN_TYPE]  String      [VARIABLES]  List    contents    elements    boolean    StringBuilder    sb    Element    element    
return  sb.toString  (  )  ;	[BUGGY]    [CONTEXT]  public  String  outerHtml()  {  StringBuilder  sb  =  new  StringBuilder();  for  (Element  element  :  contents)  {  if  (sb.length()  !=  0)  sb.append( "\n ");  sb.append(element.outerHtml());  }  [BUGGY]  return  sb.toString();          [CLASS]  Elements    [METHOD]  outerHtml  [RETURN_TYPE]  String      [VARIABLES]  List    contents    elements    boolean    StringBuilder    sb    Element    element    
element.html  (  html  )  ;	[BUGGY]    [CONTEXT]  public  Elements  html(String  html)  {  for  (Element  element  :  contents)  {  [BUGGY]  element.html(html);    }  return  this;        [CLASS]  Elements    [METHOD]  html  [RETURN_TYPE]  Elements      String  html  [VARIABLES]  List    contents    elements    String    html    boolean    Element    element    
return  this;	[BUGGY]  return  null;  [CONTEXT]  public  Elements  html(String  html)  {  for  (Element  element  :  contents)  {  element.html(html);  }  [BUGGY]  return  null;  }        [CLASS]  Elements    [METHOD]  html  [RETURN_TYPE]  Elements      String  html  [VARIABLES]  List    contents    elements    String    html    boolean    Element    element    
element.prepend  (  html  )  ;	[BUGGY]    [CONTEXT]  public  Elements  prepend(String  html)  {  for  (Element  element  :  contents)  {  [BUGGY]  element.prepend(html);    }  return  this;        [CLASS]  Elements    [METHOD]  prepend  [RETURN_TYPE]  Elements      String  html  [VARIABLES]  List    contents    elements    String    html    boolean    Element    element    
return  this;	[BUGGY]  return  null;  [CONTEXT]  public  Elements  prepend(String  html)  {  for  (Element  element  :  contents)  {  element.prepend(html);  }  [BUGGY]  return  null;  }        [CLASS]  Elements    [METHOD]  prepend  [RETURN_TYPE]  Elements      String  html  [VARIABLES]  List    contents    elements    String    html    boolean    Element    element    
element.append  (  html  )  ;	[BUGGY]    [CONTEXT]  public  Elements  append(String  html)  {  for  (Element  element  :  contents)  {  [BUGGY]  element.append(html);    }  return  this;        [CLASS]  Elements    [METHOD]  append  [RETURN_TYPE]  Elements      String  html  [VARIABLES]  List    contents    elements    String    html    boolean    Element    element    
return  this;	[BUGGY]  return  null;  [CONTEXT]  public  Elements  append(String  html)  {  for  (Element  element  :  contents)  {  element.append(html);  }  [BUGGY]  return  null;  }        [CLASS]  Elements    [METHOD]  append  [RETURN_TYPE]  Elements      String  html  [VARIABLES]  List    contents    elements    String    html    boolean    Element    element    
Validate.notEmpty  (  html  )  ;	[BUGGY]    [CONTEXT]  public  Elements  wrap(String  html)  {  [BUGGY]  Validate.notEmpty(html);    for  (Element  element  :  contents)  {  element.wrap(html);  }  return  this;        [CLASS]  Elements    [METHOD]  wrap  [RETURN_TYPE]  Elements      String  html  [VARIABLES]  List    contents    elements    String    html    boolean    Element    element    
element.wrap  (  html  )  ;	[BUGGY]  element  .prepend(  html)  ;  [CONTEXT]  public  Elements  wrap(String  html)  {  Validate.notEmpty(html);  for  (Element  element  :  contents)  {  [BUGGY]  element  .prepend  (  html  );  }  return  this;  }        [CLASS]  Elements    [METHOD]  wrap  [RETURN_TYPE]  Elements      String  html  [VARIABLES]  List    contents    elements    String    html    boolean    Element    element    
element.wrap  (  html  )  ;	[BUGGY]    [CONTEXT]  public  Elements  wrap(String  html)  {  Validate.notEmpty(html);  for  (Element  element  :  contents)  {  [BUGGY]  element.wrap(html);    }  return  this;        [CLASS]  Elements    [METHOD]  wrap  [RETURN_TYPE]  Elements      String  html  [VARIABLES]  List    contents    elements    String    html    boolean    Element    element    
return  this;	[BUGGY]  return  null;  [CONTEXT]  public  Elements  wrap(String  html)  {  Validate.notEmpty(html);  for  (Element  element  :  contents)  {  element.wrap(html);  }  [BUGGY]  return  null;  }        [CLASS]  Elements    [METHOD]  wrap  [RETURN_TYPE]  Elements      String  html  [VARIABLES]  List    contents    elements    String    html    boolean    Element    element    
return  Selector.select  (  query,  this  )  ;	[BUGGY]  return  Selector.select(  query,  null);  [CONTEXT]  public  Elements  select(String  query)  {  [BUGGY]  return  Selector.select  (  query,  null  )  ;  }        [CLASS]  Elements    [METHOD]  select  [RETURN_TYPE]  Elements      String  query  [VARIABLES]  List    contents    elements    String    query    boolean    
return  Selector.select  (  query,  this  )  ;	[BUGGY]    [CONTEXT]  public  Elements  select(String  query)  {  [BUGGY]  return  Selector.select(query,  this);          [CLASS]  Elements    [METHOD]  select  [RETURN_TYPE]  Elements      String  query  [VARIABLES]  List    contents    elements    String    query    boolean    
if  (  contents.size  (  )  >  index  )  return  new  Elements  (  get  (  index  )  )  ;	[BUGGY]  if  (  contents.size(  )  <  index)return  new  Elements(  get(  index));  [CONTEXT]  public  Elements  eq(int  index)  {  [BUGGY]  if(  contents.size  ()<  index  )  return  new  Elements  (  get  (  index  ))  ;    else  return  new  Elements();  }        [CLASS]  Elements    [METHOD]  eq  [RETURN_TYPE]  Elements      int  index  [VARIABLES]  List    contents    elements    int    index    boolean    
if  (  contents.size  (  )  >  index  )  return  new  Elements  (  get  (  index  )  )  ;	[BUGGY]  if  (  contents.size()  -  3    >  index)return  new  Elements(  get(  index));  [CONTEXT]  public  Elements  eq(int  index)  {  [BUGGY]  if(  contents.size()  -  3>  index  )  return  new  Elements  (  get  (  index  ))  ;    else  return  new  Elements();  }        [CLASS]  Elements    [METHOD]  eq  [RETURN_TYPE]  Elements      int  index  [VARIABLES]  List    contents    elements    int    index    boolean    
if  (  contents.size  (  )  >  index  )  return  new  Elements  (  get  (  index  )  )  ;	[BUGGY]  if  (  contents.size(  )  >  index)return  if  (  contents.size(  )  >  index)return    new  Elements(  )  );  [CONTEXT]  public  Elements  eq(int  index)  {  [BUGGY]  if(  contents.size  ()>  index  )  return  if(  contents.size  ()>  index  )  returnnew  Elements  ()  )  ;    else  return  new  Elements();  }        [CLASS]  Elements    [METHOD]  eq  [RETURN_TYPE]  Elements      int  index  [VARIABLES]  List    contents    elements    int    index    boolean    
if  (  contents.size  (  )  >  index  )  return  new  Elements  (  get  (  index  )  )  ;	[BUGGY]  if  (  index.size(  )  >  contents)return  new  Elements(  get(  index));  [CONTEXT]  public  Elements  eq(int  index)  {  [BUGGY]  if(  index.size  ()>  contents  )  return  new  Elements  (  get  (  index  ))  ;    else  return  new  Elements();  }        [CLASS]  Elements    [METHOD]  eq  [RETURN_TYPE]  Elements      int  index  [VARIABLES]  List    contents    elements    int    index    boolean    
if  (  contents.size  (  )  >  index  )  return  new  Elements  (  get  (  index  )  )  ;	[BUGGY]  if  (  contents.get(  )  >  index)return  new  Elements(  get(  index));  [CONTEXT]  public  Elements  eq(int  index)  {  [BUGGY]  if(  contents.get  ()>  index  )  return  new  Elements  (  get  (  index  ))  ;    else  return  new  Elements();  }        [CLASS]  Elements    [METHOD]  eq  [RETURN_TYPE]  Elements      int  index  [VARIABLES]  List    contents    elements    int    index    boolean    
if  (  contents.size  (  )  >  index  )  return  new  Elements  (  get  (  index  )  )  ;	[BUGGY]  if  (  contents.size(  )  >  index)return  new  Elements(  eq(  index));  [CONTEXT]  public  Elements  eq(int  index)  {  [BUGGY]  if(  contents.size  ()>  index  )  return  new  Elements  (  eq  (  index  ))  ;    else  return  new  Elements();  }        [CLASS]  Elements    [METHOD]  eq  [RETURN_TYPE]  Elements      int  index  [VARIABLES]  List    contents    elements    int    index    boolean    
if  (  contents.size  (  )  >  index  )  return  new  Elements  (  get  (  index  )  )  ;  else  return  new  Elements  (  )  ;  }	[BUGGY]  return  new  org.jsoup.select.Elements(get(index));  [CONTEXT]  public  Elements  eq(int  index)  {  [BUGGY]  if  (contents.size()  >  index)    return  new  org.jsoup.select.Elements(get(index));            [CLASS]  Elements    [METHOD]  eq  [RETURN_TYPE]  Elements      int  index  [VARIABLES]  List    contents    elements    int    index    boolean    
if  (  contents.size  (  )  >  index  )  return  new  Elements  (  get  (  index  )  )  ;  else  return  new  Elements  (  )  ;  }	[BUGGY]    [CONTEXT]  public  Elements  eq(int  index)  {  [BUGGY]  if  (contents.size()  >  index)                [CLASS]  Elements    [METHOD]  eq  [RETURN_TYPE]  Elements      int  index  [VARIABLES]  List    contents    elements    int    index    boolean    
return  new  Elements  (  )  ;	[BUGGY]  return  return    new  Elements(  get(  index))  ;  [CONTEXT]  public  Elements  eq(int  index)  {  if  (contents.size()  >  index)  return  new  Elements(get(index));  else  [BUGGY]  return  returnnew  Elements  (  get  (  index  ));  }        [CLASS]  Elements    [METHOD]  eq  [RETURN_TYPE]  Elements      int  index  [VARIABLES]  List    contents    elements    int    index    boolean    
return  new  Elements  (  )  ;	[BUGGY]  return    new  Elements(  get(  index))  ;  [CONTEXT]  public  Elements  eq(int  index)  {  if  (contents.size()  >  index)  return  new  Elements(get(index));  else  [BUGGY]  returnnew  Elements  (  get  (  index  ));  }        [CLASS]  Elements    [METHOD]  eq  [RETURN_TYPE]  Elements      int  index  [VARIABLES]  List    contents    elements    int    index    boolean    
return  new  Elements  (  get  (  index  )  )  ;	[BUGGY]  return  return    new  Elements(  )  );  [CONTEXT]  public  Elements  eq(int  index)  {  if  (contents.size()  >  index)  [BUGGY]  return  returnnew  Elements  ()  )  ;  else  return  new  Elements();  }        [CLASS]  Elements    [METHOD]  eq  [RETURN_TYPE]  Elements      int  index  [VARIABLES]  List    contents    elements    int    index    boolean    
return  new  Elements  (  get  (  index  )  )  ;	[BUGGY]  return  new  Elements(  eq(  index));  [CONTEXT]  public  Elements  eq(int  index)  {  if  (contents.size()  >  index)  [BUGGY]  return  new  Elements  (  eq  (  index  ))  ;  else  return  new  Elements();  }        [CLASS]  Elements    [METHOD]  eq  [RETURN_TYPE]  Elements      int  index  [VARIABLES]  List    contents    elements    int    index    boolean    
return  new  Elements  (  get  (  index  )  )  ;	[BUGGY]    [CONTEXT]  public  Elements  eq(int  index)  {  if  (contents.size()  >  index)  [BUGGY]  return  new  Elements(get(index));    else  return  new  Elements();        [CLASS]  Elements    [METHOD]  eq  [RETURN_TYPE]  Elements      int  index  [VARIABLES]  List    contents    elements    int    index    boolean    
if  (  contents.size  (  )  >  index  )  return  new  Elements  (  get  (  index  )  )  ;	[BUGGY]  if  (  contents.size()  -  0    >  index)return  new  Elements(  get(  index));  [CONTEXT]  public  Elements  eq(int  index)  {  [BUGGY]  if(  contents.size()  -  0>  index  )  return  new  Elements  (  get  (  index  ))  ;    else  return  new  Elements();  }        [CLASS]  Elements    [METHOD]  eq  [RETURN_TYPE]  Elements      int  index  [VARIABLES]  List    contents    elements    int    index    boolean    
Elements  children  =  this.select  (  query  )  ;	[BUGGY]  Elements  children  =  this.prepend(  query);  [CONTEXT]  public  boolean  is(String  query)  {  [BUGGY]  Elements  children  =  this.prepend  (  query  )  ;  return  !children.isEmpty();  }        [CLASS]  Elements    [METHOD]  is  [RETURN_TYPE]  boolean      String  query  [VARIABLES]  List    contents    elements    String    query    boolean    Elements    children    
Elements  children  =  this.select  (  query  )  ;  return  !children.isEmpty  (  )  ;	[BUGGY]  return  !children.isEmpty(  );  Elements  children  =  this.select(  query);  [CONTEXT]        [CLASS]  Elements    [METHOD]  is  [RETURN_TYPE]  boolean      String  query  [VARIABLES]  List    contents    elements    String    query    boolean    Elements    children    
Elements  children  =  this.select  (  query  )  ;  return  !children.isEmpty  (  )  ;	[BUGGY]  Elements  children  =  this.select(  query);Elements  children  =  this.select(  query);  return  !children.isEmpty(  );  [CONTEXT]        [CLASS]  Elements    [METHOD]  is  [RETURN_TYPE]  boolean      String  query  [VARIABLES]  List    contents    elements    String    query    boolean    Elements    children    
Elements  children  =  this.select  (  query  )  ;	[BUGGY]  Elements  children  =  this  .select(  query  ,  children)  ;  [CONTEXT]  public  boolean  is(String  query)  {  [BUGGY]  Elements  children  =  this  .select  (  query  ,  children  );  return  !children.isEmpty();  }        [CLASS]  Elements    [METHOD]  is  [RETURN_TYPE]  boolean      String  query  [VARIABLES]  List    contents    elements    String    query    boolean    Elements    children    
Elements  children  =  this.select  (  query  )  ;  return  !children.isEmpty  (  )  ;	[BUGGY]    [CONTEXT]  public  boolean  is(String  query)  {  [BUGGY]  Elements  children  =  this.select(query);            [CLASS]  Elements    [METHOD]  is  [RETURN_TYPE]  boolean      String  query  [VARIABLES]  List    contents    elements    String    query    boolean    Elements    children    
return  !children.isEmpty  (  )  ;	[BUGGY]  return  !children.eq(  );  [CONTEXT]  public  boolean  is(String  query)  {  Elements  children  =  this.select(query);  [BUGGY]  return  !children.eq  ()  ;  }        [CLASS]  Elements    [METHOD]  is  [RETURN_TYPE]  boolean      String  query  [VARIABLES]  List    contents    elements    String    query    boolean    Elements    children    
return  !children.isEmpty  (  )  ;	[BUGGY]    [CONTEXT]  public  boolean  is(String  query)  {  Elements  children  =  this.select(query);  [BUGGY]  return  !children.isEmpty();          [CLASS]  Elements    [METHOD]  is  [RETURN_TYPE]  boolean      String  query  [VARIABLES]  List    contents    elements    String    query    boolean    Elements    children    
return  !contents.isEmpty  (  )  ?  contents.get  (  0  )  :  null;	[BUGGY]  return  !contents.isEmpty(  )  ?  contents.get(  -9)  :  null;  [CONTEXT]  public  Element  first()  {  [BUGGY]  return  !contents.isEmpty  ()?  contents.get  (  -9  ):  null;  }        [CLASS]  Elements    [METHOD]  first  [RETURN_TYPE]  Element      [VARIABLES]  List    contents    elements    boolean    
return  !contents.isEmpty  (  )  ?  contents.get  (  0  )  :  null;	[BUGGY]  return  !contents.iterator(  )  ?  contents.get(  0)  :  null;  [CONTEXT]  public  Element  first()  {  [BUGGY]  return  !contents.iterator  ()?  contents.get  (  0  ):  null;  }        [CLASS]  Elements    [METHOD]  first  [RETURN_TYPE]  Element      [VARIABLES]  List    contents    elements    boolean    
return  !contents.isEmpty  (  )  ?  contents.get  (  0  )  :  null;	[BUGGY]  return  !contents.isEmpty(  )  ?  contents.remove(  0)  :  null;  [CONTEXT]  public  Element  first()  {  [BUGGY]  return  !contents.isEmpty  ()?  contents.remove  (  0  ):  null;  }        [CLASS]  Elements    [METHOD]  first  [RETURN_TYPE]  Element      [VARIABLES]  List    contents    elements    boolean    
return  !contents.isEmpty  (  )  ?  contents.get  (  0  )  :  null;	[BUGGY]  return  !contents.isEmpty(  )  ?  this.get(  0)  :  null;  [CONTEXT]  public  Element  first()  {  [BUGGY]  return  !contents.isEmpty  ()?  this.get  (  0  ):  null;  }        [CLASS]  Elements    [METHOD]  first  [RETURN_TYPE]  Element      [VARIABLES]  List    contents    elements    boolean    
return  !contents.isEmpty  (  )  ?  contents.get  (  0  )  :  null;	[BUGGY]    [CONTEXT]  public  Element  first()  {  [BUGGY]  return  !contents.isEmpty()  ?  contents.get(0)  :  null;          [CLASS]  Elements    [METHOD]  first  [RETURN_TYPE]  Element      [VARIABLES]  List    contents    elements    boolean    
return  !contents.isEmpty  (  )  ?  contents.get  (  contents.size  (  )  -  1  )  :  null;	[BUGGY]  return  !contents.isEmpty(  )  ?  contents.get(  contents.size(  )    <    1)  :  null;  [CONTEXT]  public  Element  last()  {  [BUGGY]  return  !contents.isEmpty  ()?  contents.get  (  contents.size  ()  <1  ):  null;  }        [CLASS]  Elements    [METHOD]  last  [RETURN_TYPE]  Element      [VARIABLES]  List    contents    elements    boolean    
return  !contents.isEmpty  (  )  ?  contents.get  (  contents.size  (  )  -  1  )  :  null;	[BUGGY]  return  !contents.isEmpty(  )  ?  contents.get(  contents.size(  )  )  :  null;  [CONTEXT]  public  Element  last()  {  [BUGGY]  return  !contents.isEmpty  ()?  contents.get  (  contents.size  ()  ):  null;  }        [CLASS]  Elements    [METHOD]  last  [RETURN_TYPE]  Element      [VARIABLES]  List    contents    elements    boolean    
return  !contents.isEmpty  (  )  ?  contents.get  (  contents.size  (  )  -  1  )  :  null;	[BUGGY]  return  !contents.isEmpty(  )  ?  contents.get(  contents.size()  +  9    -  1)  :  null;  [CONTEXT]  public  Element  last()  {  [BUGGY]  return  !contents.isEmpty  ()?  contents.get  (  contents.size()  +  9-  1  ):  null;  }        [CLASS]  Elements    [METHOD]  last  [RETURN_TYPE]  Element      [VARIABLES]  List    contents    elements    boolean    
return  !contents.isEmpty  (  )  ?  contents.get  (  contents.size  (  )  -  1  )  :  null;	[BUGGY]  return  !contents.iterator(  )  ?  contents.get(  contents.size(  )  -  1)  :  null;  [CONTEXT]  public  Element  last()  {  [BUGGY]  return  !contents.iterator  ()?  contents.get  (  contents.size  ()-  1  ):  null;  }        [CLASS]  Elements    [METHOD]  last  [RETURN_TYPE]  Element      [VARIABLES]  List    contents    elements    boolean    
return  !contents.isEmpty  (  )  ?  contents.get  (  contents.size  (  )  -  1  )  :  null;	[BUGGY]  return  !contents.isEmpty(  )  ?  contents.get(  contents.get(  )  -  1)  :  null;  [CONTEXT]  public  Element  last()  {  [BUGGY]  return  !contents.isEmpty  ()?  contents.get  (  contents.get  ()-  1  ):  null;  }        [CLASS]  Elements    [METHOD]  last  [RETURN_TYPE]  Element      [VARIABLES]  List    contents    elements    boolean    
return  !contents.isEmpty  (  )  ?  contents.get  (  contents.size  (  )  -  1  )  :  null;	[BUGGY]  return  !contents.iterator(  )  ?  1.get(  contents.size(  )  -  1)  :  null;  [CONTEXT]  public  Element  last()  {  [BUGGY]  return  !contents.iterator  ()?  1.get  (  contents.size  ()-  1  ):  null;  }        [CLASS]  Elements    [METHOD]  last  [RETURN_TYPE]  Element      [VARIABLES]  List    contents    elements    boolean    
return  !contents.isEmpty  (  )  ?  contents.get  (  contents.size  (  )  -  1  )  :  null;	[BUGGY]  return  !contents.isEmpty(  )  ?  contents.get(  contents.size()  +  6    -  1)  :  null;  [CONTEXT]  public  Element  last()  {  [BUGGY]  return  !contents.isEmpty  ()?  contents.get  (  contents.size()  +  6-  1  ):  null;  }        [CLASS]  Elements    [METHOD]  last  [RETURN_TYPE]  Element      [VARIABLES]  List    contents    elements    boolean    
return  !contents.isEmpty  (  )  ?  contents.get  (  contents.size  (  )  -  1  )  :  null;	[BUGGY]    [CONTEXT]  public  Element  last()  {  [BUGGY]  return  !contents.isEmpty()  ?  contents.get(contents.size()  -  1)  :  null;          [CLASS]  Elements    [METHOD]  last  [RETURN_TYPE]  Element      [VARIABLES]  List    contents    elements    boolean    
return  !contents.isEmpty  (  )  ?  contents.get  (  contents.size  (  )  -  1  )  :  null;	[BUGGY]  return  !contents.isEmpty(  )  ?  contents.get(  contents.size(  )    <=    1)  :  null;  [CONTEXT]  public  Element  last()  {  [BUGGY]  return  !contents.isEmpty  ()?  contents.get  (  contents.size  ()  <=1  ):  null;  }        [CLASS]  Elements    [METHOD]  last  [RETURN_TYPE]  Element      [VARIABLES]  List    contents    elements    boolean    
return  !contents.isEmpty  (  )  ?  contents.get  (  contents.size  (  )  -  1  )  :  null;	[BUGGY]  return  !contents.isEmpty(  )  ?  contents.get(  contents.size()  -  0    -  1)  :  null;  [CONTEXT]  public  Element  last()  {  [BUGGY]  return  !contents.isEmpty  ()?  contents.get  (  contents.size()  -  0-  1  ):  null;  }        [CLASS]  Elements    [METHOD]  last  [RETURN_TYPE]  Element      [VARIABLES]  List    contents    elements    boolean    
return  !contents.isEmpty  (  )  ?  contents.get  (  contents.size  (  )  -  1  )  :  null;	[BUGGY]  return  !contents.isEmpty(  )  ?  1.get(  contents.size(  )  -  1)  :  null;  [CONTEXT]  public  Element  last()  {  [BUGGY]  return  !contents.isEmpty  ()?  1.get  (  contents.size  ()-  1  ):  null;  }        [CLASS]  Elements    [METHOD]  last  [RETURN_TYPE]  Element      [VARIABLES]  List    contents    elements    boolean    
return  !contents.isEmpty  (  )  ?  contents.get  (  contents.size  (  )  -  1  )  :  null;	[BUGGY]  return  !contents.isEmpty(  )  ?  contents.get(  contents.size()  -  6    -  1)  :  null;  [CONTEXT]  public  Element  last()  {  [BUGGY]  return  !contents.isEmpty  ()?  contents.get  (  contents.size()  -  6-  1  ):  null;  }        [CLASS]  Elements    [METHOD]  last  [RETURN_TYPE]  Element      [VARIABLES]  List    contents    elements    boolean    
public  int  size  (  )  {return  contents.size  (  )  ;}	[BUGGY]  public  int  size()  -  7    {return  contents.size()  -  7  ;}  [CONTEXT]  public  Element  last()  {  return  !contents.isEmpty()  ?  contents.get(contents.size()  -  1)  :  null;  }        [BUGGY]  public  int  size()  -  7{return  contents.size()  -  7  ;}    public  boolean  isEmpty()  {return  contents.isEmpty();}    public  boolean  contains(Object  o)  {return  contents.contains(o);}          [CLASS]  Elements    [METHOD]  size  [RETURN_TYPE]  int      [VARIABLES]  List    contents    elements    boolean    
public  int  size  (  )  {return  contents.size  (  )  ;}	[BUGGY]  public  int  size(  )  {return  contents.get(  );}  [CONTEXT]  public  Element  last()  {  return  !contents.isEmpty()  ?  contents.get(contents.size()  -  1)  :  null;  }        [BUGGY]  public  int  size  (){return  contents.get  ()  ;}    public  boolean  isEmpty()  {return  contents.isEmpty();}    public  boolean  contains(Object  o)  {return  contents.contains(o);}          [CLASS]  Elements    [METHOD]  size  [RETURN_TYPE]  int      [VARIABLES]  List    contents    elements    boolean    
public  int  size  (  )  {return  contents.size  (  )  ;}	[BUGGY]  public  int  size()  +  0    {return  contents.size()  +  0  ;}  [CONTEXT]  public  Element  last()  {  return  !contents.isEmpty()  ?  contents.get(contents.size()  -  1)  :  null;  }        [BUGGY]  public  int  size()  +  0{return  contents.size()  +  0  ;}    public  boolean  isEmpty()  {return  contents.isEmpty();}    public  boolean  contains(Object  o)  {return  contents.contains(o);}          [CLASS]  Elements    [METHOD]  size  [RETURN_TYPE]  int      [VARIABLES]  List    contents    elements    boolean    
public  boolean  isEmpty  (  )  {return  contents.isEmpty  (  )  ;}	[BUGGY]  public  boolean  isEmpty(  )  {return  contents.iterator(  );}  [CONTEXT]  }        public  int  size()  {return  contents.size();}    [BUGGY]  public  boolean  isEmpty  (){return  contents.iterator  ()  ;}    public  boolean  contains(Object  o)  {return  contents.contains(o);}    public  Iterator<Element>  iterator()  {return  contents.iterator();}          [CLASS]  Elements    [METHOD]  isEmpty  [RETURN_TYPE]  boolean      [VARIABLES]  List    contents    elements    boolean    
public  boolean  contains  (  Object  o  )  {return  contents.contains  (  o  )  ;}	[BUGGY]  public  boolean  contains(  Object  contents)  {return  o.contains(  o);}  [CONTEXT]      public  int  size()  {return  contents.size();}    public  boolean  isEmpty()  {return  contents.isEmpty();}    [BUGGY]  public  boolean  contains  (  Object  contents  ){return  o.contains  (  o  )  ;}    public  Iterator<Element>  iterator()  {return  contents.iterator();}    public  Object[]  toArray()  {return  contents.toArray();}          [CLASS]  Elements    [METHOD]  contains  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  List    contents    elements    Object    o    boolean    
public  boolean  contains  (  Object  o  )  {return  contents.contains  (  o  )  ;}	[BUGGY]  public  boolean  contains(  Object  o)  {return  contents.equals(  o);}  [CONTEXT]      public  int  size()  {return  contents.size();}    public  boolean  isEmpty()  {return  contents.isEmpty();}    [BUGGY]  public  boolean  contains  (  Object  o  ){return  contents.equals  (  o  )  ;}    public  Iterator<Element>  iterator()  {return  contents.iterator();}    public  Object[]  toArray()  {return  contents.toArray();}          [CLASS]  Elements    [METHOD]  contains  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  List    contents    elements    Object    o    boolean    
public  Iterator<Element>  iterator  (  )  {return  contents.iterator  (  )  ;}	[BUGGY]  public  Iterator<Element>  iterator(  )  {return  contents.listIterator(  );}  [CONTEXT]    public  boolean  isEmpty()  {return  contents.isEmpty();}    public  boolean  contains(Object  o)  {return  contents.contains(o);}    [BUGGY]  public  Iterator<Element>  iterator  (){return  contents.listIterator  ()  ;}    public  Object[]  toArray()  {return  contents.toArray();}    public  <T>  T[]  toArray(T[]  a)  {return  contents.toArray(a);}          [CLASS]  Elements    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  List    contents    elements    boolean    
public  Object[]  toArray  (  )  {return  contents.toArray  (  )  ;}	[BUGGY]  public  Object[]  toArray(  )  {return  contents.isEmpty(  );}  [CONTEXT]    public  boolean  contains(Object  o)  {return  contents.contains(o);}    public  Iterator<Element>  iterator()  {return  contents.iterator();}    [BUGGY]  public  Object[]  toArray  (){return  contents.isEmpty  ()  ;}    public  <T>  T[]  toArray(T[]  a)  {return  contents.toArray(a);}    public  boolean  add(Element  element)  {return  contents.add(element);}          [CLASS]  Elements    [METHOD]  toArray  [RETURN_TYPE]  Object[]      [VARIABLES]  List    contents    elements    boolean    
public  Object[]  toArray  (  )  {return  contents.toArray  (  )  ;}	[BUGGY]  public  Object[]  toArray(  )  {return  contents  .toArray(  )  ;}  [CONTEXT]    public  boolean  contains(Object  o)  {return  contents.contains(o);}    public  Iterator<Element>  iterator()  {return  contents.iterator();}    [BUGGY]  public  Object[]  toArray  (){return  contents  .toArray  ();}    public  <T>  T[]  toArray(T[]  a)  {return  contents.toArray(a);}    public  boolean  add(Element  element)  {return  contents.add(element);}          [CLASS]  Elements    [METHOD]  toArray  [RETURN_TYPE]  Object[]      [VARIABLES]  List    contents    elements    boolean    
public  <T>  T[]  toArray  (  T[]  a  )  {return  contents.toArray  (  a  )  ;}	[BUGGY]  public  <T>  T[]  toArray(  T[]  contents)  {return  a.toArray(  a);}  [CONTEXT]    public  Iterator<Element>  iterator()  {return  contents.iterator();}    public  Object[]  toArray()  {return  contents.toArray();}    [BUGGY]  public  <T>  T[]  toArray  (  T[]  contents  ){return  a.toArray  (  a  )  ;}    public  boolean  add(Element  element)  {return  contents.add(element);}    public  boolean  remove(Object  o)  {return  contents.remove(o);}          [CLASS]  Elements    [METHOD]  toArray  [RETURN_TYPE]  <T>      T[]  a  [VARIABLES]  List    contents    elements    T[]    a    boolean    
public  <T>  T[]  toArray  (  T[]  a  )  {return  contents.toArray  (  a  )  ;}	[BUGGY]  public  <T>  T[]  toArray(  T[]  a)  {return  contents.get(  a);}  [CONTEXT]    public  Iterator<Element>  iterator()  {return  contents.iterator();}    public  Object[]  toArray()  {return  contents.toArray();}    [BUGGY]  public  <T>  T[]  toArray  (  T[]  a  ){return  contents.get  (  a  )  ;}    public  boolean  add(Element  element)  {return  contents.add(element);}    public  boolean  remove(Object  o)  {return  contents.remove(o);}          [CLASS]  Elements    [METHOD]  toArray  [RETURN_TYPE]  <T>      T[]  a  [VARIABLES]  List    contents    elements    T[]    a    boolean    
public  <T>  T[]  toArray  (  T[]  a  )  {return  contents.toArray  (  a  )  ;}	[BUGGY]  public  <T>  T[]  toArray(  T[]  a)  {return  this.toArray(  a);}  [CONTEXT]    public  Iterator<Element>  iterator()  {return  contents.iterator();}    public  Object[]  toArray()  {return  contents.toArray();}    [BUGGY]  public  <T>  T[]  toArray  (  T[]  a  ){return  this.toArray  (  a  )  ;}    public  boolean  add(Element  element)  {return  contents.add(element);}    public  boolean  remove(Object  o)  {return  contents.remove(o);}          [CLASS]  Elements    [METHOD]  toArray  [RETURN_TYPE]  <T>      T[]  a  [VARIABLES]  List    contents    elements    T[]    a    boolean    
public  boolean  add  (  Element  element  )  {return  contents.add  (  element  )  ;}	[BUGGY]  public  boolean  add(  Element  contents)  {return  element.add(  element);}  [CONTEXT]    public  Object[]  toArray()  {return  contents.toArray();}    public  <T>  T[]  toArray(T[]  a)  {return  contents.toArray(a);}    [BUGGY]  public  boolean  add  (  Element  contents  ){return  element.add  (  element  )  ;}    public  boolean  remove(Object  o)  {return  contents.remove(o);}    public  boolean  containsAll(Collection<?>  c)  {return  contents.containsAll(c);}          [CLASS]  Elements    [METHOD]  add  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  List    contents    elements    Element    element    boolean    
public  boolean  add  (  Element  element  )  {return  contents.add  (  element  )  ;}	[BUGGY]  public  boolean  add(  Element  element)  {return  contents.addAll(  element);}  [CONTEXT]    public  Object[]  toArray()  {return  contents.toArray();}    public  <T>  T[]  toArray(T[]  a)  {return  contents.toArray(a);}    [BUGGY]  public  boolean  add  (  Element  element  ){return  contents.addAll  (  element  )  ;}    public  boolean  remove(Object  o)  {return  contents.remove(o);}    public  boolean  containsAll(Collection<?>  c)  {return  contents.containsAll(c);}          [CLASS]  Elements    [METHOD]  add  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  List    contents    elements    Element    element    boolean    
public  boolean  add  (  Element  element  )  {return  contents.add  (  element  )  ;}	[BUGGY]  public  boolean  add(  Element  element)  {return  0.add(  element);}  [CONTEXT]    public  Object[]  toArray()  {return  contents.toArray();}    public  <T>  T[]  toArray(T[]  a)  {return  contents.toArray(a);}    [BUGGY]  public  boolean  add  (  Element  element  ){return  0.add  (  element  )  ;}    public  boolean  remove(Object  o)  {return  contents.remove(o);}    public  boolean  containsAll(Collection<?>  c)  {return  contents.containsAll(c);}          [CLASS]  Elements    [METHOD]  add  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  List    contents    elements    Element    element    boolean    
public  boolean  remove  (  Object  o  )  {return  contents.remove  (  o  )  ;}	[BUGGY]  public  boolean  remove(  Object  contents)  {return  o.remove(  o);}  [CONTEXT]    public  <T>  T[]  toArray(T[]  a)  {return  contents.toArray(a);}    public  boolean  add(Element  element)  {return  contents.add(element);}    [BUGGY]  public  boolean  remove  (  Object  contents  ){return  o.remove  (  o  )  ;}    public  boolean  containsAll(Collection<?>  c)  {return  contents.containsAll(c);}    public  boolean  addAll(Collection<?  extends  Element>  c)  {return  contents.addAll(c);}          [CLASS]  Elements    [METHOD]  remove  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  List    contents    elements    Object    o    boolean    
public  boolean  remove  (  Object  o  )  {return  contents.remove  (  o  )  ;}	[BUGGY]  public  boolean  remove(  Object  o)  {return  contents.indexOf(  o);}  [CONTEXT]    public  <T>  T[]  toArray(T[]  a)  {return  contents.toArray(a);}    public  boolean  add(Element  element)  {return  contents.add(element);}    [BUGGY]  public  boolean  remove  (  Object  o  ){return  contents.indexOf  (  o  )  ;}    public  boolean  containsAll(Collection<?>  c)  {return  contents.containsAll(c);}    public  boolean  addAll(Collection<?  extends  Element>  c)  {return  contents.addAll(c);}          [CLASS]  Elements    [METHOD]  remove  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  List    contents    elements    Object    o    boolean    
public  boolean  containsAll  (  Collection<?>  c  )  {return  contents.containsAll  (  c  )  ;}	[BUGGY]  public  boolean  contentsontainsAll(  Collection<?>  c)  {return  c.containsAll(  c);}  [CONTEXT]    public  boolean  add(Element  element)  {return  contents.add(element);}    public  boolean  remove(Object  o)  {return  contents.remove(o);}    [BUGGY]  public  boolean  contentsontainsAll  (  Collection<?>  c  ){return  c.containsAll  (  c  )  ;}    public  boolean  addAll(Collection<?  extends  Element>  c)  {return  contents.addAll(c);}    public  boolean  addAll(int  index,  Collection<?  extends  Element>  c)  {return  contents.addAll(index,  c);}          [CLASS]  Elements    [METHOD]  containsAll  [RETURN_TYPE]  boolean      Collection<?>  c  [VARIABLES]  Collection    c    List    contents    elements    boolean    
public  boolean  containsAll  (  Collection<?>  c  )  {return  contents.containsAll  (  c  )  ;}	[BUGGY]  public  boolean  containsAll(  Collection<?>  c)  {return  contents.retainAll(  c);}  [CONTEXT]    public  boolean  add(Element  element)  {return  contents.add(element);}    public  boolean  remove(Object  o)  {return  contents.remove(o);}    [BUGGY]  public  boolean  containsAll  (  Collection<?>  c  ){return  contents.retainAll  (  c  )  ;}    public  boolean  addAll(Collection<?  extends  Element>  c)  {return  contents.addAll(c);}    public  boolean  addAll(int  index,  Collection<?  extends  Element>  c)  {return  contents.addAll(index,  c);}          [CLASS]  Elements    [METHOD]  containsAll  [RETURN_TYPE]  boolean      Collection<?>  c  [VARIABLES]  Collection    c    List    contents    elements    boolean    
public  boolean  containsAll  (  Collection<?>  c  )  {return  contents.containsAll  (  c  )  ;}	[BUGGY]  public  boolean  containsAll(  Collection<?>  c)  {return  contents  .contains(  null)  ;}  [CONTEXT]    public  boolean  add(Element  element)  {return  contents.add(element);}    public  boolean  remove(Object  o)  {return  contents.remove(o);}    [BUGGY]  public  boolean  containsAll  (  Collection<?>  c  ){return  contents  .contains  (  null  );}    public  boolean  addAll(Collection<?  extends  Element>  c)  {return  contents.addAll(c);}    public  boolean  addAll(int  index,  Collection<?  extends  Element>  c)  {return  contents.addAll(index,  c);}          [CLASS]  Elements    [METHOD]  containsAll  [RETURN_TYPE]  boolean      Collection<?>  c  [VARIABLES]  Collection    c    List    contents    elements    boolean    
public  boolean  addAll  (  Collection<?  extends  Element>  c  )  {return  contents.addAll  (  c  )  ;}	[BUGGY]  public  boolean  addAll(  Collection<?  extends  Element>  contents)  {return  c.addAll(  c);}  [CONTEXT]    public  boolean  remove(Object  o)  {return  contents.remove(o);}    public  boolean  containsAll(Collection<?>  c)  {return  contents.containsAll(c);}    [BUGGY]  public  boolean  addAll  (  Collection<?  extends  Element>  contents  ){return  c.addAll  (  c  )  ;}    public  boolean  addAll(int  index,  Collection<?  extends  Element>  c)  {return  contents.addAll(index,  c);}    public  boolean  removeAll(Collection<?>  c)  {return  contents.removeAll(c);}          [CLASS]  Elements    [METHOD]  addAll  [RETURN_TYPE]  boolean      Element>  c  [VARIABLES]  Collection    c    List    contents    elements    boolean    
public  boolean  addAll  (  Collection<?  extends  Element>  c  )  {return  contents.addAll  (  c  )  ;}	[BUGGY]  public  boolean  addAll(  Collection<?  extends  Element>  c)  {return  contents.retainAll(  c);}  [CONTEXT]    public  boolean  remove(Object  o)  {return  contents.remove(o);}    public  boolean  containsAll(Collection<?>  c)  {return  contents.containsAll(c);}    [BUGGY]  public  boolean  addAll  (  Collection<?  extends  Element>  c  ){return  contents.retainAll  (  c  )  ;}    public  boolean  addAll(int  index,  Collection<?  extends  Element>  c)  {return  contents.addAll(index,  c);}    public  boolean  removeAll(Collection<?>  c)  {return  contents.removeAll(c);}          [CLASS]  Elements    [METHOD]  addAll  [RETURN_TYPE]  boolean      Element>  c  [VARIABLES]  Collection    c    List    contents    elements    boolean    
public  boolean  addAll  (  int  index,  Collection<?  extends  Element>  c  )  {return  contents.addAll  (  index,  c  )  ;}	[BUGGY]  public  boolean  addAll(  int  contents,  Collection<?  extends  Element>  c)  {return  index.addAll(  index,  c);}  [CONTEXT]    public  boolean  containsAll(Collection<?>  c)  {return  contents.containsAll(c);}    public  boolean  addAll(Collection<?  extends  Element>  c)  {return  contents.addAll(c);}    [BUGGY]  public  boolean  addAll  (  int  contents,  Collection<?  extends  Element>  c  ){return  index.addAll  (  index,  c  )  ;}    public  boolean  removeAll(Collection<?>  c)  {return  contents.removeAll(c);}    public  boolean  retainAll(Collection<?>  c)  {return  contents.retainAll(c);}          [CLASS]  Elements    [METHOD]  addAll  [RETURN_TYPE]  boolean      int  index  Element>  c  [VARIABLES]  Collection    c    List    contents    elements    boolean    int    index    
public  boolean  addAll  (  int  index,  Collection<?  extends  Element>  c  )  {return  contents.addAll  (  index,  c  )  ;}	[BUGGY]  public  boolean  addAll(  int    Collection<?  extends  Element>  c)  {return  contents.addAll(  index,  c);}  [CONTEXT]    public  boolean  containsAll(Collection<?>  c)  {return  contents.containsAll(c);}    public  boolean  addAll(Collection<?  extends  Element>  c)  {return  contents.addAll(c);}    [BUGGY]  public  boolean  addAll  (  intCollection<?  extends  Element>  c  ){return  contents.addAll  (  index,  c  )  ;}    public  boolean  removeAll(Collection<?>  c)  {return  contents.removeAll(c);}    public  boolean  retainAll(Collection<?>  c)  {return  contents.retainAll(c);}          [CLASS]  Elements    [METHOD]  addAll  [RETURN_TYPE]  boolean      int  index  Element>  c  [VARIABLES]  Collection    c    List    contents    elements    boolean    int    index    
public  boolean  addAll  (  int  index,  Collection<?  extends  Element>  c  )  {return  contents.addAll  (  index,  c  )  ;}	[BUGGY]  public  boolean  addAll(  int  c,  Collection<?  extends  Element>  index)  {return  contents.addAll(  index,  c);}  [CONTEXT]    public  boolean  containsAll(Collection<?>  c)  {return  contents.containsAll(c);}    public  boolean  addAll(Collection<?  extends  Element>  c)  {return  contents.addAll(c);}    [BUGGY]  public  boolean  addAll  (  int  c,  Collection<?  extends  Element>  index  ){return  contents.addAll  (  index,  c  )  ;}    public  boolean  removeAll(Collection<?>  c)  {return  contents.removeAll(c);}    public  boolean  retainAll(Collection<?>  c)  {return  contents.retainAll(c);}          [CLASS]  Elements    [METHOD]  addAll  [RETURN_TYPE]  boolean      int  index  Element>  c  [VARIABLES]  Collection    c    List    contents    elements    boolean    int    index    
public  boolean  addAll  (  int  index,  Collection<?  extends  Element>  c  )  {return  contents.addAll  (  index,  c  )  ;}	[BUGGY]  public  boolean  addAll(  int  index,  Collection<?  extends  Element>  c)  {return  contents.addAll(  index);}  [CONTEXT]    public  boolean  containsAll(Collection<?>  c)  {return  contents.containsAll(c);}    public  boolean  addAll(Collection<?  extends  Element>  c)  {return  contents.addAll(c);}    [BUGGY]  public  boolean  addAll  (  int  index,  Collection<?  extends  Element>  c  ){return  contents.addAll  (  index  )  ;}    public  boolean  removeAll(Collection<?>  c)  {return  contents.removeAll(c);}    public  boolean  retainAll(Collection<?>  c)  {return  contents.retainAll(c);}          [CLASS]  Elements    [METHOD]  addAll  [RETURN_TYPE]  boolean      int  index  Element>  c  [VARIABLES]  Collection    c    List    contents    elements    boolean    int    index    
public  boolean  addAll  (  int  index,  Collection<?  extends  Element>  c  )  {return  contents.addAll  (  index,  c  )  ;}	[BUGGY]  public  boolean  addAll(  int  index,  Collection<?  extends  Element>  c)  {return  contents.add(  index,  c);}  [CONTEXT]    public  boolean  containsAll(Collection<?>  c)  {return  contents.containsAll(c);}    public  boolean  addAll(Collection<?  extends  Element>  c)  {return  contents.addAll(c);}    [BUGGY]  public  boolean  addAll  (  int  index,  Collection<?  extends  Element>  c  ){return  contents.add  (  index,  c  )  ;}    public  boolean  removeAll(Collection<?>  c)  {return  contents.removeAll(c);}    public  boolean  retainAll(Collection<?>  c)  {return  contents.retainAll(c);}          [CLASS]  Elements    [METHOD]  addAll  [RETURN_TYPE]  boolean      int  index  Element>  c  [VARIABLES]  Collection    c    List    contents    elements    boolean    int    index    
public  boolean  addAll  (  int  index,  Collection<?  extends  Element>  c  )  {return  contents.addAll  (  index,  c  )  ;}	[BUGGY]  public  boolean  addAll(  int  index,  Collection<?  extends  Element>  contents)  {return  c.addAll(  index,  c);}  [CONTEXT]    public  boolean  containsAll(Collection<?>  c)  {return  contents.containsAll(c);}    public  boolean  addAll(Collection<?  extends  Element>  c)  {return  contents.addAll(c);}    [BUGGY]  public  boolean  addAll  (  int  index,  Collection<?  extends  Element>  contents  ){return  c.addAll  (  index,  c  )  ;}    public  boolean  removeAll(Collection<?>  c)  {return  contents.removeAll(c);}    public  boolean  retainAll(Collection<?>  c)  {return  contents.retainAll(c);}          [CLASS]  Elements    [METHOD]  addAll  [RETURN_TYPE]  boolean      int  index  Element>  c  [VARIABLES]  Collection    c    List    contents    elements    boolean    int    index    
public  boolean  addAll  (  int  index,  Collection<?  extends  Element>  c  )  {return  contents.addAll  (  index,  c  )  ;}	[BUGGY]  public  boolean  addAll(  int  index,  Collection<?  extends  Element>  c)  {return  null.addAll(  index,  c);}  [CONTEXT]    public  boolean  containsAll(Collection<?>  c)  {return  contents.containsAll(c);}    public  boolean  addAll(Collection<?  extends  Element>  c)  {return  contents.addAll(c);}    [BUGGY]  public  boolean  addAll  (  int  index,  Collection<?  extends  Element>  c  ){return  null.addAll  (  index,  c  )  ;}    public  boolean  removeAll(Collection<?>  c)  {return  contents.removeAll(c);}    public  boolean  retainAll(Collection<?>  c)  {return  contents.retainAll(c);}          [CLASS]  Elements    [METHOD]  addAll  [RETURN_TYPE]  boolean      int  index  Element>  c  [VARIABLES]  Collection    c    List    contents    elements    boolean    int    index    
public  boolean  removeAll  (  Collection<?>  c  )  {return  contents.removeAll  (  c  )  ;}	[BUGGY]  public  boolean  removeAll(  Collection<?>  contents)  {return  c.removeAll(  c);}  [CONTEXT]    public  boolean  addAll(Collection<?  extends  Element>  c)  {return  contents.addAll(c);}    public  boolean  addAll(int  index,  Collection<?  extends  Element>  c)  {return  contents.addAll(index,  c);}    [BUGGY]  public  boolean  removeAll  (  Collection<?>  contents  ){return  c.removeAll  (  c  )  ;}    public  boolean  retainAll(Collection<?>  c)  {return  contents.retainAll(c);}    public  void  clear()  {contents.clear();}          [CLASS]  Elements    [METHOD]  removeAll  [RETURN_TYPE]  boolean      Collection<?>  c  [VARIABLES]  Collection    c    List    contents    elements    boolean    
public  boolean  removeAll  (  Collection<?>  c  )  {return  contents.removeAll  (  c  )  ;}	[BUGGY]  public  boolean  removeAll(  Collection<?>  c)  {return  contents.retainAll(  c);}  [CONTEXT]    public  boolean  addAll(Collection<?  extends  Element>  c)  {return  contents.addAll(c);}    public  boolean  addAll(int  index,  Collection<?  extends  Element>  c)  {return  contents.addAll(index,  c);}    [BUGGY]  public  boolean  removeAll  (  Collection<?>  c  ){return  contents.retainAll  (  c  )  ;}    public  boolean  retainAll(Collection<?>  c)  {return  contents.retainAll(c);}    public  void  clear()  {contents.clear();}          [CLASS]  Elements    [METHOD]  removeAll  [RETURN_TYPE]  boolean      Collection<?>  c  [VARIABLES]  Collection    c    List    contents    elements    boolean    
public  boolean  retainAll  (  Collection<?>  c  )  {return  contents.retainAll  (  c  )  ;}	[BUGGY]  public  boolean  retainAll(  Collection<?>  contents)  {return  c.retainAll(  c);}  [CONTEXT]    public  boolean  addAll(int  index,  Collection<?  extends  Element>  c)  {return  contents.addAll(index,  c);}    public  boolean  removeAll(Collection<?>  c)  {return  contents.removeAll(c);}    [BUGGY]  public  boolean  retainAll  (  Collection<?>  contents  ){return  c.retainAll  (  c  )  ;}    public  void  clear()  {contents.clear();}    public  boolean  equals(Object  o)  {return  contents.equals(o);}          [CLASS]  Elements    [METHOD]  retainAll  [RETURN_TYPE]  boolean      Collection<?>  c  [VARIABLES]  Collection    c    List    contents    elements    boolean    
public  boolean  retainAll  (  Collection<?>  c  )  {return  contents.retainAll  (  c  )  ;}	[BUGGY]  public  boolean  retainAll(  Collection<?>  c)  {return  contents.containsAll(  c);}  [CONTEXT]    public  boolean  addAll(int  index,  Collection<?  extends  Element>  c)  {return  contents.addAll(index,  c);}    public  boolean  removeAll(Collection<?>  c)  {return  contents.removeAll(c);}    [BUGGY]  public  boolean  retainAll  (  Collection<?>  c  ){return  contents.containsAll  (  c  )  ;}    public  void  clear()  {contents.clear();}    public  boolean  equals(Object  o)  {return  contents.equals(o);}          [CLASS]  Elements    [METHOD]  retainAll  [RETURN_TYPE]  boolean      Collection<?>  c  [VARIABLES]  Collection    c    List    contents    elements    boolean    
public  boolean  retainAll  (  Collection<?>  c  )  {return  contents.retainAll  (  c  )  ;}	[BUGGY]  public  boolean  retainAll(  Collection<?>  1)  {return  contents.containsAll(  c);}  [CONTEXT]    public  boolean  addAll(int  index,  Collection<?  extends  Element>  c)  {return  contents.addAll(index,  c);}    public  boolean  removeAll(Collection<?>  c)  {return  contents.removeAll(c);}    [BUGGY]  public  boolean  retainAll  (  Collection<?>  1  ){return  contents.containsAll  (  c  )  ;}    public  void  clear()  {contents.clear();}    public  boolean  equals(Object  o)  {return  contents.equals(o);}          [CLASS]  Elements    [METHOD]  retainAll  [RETURN_TYPE]  boolean      Collection<?>  c  [VARIABLES]  Collection    c    List    contents    elements    boolean    
public  void  clear  (  )  {contents.clear  (  )  ;}	[BUGGY]  public  void  clear(  )  {contents.get(  );}  [CONTEXT]    public  boolean  removeAll(Collection<?>  c)  {return  contents.removeAll(c);}    public  boolean  retainAll(Collection<?>  c)  {return  contents.retainAll(c);}    [BUGGY]  public  void  clear  (){contents.get  ()  ;}    public  boolean  equals(Object  o)  {return  contents.equals(o);}    public  int  hashCode()  {return  contents.hashCode();}          [CLASS]  Elements    [METHOD]  clear  [RETURN_TYPE]  void      [VARIABLES]  List    contents    elements    boolean    
public  void  clear  (  )  {contents.clear  (  )  ;}	[BUGGY]  public  void  clear(  )  {contents  .iterator(  )  ;}  [CONTEXT]    public  boolean  removeAll(Collection<?>  c)  {return  contents.removeAll(c);}    public  boolean  retainAll(Collection<?>  c)  {return  contents.retainAll(c);}    [BUGGY]  public  void  clear  (){contents  .iterator  ();}    public  boolean  equals(Object  o)  {return  contents.equals(o);}    public  int  hashCode()  {return  contents.hashCode();}          [CLASS]  Elements    [METHOD]  clear  [RETURN_TYPE]  void      [VARIABLES]  List    contents    elements    boolean    
public  boolean  equals  (  Object  o  )  {return  contents.equals  (  o  )  ;}	[BUGGY]  public  boolean  equals(  Object  o)  {return  null.equals(  o);}  [CONTEXT]    public  boolean  retainAll(Collection<?>  c)  {return  contents.retainAll(c);}    public  void  clear()  {contents.clear();}    [BUGGY]  public  boolean  equals  (  Object  o  ){return  null.equals  (  o  )  ;}    public  int  hashCode()  {return  contents.hashCode();}    public  Element  get(int  index)  {return  contents.get(index);}          [CLASS]  Elements    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  List    contents    elements    Object    o    boolean    
public  boolean  equals  (  Object  o  )  {return  contents.equals  (  o  )  ;}	[BUGGY]  public  boolean  equals(  Object  contents)  {return  o.equals(  o);}  [CONTEXT]    public  boolean  retainAll(Collection<?>  c)  {return  contents.retainAll(c);}    public  void  clear()  {contents.clear();}    [BUGGY]  public  boolean  equals  (  Object  contents  ){return  o.equals  (  o  )  ;}    public  int  hashCode()  {return  contents.hashCode();}    public  Element  get(int  index)  {return  contents.get(index);}          [CLASS]  Elements    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  List    contents    elements    Object    o    boolean    
public  boolean  equals  (  Object  o  )  {return  contents.equals  (  o  )  ;}	[BUGGY]  public  boolean  equals(  Object  o)  {return  contents.contains(  o);}  [CONTEXT]    public  boolean  retainAll(Collection<?>  c)  {return  contents.retainAll(c);}    public  void  clear()  {contents.clear();}    [BUGGY]  public  boolean  equals  (  Object  o  ){return  contents.contains  (  o  )  ;}    public  int  hashCode()  {return  contents.hashCode();}    public  Element  get(int  index)  {return  contents.get(index);}          [CLASS]  Elements    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  List    contents    elements    Object    o    boolean    
public  int  hashCode  (  )  {return  contents.hashCode  (  )  ;}	[BUGGY]  public  int  hashCode(  )  {return  contents.size(  );}  [CONTEXT]    public  void  clear()  {contents.clear();}    public  boolean  equals(Object  o)  {return  contents.equals(o);}    [BUGGY]  public  int  hashCode  (){return  contents.size  ()  ;}    public  Element  get(int  index)  {return  contents.get(index);}    public  Element  set(int  index,  Element  element)  {return  contents.set(index,  element);}          [CLASS]  Elements    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  List    contents    elements    boolean    
public  int  hashCode  (  )  {return  contents.hashCode  (  )  ;}	[BUGGY]  public  int  hashCode(  )  {return  contents  .lastIndexOf(  null)  ;}  [CONTEXT]    public  void  clear()  {contents.clear();}    public  boolean  equals(Object  o)  {return  contents.equals(o);}    [BUGGY]  public  int  hashCode  (){return  contents  .lastIndexOf  (  null  );}    public  Element  get(int  index)  {return  contents.get(index);}    public  Element  set(int  index,  Element  element)  {return  contents.set(index,  element);}          [CLASS]  Elements    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  List    contents    elements    boolean    
public  Element  get  (  int  index  )  {return  contents.get  (  index  )  ;}	[BUGGY]  public  Element  get(  int  contents)  {return  index.get(  index);}  [CONTEXT]    public  boolean  equals(Object  o)  {return  contents.equals(o);}    public  int  hashCode()  {return  contents.hashCode();}    [BUGGY]  public  Element  get  (  int  contents  ){return  index.get  (  index  )  ;}    public  Element  set(int  index,  Element  element)  {return  contents.set(index,  element);}    public  void  add(int  index,  Element  element)  {contents.add(index,  element);}          [CLASS]  Elements    [METHOD]  get  [RETURN_TYPE]  Element      int  index  [VARIABLES]  List    contents    elements    int    index    boolean    
public  Element  get  (  int  index  )  {return  contents.get  (  index  )  ;}	[BUGGY]  public  Element  get(  int  index)  {return  contents.remove(  index);}  [CONTEXT]    public  boolean  equals(Object  o)  {return  contents.equals(o);}    public  int  hashCode()  {return  contents.hashCode();}    [BUGGY]  public  Element  get  (  int  index  ){return  contents.remove  (  index  )  ;}    public  Element  set(int  index,  Element  element)  {return  contents.set(index,  element);}    public  void  add(int  index,  Element  element)  {contents.add(index,  element);}          [CLASS]  Elements    [METHOD]  get  [RETURN_TYPE]  Element      int  index  [VARIABLES]  List    contents    elements    int    index    boolean    
public  Element  get  (  int  index  )  {return  contents.get  (  index  )  ;}	[BUGGY]  public  Element  get(  int  index)  {return  2.get(  index);}  [CONTEXT]    public  boolean  equals(Object  o)  {return  contents.equals(o);}    public  int  hashCode()  {return  contents.hashCode();}    [BUGGY]  public  Element  get  (  int  index  ){return  2.get  (  index  )  ;}    public  Element  set(int  index,  Element  element)  {return  contents.set(index,  element);}    public  void  add(int  index,  Element  element)  {contents.add(index,  element);}          [CLASS]  Elements    [METHOD]  get  [RETURN_TYPE]  Element      int  index  [VARIABLES]  List    contents    elements    int    index    boolean    
public  Element  set  (  int  index,  Element  element  )  {return  contents.set  (  index,  element  )  ;}	[BUGGY]  public  Element  set(  int  contents,  Element  element)  {return  index.set(  index,  element);}  [CONTEXT]    public  int  hashCode()  {return  contents.hashCode();}    public  Element  get(int  index)  {return  contents.get(index);}    [BUGGY]  public  Element  set  (  int  contents,  Element  element  ){return  index.set  (  index,  element  )  ;}    public  void  add(int  index,  Element  element)  {contents.add(index,  element);}    public  Element  remove(int  index)  {return  contents.remove(index);}          [CLASS]  Elements    [METHOD]  set  [RETURN_TYPE]  Element      int  index  Element  element  [VARIABLES]  List    contents    elements    boolean    int    index    Element    element    
public  Element  set  (  int  index,  Element  element  )  {return  contents.set  (  index,  element  )  ;}	[BUGGY]  public  Element  set(  int    Element  element)  {return  contents.set(  index,  element);}  [CONTEXT]    public  int  hashCode()  {return  contents.hashCode();}    public  Element  get(int  index)  {return  contents.get(index);}    [BUGGY]  public  Element  set  (  intElement  element  ){return  contents.set  (  index,  element  )  ;}    public  void  add(int  index,  Element  element)  {contents.add(index,  element);}    public  Element  remove(int  index)  {return  contents.remove(index);}          [CLASS]  Elements    [METHOD]  set  [RETURN_TYPE]  Element      int  index  Element  element  [VARIABLES]  List    contents    elements    boolean    int    index    Element    element    
public  Element  set  (  int  index,  Element  element  )  {return  contents.set  (  index,  element  )  ;}	[BUGGY]  public  Element  set(  int  index,  Element  contents)  {return  element.set(  index,  element);}  [CONTEXT]    public  int  hashCode()  {return  contents.hashCode();}    public  Element  get(int  index)  {return  contents.get(index);}    [BUGGY]  public  Element  set  (  int  index,  Element  contents  ){return  element.set  (  index,  element  )  ;}    public  void  add(int  index,  Element  element)  {contents.add(index,  element);}    public  Element  remove(int  index)  {return  contents.remove(index);}          [CLASS]  Elements    [METHOD]  set  [RETURN_TYPE]  Element      int  index  Element  element  [VARIABLES]  List    contents    elements    boolean    int    index    Element    element    
public  Element  set  (  int  index,  Element  element  )  {return  contents.set  (  index,  element  )  ;}	[BUGGY]  public  Element  set(  int  index,  Element  element)  {return  contents.set(  index);}  [CONTEXT]    public  int  hashCode()  {return  contents.hashCode();}    public  Element  get(int  index)  {return  contents.get(index);}    [BUGGY]  public  Element  set  (  int  index,  Element  element  ){return  contents.set  (  index  )  ;}    public  void  add(int  index,  Element  element)  {contents.add(index,  element);}    public  Element  remove(int  index)  {return  contents.remove(index);}          [CLASS]  Elements    [METHOD]  set  [RETURN_TYPE]  Element      int  index  Element  element  [VARIABLES]  List    contents    elements    boolean    int    index    Element    element    
public  Element  set  (  int  index,  Element  element  )  {return  contents.set  (  index,  element  )  ;}	[BUGGY]  public  Element  set(  int  index,  Element  element)  {return  contents.add(  index,  element);}  [CONTEXT]    public  int  hashCode()  {return  contents.hashCode();}    public  Element  get(int  index)  {return  contents.get(index);}    [BUGGY]  public  Element  set  (  int  index,  Element  element  ){return  contents.add  (  index,  element  )  ;}    public  void  add(int  index,  Element  element)  {contents.add(index,  element);}    public  Element  remove(int  index)  {return  contents.remove(index);}          [CLASS]  Elements    [METHOD]  set  [RETURN_TYPE]  Element      int  index  Element  element  [VARIABLES]  List    contents    elements    boolean    int    index    Element    element    
public  Element  set  (  int  index,  Element  element  )  {return  contents.set  (  index,  element  )  ;}	[BUGGY]  public  Element  set(  int  index,  Element  element)  {return  contents  .get(  index)  ;}  [CONTEXT]    public  int  hashCode()  {return  contents.hashCode();}    public  Element  get(int  index)  {return  contents.get(index);}    [BUGGY]  public  Element  set  (  int  index,  Element  element  ){return  contents  .get  (  index  );}    public  void  add(int  index,  Element  element)  {contents.add(index,  element);}    public  Element  remove(int  index)  {return  contents.remove(index);}          [CLASS]  Elements    [METHOD]  set  [RETURN_TYPE]  Element      int  index  Element  element  [VARIABLES]  List    contents    elements    boolean    int    index    Element    element    
public  Element  set  (  int  index,  Element  element  )  {return  contents.set  (  index,  element  )  ;}	[BUGGY]  public  Element  set(  int  index,  Element  element)  {return  null.set(  index,  element);}  [CONTEXT]    public  int  hashCode()  {return  contents.hashCode();}    public  Element  get(int  index)  {return  contents.get(index);}    [BUGGY]  public  Element  set  (  int  index,  Element  element  ){return  null.set  (  index,  element  )  ;}    public  void  add(int  index,  Element  element)  {contents.add(index,  element);}    public  Element  remove(int  index)  {return  contents.remove(index);}          [CLASS]  Elements    [METHOD]  set  [RETURN_TYPE]  Element      int  index  Element  element  [VARIABLES]  List    contents    elements    boolean    int    index    Element    element    
public  Element  set  (  int  index,  Element  element  )  {return  contents.set  (  index,  element  )  ;}	[BUGGY]  public  Element  set(  int  element,  Element  index)  {return  contents.set(  index,  element);}  [CONTEXT]    public  int  hashCode()  {return  contents.hashCode();}    public  Element  get(int  index)  {return  contents.get(index);}    [BUGGY]  public  Element  set  (  int  element,  Element  index  ){return  contents.set  (  index,  element  )  ;}    public  void  add(int  index,  Element  element)  {contents.add(index,  element);}    public  Element  remove(int  index)  {return  contents.remove(index);}          [CLASS]  Elements    [METHOD]  set  [RETURN_TYPE]  Element      int  index  Element  element  [VARIABLES]  List    contents    elements    boolean    int    index    Element    element    
public  void  add  (  int  index,  Element  element  )  {contents.add  (  index,  element  )  ;}	[BUGGY]  public  void  add(  int    Element  element)  {contents.add(  index,  element);}  [CONTEXT]    public  Element  get(int  index)  {return  contents.get(index);}    public  Element  set(int  index,  Element  element)  {return  contents.set(index,  element);}    [BUGGY]  public  void  add  (  intElement  element  ){contents.add  (  index,  element  )  ;}    public  Element  remove(int  index)  {return  contents.remove(index);}    public  int  indexOf(Object  o)  {return  contents.indexOf(o);}          [CLASS]  Elements    [METHOD]  add  [RETURN_TYPE]  void      int  index  Element  element  [VARIABLES]  List    contents    elements    boolean    int    index    Element    element    
public  void  add  (  int  index,  Element  element  )  {contents.add  (  index,  element  )  ;}	[BUGGY]  public  void  add(  int  element,  Element  index)  {contents.add(  index,  element);}  [CONTEXT]    public  Element  get(int  index)  {return  contents.get(index);}    public  Element  set(int  index,  Element  element)  {return  contents.set(index,  element);}    [BUGGY]  public  void  add  (  int  element,  Element  index  ){contents.add  (  index,  element  )  ;}    public  Element  remove(int  index)  {return  contents.remove(index);}    public  int  indexOf(Object  o)  {return  contents.indexOf(o);}          [CLASS]  Elements    [METHOD]  add  [RETURN_TYPE]  void      int  index  Element  element  [VARIABLES]  List    contents    elements    boolean    int    index    Element    element    
public  void  add  (  int  index,  Element  element  )  {contents.add  (  index,  element  )  ;}	[BUGGY]  public  void  add(  int  index,  Element  element)  {contents.add(  index);}  [CONTEXT]    public  Element  get(int  index)  {return  contents.get(index);}    public  Element  set(int  index,  Element  element)  {return  contents.set(index,  element);}    [BUGGY]  public  void  add  (  int  index,  Element  element  ){contents.add  (  index  )  ;}    public  Element  remove(int  index)  {return  contents.remove(index);}    public  int  indexOf(Object  o)  {return  contents.indexOf(o);}          [CLASS]  Elements    [METHOD]  add  [RETURN_TYPE]  void      int  index  Element  element  [VARIABLES]  List    contents    elements    boolean    int    index    Element    element    
public  void  add  (  int  index,  Element  element  )  {contents.add  (  index,  element  )  ;}	[BUGGY]  public  void  add(  int  index,  Element  element)  {contents.set(  index,  element);}  [CONTEXT]    public  Element  get(int  index)  {return  contents.get(index);}    public  Element  set(int  index,  Element  element)  {return  contents.set(index,  element);}    [BUGGY]  public  void  add  (  int  index,  Element  element  ){contents.set  (  index,  element  )  ;}    public  Element  remove(int  index)  {return  contents.remove(index);}    public  int  indexOf(Object  o)  {return  contents.indexOf(o);}          [CLASS]  Elements    [METHOD]  add  [RETURN_TYPE]  void      int  index  Element  element  [VARIABLES]  List    contents    elements    boolean    int    index    Element    element    
public  Element  remove  (  int  index  )  {return  contents.remove  (  index  )  ;}	[BUGGY]  public  Element  remove(  int  contents)  {return  index.remove(  index);}  [CONTEXT]    public  Element  set(int  index,  Element  element)  {return  contents.set(index,  element);}    public  void  add(int  index,  Element  element)  {contents.add(index,  element);}    [BUGGY]  public  Element  remove  (  int  contents  ){return  index.remove  (  index  )  ;}    public  int  indexOf(Object  o)  {return  contents.indexOf(o);}    public  int  lastIndexOf(Object  o)  {return  contents.lastIndexOf(o);}          [CLASS]  Elements    [METHOD]  remove  [RETURN_TYPE]  Element      int  index  [VARIABLES]  List    contents    elements    int    index    boolean    
public  Element  remove  (  int  index  )  {return  contents.remove  (  index  )  ;}	[BUGGY]  public  Element  remove(  int  index)  {return  contents.get(  index);}  [CONTEXT]    public  Element  set(int  index,  Element  element)  {return  contents.set(index,  element);}    public  void  add(int  index,  Element  element)  {contents.add(index,  element);}    [BUGGY]  public  Element  remove  (  int  index  ){return  contents.get  (  index  )  ;}    public  int  indexOf(Object  o)  {return  contents.indexOf(o);}    public  int  lastIndexOf(Object  o)  {return  contents.lastIndexOf(o);}          [CLASS]  Elements    [METHOD]  remove  [RETURN_TYPE]  Element      int  index  [VARIABLES]  List    contents    elements    int    index    boolean    
public  int  indexOf  (  Object  o  )  {return  contents.indexOf  (  o  )  ;}	[BUGGY]  public  int  indexOf(  Object  contents)  {return  o.indexOf(  o);}  [CONTEXT]    public  void  add(int  index,  Element  element)  {contents.add(index,  element);}    public  Element  remove(int  index)  {return  contents.remove(index);}    [BUGGY]  public  int  indexOf  (  Object  contents  ){return  o.indexOf  (  o  )  ;}    public  int  lastIndexOf(Object  o)  {return  contents.lastIndexOf(o);}    public  ListIterator<Element>  listIterator()  {return  contents.listIterator();}          [CLASS]  Elements    [METHOD]  indexOf  [RETURN_TYPE]  int      Object  o  [VARIABLES]  List    contents    elements    Object    o    boolean    
public  int  indexOf  (  Object  o  )  {return  contents.indexOf  (  o  )  ;}	[BUGGY]  public  int  indexOf(  Object  o)  {return  contents.lastIndexOf(  o);}  [CONTEXT]    public  void  add(int  index,  Element  element)  {contents.add(index,  element);}    public  Element  remove(int  index)  {return  contents.remove(index);}    [BUGGY]  public  int  indexOf  (  Object  o  ){return  contents.lastIndexOf  (  o  )  ;}    public  int  lastIndexOf(Object  o)  {return  contents.lastIndexOf(o);}    public  ListIterator<Element>  listIterator()  {return  contents.listIterator();}          [CLASS]  Elements    [METHOD]  indexOf  [RETURN_TYPE]  int      Object  o  [VARIABLES]  List    contents    elements    Object    o    boolean    
public  int  lastIndexOf  (  Object  o  )  {return  contents.lastIndexOf  (  o  )  ;}	[BUGGY]  public  int  lastIndexOf(  Object  contents)  {return  o.lastIndexOf(  o);}  [CONTEXT]    public  Element  remove(int  index)  {return  contents.remove(index);}    public  int  indexOf(Object  o)  {return  contents.indexOf(o);}    [BUGGY]  public  int  lastIndexOf  (  Object  contents  ){return  o.lastIndexOf  (  o  )  ;}    public  ListIterator<Element>  listIterator()  {return  contents.listIterator();}    public  ListIterator<Element>  listIterator(int  index)  {return  contents.listIterator(index);}          [CLASS]  Elements    [METHOD]  lastIndexOf  [RETURN_TYPE]  int      Object  o  [VARIABLES]  List    contents    elements    Object    o    boolean    
public  int  lastIndexOf  (  Object  o  )  {return  contents.lastIndexOf  (  o  )  ;}	[BUGGY]  public  int  lastIndexOf(  Object  o)  {return  contents.indexOf(  o);}  [CONTEXT]    public  Element  remove(int  index)  {return  contents.remove(index);}    public  int  indexOf(Object  o)  {return  contents.indexOf(o);}    [BUGGY]  public  int  lastIndexOf  (  Object  o  ){return  contents.indexOf  (  o  )  ;}    public  ListIterator<Element>  listIterator()  {return  contents.listIterator();}    public  ListIterator<Element>  listIterator(int  index)  {return  contents.listIterator(index);}          [CLASS]  Elements    [METHOD]  lastIndexOf  [RETURN_TYPE]  int      Object  o  [VARIABLES]  List    contents    elements    Object    o    boolean    
public  int  lastIndexOf  (  Object  o  )  {return  contents.lastIndexOf  (  o  )  ;}	[BUGGY]  public  int  lastIndexOf(  Object  o)  {return  null.indexOf(  o);}  [CONTEXT]    public  Element  remove(int  index)  {return  contents.remove(index);}    public  int  indexOf(Object  o)  {return  contents.indexOf(o);}    [BUGGY]  public  int  lastIndexOf  (  Object  o  ){return  null.indexOf  (  o  )  ;}    public  ListIterator<Element>  listIterator()  {return  contents.listIterator();}    public  ListIterator<Element>  listIterator(int  index)  {return  contents.listIterator(index);}          [CLASS]  Elements    [METHOD]  lastIndexOf  [RETURN_TYPE]  int      Object  o  [VARIABLES]  List    contents    elements    Object    o    boolean    
public  ListIterator<Element>  listIterator  (  )  {return  contents.listIterator  (  )  ;}	[BUGGY]  public  ListIterator<Element>  listIterator(  )  {return  contents.iterator(  );}  [CONTEXT]    public  int  indexOf(Object  o)  {return  contents.indexOf(o);}    public  int  lastIndexOf(Object  o)  {return  contents.lastIndexOf(o);}    [BUGGY]  public  ListIterator<Element>  listIterator  (){return  contents.iterator  ()  ;}    public  ListIterator<Element>  listIterator(int  index)  {return  contents.listIterator(index);}    public  List<Element>  subList(int  fromIndex,  int  toIndex)  {return  contents.subList(fromIndex,  toIndex);}  }        [CLASS]  Elements    [METHOD]  listIterator  [RETURN_TYPE]  ListIterator      [VARIABLES]  List    contents    elements    boolean    
public  ListIterator<Element>  listIterator  (  int  index  )  {return  contents.listIterator  (  index  )  ;}	[BUGGY]  public  ListIterator<Element>  listIterator(  int  contents)  {return  index.listIterator(  index);}  [CONTEXT]    public  int  lastIndexOf(Object  o)  {return  contents.lastIndexOf(o);}    public  ListIterator<Element>  listIterator()  {return  contents.listIterator();}    [BUGGY]  public  ListIterator<Element>  listIterator  (  int  contents  ){return  index.listIterator  (  index  )  ;}    public  List<Element>  subList(int  fromIndex,  int  toIndex)  {return  contents.subList(fromIndex,  toIndex);}  }        [CLASS]  Elements    [METHOD]  listIterator  [RETURN_TYPE]  ListIterator      int  index  [VARIABLES]  List    contents    elements    int    index    boolean    
public  ListIterator<Element>  listIterator  (  int  index  )  {return  contents.listIterator  (  index  )  ;}	[BUGGY]  public  ListIterator<Element>  listIterator(  int  index)  {return  contents.get(  index);}  [CONTEXT]    public  int  lastIndexOf(Object  o)  {return  contents.lastIndexOf(o);}    public  ListIterator<Element>  listIterator()  {return  contents.listIterator();}    [BUGGY]  public  ListIterator<Element>  listIterator  (  int  index  ){return  contents.get  (  index  )  ;}    public  List<Element>  subList(int  fromIndex,  int  toIndex)  {return  contents.subList(fromIndex,  toIndex);}  }        [CLASS]  Elements    [METHOD]  listIterator  [RETURN_TYPE]  ListIterator      int  index  [VARIABLES]  List    contents    elements    int    index    boolean    
public  ListIterator<Element>  listIterator  (  int  index  )  {return  contents.listIterator  (  index  )  ;}	[BUGGY]  public  ListIterator<Element>  listIterator(  int  index)  {return  contents  .iterator(  )  ;}  [CONTEXT]    public  int  lastIndexOf(Object  o)  {return  contents.lastIndexOf(o);}    public  ListIterator<Element>  listIterator()  {return  contents.listIterator();}    [BUGGY]  public  ListIterator<Element>  listIterator  (  int  index  ){return  contents  .iterator  ();}    public  List<Element>  subList(int  fromIndex,  int  toIndex)  {return  contents.subList(fromIndex,  toIndex);}  }        [CLASS]  Elements    [METHOD]  listIterator  [RETURN_TYPE]  ListIterator      int  index  [VARIABLES]  List    contents    elements    int    index    boolean    
public  List<Element>  subList  (  int  fromIndex,  int  toIndex  )  {return  contents.subList  (  fromIndex,  toIndex  )  ;}	[BUGGY]  public  List<Element>  subList(  int  toIndex,  int  fromIndex)  {return  contents.subList(  fromIndex,  toIndex);}  [CONTEXT]    public  ListIterator<Element>  listIterator()  {return  contents.listIterator();}    public  ListIterator<Element>  listIterator(int  index)  {return  contents.listIterator(index);}    [BUGGY]  public  List<Element>  subList  (  int  toIndex,  int  fromIndex  ){return  contents.subList  (  fromIndex,  toIndex  )  ;}  }        [CLASS]  Elements    [METHOD]  subList  [RETURN_TYPE]  List      int  fromIndex  int  toIndex  [VARIABLES]  List    contents    elements    int    fromIndex    toIndex    boolean    
public  List<Element>  subList  (  int  fromIndex,  int  toIndex  )  {return  contents.subList  (  fromIndex,  toIndex  )  ;}	[BUGGY]  public  List<Element>  subList(  int    int  toIndex)  {return  contents.subList(  fromIndex,  toIndex);}  [CONTEXT]    public  ListIterator<Element>  listIterator()  {return  contents.listIterator();}    public  ListIterator<Element>  listIterator(int  index)  {return  contents.listIterator(index);}    [BUGGY]  public  List<Element>  subList  (  intint  toIndex  ){return  contents.subList  (  fromIndex,  toIndex  )  ;}  }        [CLASS]  Elements    [METHOD]  subList  [RETURN_TYPE]  List      int  fromIndex  int  toIndex  [VARIABLES]  List    contents    elements    int    fromIndex    toIndex    boolean    
public  List<Element>  subList  (  int  fromIndex,  int  toIndex  )  {return  contents.subList  (  fromIndex,  toIndex  )  ;}	[BUGGY]  public  List<Element>  subList(  int  fromIndex,  int  toIndex)  {return  contents.subList(  fromIndex);}  [CONTEXT]    public  ListIterator<Element>  listIterator()  {return  contents.listIterator();}    public  ListIterator<Element>  listIterator(int  index)  {return  contents.listIterator(index);}    [BUGGY]  public  List<Element>  subList  (  int  fromIndex,  int  toIndex  ){return  contents.subList  (  fromIndex  )  ;}  }        [CLASS]  Elements    [METHOD]  subList  [RETURN_TYPE]  List      int  fromIndex  int  toIndex  [VARIABLES]  List    contents    elements    int    fromIndex    toIndex    boolean    
public  List<Element>  subList  (  int  fromIndex,  int  toIndex  )  {return  contents.subList  (  fromIndex,  toIndex  )  ;}	[BUGGY]  public  List<Element>  subList(  int  fromIndex,  int  contents)  {return  toIndex.subList(  fromIndex,  toIndex);}  [CONTEXT]    public  ListIterator<Element>  listIterator()  {return  contents.listIterator();}    public  ListIterator<Element>  listIterator(int  index)  {return  contents.listIterator(index);}    [BUGGY]  public  List<Element>  subList  (  int  fromIndex,  int  contents  ){return  toIndex.subList  (  fromIndex,  toIndex  )  ;}  }        [CLASS]  Elements    [METHOD]  subList  [RETURN_TYPE]  List      int  fromIndex  int  toIndex  [VARIABLES]  List    contents    elements    int    fromIndex    toIndex    boolean    
public  List<Element>  subList  (  int  fromIndex,  int  toIndex  )  {return  contents.subList  (  fromIndex,  toIndex  )  ;}	[BUGGY]  public  List<Element>  subList(  int  fromIndex,  int  toIndex)  {return  contents.set(  fromIndex,  toIndex);}  [CONTEXT]    public  ListIterator<Element>  listIterator()  {return  contents.listIterator();}    public  ListIterator<Element>  listIterator(int  index)  {return  contents.listIterator(index);}    [BUGGY]  public  List<Element>  subList  (  int  fromIndex,  int  toIndex  ){return  contents.set  (  fromIndex,  toIndex  )  ;}  }        [CLASS]  Elements    [METHOD]  subList  [RETURN_TYPE]  List      int  fromIndex  int  toIndex  [VARIABLES]  List    contents    elements    int    fromIndex    toIndex    boolean    
public  List<Element>  subList  (  int  fromIndex,  int  toIndex  )  {return  contents.subList  (  fromIndex,  toIndex  )  ;}	[BUGGY]  public  List<Element>  subList(  int  fromIndex,  int  toIndex)  {return  contents  .size(  )  ;}  [CONTEXT]    public  ListIterator<Element>  listIterator()  {return  contents.listIterator();}    public  ListIterator<Element>  listIterator(int  index)  {return  contents.listIterator(index);}    [BUGGY]  public  List<Element>  subList  (  int  fromIndex,  int  toIndex  ){return  contents  .size  ();}  }        [CLASS]  Elements    [METHOD]  subList  [RETURN_TYPE]  List      int  fromIndex  int  toIndex  [VARIABLES]  List    contents    elements    int    fromIndex    toIndex    boolean    
public  List<Element>  subList  (  int  fromIndex,  int  toIndex  )  {return  contents.subList  (  fromIndex,  toIndex  )  ;}	[BUGGY]  public  List<Element>  subList(  int  contents,  int  toIndex)  {return  fromIndex.subList(  fromIndex,  toIndex);}  [CONTEXT]    public  ListIterator<Element>  listIterator()  {return  contents.listIterator();}    public  ListIterator<Element>  listIterator(int  index)  {return  contents.listIterator(index);}    [BUGGY]  public  List<Element>  subList  (  int  contents,  int  toIndex  ){return  fromIndex.subList  (  fromIndex,  toIndex  )  ;}  }        [CLASS]  Elements    [METHOD]  subList  [RETURN_TYPE]  List      int  fromIndex  int  toIndex  [VARIABLES]  List    contents    elements    int    fromIndex    toIndex    boolean    
accumulateMatches  (  eval,  elements,  root  )  ;	[BUGGY]  accumulateMatches(  elements,  eval,  root);  [CONTEXT]  public  static  Elements  collect  (Evaluator  eval,  Element  root)  {  Elements  elements  =  new  Elements();  [BUGGY]  accumulateMatches  (  elements,  eval,  root  )  ;  return  elements;  }        [CLASS]  Collector    [METHOD]  collect  [RETURN_TYPE]  Elements      Evaluator  eval  Element  root  [VARIABLES]  boolean    Element    root    Evaluator    eval    Elements    elements    
accumulateMatches  (  eval,  elements,  root  )  ;	[BUGGY]  accumulateMatches(    elements,  root);  [CONTEXT]  public  static  Elements  collect  (Evaluator  eval,  Element  root)  {  Elements  elements  =  new  Elements();  [BUGGY]  accumulateMatches  (elements,  root  )  ;  return  elements;  }        [CLASS]  Collector    [METHOD]  collect  [RETURN_TYPE]  Elements      Evaluator  eval  Element  root  [VARIABLES]  boolean    Element    root    Evaluator    eval    Elements    elements    
accumulateMatches  (  eval,  elements,  root  )  ;	[BUGGY]  accumulateMatches(  eval,  root,  elements);  [CONTEXT]  public  static  Elements  collect  (Evaluator  eval,  Element  root)  {  Elements  elements  =  new  Elements();  [BUGGY]  accumulateMatches  (  eval,  root,  elements  )  ;  return  elements;  }        [CLASS]  Collector    [METHOD]  collect  [RETURN_TYPE]  Elements      Evaluator  eval  Element  root  [VARIABLES]  boolean    Element    root    Evaluator    eval    Elements    elements    
accumulateMatches  (  eval,  elements,  root  )  ;	[BUGGY]  accumulateMatches(  eval,    root);  [CONTEXT]  public  static  Elements  collect  (Evaluator  eval,  Element  root)  {  Elements  elements  =  new  Elements();  [BUGGY]  accumulateMatches  (  eval,root  )  ;  return  elements;  }        [CLASS]  Collector    [METHOD]  collect  [RETURN_TYPE]  Elements      Evaluator  eval  Element  root  [VARIABLES]  boolean    Element    root    Evaluator    eval    Elements    elements    
accumulateMatches  (  eval,  elements,  root  )  ;	[BUGGY]  accumulateMatches(  root,  elements,  eval);  [CONTEXT]  public  static  Elements  collect  (Evaluator  eval,  Element  root)  {  Elements  elements  =  new  Elements();  [BUGGY]  accumulateMatches  (  root,  elements,  eval  )  ;  return  elements;  }        [CLASS]  Collector    [METHOD]  collect  [RETURN_TYPE]  Elements      Evaluator  eval  Element  root  [VARIABLES]  boolean    Element    root    Evaluator    eval    Elements    elements    
accumulateMatches  (  eval,  elements,  root  )  ;	[BUGGY]  accumulateMatches(  eval,  elements);  [CONTEXT]  public  static  Elements  collect  (Evaluator  eval,  Element  root)  {  Elements  elements  =  new  Elements();  [BUGGY]  accumulateMatches  (  eval,  elements  )  ;  return  elements;  }        [CLASS]  Collector    [METHOD]  collect  [RETURN_TYPE]  Elements      Evaluator  eval  Element  root  [VARIABLES]  boolean    Element    root    Evaluator    eval    Elements    elements    
accumulateMatches  (  eval,  elements,  root  )  ;	[BUGGY]    [CONTEXT]  public  static  Elements  collect  (Evaluator  eval,  Element  root)  {  Elements  elements  =  new  Elements();  [BUGGY]  accumulateMatches(eval,  elements,  root);    return  elements;        [CLASS]  Collector    [METHOD]  collect  [RETURN_TYPE]  Elements      Evaluator  eval  Element  root  [VARIABLES]  boolean    Element    root    Evaluator    eval    Elements    elements    
if  (  eval.matches  (  element  )  )  elements.add  (  element  )  ;	[BUGGY]  if  (  eval.matches(  child))elements.add(  element);  [CONTEXT]  private  static  void  accumulateMatches(Evaluator  eval,  List<Element>  elements,  Element  element)  {  [BUGGY]  if(  eval.matches  (  child  ))  elements.add  (  element  )  ;    for  (Element  child:  element.children())  accumulateMatches(eval,  elements,  child);  }        [CLASS]  Collector    [METHOD]  accumulateMatches  [RETURN_TYPE]  void      Evaluator  eval  Element>  elements  Element  element  [VARIABLES]  boolean    Element    child    element    List    elements    Evaluator    eval    
if  (  eval.matches  (  element  )  )  elements.add  (  element  )  ;	[BUGGY]  if  (  elements.matches(  element))eval.add(  element);  [CONTEXT]  private  static  void  accumulateMatches(Evaluator  eval,  List<Element>  elements,  Element  element)  {  [BUGGY]  if(  elements.matches  (  element  ))  eval.add  (  element  )  ;    for  (Element  child:  element.children())  accumulateMatches(eval,  elements,  child);  }        [CLASS]  Collector    [METHOD]  accumulateMatches  [RETURN_TYPE]  void      Evaluator  eval  Element>  elements  Element  element  [VARIABLES]  boolean    Element    child    element    List    elements    Evaluator    eval    
if  (  eval.matches  (  element  )  )  elements.add  (  element  )  ;	[BUGGY]  if  (  element.matches(  eval))elements.add(  element);  [CONTEXT]  private  static  void  accumulateMatches(Evaluator  eval,  List<Element>  elements,  Element  element)  {  [BUGGY]  if(  element.matches  (  eval  ))  elements.add  (  element  )  ;    for  (Element  child:  element.children())  accumulateMatches(eval,  elements,  child);  }        [CLASS]  Collector    [METHOD]  accumulateMatches  [RETURN_TYPE]  void      Evaluator  eval  Element>  elements  Element  element  [VARIABLES]  boolean    Element    child    element    List    elements    Evaluator    eval    
if  (  eval.matches  (  element  )  )  elements.add  (  element  )  ;  for  (  Element  child:  element.children  (  )  )  accumulateMatches  (  eval,  elements,  child  )  ;  }	[BUGGY]  elements.add(element);  [CONTEXT]  private  static  void  accumulateMatches(Evaluator  eval,  List<Element>  elements,  Element  element)  {  [BUGGY]  if  (eval.matches(element))    elements.add(element);            [CLASS]  Collector    [METHOD]  accumulateMatches  [RETURN_TYPE]  void      Evaluator  eval  Element>  elements  Element  element  [VARIABLES]  boolean    Element    child    element    List    elements    Evaluator    eval    
if  (  eval.matches  (  element  )  )  elements.add  (  element  )  ;  for  (  Element  child:  element.children  (  )  )  accumulateMatches  (  eval,  elements,  child  )  ;  }	[BUGGY]    [CONTEXT]  private  static  void  accumulateMatches(Evaluator  eval,  List<Element>  elements,  Element  element)  {  [BUGGY]  if  (eval.matches(element))                [CLASS]  Collector    [METHOD]  accumulateMatches  [RETURN_TYPE]  void      Evaluator  eval  Element>  elements  Element  element  [VARIABLES]  boolean    Element    child    element    List    elements    Evaluator    eval    
elements.add  (  element  )  ;	[BUGGY]  elements.add(  child);  [CONTEXT]  private  static  void  accumulateMatches(Evaluator  eval,  List<Element>  elements,  Element  element)  {  if  (eval.matches(element))  [BUGGY]  elements.add  (  child  )  ;  for  (Element  child:  element.children())  accumulateMatches(eval,  elements,  child);  }        [CLASS]  Collector    [METHOD]  accumulateMatches  [RETURN_TYPE]  void      Evaluator  eval  Element>  elements  Element  element  [VARIABLES]  boolean    Element    child    element    List    elements    Evaluator    eval    
elements.add  (  element  )  ;	[BUGGY]    [CONTEXT]  private  static  void  accumulateMatches(Evaluator  eval,  List<Element>  elements,  Element  element)  {  if  (eval.matches(element))  [BUGGY]  elements.add(element);    for  (Element  child:  element.children())  accumulateMatches(eval,  elements,  child);        [CLASS]  Collector    [METHOD]  accumulateMatches  [RETURN_TYPE]  void      Evaluator  eval  Element>  elements  Element  element  [VARIABLES]  boolean    Element    child    element    List    elements    Evaluator    eval    
for  (  Element  child:  element.children  (  )  )  accumulateMatches  (  eval,  elements,  child  )  ;	[BUGGY]  for  (  Element  child:  child.children(  ))accumulateMatches(  eval,  elements,  child);  [CONTEXT]  private  static  void  accumulateMatches(Evaluator  eval,  List<Element>  elements,  Element  element)  {  if  (eval.matches(element))  elements.add(element);  [BUGGY]  for(  Element  child:  child.children  ())  accumulateMatches  (  eval,  elements,  child  )  ;    }        [CLASS]  Collector    [METHOD]  accumulateMatches  [RETURN_TYPE]  void      Evaluator  eval  Element>  elements  Element  element  [VARIABLES]  boolean    Element    child    element    List    elements    Evaluator    eval    
for  (  Element  child:  element.children  (  )  )  accumulateMatches  (  eval,  elements,  child  )  ;  }	[BUGGY]    [CONTEXT]  private  static  void  accumulateMatches(Evaluator  eval,  List<Element>  elements,  Element  element)  {  if  (eval.matches(element))  elements.add(element);  [BUGGY]  for  (Element  child:  element.children())            [CLASS]  Collector    [METHOD]  accumulateMatches  [RETURN_TYPE]  void      Evaluator  eval  Element>  elements  Element  element  [VARIABLES]  boolean    Element    child    element    List    elements    Evaluator    eval    
accumulateMatches  (  eval,  elements,  child  )  ;	[BUGGY]  accumulateMatches(  eval,  elements,  element);  [CONTEXT]  private  static  void  accumulateMatches(Evaluator  eval,  List<Element>  elements,  Element  element)  {  if  (eval.matches(element))  elements.add(element);  for  (Element  child:  element.children())  [BUGGY]  accumulateMatches  (  eval,  elements,  element  )  ;  }        [CLASS]  Collector    [METHOD]  accumulateMatches  [RETURN_TYPE]  void      Evaluator  eval  Element>  elements  Element  element  [VARIABLES]  boolean    Element    child    element    List    elements    Evaluator    eval    
accumulateMatches  (  eval,  elements,  child  )  ;	[BUGGY]  accumulateMatches(  child,  elements,  eval);  [CONTEXT]  private  static  void  accumulateMatches(Evaluator  eval,  List<Element>  elements,  Element  element)  {  if  (eval.matches(element))  elements.add(element);  for  (Element  child:  element.children())  [BUGGY]  accumulateMatches  (  child,  elements,  eval  )  ;  }        [CLASS]  Collector    [METHOD]  accumulateMatches  [RETURN_TYPE]  void      Evaluator  eval  Element>  elements  Element  element  [VARIABLES]  boolean    Element    child    element    List    elements    Evaluator    eval    
accumulateMatches  (  eval,  elements,  child  )  ;	[BUGGY]  accumulateMatches(    elements,  child);  [CONTEXT]  private  static  void  accumulateMatches(Evaluator  eval,  List<Element>  elements,  Element  element)  {  if  (eval.matches(element))  elements.add(element);  for  (Element  child:  element.children())  [BUGGY]  accumulateMatches  (elements,  child  )  ;  }        [CLASS]  Collector    [METHOD]  accumulateMatches  [RETURN_TYPE]  void      Evaluator  eval  Element>  elements  Element  element  [VARIABLES]  boolean    Element    child    element    List    elements    Evaluator    eval    
accumulateMatches  (  eval,  elements,  child  )  ;	[BUGGY]  accumulateMatches(  eval,  child,  elements);  [CONTEXT]  private  static  void  accumulateMatches(Evaluator  eval,  List<Element>  elements,  Element  element)  {  if  (eval.matches(element))  elements.add(element);  for  (Element  child:  element.children())  [BUGGY]  accumulateMatches  (  eval,  child,  elements  )  ;  }        [CLASS]  Collector    [METHOD]  accumulateMatches  [RETURN_TYPE]  void      Evaluator  eval  Element>  elements  Element  element  [VARIABLES]  boolean    Element    child    element    List    elements    Evaluator    eval    
accumulateMatches  (  eval,  elements,  child  )  ;	[BUGGY]  accumulateMatches(  eval,    child);  [CONTEXT]  private  static  void  accumulateMatches(Evaluator  eval,  List<Element>  elements,  Element  element)  {  if  (eval.matches(element))  elements.add(element);  for  (Element  child:  element.children())  [BUGGY]  accumulateMatches  (  eval,child  )  ;  }        [CLASS]  Collector    [METHOD]  accumulateMatches  [RETURN_TYPE]  void      Evaluator  eval  Element>  elements  Element  element  [VARIABLES]  boolean    Element    child    element    List    elements    Evaluator    eval    
accumulateMatches  (  eval,  elements,  child  )  ;	[BUGGY]  accumulateMatches(  eval,  elements);  [CONTEXT]  private  static  void  accumulateMatches(Evaluator  eval,  List<Element>  elements,  Element  element)  {  if  (eval.matches(element))  elements.add(element);  for  (Element  child:  element.children())  [BUGGY]  accumulateMatches  (  eval,  elements  )  ;  }        [CLASS]  Collector    [METHOD]  accumulateMatches  [RETURN_TYPE]  void      Evaluator  eval  Element>  elements  Element  element  [VARIABLES]  boolean    Element    child    element    List    elements    Evaluator    eval    
accumulateMatches  (  eval,  elements,  child  )  ;	[BUGGY]    [CONTEXT]  private  static  void  accumulateMatches(Evaluator  eval,  List<Element>  elements,  Element  element)  {  if  (eval.matches(element))  elements.add(element);  for  (Element  child:  element.children())  [BUGGY]  accumulateMatches(eval,  elements,  child);          [CLASS]  Collector    [METHOD]  accumulateMatches  [RETURN_TYPE]  void      Evaluator  eval  Element>  elements  Element  element  [VARIABLES]  boolean    Element    child    element    List    elements    Evaluator    eval    
final  List<Node>  childNodes;	[BUGGY]  List<Node>  childNodes;  [CONTEXT]  The  base,  abstract  Node  model.  Elements,  Documents,  Comments  etc  are  all  Node  instances.    @author  Jonathan  Hedley,  jonathan@hedley.net  */  public  abstract  class  Node  {  Node  parentNode;  [BUGGY]  List<Node>  childNodes;  final  Attributes  attributes;  String  baseUri;        Create  a  new  Node.        [CLASS]  Node      [VARIABLES]  
String  baseUri;	[BUGGY]  char  baseUri;  [CONTEXT]  @author  Jonathan  Hedley,  jonathan@hedley.net  */  public  abstract  class  Node  {  Node  parentNode;  final  List<Node>  childNodes;  final  Attributes  attributes;  [BUGGY]  char  baseUri;        Create  a  new  Node.  @param  baseUri  base  URI  @param  attributes  attributes  (not  null,  but  may  be  empty)        [CLASS]  Node      [VARIABLES]  
Validate.notNull  (  baseUri  )  ;	[BUGGY]  Validate.notEmpty(  baseUri);  [CONTEXT]  protected  Node(String  baseUri,  Attributes  attributes)  {  [BUGGY]  Validate.notEmpty  (  baseUri  )  ;  Validate.notNull(attributes);    childNodes  =  new  ArrayList<Node>();  this.baseUri  =  baseUri.trim();  this.attributes  =  attributes;  }        [CLASS]  Node    [METHOD]  <init>  [RETURN_TYPE]  Attributes)      String  baseUri  Attributes  attributes  [VARIABLES]  Attributes    attributes    List    childNodes    String    baseUri    boolean    Node    parentNode    
Validate.notNull  (  baseUri  )  ;	[BUGGY]    [CONTEXT]  protected  Node(String  baseUri,  Attributes  attributes)  {  [BUGGY]  Validate.notNull(baseUri);    Validate.notNull(attributes);    childNodes  =  new  ArrayList<Node>();  this.baseUri  =  baseUri.trim();  this.attributes  =  attributes;        [CLASS]  Node    [METHOD]  <init>  [RETURN_TYPE]  Attributes)      String  baseUri  Attributes  attributes  [VARIABLES]  Attributes    attributes    List    childNodes    String    baseUri    boolean    Node    parentNode    
Validate.notNull  (  baseUri  )  ;	[BUGGY]  Validate.notNull(  attributes);  Validate.notNull(  baseUri);  [CONTEXT]        [CLASS]  Node    [METHOD]  <init>  [RETURN_TYPE]  Attributes)      String  baseUri  Attributes  attributes  [VARIABLES]  Attributes    attributes    List    childNodes    String    baseUri    boolean    Node    parentNode    
Validate.notNull  (  baseUri  )  ;	[BUGGY]  Validate.notNull(  index);Validate.notNull(  baseUri);  [CONTEXT]        [CLASS]  Node    [METHOD]  <init>  [RETURN_TYPE]  Attributes)      String  baseUri  Attributes  attributes  [VARIABLES]  Attributes    attributes    List    childNodes    String    baseUri    boolean    Node    parentNode    
Validate.notNull  (  baseUri  )  ;	[BUGGY]  Validate.notNull(  parentNode);Validate.notNull(  baseUri);  [CONTEXT]        [CLASS]  Node    [METHOD]  <init>  [RETURN_TYPE]  Attributes)      String  baseUri  Attributes  attributes  [VARIABLES]  Attributes    attributes    List    childNodes    String    baseUri    boolean    Node    parentNode    
Validate.notNull  (  baseUri  )  ;	[BUGGY]  Validate.notNull(  attributeKey);Validate.notNull(  baseUri);  [CONTEXT]        [CLASS]  Node    [METHOD]  <init>  [RETURN_TYPE]  Attributes)      String  baseUri  Attributes  attributes  [VARIABLES]  Attributes    attributes    List    childNodes    String    baseUri    boolean    Node    parentNode    
Validate.notNull  (  baseUri  )  ;	[BUGGY]  Validate.notNull(  search);Validate.notNull(  baseUri);  [CONTEXT]        [CLASS]  Node    [METHOD]  <init>  [RETURN_TYPE]  Attributes)      String  baseUri  Attributes  attributes  [VARIABLES]  Attributes    attributes    List    childNodes    String    baseUri    boolean    Node    parentNode    
Validate.notNull  (  baseUri  )  ;	[BUGGY]  Validate.notNull(  in);Validate.notNull(  baseUri);  [CONTEXT]        [CLASS]  Node    [METHOD]  <init>  [RETURN_TYPE]  Attributes)      String  baseUri  Attributes  attributes  [VARIABLES]  Attributes    attributes    List    childNodes    String    baseUri    boolean    Node    parentNode    
Validate.notNull  (  baseUri  )  ;	[BUGGY]  Validate.notEmpty(  attributeKey);Validate.notNull(  baseUri);  [CONTEXT]        [CLASS]  Node    [METHOD]  <init>  [RETURN_TYPE]  Attributes)      String  baseUri  Attributes  attributes  [VARIABLES]  Attributes    attributes    List    childNodes    String    baseUri    boolean    Node    parentNode    
Validate.notNull  (  baseUri  )  ;	[BUGGY]  Validate.notNull(  nodes);Validate.notNull(  baseUri);  [CONTEXT]        [CLASS]  Node    [METHOD]  <init>  [RETURN_TYPE]  Attributes)      String  baseUri  Attributes  attributes  [VARIABLES]  Attributes    attributes    List    childNodes    String    baseUri    boolean    Node    parentNode    
Validate.notNull  (  attributes  )  ;	[BUGGY]    [CONTEXT]  protected  Node(String  baseUri,  Attributes  attributes)  {  Validate.notNull(baseUri);  [BUGGY]  Validate.notNull(attributes);      childNodes  =  new  ArrayList<Node>();  this.baseUri  =  baseUri.trim();  this.attributes  =  attributes;        [CLASS]  Node    [METHOD]  <init>  [RETURN_TYPE]  Attributes)      String  baseUri  Attributes  attributes  [VARIABLES]  Attributes    attributes    List    childNodes    String    baseUri    boolean    Node    parentNode    
childNodes  =  new  ArrayList<Node>  (  )  ;	[BUGGY]  childNodes  ;  [CONTEXT]  protected  Node(String  baseUri,  Attributes  attributes)  {  Validate.notNull(baseUri);  Validate.notNull(attributes);    [BUGGY]  childNodes  ;  this.baseUri  =  baseUri.trim();  this.attributes  =  attributes;  }        [CLASS]  Node    [METHOD]  <init>  [RETURN_TYPE]  Attributes)      String  baseUri  Attributes  attributes  [VARIABLES]  Attributes    attributes    List    childNodes    String    baseUri    boolean    Node    parentNode    
this.baseUri  =  baseUri.trim  (  )  ;	[BUGGY]  this.baseUri  =    null.trim(  );  [CONTEXT]  protected  Node(String  baseUri,  Attributes  attributes)  {  Validate.notNull(baseUri);  Validate.notNull(attributes);    childNodes  =  new  ArrayList<Node>();  [BUGGY]  this.baseUri  =null.trim  ()  ;  this.attributes  =  attributes;  }        [CLASS]  Node    [METHOD]  <init>  [RETURN_TYPE]  Attributes)      String  baseUri  Attributes  attributes  [VARIABLES]  Attributes    attributes    List    childNodes    String    baseUri    boolean    Node    parentNode    
this.baseUri  =  baseUri.trim  (  )  ;	[BUGGY]    this.baseUri  =  baseUri.trim(  );  [CONTEXT]        [CLASS]  Node    [METHOD]  <init>  [RETURN_TYPE]  Attributes)      String  baseUri  Attributes  attributes  [VARIABLES]  Attributes    attributes    List    childNodes    String    baseUri    boolean    Node    parentNode    
this.baseUri  =  baseUri.trim  (  )  ;	[BUGGY]  this.baseUri  =  baseUri;this.baseUri  =  baseUri.trim(  );  [CONTEXT]        [CLASS]  Node    [METHOD]  <init>  [RETURN_TYPE]  Attributes)      String  baseUri  Attributes  attributes  [VARIABLES]  Attributes    attributes    List    childNodes    String    baseUri    boolean    Node    parentNode    
this.baseUri  =  baseUri.trim  (  )  ;	[BUGGY]  this.baseUri  =  baseUri  .substring(  )  ;  [CONTEXT]  protected  Node(String  baseUri,  Attributes  attributes)  {  Validate.notNull(baseUri);  Validate.notNull(attributes);    childNodes  =  new  ArrayList<Node>();  [BUGGY]  this.baseUri  =  baseUri  .substring  ();  this.attributes  =  attributes;  }        [CLASS]  Node    [METHOD]  <init>  [RETURN_TYPE]  Attributes)      String  baseUri  Attributes  attributes  [VARIABLES]  Attributes    attributes    List    childNodes    String    baseUri    boolean    Node    parentNode    
this.baseUri  =  baseUri.trim  (  )  ;	[BUGGY]    [CONTEXT]  protected  Node(String  baseUri,  Attributes  attributes)  {  Validate.notNull(baseUri);  Validate.notNull(attributes);    childNodes  =  new  ArrayList<Node>();  [BUGGY]  this.baseUri  =  baseUri.trim();    this.attributes  =  attributes;        [CLASS]  Node    [METHOD]  <init>  [RETURN_TYPE]  Attributes)      String  baseUri  Attributes  attributes  [VARIABLES]  Attributes    attributes    List    childNodes    String    baseUri    boolean    Node    parentNode    
this.attributes  =  attributes;	[BUGGY]  this.attributes  =    null;  [CONTEXT]  protected  Node(String  baseUri,  Attributes  attributes)  {  Validate.notNull(baseUri);  Validate.notNull(attributes);    childNodes  =  new  ArrayList<Node>();  this.baseUri  =  baseUri.trim();  [BUGGY]  this.attributes  =null;  }        [CLASS]  Node    [METHOD]  <init>  [RETURN_TYPE]  Attributes)      String  baseUri  Attributes  attributes  [VARIABLES]  Attributes    attributes    List    childNodes    String    baseUri    boolean    Node    parentNode    
this  (  baseUri,  new  Attributes  (  )  )  ;	[BUGGY]    [CONTEXT]  protected  Node(String  baseUri)  {  [BUGGY]  this(baseUri,  new  Attributes());          [CLASS]  Node    [METHOD]  <init>  [RETURN_TYPE]  String)      String  baseUri  [VARIABLES]  Attributes    attributes    List    childNodes    String    baseUri    boolean    Node    parentNode    
Validate.notNull  (  attributeKey  )  ;	[BUGGY]  Validate.notNull(  baseUri);  [CONTEXT]  public  String  attr(String  attributeKey)  {  [BUGGY]  Validate.notNull  (  baseUri  )  ;    if  (hasAttr(attributeKey))  return  attributes.get(attributeKey);  else  if  (attributeKey.toLowerCase().startsWith( "abs: "))  return  absUrl(attributeKey.substring( "abs: ".length()));  else  return   " ";  }        [CLASS]  Node    [METHOD]  attr  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    baseUri    boolean    Node    parentNode    
Validate.notNull  (  attributeKey  )  ;	[BUGGY]  Validate.notEmpty(  attributeKey);  [CONTEXT]  public  String  attr(String  attributeKey)  {  [BUGGY]  Validate.notEmpty  (  attributeKey  )  ;    if  (hasAttr(attributeKey))  return  attributes.get(attributeKey);  else  if  (attributeKey.toLowerCase().startsWith( "abs: "))  return  absUrl(attributeKey.substring( "abs: ".length()));  else  return   " ";  }        [CLASS]  Node    [METHOD]  attr  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    baseUri    boolean    Node    parentNode    
Validate.notNull  (  attributeKey  )  ;	[BUGGY]  Validate  .notEmpty(  baseUri)  ;  [CONTEXT]  public  String  attr(String  attributeKey)  {  [BUGGY]  Validate  .notEmpty  (  baseUri  );    if  (hasAttr(attributeKey))  return  attributes.get(attributeKey);  else  if  (attributeKey.toLowerCase().startsWith( "abs: "))  return  absUrl(attributeKey.substring( "abs: ".length()));  else  return   " ";  }        [CLASS]  Node    [METHOD]  attr  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    baseUri    boolean    Node    parentNode    
Validate.notNull  (  attributeKey  )  ;	[BUGGY]    [CONTEXT]  public  String  attr(String  attributeKey)  {  [BUGGY]  Validate.notNull(attributeKey);      if  (hasAttr(attributeKey))  return  attributes.get(attributeKey);  else  if  (attributeKey.toLowerCase().startsWith( "abs: "))  return  absUrl(attributeKey.substring( "abs: ".length()));  else  return   " ";        [CLASS]  Node    [METHOD]  attr  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    baseUri    boolean    Node    parentNode    
if  (  hasAttr  (  attributeKey  )  )  return  attributes.get  (  attributeKey  )  ;	[BUGGY]  if  (  hasAttr(  baseUri))return  attributes.get(  attributeKey);  [CONTEXT]  public  String  attr(String  attributeKey)  {  Validate.notNull(attributeKey);    [BUGGY]  if(  hasAttr  (  baseUri  ))  return  attributes.get  (  attributeKey  )  ;    else  if  (attributeKey.toLowerCase().startsWith( "abs: "))  return  absUrl(attributeKey.substring( "abs: ".length()));  else  return   " ";  }        [CLASS]  Node    [METHOD]  attr  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    baseUri    boolean    Node    parentNode    
if  (  hasAttr  (  attributeKey  )  )  return  attributes.get  (  attributeKey  )  ;	[BUGGY]  if  (  hasAttr(  attributes))return  attributeKey.get(  attributeKey);  [CONTEXT]  public  String  attr(String  attributeKey)  {  Validate.notNull(attributeKey);    [BUGGY]  if(  hasAttr  (  attributes  ))  return  attributeKey.get  (  attributeKey  )  ;    else  if  (attributeKey.toLowerCase().startsWith( "abs: "))  return  absUrl(attributeKey.substring( "abs: ".length()));  else  return   " ";  }        [CLASS]  Node    [METHOD]  attr  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    baseUri    boolean    Node    parentNode    
if  (  hasAttr  (  attributeKey  )  )  return  attributes.get  (  attributeKey  )  ;	[BUGGY]  if  (  attr(  attributeKey))return  attributes.get(  attributeKey);  [CONTEXT]  public  String  attr(String  attributeKey)  {  Validate.notNull(attributeKey);    [BUGGY]  if(  attr  (  attributeKey  ))  return  attributes.get  (  attributeKey  )  ;    else  if  (attributeKey.toLowerCase().startsWith( "abs: "))  return  absUrl(attributeKey.substring( "abs: ".length()));  else  return   " ";  }        [CLASS]  Node    [METHOD]  attr  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    baseUri    boolean    Node    parentNode    
if  (  hasAttr  (  attributeKey  )  )  return  attributes.get  (  attributeKey  )  ;	[BUGGY]  if  (  hasAttr(  attributeKey))return  attributes.hasKey(  attributeKey);  [CONTEXT]  public  String  attr(String  attributeKey)  {  Validate.notNull(attributeKey);    [BUGGY]  if(  hasAttr  (  attributeKey  ))  return  attributes.hasKey  (  attributeKey  )  ;    else  if  (attributeKey.toLowerCase().startsWith( "abs: "))  return  absUrl(attributeKey.substring( "abs: ".length()));  else  return   " ";  }        [CLASS]  Node    [METHOD]  attr  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    baseUri    boolean    Node    parentNode    
if  (  hasAttr  (  attributeKey  )  )  return  attributes.get  (  attributeKey  )  ;  else  if  (  attributeKey.toLowerCase  (  )  .startsWith  (   "abs: "  )  )  return  absUrl  (  attributeKey.substring  (   "abs: ".length  (  )  )  )  ;  else  return   " ";  }	[BUGGY]  return  attributes.get(attributeKey);  [CONTEXT]  public  String  attr(String  attributeKey)  {  Validate.notNull(attributeKey);    [BUGGY]  if  (hasAttr(attributeKey))    return  attributes.get(attributeKey);              [CLASS]  Node    [METHOD]  attr  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    baseUri    boolean    Node    parentNode    
if  (  hasAttr  (  attributeKey  )  )  return  attributes.get  (  attributeKey  )  ;  else  if  (  attributeKey.toLowerCase  (  )  .startsWith  (   "abs: "  )  )  return  absUrl  (  attributeKey.substring  (   "abs: ".length  (  )  )  )  ;  else  return   " ";  }	[BUGGY]    [CONTEXT]  public  String  attr(String  attributeKey)  {  Validate.notNull(attributeKey);    [BUGGY]  if  (hasAttr(attributeKey))                  [CLASS]  Node    [METHOD]  attr  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    baseUri    boolean    Node    parentNode    
else  if  (  attributeKey.toLowerCase  (  )  .startsWith  (   "abs: "  )  )  return  absUrl  (  attributeKey.substring  (   "abs: ".length  (  )  )  )  ;	[BUGGY]  else  if  (  attributeKey.toLowerCase(  ).startsWith(   "b "))return  absUrl(  attributeKey.substring(   "b ".length(  )));  [CONTEXT]  public  String  attr(String  attributeKey)  {  Validate.notNull(attributeKey);    if  (hasAttr(attributeKey))  return  attributes.get(attributeKey);  [BUGGY]  else  if(  attributeKey.toLowerCase  ()  .startsWith  (   "b "  ))  return  absUrl  (  attributeKey.substring  (   "b ".length  ()))  ;    else  return   " ";  }        [CLASS]  Node    [METHOD]  attr  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    baseUri    boolean    Node    parentNode    
else  if  (  attributeKey.toLowerCase  (  )  .startsWith  (   "abs: "  )  )  return  absUrl  (  attributeKey.substring  (   "abs: ".length  (  )  )  )  ;	[BUGGY]  else  if  (  attributeKey.toLowerCase(  ).startsWith(   "sbs: "))return  absUrl(  attributeKey.substring(   "sbs: ".length(  )));  [CONTEXT]  public  String  attr(String  attributeKey)  {  Validate.notNull(attributeKey);    if  (hasAttr(attributeKey))  return  attributes.get(attributeKey);  [BUGGY]  else  if(  attributeKey.toLowerCase  ()  .startsWith  (   "sbs: "  ))  return  absUrl  (  attributeKey.substring  (   "sbs: ".length  ()))  ;    else  return   " ";  }        [CLASS]  Node    [METHOD]  attr  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    baseUri    boolean    Node    parentNode    
else  if  (  attributeKey.toLowerCase  (  )  .startsWith  (   "abs: "  )  )  return  absUrl  (  attributeKey.substring  (   "abs: ".length  (  )  )  )  ;	[BUGGY]  else  if  (  attributeKey.toLowerCase(  ).startsWith(   "abs: "))return  absUrl(  attributeKey.substring(   "abs: ".length()  -  8  ));  [CONTEXT]  public  String  attr(String  attributeKey)  {  Validate.notNull(attributeKey);    if  (hasAttr(attributeKey))  return  attributes.get(attributeKey);  [BUGGY]  else  if(  attributeKey.toLowerCase  ()  .startsWith  (   "abs: "  ))  return  absUrl  (  attributeKey.substring  (   "abs: ".length()  -  8))  ;    else  return   " ";  }        [CLASS]  Node    [METHOD]  attr  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    baseUri    boolean    Node    parentNode    
else  if  (  attributeKey.toLowerCase  (  )  .startsWith  (   "abs: "  )  )  return  absUrl  (  attributeKey.substring  (   "abs: ".length  (  )  )  )  ;	[BUGGY]  else  if  (  baseUri.toLowerCase(  ).startsWith(   "abs: "))return  absUrl(  attributeKey.substring(   "abs: ".length(  )));  [CONTEXT]  public  String  attr(String  attributeKey)  {  Validate.notNull(attributeKey);    if  (hasAttr(attributeKey))  return  attributes.get(attributeKey);  [BUGGY]  else  if(  baseUri.toLowerCase  ()  .startsWith  (   "abs: "  ))  return  absUrl  (  attributeKey.substring  (   "abs: ".length  ()))  ;    else  return   " ";  }        [CLASS]  Node    [METHOD]  attr  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    baseUri    boolean    Node    parentNode    
else  if  (  attributeKey.toLowerCase  (  )  .startsWith  (   "abs: "  )  )  return  absUrl  (  attributeKey.substring  (   "abs: ".length  (  )  )  )  ;	[BUGGY]  else  if  (  attributeKey.toLowerCase(  ).startsWith(   "abs: "))return  attr(  attributeKey.substring(   "abs: ".length(  )));  [CONTEXT]  public  String  attr(String  attributeKey)  {  Validate.notNull(attributeKey);    if  (hasAttr(attributeKey))  return  attributes.get(attributeKey);  [BUGGY]  else  if(  attributeKey.toLowerCase  ()  .startsWith  (   "abs: "  ))  return  attr  (  attributeKey.substring  (   "abs: ".length  ()))  ;    else  return   " ";  }        [CLASS]  Node    [METHOD]  attr  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    baseUri    boolean    Node    parentNode    
else  if  (  attributeKey.toLowerCase  (  )  .startsWith  (   "abs: "  )  )  return  absUrl  (  attributeKey.substring  (   "abs: ".length  (  )  )  )  ;	[BUGGY]  else  if  (  attributeKey.toLowerCase(  ).startsWith(   "abs: "))return  absUrl(  attributeKey.substring(   "abs: ".startsWith(  )));  [CONTEXT]  public  String  attr(String  attributeKey)  {  Validate.notNull(attributeKey);    if  (hasAttr(attributeKey))  return  attributes.get(attributeKey);  [BUGGY]  else  if(  attributeKey.toLowerCase  ()  .startsWith  (   "abs: "  ))  return  absUrl  (  attributeKey.substring  (   "abs: ".startsWith  ()))  ;    else  return   " ";  }        [CLASS]  Node    [METHOD]  attr  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    baseUri    boolean    Node    parentNode    
return  absUrl  (  attributeKey.substring  (   "abs: ".length  (  )  )  )  ;	[BUGGY]  return  absUrl(  attributeKey.substring(   "b ".length(  )));  [CONTEXT]  public  String  attr(String  attributeKey)  {  Validate.notNull(attributeKey);    if  (hasAttr(attributeKey))  return  attributes.get(attributeKey);  else  if  (attributeKey.toLowerCase().startsWith( "abs: "))  [BUGGY]  return  absUrl  (  attributeKey.substring  (   "b ".length  ()))  ;  else  return   " ";  }        [CLASS]  Node    [METHOD]  attr  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    baseUri    boolean    Node    parentNode    
return  absUrl  (  attributeKey.substring  (   "abs: ".length  (  )  )  )  ;	[BUGGY]  return  absUrl(  attributeKey.substring(   "abs: ".length()  +  5  ));  [CONTEXT]  public  String  attr(String  attributeKey)  {  Validate.notNull(attributeKey);    if  (hasAttr(attributeKey))  return  attributes.get(attributeKey);  else  if  (attributeKey.toLowerCase().startsWith( "abs: "))  [BUGGY]  return  absUrl  (  attributeKey.substring  (   "abs: ".length()  +  5))  ;  else  return   " ";  }        [CLASS]  Node    [METHOD]  attr  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    baseUri    boolean    Node    parentNode    
return  absUrl  (  attributeKey.substring  (   "abs: ".length  (  )  )  )  ;	[BUGGY]  return  absUrl(  baseUri.substring(   "abs: ".length(  )));  [CONTEXT]  public  String  attr(String  attributeKey)  {  Validate.notNull(attributeKey);    if  (hasAttr(attributeKey))  return  attributes.get(attributeKey);  else  if  (attributeKey.toLowerCase().startsWith( "abs: "))  [BUGGY]  return  absUrl  (  baseUri.substring  (   "abs: ".length  ()))  ;  else  return   " ";  }        [CLASS]  Node    [METHOD]  attr  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    baseUri    boolean    Node    parentNode    
return  absUrl  (  attributeKey.substring  (   "abs: ".length  (  )  )  )  ;	[BUGGY]  return  attr(  attributeKey.substring(   "abs: ".length(  )));  [CONTEXT]  public  String  attr(String  attributeKey)  {  Validate.notNull(attributeKey);    if  (hasAttr(attributeKey))  return  attributes.get(attributeKey);  else  if  (attributeKey.toLowerCase().startsWith( "abs: "))  [BUGGY]  return  attr  (  attributeKey.substring  (   "abs: ".length  ()))  ;  else  return   " ";  }        [CLASS]  Node    [METHOD]  attr  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    baseUri    boolean    Node    parentNode    
return  absUrl  (  attributeKey.substring  (   "abs: ".length  (  )  )  )  ;	[BUGGY]  return  absUrl(  attributeKey.substring(   "abs: ".startsWith(  )));  [CONTEXT]  public  String  attr(String  attributeKey)  {  Validate.notNull(attributeKey);    if  (hasAttr(attributeKey))  return  attributes.get(attributeKey);  else  if  (attributeKey.toLowerCase().startsWith( "abs: "))  [BUGGY]  return  absUrl  (  attributeKey.substring  (   "abs: ".startsWith  ()))  ;  else  return   " ";  }        [CLASS]  Node    [METHOD]  attr  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    baseUri    boolean    Node    parentNode    
return  absUrl  (  attributeKey.substring  (   "abs: ".length  (  )  )  )  ;	[BUGGY]  return  absUrl(  attributeKey.substring(   " ".length(  )));  [CONTEXT]  public  String  attr(String  attributeKey)  {  Validate.notNull(attributeKey);    if  (hasAttr(attributeKey))  return  attributes.get(attributeKey);  else  if  (attributeKey.toLowerCase().startsWith( "abs: "))  [BUGGY]  return  absUrl  (  attributeKey.substring  (   " ".length  ()))  ;  else  return   " ";  }        [CLASS]  Node    [METHOD]  attr  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    baseUri    boolean    Node    parentNode    
return  absUrl  (  attributeKey.substring  (   "abs: ".length  (  )  )  )  ;	[BUGGY]  return  absUrl(  attributeKey.substring(   "abs: ".length()  -  2  ));  [CONTEXT]  public  String  attr(String  attributeKey)  {  Validate.notNull(attributeKey);    if  (hasAttr(attributeKey))  return  attributes.get(attributeKey);  else  if  (attributeKey.toLowerCase().startsWith( "abs: "))  [BUGGY]  return  absUrl  (  attributeKey.substring  (   "abs: ".length()  -  2))  ;  else  return   " ";  }        [CLASS]  Node    [METHOD]  attr  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    baseUri    boolean    Node    parentNode    
return  absUrl  (  attributeKey.substring  (   "abs: ".length  (  )  )  )  ;	[BUGGY]  return  absUrl(  attributeKey  .trim(  )  );  [CONTEXT]  public  String  attr(String  attributeKey)  {  Validate.notNull(attributeKey);    if  (hasAttr(attributeKey))  return  attributes.get(attributeKey);  else  if  (attributeKey.toLowerCase().startsWith( "abs: "))  [BUGGY]  return  absUrl  (  attributeKey  .trim  ()  )  ;  else  return   " ";  }        [CLASS]  Node    [METHOD]  attr  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    baseUri    boolean    Node    parentNode    
return  absUrl  (  attributeKey.substring  (   "abs: ".length  (  )  )  )  ;	[BUGGY]  return  absUrl(  attributeKey.substring(   "abs: "  .startsWith(  attributeKey)  ));  [CONTEXT]  public  String  attr(String  attributeKey)  {  Validate.notNull(attributeKey);    if  (hasAttr(attributeKey))  return  attributes.get(attributeKey);  else  if  (attributeKey.toLowerCase().startsWith( "abs: "))  [BUGGY]  return  absUrl  (  attributeKey.substring  (   "abs: "  .startsWith  (  attributeKey  )  ))  ;  else  return   " ";  }        [CLASS]  Node    [METHOD]  attr  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    baseUri    boolean    Node    parentNode    
return  absUrl  (  attributeKey.substring  (   "abs: ".length  (  )  )  )  ;	[BUGGY]    [CONTEXT]  public  String  attr(String  attributeKey)  {  Validate.notNull(attributeKey);    if  (hasAttr(attributeKey))  return  attributes.get(attributeKey);  else  if  (attributeKey.toLowerCase().startsWith( "abs: "))  [BUGGY]  return  absUrl(attributeKey.substring( "abs: ".length()));    else  return   " ";        [CLASS]  Node    [METHOD]  attr  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    baseUri    boolean    Node    parentNode    
return  absUrl  (  attributeKey.substring  (   "abs: ".length  (  )  )  )  ;	[BUGGY]  return  absUrl(  attributeKey.substring(   "abs:ab ".length(  )));  [CONTEXT]  public  String  attr(String  attributeKey)  {  Validate.notNull(attributeKey);    if  (hasAttr(attributeKey))  return  attributes.get(attributeKey);  else  if  (attributeKey.toLowerCase().startsWith( "abs: "))  [BUGGY]  return  absUrl  (  attributeKey.substring  (   "abs:ab ".length  ()))  ;  else  return   " ";  }        [CLASS]  Node    [METHOD]  attr  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    baseUri    boolean    Node    parentNode    
return  absUrl  (  attributeKey.substring  (   "abs: ".length  (  )  )  )  ;	[BUGGY]  return  absUrl(  attributeKey.substring(   "abs: ".length()  -  4  ));  [CONTEXT]  public  String  attr(String  attributeKey)  {  Validate.notNull(attributeKey);    if  (hasAttr(attributeKey))  return  attributes.get(attributeKey);  else  if  (attributeKey.toLowerCase().startsWith( "abs: "))  [BUGGY]  return  absUrl  (  attributeKey.substring  (   "abs: ".length()  -  4))  ;  else  return   " ";  }        [CLASS]  Node    [METHOD]  attr  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    baseUri    boolean    Node    parentNode    
return  absUrl  (  attributeKey.substring  (   "abs: ".length  (  )  )  )  ;	[BUGGY]  return  absUrl(  baseUri.substring(   "abs: ".startsWith(  )));  [CONTEXT]  public  String  attr(String  attributeKey)  {  Validate.notNull(attributeKey);    if  (hasAttr(attributeKey))  return  attributes.get(attributeKey);  else  if  (attributeKey.toLowerCase().startsWith( "abs: "))  [BUGGY]  return  absUrl  (  baseUri.substring  (   "abs: ".startsWith  ()))  ;  else  return   " ";  }        [CLASS]  Node    [METHOD]  attr  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    baseUri    boolean    Node    parentNode    
return  absUrl  (  attributeKey.substring  (   "abs: ".length  (  )  )  )  ;  else  return   " ";	[BUGGY]    [CONTEXT]  public  String  attr(String  attributeKey)  {  Validate.notNull(attributeKey);    if  (hasAttr(attributeKey))  return  attributes.get(attributeKey);  else  if  (attributeKey.toLowerCase().startsWith( "abs: "))  [BUGGY]  return  absUrl(attributeKey.substring( "abs: ".length()));            [CLASS]  Node    [METHOD]  attr  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    baseUri    boolean    Node    parentNode    
return  absUrl  (  attributeKey.substring  (   "abs: ".length  (  )  )  )  ;	[BUGGY]  return  absUrl(  attributeKey.substring(   "abs: ".length()  +  2  ));  [CONTEXT]  public  String  attr(String  attributeKey)  {  Validate.notNull(attributeKey);    if  (hasAttr(attributeKey))  return  attributes.get(attributeKey);  else  if  (attributeKey.toLowerCase().startsWith( "abs: "))  [BUGGY]  return  absUrl  (  attributeKey.substring  (   "abs: ".length()  +  2))  ;  else  return   " ";  }        [CLASS]  Node    [METHOD]  attr  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    baseUri    boolean    Node    parentNode    
return  absUrl  (  attributeKey.substring  (   "abs: ".length  (  )  )  )  ;	[BUGGY]  return  absUrl(  attributeKey.substring(   "abs:bs ".length(  )));  [CONTEXT]  public  String  attr(String  attributeKey)  {  Validate.notNull(attributeKey);    if  (hasAttr(attributeKey))  return  attributes.get(attributeKey);  else  if  (attributeKey.toLowerCase().startsWith( "abs: "))  [BUGGY]  return  absUrl  (  attributeKey.substring  (   "abs:bs ".length  ()))  ;  else  return   " ";  }        [CLASS]  Node    [METHOD]  attr  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    baseUri    boolean    Node    parentNode    
else  if  (  attributeKey.toLowerCase  (  )  .startsWith  (   "abs: "  )  )  return  absUrl  (  attributeKey.substring  (   "abs: ".length  (  )  )  )  ;	[BUGGY]  else  if  (  attributeKey.toLowerCase(  ).startsWith(   "abs:a "))return  absUrl(  attributeKey.substring(   "abs:a ".length(  )));  [CONTEXT]  public  String  attr(String  attributeKey)  {  Validate.notNull(attributeKey);    if  (hasAttr(attributeKey))  return  attributes.get(attributeKey);  [BUGGY]  else  if(  attributeKey.toLowerCase  ()  .startsWith  (   "abs:a "  ))  return  absUrl  (  attributeKey.substring  (   "abs:a ".length  ()))  ;    else  return   " ";  }        [CLASS]  Node    [METHOD]  attr  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    baseUri    boolean    Node    parentNode    
else  if  (  attributeKey.toLowerCase  (  )  .startsWith  (   "abs: "  )  )  return  absUrl  (  attributeKey.substring  (   "abs: ".length  (  )  )  )  ;	[BUGGY]  else  if  (  attributeKey.toLowerCase(  ).startsWith(   "abs: "))return  absUrl(  attributeKey.substring(   "abs: ".length()  -  6  ));  [CONTEXT]  public  String  attr(String  attributeKey)  {  Validate.notNull(attributeKey);    if  (hasAttr(attributeKey))  return  attributes.get(attributeKey);  [BUGGY]  else  if(  attributeKey.toLowerCase  ()  .startsWith  (   "abs: "  ))  return  absUrl  (  attributeKey.substring  (   "abs: ".length()  -  6))  ;    else  return   " ";  }        [CLASS]  Node    [METHOD]  attr  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    baseUri    boolean    Node    parentNode    
else  if  (  attributeKey.toLowerCase  (  )  .startsWith  (   "abs: "  )  )  return  absUrl  (  attributeKey.substring  (   "abs: ".length  (  )  )  )  ;	[BUGGY]  else  if  (  attributeKey  .trim(  )  .startsWith(   "abs: "))return  absUrl(  attributeKey.substring(   "abs: ".length(  )));  [CONTEXT]  public  String  attr(String  attributeKey)  {  Validate.notNull(attributeKey);    if  (hasAttr(attributeKey))  return  attributes.get(attributeKey);  [BUGGY]  else  if(  attributeKey  .trim  ().startsWith  (   "abs: "  ))  return  absUrl  (  attributeKey.substring  (   "abs: ".length  ()))  ;    else  return   " ";  }        [CLASS]  Node    [METHOD]  attr  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    baseUri    boolean    Node    parentNode    
else  if  (  attributeKey.toLowerCase  (  )  .startsWith  (   "abs: "  )  )  return  absUrl  (  attributeKey.substring  (   "abs: ".length  (  )  )  )  ;  else  return   " ";  }	[BUGGY]    [CONTEXT]  public  String  attr(String  attributeKey)  {  Validate.notNull(attributeKey);    if  (hasAttr(attributeKey))  return  attributes.get(attributeKey);  [BUGGY]  else  if  (attributeKey.toLowerCase().startsWith( "abs: "))              [CLASS]  Node    [METHOD]  attr  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    baseUri    boolean    Node    parentNode    
else  if  (  attributeKey.toLowerCase  (  )  .startsWith  (   "abs: "  )  )  return  absUrl  (  attributeKey.substring  (   "abs: ".length  (  )  )  )  ;	[BUGGY]  else  if  (  attributeKey.toLowerCase(  ).startsWith(   "abs: "))return  absUrl(  attributeKey.substring(   "abs: ".length()  +  0  ));  [CONTEXT]  public  String  attr(String  attributeKey)  {  Validate.notNull(attributeKey);    if  (hasAttr(attributeKey))  return  attributes.get(attributeKey);  [BUGGY]  else  if(  attributeKey.toLowerCase  ()  .startsWith  (   "abs: "  ))  return  absUrl  (  attributeKey.substring  (   "abs: ".length()  +  0))  ;    else  return   " ";  }        [CLASS]  Node    [METHOD]  attr  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    baseUri    boolean    Node    parentNode    
return  absUrl  (  attributeKey.substring  (   "abs: ".length  (  )  )  )  ;	[BUGGY]  return  absUrl(  attributeKey.substring(   "abs:b ".length(  )));  [CONTEXT]  public  String  attr(String  attributeKey)  {  Validate.notNull(attributeKey);    if  (hasAttr(attributeKey))  return  attributes.get(attributeKey);  else  if  (attributeKey.toLowerCase().startsWith( "abs: "))  [BUGGY]  return  absUrl  (  attributeKey.substring  (   "abs:b ".length  ()))  ;  else  return   " ";  }        [CLASS]  Node    [METHOD]  attr  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    baseUri    boolean    Node    parentNode    
return  absUrl  (  attributeKey.substring  (   "abs: ".length  (  )  )  )  ;	[BUGGY]  return  absUrl(  attributeKey.substring(   "abs: ".length()  -  6  ));  [CONTEXT]  public  String  attr(String  attributeKey)  {  Validate.notNull(attributeKey);    if  (hasAttr(attributeKey))  return  attributes.get(attributeKey);  else  if  (attributeKey.toLowerCase().startsWith( "abs: "))  [BUGGY]  return  absUrl  (  attributeKey.substring  (   "abs: ".length()  -  6))  ;  else  return   " ";  }        [CLASS]  Node    [METHOD]  attr  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    baseUri    boolean    Node    parentNode    
return  absUrl  (  attributeKey.substring  (   "abs: ".length  (  )  )  )  ;	[BUGGY]  return  absUrl(  attributeKey.substring(   "abs: ".length()  -  3  ));  [CONTEXT]  public  String  attr(String  attributeKey)  {  Validate.notNull(attributeKey);    if  (hasAttr(attributeKey))  return  attributes.get(attributeKey);  else  if  (attributeKey.toLowerCase().startsWith( "abs: "))  [BUGGY]  return  absUrl  (  attributeKey.substring  (   "abs: ".length()  -  3))  ;  else  return   " ";  }        [CLASS]  Node    [METHOD]  attr  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    baseUri    boolean    Node    parentNode    
return  absUrl  (  attributeKey.substring  (   "abs: ".length  (  )  )  )  ;	[BUGGY]  return  absUrl(  attributeKey.substring(   "ab ".length(  )));  [CONTEXT]  public  String  attr(String  attributeKey)  {  Validate.notNull(attributeKey);    if  (hasAttr(attributeKey))  return  attributes.get(attributeKey);  else  if  (attributeKey.toLowerCase().startsWith( "abs: "))  [BUGGY]  return  absUrl  (  attributeKey.substring  (   "ab ".length  ()))  ;  else  return   " ";  }        [CLASS]  Node    [METHOD]  attr  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    baseUri    boolean    Node    parentNode    
return  absUrl  (  attributeKey.substring  (   "abs: ".length  (  )  )  )  ;	[BUGGY]  return  absUrl(  attributeKey.substring(   "abs: ".length()  -  1  ));  [CONTEXT]  public  String  attr(String  attributeKey)  {  Validate.notNull(attributeKey);    if  (hasAttr(attributeKey))  return  attributes.get(attributeKey);  else  if  (attributeKey.toLowerCase().startsWith( "abs: "))  [BUGGY]  return  absUrl  (  attributeKey.substring  (   "abs: ".length()  -  1))  ;  else  return   " ";  }        [CLASS]  Node    [METHOD]  attr  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    baseUri    boolean    Node    parentNode    
return  attributes.get  (  attributeKey  )  ;	[BUGGY]  return  attributes.get(  baseUri);  [CONTEXT]  public  String  attr(String  attributeKey)  {  Validate.notNull(attributeKey);    if  (hasAttr(attributeKey))  [BUGGY]  return  attributes.get  (  baseUri  )  ;  else  if  (attributeKey.toLowerCase().startsWith( "abs: "))  return  absUrl(attributeKey.substring( "abs: ".length()));  else  return   " ";  }        [CLASS]  Node    [METHOD]  attr  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    baseUri    boolean    Node    parentNode    
return  attributes.get  (  attributeKey  )  ;	[BUGGY]  return  attributeKey.get(  attributes);  [CONTEXT]  public  String  attr(String  attributeKey)  {  Validate.notNull(attributeKey);    if  (hasAttr(attributeKey))  [BUGGY]  return  attributeKey.get  (  attributes  )  ;  else  if  (attributeKey.toLowerCase().startsWith( "abs: "))  return  absUrl(attributeKey.substring( "abs: ".length()));  else  return   " ";  }        [CLASS]  Node    [METHOD]  attr  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    baseUri    boolean    Node    parentNode    
return  attributes.get  (  attributeKey  )  ;	[BUGGY]  return  attributes.hasKey(  attributeKey);  [CONTEXT]  public  String  attr(String  attributeKey)  {  Validate.notNull(attributeKey);    if  (hasAttr(attributeKey))  [BUGGY]  return  attributes.hasKey  (  attributeKey  )  ;  else  if  (attributeKey.toLowerCase().startsWith( "abs: "))  return  absUrl(attributeKey.substring( "abs: ".length()));  else  return   " ";  }        [CLASS]  Node    [METHOD]  attr  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    baseUri    boolean    Node    parentNode    
return  attributes.get  (  attributeKey  )  ;	[BUGGY]  return  attributes  .put(  baseUri  ,  attributeKey)  ;  [CONTEXT]  public  String  attr(String  attributeKey)  {  Validate.notNull(attributeKey);    if  (hasAttr(attributeKey))  [BUGGY]  return  attributes  .put  (  baseUri  ,  attributeKey  );  else  if  (attributeKey.toLowerCase().startsWith( "abs: "))  return  absUrl(attributeKey.substring( "abs: ".length()));  else  return   " ";  }        [CLASS]  Node    [METHOD]  attr  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    baseUri    boolean    Node    parentNode    
return  attributes.get  (  attributeKey  )  ;	[BUGGY]  return  attributes  .put(  attributeKey  ,  baseUri)  ;  [CONTEXT]  public  String  attr(String  attributeKey)  {  Validate.notNull(attributeKey);    if  (hasAttr(attributeKey))  [BUGGY]  return  attributes  .put  (  attributeKey  ,  baseUri  );  else  if  (attributeKey.toLowerCase().startsWith( "abs: "))  return  absUrl(attributeKey.substring( "abs: ".length()));  else  return   " ";  }        [CLASS]  Node    [METHOD]  attr  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    baseUri    boolean    Node    parentNode    
return  attributes.get  (  attributeKey  )  ;	[BUGGY]    [CONTEXT]  public  String  attr(String  attributeKey)  {  Validate.notNull(attributeKey);    if  (hasAttr(attributeKey))  [BUGGY]  return  attributes.get(attributeKey);    else  if  (attributeKey.toLowerCase().startsWith( "abs: "))  return  absUrl(attributeKey.substring( "abs: ".length()));  else  return   " ";        [CLASS]  Node    [METHOD]  attr  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    baseUri    boolean    Node    parentNode    
else  if  (  attributeKey.toLowerCase  (  )  .startsWith  (   "abs: "  )  )  return  absUrl  (  attributeKey.substring  (   "abs: ".length  (  )  )  )  ;	[BUGGY]  else  if  (  attributeKey.toLowerCase(  ).startsWith(   "abbs: "))return  absUrl(  attributeKey.substring(   "abbs: ".length(  )));  [CONTEXT]  public  String  attr(String  attributeKey)  {  Validate.notNull(attributeKey);    if  (hasAttr(attributeKey))  return  attributes.get(attributeKey);  [BUGGY]  else  if(  attributeKey.toLowerCase  ()  .startsWith  (   "abbs: "  ))  return  absUrl  (  attributeKey.substring  (   "abbs: ".length  ()))  ;    else  return   " ";  }        [CLASS]  Node    [METHOD]  attr  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    baseUri    boolean    Node    parentNode    
else  if  (  attributeKey.toLowerCase  (  )  .startsWith  (   "abs: "  )  )  return  absUrl  (  attributeKey.substring  (   "abs: ".length  (  )  )  )  ;	[BUGGY]  else  if  (  attributeKey.toLowerCase(  ).startsWith(   "ab "))return  absUrl(  attributeKey.substring(   "ab ".length(  )));  [CONTEXT]  public  String  attr(String  attributeKey)  {  Validate.notNull(attributeKey);    if  (hasAttr(attributeKey))  return  attributes.get(attributeKey);  [BUGGY]  else  if(  attributeKey.toLowerCase  ()  .startsWith  (   "ab "  ))  return  absUrl  (  attributeKey.substring  (   "ab ".length  ()))  ;    else  return   " ";  }        [CLASS]  Node    [METHOD]  attr  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    baseUri    boolean    Node    parentNode    
else  if  (  attributeKey.toLowerCase  (  )  .startsWith  (   "abs: "  )  )  return  absUrl  (  attributeKey.substring  (   "abs: ".length  (  )  )  )  ;	[BUGGY]  else  if  (  attributeKey.toLowerCase(  ).startsWith(   "abs: "))return  absUrl(  attributeKey.substring(   "abs: ".length()  +  7  ));  [CONTEXT]  public  String  attr(String  attributeKey)  {  Validate.notNull(attributeKey);    if  (hasAttr(attributeKey))  return  attributes.get(attributeKey);  [BUGGY]  else  if(  attributeKey.toLowerCase  ()  .startsWith  (   "abs: "  ))  return  absUrl  (  attributeKey.substring  (   "abs: ".length()  +  7))  ;    else  return   " ";  }        [CLASS]  Node    [METHOD]  attr  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    baseUri    boolean    Node    parentNode    
else  if  (  attributeKey.toLowerCase  (  )  .startsWith  (   "abs: "  )  )  return  absUrl  (  attributeKey.substring  (   "abs: ".length  (  )  )  )  ;  else  return   " ";  }	[BUGGY]  return  absUrl(attributeKey.substring( "abs: ".length()));  [CONTEXT]  public  String  attr(String  attributeKey)  {  Validate.notNull(attributeKey);    if  (hasAttr(attributeKey))  return  attributes.get(attributeKey);  [BUGGY]  else  if  (attributeKey.toLowerCase().startsWith( "abs: "))    return  absUrl(attributeKey.substring( "abs: ".length()));          [CLASS]  Node    [METHOD]  attr  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    baseUri    boolean    Node    parentNode    
return  absUrl  (  attributeKey.substring  (   "abs: ".length  (  )  )  )  ;	[BUGGY]  return  absUrl(  attributeKey.substring(   "abs:abs ".length(  )));  [CONTEXT]  public  String  attr(String  attributeKey)  {  Validate.notNull(attributeKey);    if  (hasAttr(attributeKey))  return  attributes.get(attributeKey);  else  if  (attributeKey.toLowerCase().startsWith( "abs: "))  [BUGGY]  return  absUrl  (  attributeKey.substring  (   "abs:abs ".length  ()))  ;  else  return   " ";  }        [CLASS]  Node    [METHOD]  attr  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    baseUri    boolean    Node    parentNode    
return  absUrl  (  attributeKey.substring  (   "abs: ".length  (  )  )  )  ;	[BUGGY]  return  absUrl(  attributeKey.substring(   "abs: ".length()  -  8  ));  [CONTEXT]  public  String  attr(String  attributeKey)  {  Validate.notNull(attributeKey);    if  (hasAttr(attributeKey))  return  attributes.get(attributeKey);  else  if  (attributeKey.toLowerCase().startsWith( "abs: "))  [BUGGY]  return  absUrl  (  attributeKey.substring  (   "abs: ".length()  -  8))  ;  else  return   " ";  }        [CLASS]  Node    [METHOD]  attr  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    baseUri    boolean    Node    parentNode    
return  absUrl  (  attributeKey.substring  (   "abs: ".length  (  )  )  )  ;	[BUGGY]  return  absUrl(  attributeKey.substring(   "abs: "  .startsWith(  baseUri)  ));  [CONTEXT]  public  String  attr(String  attributeKey)  {  Validate.notNull(attributeKey);    if  (hasAttr(attributeKey))  return  attributes.get(attributeKey);  else  if  (attributeKey.toLowerCase().startsWith( "abs: "))  [BUGGY]  return  absUrl  (  attributeKey.substring  (   "abs: "  .startsWith  (  baseUri  )  ))  ;  else  return   " ";  }        [CLASS]  Node    [METHOD]  attr  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    baseUri    boolean    Node    parentNode    
return  absUrl  (  attributeKey.substring  (   "abs: ".length  (  )  )  )  ;	[BUGGY]  return  absUrl(  attributeKey.substring(   "abs: ".length()  -  0  ));  [CONTEXT]  public  String  attr(String  attributeKey)  {  Validate.notNull(attributeKey);    if  (hasAttr(attributeKey))  return  attributes.get(attributeKey);  else  if  (attributeKey.toLowerCase().startsWith( "abs: "))  [BUGGY]  return  absUrl  (  attributeKey.substring  (   "abs: ".length()  -  0))  ;  else  return   " ";  }        [CLASS]  Node    [METHOD]  attr  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    baseUri    boolean    Node    parentNode    
return  absUrl  (  attributeKey.substring  (   "abs: ".length  (  )  )  )  ;	[BUGGY]  return  absUrl(  attributeKey.substring(   "bbs: ".length(  )));  [CONTEXT]  public  String  attr(String  attributeKey)  {  Validate.notNull(attributeKey);    if  (hasAttr(attributeKey))  return  attributes.get(attributeKey);  else  if  (attributeKey.toLowerCase().startsWith( "abs: "))  [BUGGY]  return  absUrl  (  attributeKey.substring  (   "bbs: ".length  ()))  ;  else  return   " ";  }        [CLASS]  Node    [METHOD]  attr  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    baseUri    boolean    Node    parentNode    
return  absUrl  (  attributeKey.substring  (   "abs: ".length  (  )  )  )  ;	[BUGGY]  return  absUrl(  attributeKey.substring(   "abs: ".length()  +  7  ));  [CONTEXT]  public  String  attr(String  attributeKey)  {  Validate.notNull(attributeKey);    if  (hasAttr(attributeKey))  return  attributes.get(attributeKey);  else  if  (attributeKey.toLowerCase().startsWith( "abs: "))  [BUGGY]  return  absUrl  (  attributeKey.substring  (   "abs: ".length()  +  7))  ;  else  return   " ";  }        [CLASS]  Node    [METHOD]  attr  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    baseUri    boolean    Node    parentNode    
else  if  (  attributeKey.toLowerCase  (  )  .startsWith  (   "abs: "  )  )  return  absUrl  (  attributeKey.substring  (   "abs: ".length  (  )  )  )  ;	[BUGGY]  else  if  (  attributeKey.toLowerCase(  ).startsWith(   "abs:s "))return  absUrl(  attributeKey.substring(   "abs:s ".length(  )));  [CONTEXT]  public  String  attr(String  attributeKey)  {  Validate.notNull(attributeKey);    if  (hasAttr(attributeKey))  return  attributes.get(attributeKey);  [BUGGY]  else  if(  attributeKey.toLowerCase  ()  .startsWith  (   "abs:s "  ))  return  absUrl  (  attributeKey.substring  (   "abs:s ".length  ()))  ;    else  return   " ";  }        [CLASS]  Node    [METHOD]  attr  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    baseUri    boolean    Node    parentNode    
else  if  (  attributeKey.toLowerCase  (  )  .startsWith  (   "abs: "  )  )  return  absUrl  (  attributeKey.substring  (   "abs: ".length  (  )  )  )  ;	[BUGGY]  else  if  (  attributeKey.toLowerCase(  ).startsWith(   "abs: "))return  absUrl(  attributeKey.substring(   "abs: ".length()  +  8  ));  [CONTEXT]  public  String  attr(String  attributeKey)  {  Validate.notNull(attributeKey);    if  (hasAttr(attributeKey))  return  attributes.get(attributeKey);  [BUGGY]  else  if(  attributeKey.toLowerCase  ()  .startsWith  (   "abs: "  ))  return  absUrl  (  attributeKey.substring  (   "abs: ".length()  +  8))  ;    else  return   " ";  }        [CLASS]  Node    [METHOD]  attr  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    baseUri    boolean    Node    parentNode    
return  absUrl  (  attributeKey.substring  (   "abs: ".length  (  )  )  )  ;	[BUGGY]  return  absUrl(  attributeKey.substring(   "abs: ".length()  -  7  ));  [CONTEXT]  public  String  attr(String  attributeKey)  {  Validate.notNull(attributeKey);    if  (hasAttr(attributeKey))  return  attributes.get(attributeKey);  else  if  (attributeKey.toLowerCase().startsWith( "abs: "))  [BUGGY]  return  absUrl  (  attributeKey.substring  (   "abs: ".length()  -  7))  ;  else  return   " ";  }        [CLASS]  Node    [METHOD]  attr  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    baseUri    boolean    Node    parentNode    
return  absUrl  (  attributeKey.substring  (   "abs: ".length  (  )  )  )  ;	[BUGGY]  return  absUrl(  attributeKey.substring(   "abs: ".length()  +  1  ));  [CONTEXT]  public  String  attr(String  attributeKey)  {  Validate.notNull(attributeKey);    if  (hasAttr(attributeKey))  return  attributes.get(attributeKey);  else  if  (attributeKey.toLowerCase().startsWith( "abs: "))  [BUGGY]  return  absUrl  (  attributeKey.substring  (   "abs: ".length()  +  1))  ;  else  return   " ";  }        [CLASS]  Node    [METHOD]  attr  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    baseUri    boolean    Node    parentNode    
return  absUrl  (  attributeKey.substring  (   "abs: ".length  (  )  )  )  ;	[BUGGY]  return  absUrl(  attributeKey.substring(   "abs:a ".length(  )));  [CONTEXT]  public  String  attr(String  attributeKey)  {  Validate.notNull(attributeKey);    if  (hasAttr(attributeKey))  return  attributes.get(attributeKey);  else  if  (attributeKey.toLowerCase().startsWith( "abs: "))  [BUGGY]  return  absUrl  (  attributeKey.substring  (   "abs:a ".length  ()))  ;  else  return   " ";  }        [CLASS]  Node    [METHOD]  attr  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    baseUri    boolean    Node    parentNode    
return  absUrl  (  attributeKey.substring  (   "abs: ".length  (  )  )  )  ;	[BUGGY]  return  absUrl(  attributeKey.substring(   "abs: ".length()  -  9  ));  [CONTEXT]  public  String  attr(String  attributeKey)  {  Validate.notNull(attributeKey);    if  (hasAttr(attributeKey))  return  attributes.get(attributeKey);  else  if  (attributeKey.toLowerCase().startsWith( "abs: "))  [BUGGY]  return  absUrl  (  attributeKey.substring  (   "abs: ".length()  -  9))  ;  else  return   " ";  }        [CLASS]  Node    [METHOD]  attr  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    baseUri    boolean    Node    parentNode    
attributes.put  (  attributeKey,  attributeValue  )  ;	[BUGGY]  attributes.put(  baseUri,  attributeValue);  [CONTEXT]  public  Node  attr(String  attributeKey,  String  attributeValue)  {  [BUGGY]  attributes.put  (  baseUri,  attributeValue  )  ;  return  this;  }        [CLASS]  Node    [METHOD]  attr  [RETURN_TYPE]  Node      String  attributeKey  String  attributeValue  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    boolean    Node    parentNode    
attributes.put  (  attributeKey,  attributeValue  )  ;	[BUGGY]  attributes.put(  attributeKey,  baseUri);  [CONTEXT]  public  Node  attr(String  attributeKey,  String  attributeValue)  {  [BUGGY]  attributes.put  (  attributeKey,  baseUri  )  ;  return  this;  }        [CLASS]  Node    [METHOD]  attr  [RETURN_TYPE]  Node      String  attributeKey  String  attributeValue  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    boolean    Node    parentNode    
attributes.put  (  attributeKey,  attributeValue  )  ;	[BUGGY]  attributes.put(  attributeValue,  attributeKey);  [CONTEXT]  public  Node  attr(String  attributeKey,  String  attributeValue)  {  [BUGGY]  attributes.put  (  attributeValue,  attributeKey  )  ;  return  this;  }        [CLASS]  Node    [METHOD]  attr  [RETURN_TYPE]  Node      String  attributeKey  String  attributeValue  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    boolean    Node    parentNode    
attributes.put  (  attributeKey,  attributeValue  )  ;	[BUGGY]  attributes.put(    attributeValue);  [CONTEXT]  public  Node  attr(String  attributeKey,  String  attributeValue)  {  [BUGGY]  attributes.put  (attributeValue  )  ;  return  this;  }        [CLASS]  Node    [METHOD]  attr  [RETURN_TYPE]  Node      String  attributeKey  String  attributeValue  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    boolean    Node    parentNode    
attributes.put  (  attributeKey,  attributeValue  )  ;	[BUGGY]  attributes.put(  attributeKey);  [CONTEXT]  public  Node  attr(String  attributeKey,  String  attributeValue)  {  [BUGGY]  attributes.put  (  attributeKey  )  ;  return  this;  }        [CLASS]  Node    [METHOD]  attr  [RETURN_TYPE]  Node      String  attributeKey  String  attributeValue  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    boolean    Node    parentNode    
attributes.put  (  attributeKey,  attributeValue  )  ;  return  this;	[BUGGY]    [CONTEXT]  public  Node  attr(String  attributeKey,  String  attributeValue)  {  [BUGGY]  attributes.put(attributeKey,  attributeValue);            [CLASS]  Node    [METHOD]  attr  [RETURN_TYPE]  Node      String  attributeKey  String  attributeValue  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    boolean    Node    parentNode    
attributes.put  (  attributeKey,  attributeValue  )  ;	[BUGGY]    attributes.put(  attributeKey,  attributeValue);  [CONTEXT]        [CLASS]  Node    [METHOD]  attr  [RETURN_TYPE]  Node      String  attributeKey  String  attributeValue  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    boolean    Node    parentNode    
attributes.put  (  attributeKey,  attributeValue  )  ;	[BUGGY]  return  attributes.get(  attributeKey);attributes.put(  attributeKey,  attributeValue);  [CONTEXT]        [CLASS]  Node    [METHOD]  attr  [RETURN_TYPE]  Node      String  attributeKey  String  attributeValue  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    boolean    Node    parentNode    
attributes.put  (  attributeKey,  attributeValue  )  ;	[BUGGY]  attributes.remove(  attributeKey);attributes.put(  attributeKey,  attributeValue);  [CONTEXT]        [CLASS]  Node    [METHOD]  attr  [RETURN_TYPE]  Node      String  attributeKey  String  attributeValue  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    boolean    Node    parentNode    
return  this;	[BUGGY]  return  null;  [CONTEXT]  public  Node  attr(String  attributeKey,  String  attributeValue)  {  attributes.put(attributeKey,  attributeValue);  [BUGGY]  return  null;  }        [CLASS]  Node    [METHOD]  attr  [RETURN_TYPE]  Node      String  attributeKey  String  attributeValue  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    boolean    Node    parentNode    
Validate.notNull  (  attributeKey  )  ;	[BUGGY]  Validate.notNull(  baseUri);  [CONTEXT]  public  boolean  hasAttr(String  attributeKey)  {  [BUGGY]  Validate.notNull  (  baseUri  )  ;  return  attributes.hasKey(attributeKey);  }        [CLASS]  Node    [METHOD]  hasAttr  [RETURN_TYPE]  boolean      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    boolean    Node    parentNode    
Validate.notNull  (  attributeKey  )  ;	[BUGGY]  Validate.notEmpty(  attributeKey);  [CONTEXT]  public  boolean  hasAttr(String  attributeKey)  {  [BUGGY]  Validate.notEmpty  (  attributeKey  )  ;  return  attributes.hasKey(attributeKey);  }        [CLASS]  Node    [METHOD]  hasAttr  [RETURN_TYPE]  boolean      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    boolean    Node    parentNode    
Validate.notNull  (  attributeKey  )  ;	[BUGGY]    [CONTEXT]  public  boolean  hasAttr(String  attributeKey)  {  [BUGGY]  Validate.notNull(attributeKey);    return  attributes.hasKey(attributeKey);        [CLASS]  Node    [METHOD]  hasAttr  [RETURN_TYPE]  boolean      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    boolean    Node    parentNode    
return  attributes.hasKey  (  attributeKey  )  ;	[BUGGY]  return  attributeKey.hasKey(  attributes);  [CONTEXT]  public  boolean  hasAttr(String  attributeKey)  {  Validate.notNull(attributeKey);  [BUGGY]  return  attributeKey.hasKey  (  attributes  )  ;  }        [CLASS]  Node    [METHOD]  hasAttr  [RETURN_TYPE]  boolean      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    boolean    Node    parentNode    
return  attributes.hasKey  (  attributeKey  )  ;	[BUGGY]  return  attributes.get(  attributeKey);  [CONTEXT]  public  boolean  hasAttr(String  attributeKey)  {  Validate.notNull(attributeKey);  [BUGGY]  return  attributes.get  (  attributeKey  )  ;  }        [CLASS]  Node    [METHOD]  hasAttr  [RETURN_TYPE]  boolean      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    boolean    Node    parentNode    
return  attributes.hasKey  (  attributeKey  )  ;	[BUGGY]  return  attributes.hasKey(  baseUri);  [CONTEXT]  public  boolean  hasAttr(String  attributeKey)  {  Validate.notNull(attributeKey);  [BUGGY]  return  attributes.hasKey  (  baseUri  )  ;  }        [CLASS]  Node    [METHOD]  hasAttr  [RETURN_TYPE]  boolean      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    boolean    Node    parentNode    
return  attributes.hasKey  (  attributeKey  )  ;	[BUGGY]    [CONTEXT]  public  boolean  hasAttr(String  attributeKey)  {  Validate.notNull(attributeKey);  [BUGGY]  return  attributes.hasKey(attributeKey);          [CLASS]  Node    [METHOD]  hasAttr  [RETURN_TYPE]  boolean      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    boolean    Node    parentNode    
Validate.notNull  (  attributeKey  )  ;	[BUGGY]  Validate.notNull(  baseUri);  [CONTEXT]  public  Node  removeAttr(String  attributeKey)  {  [BUGGY]  Validate.notNull  (  baseUri  )  ;  attributes.remove(attributeKey);  return  this;  }        [CLASS]  Node    [METHOD]  removeAttr  [RETURN_TYPE]  Node      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    boolean    Node    parentNode    
Validate.notNull  (  attributeKey  )  ;	[BUGGY]  Validate.notEmpty(  attributeKey);  [CONTEXT]  public  Node  removeAttr(String  attributeKey)  {  [BUGGY]  Validate.notEmpty  (  attributeKey  )  ;  attributes.remove(attributeKey);  return  this;  }        [CLASS]  Node    [METHOD]  removeAttr  [RETURN_TYPE]  Node      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    boolean    Node    parentNode    
Validate.notNull  (  attributeKey  )  ;	[BUGGY]  Validate  .notEmpty(  baseUri)  ;  [CONTEXT]  public  Node  removeAttr(String  attributeKey)  {  [BUGGY]  Validate  .notEmpty  (  baseUri  );  attributes.remove(attributeKey);  return  this;  }        [CLASS]  Node    [METHOD]  removeAttr  [RETURN_TYPE]  Node      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    boolean    Node    parentNode    
Validate.notNull  (  attributeKey  )  ;  attributes.remove  (  attributeKey  )  ;	[BUGGY]    [CONTEXT]  public  Node  removeAttr(String  attributeKey)  {  [BUGGY]  Validate.notNull(attributeKey);      return  this;        [CLASS]  Node    [METHOD]  removeAttr  [RETURN_TYPE]  Node      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    boolean    Node    parentNode    
Validate.notNull  (  attributeKey  )  ;	[BUGGY]  Validate.notNull(  index);Validate.notNull(  attributeKey);  [CONTEXT]        [CLASS]  Node    [METHOD]  removeAttr  [RETURN_TYPE]  Node      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    boolean    Node    parentNode    
Validate.notNull  (  attributeKey  )  ;	[BUGGY]  return  attributes.get(  attributeKey);Validate.notNull(  attributeKey);  [CONTEXT]        [CLASS]  Node    [METHOD]  removeAttr  [RETURN_TYPE]  Node      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    boolean    Node    parentNode    
Validate.notNull  (  attributeKey  )  ;	[BUGGY]  Validate.notNull(  parentNode);Validate.notNull(  attributeKey);  [CONTEXT]        [CLASS]  Node    [METHOD]  removeAttr  [RETURN_TYPE]  Node      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    boolean    Node    parentNode    
Validate.notNull  (  attributeKey  )  ;	[BUGGY]  Validate.notNull(  baseUri);Validate.notNull(  attributeKey);  [CONTEXT]        [CLASS]  Node    [METHOD]  removeAttr  [RETURN_TYPE]  Node      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    boolean    Node    parentNode    
Validate.notNull  (  attributeKey  )  ;	[BUGGY]  Validate.notNull(  search);Validate.notNull(  attributeKey);  [CONTEXT]        [CLASS]  Node    [METHOD]  removeAttr  [RETURN_TYPE]  Node      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    boolean    Node    parentNode    
Validate.notNull  (  attributeKey  )  ;	[BUGGY]  return  attributes.hasKey(  attributeKey);Validate.notNull(  attributeKey);  [CONTEXT]        [CLASS]  Node    [METHOD]  removeAttr  [RETURN_TYPE]  Node      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    boolean    Node    parentNode    
Validate.notNull  (  attributeKey  )  ;	[BUGGY]  Validate.notNull(  attributes);Validate.notNull(  attributeKey);  [CONTEXT]        [CLASS]  Node    [METHOD]  removeAttr  [RETURN_TYPE]  Node      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    boolean    Node    parentNode    
Validate.notNull  (  attributeKey  )  ;	[BUGGY]  attributes.remove(  attributeKey);Validate.notNull(  attributeKey);  [CONTEXT]        [CLASS]  Node    [METHOD]  removeAttr  [RETURN_TYPE]  Node      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    boolean    Node    parentNode    
Validate.notNull  (  attributeKey  )  ;	[BUGGY]  Validate.notNull(  in);Validate.notNull(  attributeKey);  [CONTEXT]        [CLASS]  Node    [METHOD]  removeAttr  [RETURN_TYPE]  Node      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    boolean    Node    parentNode    
Validate.notNull  (  attributeKey  )  ;	[BUGGY]  Validate.notEmpty(  attributeKey);Validate.notNull(  attributeKey);  [CONTEXT]        [CLASS]  Node    [METHOD]  removeAttr  [RETURN_TYPE]  Node      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    boolean    Node    parentNode    
Validate.notNull  (  attributeKey  )  ;	[BUGGY]  Validate.notNull(  nodes);Validate.notNull(  attributeKey);  [CONTEXT]        [CLASS]  Node    [METHOD]  removeAttr  [RETURN_TYPE]  Node      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    boolean    Node    parentNode    
Validate.notNull  (  attributeKey  )  ;	[BUGGY]  String  relUrl  =  attr(  attributeKey);Validate.notNull(  attributeKey);  [CONTEXT]        [CLASS]  Node    [METHOD]  removeAttr  [RETURN_TYPE]  Node      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    boolean    Node    parentNode    
attributes.remove  (  attributeKey  )  ;	[BUGGY]  attributes.remove(  baseUri);  [CONTEXT]  public  Node  removeAttr(String  attributeKey)  {  Validate.notNull(attributeKey);  [BUGGY]  attributes.remove  (  baseUri  )  ;  return  this;  }        [CLASS]  Node    [METHOD]  removeAttr  [RETURN_TYPE]  Node      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    boolean    Node    parentNode    
attributes.remove  (  attributeKey  )  ;	[BUGGY]  attributes.get(  attributeKey);  [CONTEXT]  public  Node  removeAttr(String  attributeKey)  {  Validate.notNull(attributeKey);  [BUGGY]  attributes.get  (  attributeKey  )  ;  return  this;  }        [CLASS]  Node    [METHOD]  removeAttr  [RETURN_TYPE]  Node      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    boolean    Node    parentNode    
attributes.remove  (  attributeKey  )  ;	[BUGGY]  attributes  .hashCode(  )  ;  [CONTEXT]  public  Node  removeAttr(String  attributeKey)  {  Validate.notNull(attributeKey);  [BUGGY]  attributes  .hashCode  ();  return  this;  }        [CLASS]  Node    [METHOD]  removeAttr  [RETURN_TYPE]  Node      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    boolean    Node    parentNode    
attributes.remove  (  attributeKey  )  ;	[BUGGY]  attributes.get(  baseUri);  [CONTEXT]  public  Node  removeAttr(String  attributeKey)  {  Validate.notNull(attributeKey);  [BUGGY]  attributes.get  (  baseUri  )  ;  return  this;  }        [CLASS]  Node    [METHOD]  removeAttr  [RETURN_TYPE]  Node      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    boolean    Node    parentNode    
attributes.remove  (  attributeKey  )  ;	[BUGGY]    [CONTEXT]  public  Node  removeAttr(String  attributeKey)  {  Validate.notNull(attributeKey);  [BUGGY]  attributes.remove(attributeKey);    return  this;        [CLASS]  Node    [METHOD]  removeAttr  [RETURN_TYPE]  Node      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    boolean    Node    parentNode    
attributes.remove  (  attributeKey  )  ;	[BUGGY]    attributes.remove(  attributeKey);  [CONTEXT]        [CLASS]  Node    [METHOD]  removeAttr  [RETURN_TYPE]  Node      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    boolean    Node    parentNode    
attributes.remove  (  attributeKey  )  ;	[BUGGY]  return  attributes.get(  attributeKey);attributes.remove(  attributeKey);  [CONTEXT]        [CLASS]  Node    [METHOD]  removeAttr  [RETURN_TYPE]  Node      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    boolean    Node    parentNode    
attributes.remove  (  attributeKey  )  ;	[BUGGY]  attributes.put(  attributeKey,  attributeValue);attributes.remove(  attributeKey);  [CONTEXT]        [CLASS]  Node    [METHOD]  removeAttr  [RETURN_TYPE]  Node      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    boolean    Node    parentNode    
attributes.remove  (  attributeKey  )  ;	[BUGGY]  Validate.notNull(  attributeKey);attributes.remove(  attributeKey);  [CONTEXT]        [CLASS]  Node    [METHOD]  removeAttr  [RETURN_TYPE]  Node      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    boolean    Node    parentNode    
attributes.remove  (  attributeKey  )  ;	[BUGGY]  return  attributes.hasKey(  attributeKey);attributes.remove(  attributeKey);  [CONTEXT]        [CLASS]  Node    [METHOD]  removeAttr  [RETURN_TYPE]  Node      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    boolean    Node    parentNode    
attributes.remove  (  attributeKey  )  ;	[BUGGY]  Validate.notNull(  attributes);attributes.remove(  attributeKey);  [CONTEXT]        [CLASS]  Node    [METHOD]  removeAttr  [RETURN_TYPE]  Node      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    boolean    Node    parentNode    
attributes.remove  (  attributeKey  )  ;	[BUGGY]  Validate.notEmpty(  attributeKey);attributes.remove(  attributeKey);  [CONTEXT]        [CLASS]  Node    [METHOD]  removeAttr  [RETURN_TYPE]  Node      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    boolean    Node    parentNode    
attributes.remove  (  attributeKey  )  ;	[BUGGY]  String  relUrl  =  attr(  attributeKey);attributes.remove(  attributeKey);  [CONTEXT]        [CLASS]  Node    [METHOD]  removeAttr  [RETURN_TYPE]  Node      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    boolean    Node    parentNode    
return  this;	[BUGGY]  return  null;  [CONTEXT]  public  Node  removeAttr(String  attributeKey)  {  Validate.notNull(attributeKey);  attributes.remove(attributeKey);  [BUGGY]  return  null;  }        [CLASS]  Node    [METHOD]  removeAttr  [RETURN_TYPE]  Node      String  attributeKey  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    boolean    Node    parentNode    
return  baseUri;	[BUGGY]  return  attributeValue;  [CONTEXT]  public  String  baseUri()  {  [BUGGY]  return  attributeValue;  }        [CLASS]  Node    [METHOD]  baseUri  [RETURN_TYPE]  String      [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    boolean    Node    parentNode    
Validate.notNull  (  baseUri  )  ;	[BUGGY]  Validate.notNull(  attributeValue);  [CONTEXT]  public  void  setBaseUri(String  baseUri)  {  [BUGGY]  Validate.notNull  (  attributeValue  )  ;  this.baseUri  =  baseUri;  }        [CLASS]  Node    [METHOD]  setBaseUri  [RETURN_TYPE]  void      String  baseUri  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    boolean    Node    parentNode    
Validate.notNull  (  baseUri  )  ;	[BUGGY]  Validate.notEmpty(  baseUri);  [CONTEXT]  public  void  setBaseUri(String  baseUri)  {  [BUGGY]  Validate.notEmpty  (  baseUri  )  ;  this.baseUri  =  baseUri;  }        [CLASS]  Node    [METHOD]  setBaseUri  [RETURN_TYPE]  void      String  baseUri  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    boolean    Node    parentNode    
Validate.notNull  (  baseUri  )  ;	[BUGGY]  Validate.notEmpty(  attributeValue);  [CONTEXT]  public  void  setBaseUri(String  baseUri)  {  [BUGGY]  Validate.notEmpty  (  attributeValue  )  ;  this.baseUri  =  baseUri;  }        [CLASS]  Node    [METHOD]  setBaseUri  [RETURN_TYPE]  void      String  baseUri  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    boolean    Node    parentNode    
Validate.notNull  (  baseUri  )  ;  this.baseUri  =  baseUri;	[BUGGY]    [CONTEXT]  public  void  setBaseUri(String  baseUri)  {  [BUGGY]  Validate.notNull(baseUri);            [CLASS]  Node    [METHOD]  setBaseUri  [RETURN_TYPE]  void      String  baseUri  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    boolean    Node    parentNode    
Validate.notNull  (  baseUri  )  ;  this.baseUri  =  baseUri;	[BUGGY]  this.baseUri  =  baseUri;  Validate.notNull(  baseUri);  [CONTEXT]        [CLASS]  Node    [METHOD]  setBaseUri  [RETURN_TYPE]  void      String  baseUri  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    boolean    Node    parentNode    
Validate.notNull  (  baseUri  )  ;  this.baseUri  =  baseUri;	[BUGGY]  Validate.notNull(  baseUri);Validate.notNull(  baseUri);  this.baseUri  =  baseUri;  [CONTEXT]        [CLASS]  Node    [METHOD]  setBaseUri  [RETURN_TYPE]  void      String  baseUri  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    boolean    Node    parentNode    
this.baseUri  =  baseUri;	[BUGGY]  this.baseUri  =  attributeValue;  [CONTEXT]  public  void  setBaseUri(String  baseUri)  {  Validate.notNull(baseUri);  [BUGGY]  this.baseUri  =  attributeValue;  }        [CLASS]  Node    [METHOD]  setBaseUri  [RETURN_TYPE]  void      String  baseUri  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    boolean    Node    parentNode    
Validate.notEmpty  (  attributeKey  )  ;	[BUGGY]  Validate.notEmpty(  relUrl);  [CONTEXT]  public  String  absUrl(String  attributeKey)  {  [BUGGY]  Validate.notEmpty  (  relUrl  )  ;    String  relUrl  =  attr(attributeKey);  if  (!hasAttr(attributeKey))  {  return   " ";  //  nothing  to  make  absolute  with  }  else  {  URL  base;  try  {  try  {  base  =  new  URL(baseUri);  }  catch  (MalformedURLException  e)  {      URL  abs  =  new  URL(relUrl);  return  abs.toExternalForm();  }  URL  abs  =  new  URL(base,  relUrl);  return  abs.toExternalForm();  }  catch  (MalformedURLException  e)  {  return   " ";  }  }  }        [CLASS]  Node    [METHOD]  absUrl  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  MalformedURLException    e    boolean    Node    parentNode    Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    URL    abs    base    
Validate.notEmpty  (  attributeKey  )  ;	[BUGGY]  Validate.notNull(  attributeKey);  [CONTEXT]  public  String  absUrl(String  attributeKey)  {  [BUGGY]  Validate.notNull  (  attributeKey  )  ;    String  relUrl  =  attr(attributeKey);  if  (!hasAttr(attributeKey))  {  return   " ";  //  nothing  to  make  absolute  with  }  else  {  URL  base;  try  {  try  {  base  =  new  URL(baseUri);  }  catch  (MalformedURLException  e)  {      URL  abs  =  new  URL(relUrl);  return  abs.toExternalForm();  }  URL  abs  =  new  URL(base,  relUrl);  return  abs.toExternalForm();  }  catch  (MalformedURLException  e)  {  return   " ";  }  }  }        [CLASS]  Node    [METHOD]  absUrl  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  MalformedURLException    e    boolean    Node    parentNode    Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    URL    abs    base    
Validate.notEmpty  (  attributeKey  )  ;	[BUGGY]    [CONTEXT]  public  String  absUrl(String  attributeKey)  {  [BUGGY]  Validate.notEmpty(attributeKey);      String  relUrl  =  attr(attributeKey);  if  (!hasAttr(attributeKey))  {  return   " ";  //  nothing  to  make  absolute  with  }  else  {  URL  base;  try  {  try  {  base  =  new  URL(baseUri);  }  catch  (MalformedURLException  e)  {      URL  abs  =  new  URL(relUrl);  return  abs.toExternalForm();  }  URL  abs  =  new  URL(base,  relUrl);  return  abs.toExternalForm();  }  catch  (MalformedURLException  e)  {  return   " ";  }  }        [CLASS]  Node    [METHOD]  absUrl  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  MalformedURLException    e    boolean    Node    parentNode    Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    URL    abs    base    
String  relUrl  =  attr  (  attributeKey  )  ;	[BUGGY]  char  relUrl  =  attr(  attributeKey);  [CONTEXT]  public  String  absUrl(String  attributeKey)  {  Validate.notEmpty(attributeKey);    [BUGGY]  char  relUrl  =  attr  (  attributeKey  )  ;  if  (!hasAttr(attributeKey))  {  return   " ";  //  nothing  to  make  absolute  with  }  else  {  URL  base;  try  {  try  {  base  =  new  URL(baseUri);  }  catch  (MalformedURLException  e)  {      URL  abs  =  new  URL(relUrl);  return  abs.toExternalForm();  }  URL  abs  =  new  URL(base,  relUrl);  return  abs.toExternalForm();  }  catch  (MalformedURLException  e)  {  return   " ";  }  }  }        [CLASS]  Node    [METHOD]  absUrl  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  MalformedURLException    e    boolean    Node    parentNode    Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    URL    abs    base    
String  relUrl  =  attr  (  attributeKey  )  ;	[BUGGY]  String  relUrl  =  attr(  baseUri);  [CONTEXT]  public  String  absUrl(String  attributeKey)  {  Validate.notEmpty(attributeKey);    [BUGGY]  String  relUrl  =  attr  (  baseUri  )  ;  if  (!hasAttr(attributeKey))  {  return   " ";  //  nothing  to  make  absolute  with  }  else  {  URL  base;  try  {  try  {  base  =  new  URL(baseUri);  }  catch  (MalformedURLException  e)  {      URL  abs  =  new  URL(relUrl);  return  abs.toExternalForm();  }  URL  abs  =  new  URL(base,  relUrl);  return  abs.toExternalForm();  }  catch  (MalformedURLException  e)  {  return   " ";  }  }  }        [CLASS]  Node    [METHOD]  absUrl  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  MalformedURLException    e    boolean    Node    parentNode    Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    URL    abs    base    
String  relUrl  =  attr  (  attributeKey  )  ;	[BUGGY]  String  relUrl  =  hasAttr(  attributeKey);  [CONTEXT]  public  String  absUrl(String  attributeKey)  {  Validate.notEmpty(attributeKey);    [BUGGY]  String  relUrl  =  hasAttr  (  attributeKey  )  ;  if  (!hasAttr(attributeKey))  {  return   " ";  //  nothing  to  make  absolute  with  }  else  {  URL  base;  try  {  try  {  base  =  new  URL(baseUri);  }  catch  (MalformedURLException  e)  {      URL  abs  =  new  URL(relUrl);  return  abs.toExternalForm();  }  URL  abs  =  new  URL(base,  relUrl);  return  abs.toExternalForm();  }  catch  (MalformedURLException  e)  {  return   " ";  }  }  }        [CLASS]  Node    [METHOD]  absUrl  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  MalformedURLException    e    boolean    Node    parentNode    Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    URL    abs    base    
String  relUrl  =  attr  (  attributeKey  )  ;	[BUGGY]  String  relUrl  =  hasAttr(  baseUri);  [CONTEXT]  public  String  absUrl(String  attributeKey)  {  Validate.notEmpty(attributeKey);    [BUGGY]  String  relUrl  =  hasAttr  (  baseUri  )  ;  if  (!hasAttr(attributeKey))  {  return   " ";  //  nothing  to  make  absolute  with  }  else  {  URL  base;  try  {  try  {  base  =  new  URL(baseUri);  }  catch  (MalformedURLException  e)  {      URL  abs  =  new  URL(relUrl);  return  abs.toExternalForm();  }  URL  abs  =  new  URL(base,  relUrl);  return  abs.toExternalForm();  }  catch  (MalformedURLException  e)  {  return   " ";  }  }  }        [CLASS]  Node    [METHOD]  absUrl  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  MalformedURLException    e    boolean    Node    parentNode    Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    URL    abs    base    
String  relUrl  =  attr  (  attributeKey  )  ;	[BUGGY]  if  (  !hasAttr(  attributeKey))  {  String  relUrl  =  attr(  attributeKey);  }  [CONTEXT]        [CLASS]  Node    [METHOD]  absUrl  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  MalformedURLException    e    boolean    Node    parentNode    Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    URL    abs    base    
String  relUrl  =  attr  (  attributeKey  )  ;	[BUGGY]  String  relUrl  =  attr(  relUrl);  [CONTEXT]  public  String  absUrl(String  attributeKey)  {  Validate.notEmpty(attributeKey);    [BUGGY]  String  relUrl  =  attr  (  relUrl  )  ;  if  (!hasAttr(attributeKey))  {  return   " ";  //  nothing  to  make  absolute  with  }  else  {  URL  base;  try  {  try  {  base  =  new  URL(baseUri);  }  catch  (MalformedURLException  e)  {      URL  abs  =  new  URL(relUrl);  return  abs.toExternalForm();  }  URL  abs  =  new  URL(base,  relUrl);  return  abs.toExternalForm();  }  catch  (MalformedURLException  e)  {  return   " ";  }  }  }        [CLASS]  Node    [METHOD]  absUrl  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  MalformedURLException    e    boolean    Node    parentNode    Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    URL    abs    base    
String  relUrl  =  attr  (  attributeKey  )  ;	[BUGGY]    [CONTEXT]  public  String  absUrl(String  attributeKey)  {  Validate.notEmpty(attributeKey);    [BUGGY]  String  relUrl  =  attr(attributeKey);    if  (!hasAttr(attributeKey))  {  return   " ";  //  nothing  to  make  absolute  with  }  else  {  URL  base;  try  {  try  {  base  =  new  URL(baseUri);  }  catch  (MalformedURLException  e)  {      URL  abs  =  new  URL(relUrl);  return  abs.toExternalForm();  }  URL  abs  =  new  URL(base,  relUrl);  return  abs.toExternalForm();  }  catch  (MalformedURLException  e)  {  return   " ";  }  }        [CLASS]  Node    [METHOD]  absUrl  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  MalformedURLException    e    boolean    Node    parentNode    Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    URL    abs    base    
if  (  !hasAttr  (  attributeKey  )  )  {	[BUGGY]  if  (  !hasAttr(  relUrl))  {  [CONTEXT]  public  String  absUrl(String  attributeKey)  {  Validate.notEmpty(attributeKey);    String  relUrl  =  attr(attributeKey);  [BUGGY]  if(  !hasAttr  (  relUrl  )){  return   " ";  //  nothing  to  make  absolute  with  }  else  {  URL  base;  try  {  try  {  base  =  new  URL(baseUri);  }  catch  (MalformedURLException  e)  {      URL  abs  =  new  URL(relUrl);  return  abs.toExternalForm();  }  URL  abs  =  new  URL(base,  relUrl);  return  abs.toExternalForm();  }  catch  (MalformedURLException  e)  {  return   " ";  }  }  }        [CLASS]  Node    [METHOD]  absUrl  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  MalformedURLException    e    boolean    Node    parentNode    Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    URL    abs    base    
if  (  !hasAttr  (  attributeKey  )  )  {	[BUGGY]  if  (  !attr(  attributeKey))  {  [CONTEXT]  public  String  absUrl(String  attributeKey)  {  Validate.notEmpty(attributeKey);    String  relUrl  =  attr(attributeKey);  [BUGGY]  if(  !attr  (  attributeKey  )){  return   " ";  //  nothing  to  make  absolute  with  }  else  {  URL  base;  try  {  try  {  base  =  new  URL(baseUri);  }  catch  (MalformedURLException  e)  {      URL  abs  =  new  URL(relUrl);  return  abs.toExternalForm();  }  URL  abs  =  new  URL(base,  relUrl);  return  abs.toExternalForm();  }  catch  (MalformedURLException  e)  {  return   " ";  }  }  }        [CLASS]  Node    [METHOD]  absUrl  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  MalformedURLException    e    boolean    Node    parentNode    Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    URL    abs    base    
base  =  new  URL  (  baseUri  )  ;	[BUGGY]  base  =  base  =    new  URL(  base,  relUrl)  ;  [CONTEXT]  public  String  absUrl(String  attributeKey)  {  Validate.notEmpty(attributeKey);    String  relUrl  =  attr(attributeKey);  if  (!hasAttr(attributeKey))  {  return   " ";  //  nothing  to  make  absolute  with  }  else  {  URL  base;  try  {  try  {  [BUGGY]  base  =  base  =new  URL  (  base,  relUrl  );  }  catch  (MalformedURLException  e)  {      URL  abs  =  new  URL(relUrl);  return  abs.toExternalForm();  }  URL  abs  =  new  URL(base,  relUrl);  return  abs.toExternalForm();  }  catch  (MalformedURLException  e)  {  return   " ";  }  }  }        [CLASS]  Node    [METHOD]  absUrl  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  MalformedURLException    e    boolean    Node    parentNode    Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    URL    abs    base    
base  =  new  URL  (  baseUri  )  ;	[BUGGY]  base  =  new  URL(  relUrl);  [CONTEXT]  public  String  absUrl(String  attributeKey)  {  Validate.notEmpty(attributeKey);    String  relUrl  =  attr(attributeKey);  if  (!hasAttr(attributeKey))  {  return   " ";  //  nothing  to  make  absolute  with  }  else  {  URL  base;  try  {  try  {  [BUGGY]  base  =  new  URL  (  relUrl  )  ;  }  catch  (MalformedURLException  e)  {      URL  abs  =  new  URL(relUrl);  return  abs.toExternalForm();  }  URL  abs  =  new  URL(base,  relUrl);  return  abs.toExternalForm();  }  catch  (MalformedURLException  e)  {  return   " ";  }  }  }        [CLASS]  Node    [METHOD]  absUrl  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  MalformedURLException    e    boolean    Node    parentNode    Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    URL    abs    base    
base  =  new  URL  (  baseUri  )  ;	[BUGGY]  base  =    new  URL(  base,  relUrl)  ;  [CONTEXT]  public  String  absUrl(String  attributeKey)  {  Validate.notEmpty(attributeKey);    String  relUrl  =  attr(attributeKey);  if  (!hasAttr(attributeKey))  {  return   " ";  //  nothing  to  make  absolute  with  }  else  {  URL  base;  try  {  try  {  [BUGGY]  base  =new  URL  (  base,  relUrl  );  }  catch  (MalformedURLException  e)  {      URL  abs  =  new  URL(relUrl);  return  abs.toExternalForm();  }  URL  abs  =  new  URL(base,  relUrl);  return  abs.toExternalForm();  }  catch  (MalformedURLException  e)  {  return   " ";  }  }  }        [CLASS]  Node    [METHOD]  absUrl  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  MalformedURLException    e    boolean    Node    parentNode    Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    URL    abs    base    
return  abs.toExternalForm  (  )  ;	[BUGGY]  return  base.toExternalForm(  );  [CONTEXT]  public  String  absUrl(String  attributeKey)  {  Validate.notEmpty(attributeKey);    String  relUrl  =  attr(attributeKey);  if  (!hasAttr(attributeKey))  {  return   " ";  //  nothing  to  make  absolute  with  }  else  {  URL  base;  try  {  try  {  base  =  new  URL(baseUri);  }  catch  (MalformedURLException  e)  {      URL  abs  =  new  URL(relUrl);  [BUGGY]  return  base.toExternalForm  ()  ;  }  URL  abs  =  new  URL(base,  relUrl);  return  abs.toExternalForm();  }  catch  (MalformedURLException  e)  {  return   " ";  }  }  }        [CLASS]  Node    [METHOD]  absUrl  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  MalformedURLException    e    boolean    Node    parentNode    Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    URL    abs    base    
return  abs.toExternalForm  (  )  ;	[BUGGY]  return  abs  .URL(  )  ;  [CONTEXT]  public  String  absUrl(String  attributeKey)  {  Validate.notEmpty(attributeKey);    String  relUrl  =  attr(attributeKey);  if  (!hasAttr(attributeKey))  {  return   " ";  //  nothing  to  make  absolute  with  }  else  {  URL  base;  try  {  try  {  base  =  new  URL(baseUri);  }  catch  (MalformedURLException  e)  {      URL  abs  =  new  URL(relUrl);  [BUGGY]  return  abs  .URL  ();  }  URL  abs  =  new  URL(base,  relUrl);  return  abs.toExternalForm();  }  catch  (MalformedURLException  e)  {  return   " ";  }  }  }        [CLASS]  Node    [METHOD]  absUrl  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  MalformedURLException    e    boolean    Node    parentNode    Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    URL    abs    base    
return  abs.toExternalForm  (  )  ;	[BUGGY]  return  base.toExternalForm(  );  [CONTEXT]  public  String  absUrl(String  attributeKey)  {  Validate.notEmpty(attributeKey);    String  relUrl  =  attr(attributeKey);  if  (!hasAttr(attributeKey))  {  return   " ";  //  nothing  to  make  absolute  with  }  else  {  URL  base;  try  {  try  {  base  =  new  URL(baseUri);  }  catch  (MalformedURLException  e)  {      URL  abs  =  new  URL(relUrl);  return  abs.toExternalForm();  }  URL  abs  =  new  URL(base,  relUrl);  [BUGGY]  return  base.toExternalForm  ()  ;  }  catch  (MalformedURLException  e)  {  return   " ";  }  }  }        [CLASS]  Node    [METHOD]  absUrl  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  MalformedURLException    e    boolean    Node    parentNode    Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    URL    abs    base    
return  abs.toExternalForm  (  )  ;	[BUGGY]  return  abs  .URL(  )  ;  [CONTEXT]  public  String  absUrl(String  attributeKey)  {  Validate.notEmpty(attributeKey);    String  relUrl  =  attr(attributeKey);  if  (!hasAttr(attributeKey))  {  return   " ";  //  nothing  to  make  absolute  with  }  else  {  URL  base;  try  {  try  {  base  =  new  URL(baseUri);  }  catch  (MalformedURLException  e)  {      URL  abs  =  new  URL(relUrl);  return  abs.toExternalForm();  }  URL  abs  =  new  URL(base,  relUrl);  [BUGGY]  return  abs  .URL  ();  }  catch  (MalformedURLException  e)  {  return   " ";  }  }  }        [CLASS]  Node    [METHOD]  absUrl  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  MalformedURLException    e    boolean    Node    parentNode    Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    URL    abs    base    
URL  abs  =  new  URL  (  relUrl  )  ;	[BUGGY]  URL  abs  =  new  URL(  baseUri)  ;  [CONTEXT]  public  String  absUrl(String  attributeKey)  {  Validate.notEmpty(attributeKey);    String  relUrl  =  attr(attributeKey);  if  (!hasAttr(attributeKey))  {  return   " ";  //  nothing  to  make  absolute  with  }  else  {  URL  base;  try  {  try  {  base  =  new  URL(baseUri);  }  catch  (MalformedURLException  e)  {      [BUGGY]  URL  abs  =  new  URL  (  baseUri  );  return  abs.toExternalForm();  }  URL  abs  =  new  URL(base,  relUrl);  return  abs.toExternalForm();  }  catch  (MalformedURLException  e)  {  return   " ";  }  }  }        [CLASS]  Node    [METHOD]  absUrl  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  MalformedURLException    e    boolean    Node    parentNode    Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    URL    abs    base    
URL  abs  =  new  URL  (  base,  relUrl  )  ;	[BUGGY]  URL  abs  =  new  URL(  baseUri)  ;  [CONTEXT]  public  String  absUrl(String  attributeKey)  {  Validate.notEmpty(attributeKey);    String  relUrl  =  attr(attributeKey);  if  (!hasAttr(attributeKey))  {  return   " ";  //  nothing  to  make  absolute  with  }  else  {  URL  base;  try  {  try  {  base  =  new  URL(baseUri);  }  catch  (MalformedURLException  e)  {      URL  abs  =  new  URL(relUrl);  return  abs.toExternalForm();  }  [BUGGY]  URL  abs  =  new  URL  (  baseUri  );  return  abs.toExternalForm();  }  catch  (MalformedURLException  e)  {  return   " ";  }  }  }        [CLASS]  Node    [METHOD]  absUrl  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  MalformedURLException    e    boolean    Node    parentNode    Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    URL    abs    base    
URL  abs  =  new  URL  (  base,  relUrl  )  ;	[BUGGY]  URL  abs  =  new  URL(    relUrl);  [CONTEXT]  public  String  absUrl(String  attributeKey)  {  Validate.notEmpty(attributeKey);    String  relUrl  =  attr(attributeKey);  if  (!hasAttr(attributeKey))  {  return   " ";  //  nothing  to  make  absolute  with  }  else  {  URL  base;  try  {  try  {  base  =  new  URL(baseUri);  }  catch  (MalformedURLException  e)  {      URL  abs  =  new  URL(relUrl);  return  abs.toExternalForm();  }  [BUGGY]  URL  abs  =  new  URL  (relUrl  )  ;  return  abs.toExternalForm();  }  catch  (MalformedURLException  e)  {  return   " ";  }  }  }        [CLASS]  Node    [METHOD]  absUrl  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  MalformedURLException    e    boolean    Node    parentNode    Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    URL    abs    base    
URL  abs  =  new  URL  (  base,  relUrl  )  ;	[BUGGY]  URL  abs  =  new  URL(  base);  [CONTEXT]  public  String  absUrl(String  attributeKey)  {  Validate.notEmpty(attributeKey);    String  relUrl  =  attr(attributeKey);  if  (!hasAttr(attributeKey))  {  return   " ";  //  nothing  to  make  absolute  with  }  else  {  URL  base;  try  {  try  {  base  =  new  URL(baseUri);  }  catch  (MalformedURLException  e)  {      URL  abs  =  new  URL(relUrl);  return  abs.toExternalForm();  }  [BUGGY]  URL  abs  =  new  URL  (  base  )  ;  return  abs.toExternalForm();  }  catch  (MalformedURLException  e)  {  return   " ";  }  }  }        [CLASS]  Node    [METHOD]  absUrl  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  MalformedURLException    e    boolean    Node    parentNode    Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    URL    abs    base    
URL  abs  =  new  URL  (  base,  relUrl  )  ;	[BUGGY]  URL  abs  =  new  URL(  abs,  relUrl);  [CONTEXT]  public  String  absUrl(String  attributeKey)  {  Validate.notEmpty(attributeKey);    String  relUrl  =  attr(attributeKey);  if  (!hasAttr(attributeKey))  {  return   " ";  //  nothing  to  make  absolute  with  }  else  {  URL  base;  try  {  try  {  base  =  new  URL(baseUri);  }  catch  (MalformedURLException  e)  {      URL  abs  =  new  URL(relUrl);  return  abs.toExternalForm();  }  [BUGGY]  URL  abs  =  new  URL  (  abs,  relUrl  )  ;  return  abs.toExternalForm();  }  catch  (MalformedURLException  e)  {  return   " ";  }  }  }        [CLASS]  Node    [METHOD]  absUrl  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  MalformedURLException    e    boolean    Node    parentNode    Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    URL    abs    base    
URL  abs  =  new  URL  (  base,  relUrl  )  ;	[BUGGY]  URL  abs  =  new  URL(  base,  baseUri);  [CONTEXT]  public  String  absUrl(String  attributeKey)  {  Validate.notEmpty(attributeKey);    String  relUrl  =  attr(attributeKey);  if  (!hasAttr(attributeKey))  {  return   " ";  //  nothing  to  make  absolute  with  }  else  {  URL  base;  try  {  try  {  base  =  new  URL(baseUri);  }  catch  (MalformedURLException  e)  {      URL  abs  =  new  URL(relUrl);  return  abs.toExternalForm();  }  [BUGGY]  URL  abs  =  new  URL  (  base,  baseUri  )  ;  return  abs.toExternalForm();  }  catch  (MalformedURLException  e)  {  return   " ";  }  }  }        [CLASS]  Node    [METHOD]  absUrl  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  MalformedURLException    e    boolean    Node    parentNode    Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    URL    abs    base    
URL  abs  =  new  URL  (  base,  relUrl  )  ;	[BUGGY]  URL  abs  =  new  URL(  relUrl,  base);  [CONTEXT]  public  String  absUrl(String  attributeKey)  {  Validate.notEmpty(attributeKey);    String  relUrl  =  attr(attributeKey);  if  (!hasAttr(attributeKey))  {  return   " ";  //  nothing  to  make  absolute  with  }  else  {  URL  base;  try  {  try  {  base  =  new  URL(baseUri);  }  catch  (MalformedURLException  e)  {      URL  abs  =  new  URL(relUrl);  return  abs.toExternalForm();  }  [BUGGY]  URL  abs  =  new  URL  (  relUrl,  base  )  ;  return  abs.toExternalForm();  }  catch  (MalformedURLException  e)  {  return   " ";  }  }  }        [CLASS]  Node    [METHOD]  absUrl  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  MalformedURLException    e    boolean    Node    parentNode    Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    URL    abs    base    
URL  abs  =  new  URL  (  relUrl  )  ;	[BUGGY]    URL  abs  =  new  URL(  relUrl);  [CONTEXT]        [CLASS]  Node    [METHOD]  absUrl  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  MalformedURLException    e    boolean    Node    parentNode    Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    URL    abs    base    
URL  abs  =  new  URL  (  relUrl  )  ;	[BUGGY]  URL  abs  =  new  URL(  base,  relUrl);URL  abs  =  new  URL(  relUrl);  [CONTEXT]        [CLASS]  Node    [METHOD]  absUrl  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  MalformedURLException    e    boolean    Node    parentNode    Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    URL    abs    base    
URL  abs  =  new  URL  (  base,  relUrl  )  ;	[BUGGY]  return  abs.toExternalForm(  );  URL  abs  =  new  URL(  base,  relUrl);  [CONTEXT]        [CLASS]  Node    [METHOD]  absUrl  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  MalformedURLException    e    boolean    Node    parentNode    Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    URL    abs    base    
URL  abs  =  new  URL  (  base,  relUrl  )  ;	[BUGGY]  URL  abs  =  new  URL(  relUrl);URL  abs  =  new  URL(  base,  relUrl);  [CONTEXT]        [CLASS]  Node    [METHOD]  absUrl  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  MalformedURLException    e    boolean    Node    parentNode    Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    URL    abs    base    
return  abs.toExternalForm  (  )  ;	[BUGGY]    [CONTEXT]  public  String  absUrl(String  attributeKey)  {  Validate.notEmpty(attributeKey);    String  relUrl  =  attr(attributeKey);  if  (!hasAttr(attributeKey))  {  return   " ";  //  nothing  to  make  absolute  with  }  else  {  URL  base;  try  {  try  {  base  =  new  URL(baseUri);  }  catch  (MalformedURLException  e)  {      URL  abs  =  new  URL(relUrl);  [BUGGY]  return  abs.toExternalForm();    }  URL  abs  =  new  URL(base,  relUrl);  return  abs.toExternalForm();  }  catch  (MalformedURLException  e)  {  return   " ";  }  }        [CLASS]  Node    [METHOD]  absUrl  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  MalformedURLException    e    boolean    Node    parentNode    Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    URL    abs    base    
return  abs.toExternalForm  (  )  ;	[BUGGY]  return  base  .URL(  )  ;  [CONTEXT]  public  String  absUrl(String  attributeKey)  {  Validate.notEmpty(attributeKey);    String  relUrl  =  attr(attributeKey);  if  (!hasAttr(attributeKey))  {  return   " ";  //  nothing  to  make  absolute  with  }  else  {  URL  base;  try  {  try  {  base  =  new  URL(baseUri);  }  catch  (MalformedURLException  e)  {      URL  abs  =  new  URL(relUrl);  return  abs.toExternalForm();  }  URL  abs  =  new  URL(base,  relUrl);  [BUGGY]  return  base  .URL  ();  }  catch  (MalformedURLException  e)  {  return   " ";  }  }  }        [CLASS]  Node    [METHOD]  absUrl  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  MalformedURLException    e    boolean    Node    parentNode    Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    URL    abs    base    
return  abs.toExternalForm  (  )  ;	[BUGGY]    [CONTEXT]  public  String  absUrl(String  attributeKey)  {  Validate.notEmpty(attributeKey);    String  relUrl  =  attr(attributeKey);  if  (!hasAttr(attributeKey))  {  return   " ";  //  nothing  to  make  absolute  with  }  else  {  URL  base;  try  {  try  {  base  =  new  URL(baseUri);  }  catch  (MalformedURLException  e)  {      URL  abs  =  new  URL(relUrl);  return  abs.toExternalForm();  }  URL  abs  =  new  URL(base,  relUrl);  [BUGGY]  return  abs.toExternalForm();    }  catch  (MalformedURLException  e)  {  return   " ";  }  }        [CLASS]  Node    [METHOD]  absUrl  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  MalformedURLException    e    boolean    Node    parentNode    Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    URL    abs    base    
return  abs.toExternalForm  (  )  ;	[BUGGY]  return  base  .URL(  )  ;  [CONTEXT]  public  String  absUrl(String  attributeKey)  {  Validate.notEmpty(attributeKey);    String  relUrl  =  attr(attributeKey);  if  (!hasAttr(attributeKey))  {  return   " ";  //  nothing  to  make  absolute  with  }  else  {  URL  base;  try  {  try  {  base  =  new  URL(baseUri);  }  catch  (MalformedURLException  e)  {      URL  abs  =  new  URL(relUrl);  [BUGGY]  return  base  .URL  ();  }  URL  abs  =  new  URL(base,  relUrl);  return  abs.toExternalForm();  }  catch  (MalformedURLException  e)  {  return   " ";  }  }  }        [CLASS]  Node    [METHOD]  absUrl  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  MalformedURLException    e    boolean    Node    parentNode    Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    URL    abs    base    
URL  abs  =  new  URL  (  base,  relUrl  )  ;  return  abs.toExternalForm  (  )  ;	[BUGGY]  return  abs.toExternalForm(  );  URL  abs  =  new  URL(  base,  relUrl);  [CONTEXT]        [CLASS]  Node    [METHOD]  absUrl  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  MalformedURLException    e    boolean    Node    parentNode    Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    URL    abs    base    
URL  abs  =  new  URL  (  base,  relUrl  )  ;  return  abs.toExternalForm  (  )  ;	[BUGGY]  URL  abs  =  new  URL(  base,  relUrl);URL  abs  =  new  URL(  base,  relUrl);  return  abs.toExternalForm(  );  [CONTEXT]        [CLASS]  Node    [METHOD]  absUrl  [RETURN_TYPE]  String      String  attributeKey  [VARIABLES]  MalformedURLException    e    boolean    Node    parentNode    Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    URL    abs    base    
return  childNodes.get  (  index  )  ;	[BUGGY]  return  index.get(  childNodes);  [CONTEXT]  public  Node  childNode(int  index)  {  [BUGGY]  return  index.get  (  childNodes  )  ;  }        [CLASS]  Node    [METHOD]  childNode  [RETURN_TYPE]  Node      int  index  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    int    index    Node    parentNode    
return  childNodes.get  (  index  )  ;	[BUGGY]  return  childNodes.remove(  index);  [CONTEXT]  public  Node  childNode(int  index)  {  [BUGGY]  return  childNodes.remove  (  index  )  ;  }        [CLASS]  Node    [METHOD]  childNode  [RETURN_TYPE]  Node      int  index  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    int    index    Node    parentNode    
return  childNodes.get  (  index  )  ;	[BUGGY]  return  childNodes  .put(  baseUri  ,  attributeKey)  ;  [CONTEXT]  public  Node  childNode(int  index)  {  [BUGGY]  return  childNodes  .put  (  baseUri  ,  attributeKey  );  }        [CLASS]  Node    [METHOD]  childNode  [RETURN_TYPE]  Node      int  index  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    int    index    Node    parentNode    
return  childNodes.get  (  index  )  ;	[BUGGY]  return  childNodes  .put(  baseUri  ,  baseUri)  ;  [CONTEXT]  public  Node  childNode(int  index)  {  [BUGGY]  return  childNodes  .put  (  baseUri  ,  baseUri  );  }        [CLASS]  Node    [METHOD]  childNode  [RETURN_TYPE]  Node      int  index  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    int    index    Node    parentNode    
return  childNodes.get  (  index  )  ;	[BUGGY]  return  childNodes  .put(  baseUri  ,  relUrl)  ;  [CONTEXT]  public  Node  childNode(int  index)  {  [BUGGY]  return  childNodes  .put  (  baseUri  ,  relUrl  );  }        [CLASS]  Node    [METHOD]  childNode  [RETURN_TYPE]  Node      int  index  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    int    index    Node    parentNode    
return  childNodes.get  (  index  )  ;	[BUGGY]    [CONTEXT]  public  Node  childNode(int  index)  {  [BUGGY]  return  childNodes.get(index);          [CLASS]  Node    [METHOD]  childNode  [RETURN_TYPE]  Node      int  index  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    int    index    Node    parentNode    
return  Collections.unmodifiableList  (  childNodes  )  ;  }	[BUGGY]    [CONTEXT]  public  List<Node>  childNodes()  {  [BUGGY]  return  Collections.unmodifiableList(childNodes);          [CLASS]  Node    [METHOD]  childNodes  [RETURN_TYPE]  List      [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    parentNode    
Validate.notNull  (  parentNode  )  ;	[BUGGY]    [CONTEXT]  public  void  remove()  {  [BUGGY]  Validate.notNull(parentNode);    parentNode.removeChild(this);        [CLASS]  Node    [METHOD]  remove  [RETURN_TYPE]  void      [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    parentNode    
Validate.notNull  (  parentNode  )  ;	[BUGGY]    Validate.notNull(  parentNode);  [CONTEXT]        [CLASS]  Node    [METHOD]  remove  [RETURN_TYPE]  void      [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    parentNode    
Validate.notNull  (  parentNode  )  ;	[BUGGY]  Validate.notNull(  index);Validate.notNull(  parentNode);  [CONTEXT]        [CLASS]  Node    [METHOD]  remove  [RETURN_TYPE]  void      [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    parentNode    
Validate.notNull  (  parentNode  )  ;	[BUGGY]  Validate.notNull(  baseUri);Validate.notNull(  parentNode);  [CONTEXT]        [CLASS]  Node    [METHOD]  remove  [RETURN_TYPE]  void      [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    parentNode    
Validate.notNull  (  parentNode  )  ;	[BUGGY]  Validate.notNull(  attributeKey);Validate.notNull(  parentNode);  [CONTEXT]        [CLASS]  Node    [METHOD]  remove  [RETURN_TYPE]  void      [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    parentNode    
Validate.notNull  (  parentNode  )  ;	[BUGGY]  Validate.notNull(  search);Validate.notNull(  parentNode);  [CONTEXT]        [CLASS]  Node    [METHOD]  remove  [RETURN_TYPE]  void      [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    parentNode    
Validate.notNull  (  parentNode  )  ;	[BUGGY]  Validate.notNull(  attributes);Validate.notNull(  parentNode);  [CONTEXT]        [CLASS]  Node    [METHOD]  remove  [RETURN_TYPE]  void      [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    parentNode    
Validate.notNull  (  parentNode  )  ;	[BUGGY]  Validate.notNull(  in);Validate.notNull(  parentNode);  [CONTEXT]        [CLASS]  Node    [METHOD]  remove  [RETURN_TYPE]  void      [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    parentNode    
Validate.notNull  (  parentNode  )  ;	[BUGGY]  Validate.notEmpty(  attributeKey);Validate.notNull(  parentNode);  [CONTEXT]        [CLASS]  Node    [METHOD]  remove  [RETURN_TYPE]  void      [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    parentNode    
Validate.notNull  (  parentNode  )  ;	[BUGGY]  Validate.notNull(  nodes);Validate.notNull(  parentNode);  [CONTEXT]        [CLASS]  Node    [METHOD]  remove  [RETURN_TYPE]  void      [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    parentNode    
Validate.notNull  (  parentNode  )  ;	[BUGGY]  Validate.isTrue(  out.parentNode  ==  this);Validate.notNull(  parentNode);  [CONTEXT]        [CLASS]  Node    [METHOD]  remove  [RETURN_TYPE]  void      [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    parentNode    
parentNode.removeChild  (  this  )  ;	[BUGGY]  parentNode.childNodes(  this);  [CONTEXT]  public  void  remove()  {  Validate.notNull(parentNode);  [BUGGY]  parentNode.childNodes  (  this  )  ;  }        [CLASS]  Node    [METHOD]  remove  [RETURN_TYPE]  void      [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    parentNode    
parentNode.removeChild  (  this  )  ;	[BUGGY]  parentNode  .replaceChild(  parentNode  ,  parentNode)  ;  [CONTEXT]  public  void  remove()  {  Validate.notNull(parentNode);  [BUGGY]  parentNode  .replaceChild  (  parentNode  ,  parentNode  );  }        [CLASS]  Node    [METHOD]  remove  [RETURN_TYPE]  void      [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    parentNode    
parentNode.removeChild  (  this  )  ;	[BUGGY]    [CONTEXT]  public  void  remove()  {  Validate.notNull(parentNode);  [BUGGY]  parentNode.removeChild(this);          [CLASS]  Node    [METHOD]  remove  [RETURN_TYPE]  void      [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    parentNode    
Validate.notNull  (  in  )  ;	[BUGGY]  Validate  .notEmpty(  baseUri)  ;  [CONTEXT]  public  void  replaceWith(Node  in)  {  [BUGGY]  Validate  .notEmpty  (  baseUri  );  Validate.notNull(parentNode);  parentNode.replaceChild(this,  in);  }        [CLASS]  Node    [METHOD]  replaceWith  [RETURN_TYPE]  void      Node  in  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    parentNode    
Validate.notNull  (  in  )  ;	[BUGGY]  Validate.notNull(  parentNode);  [CONTEXT]  public  void  replaceWith(Node  in)  {  [BUGGY]  Validate.notNull  (  parentNode  )  ;  Validate.notNull(parentNode);  parentNode.replaceChild(this,  in);  }        [CLASS]  Node    [METHOD]  replaceWith  [RETURN_TYPE]  void      Node  in  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    parentNode    
Validate.notNull  (  in  )  ;  Validate.notNull  (  parentNode  )  ;	[BUGGY]    [CONTEXT]  public  void  replaceWith(Node  in)  {  [BUGGY]  Validate.notNull(in);      parentNode.replaceChild(this,  in);        [CLASS]  Node    [METHOD]  replaceWith  [RETURN_TYPE]  void      Node  in  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    parentNode    
Validate.notNull  (  in  )  ;	[BUGGY]  Validate.notNull(  index);Validate.notNull(  in);  [CONTEXT]        [CLASS]  Node    [METHOD]  replaceWith  [RETURN_TYPE]  void      Node  in  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    parentNode    
Validate.notNull  (  in  )  ;	[BUGGY]  Validate.notNull(  parentNode);Validate.notNull(  in);  [CONTEXT]        [CLASS]  Node    [METHOD]  replaceWith  [RETURN_TYPE]  void      Node  in  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    parentNode    
Validate.notNull  (  in  )  ;	[BUGGY]  Validate.notNull(  baseUri);Validate.notNull(  in);  [CONTEXT]        [CLASS]  Node    [METHOD]  replaceWith  [RETURN_TYPE]  void      Node  in  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    parentNode    
Validate.notNull  (  in  )  ;	[BUGGY]  Validate.notNull(  attributeKey);Validate.notNull(  in);  [CONTEXT]        [CLASS]  Node    [METHOD]  replaceWith  [RETURN_TYPE]  void      Node  in  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    parentNode    
Validate.notNull  (  in  )  ;	[BUGGY]  Validate.notNull(  search);Validate.notNull(  in);  [CONTEXT]        [CLASS]  Node    [METHOD]  replaceWith  [RETURN_TYPE]  void      Node  in  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    parentNode    
Validate.notNull  (  in  )  ;	[BUGGY]  Validate.notNull(  attributes);Validate.notNull(  in);  [CONTEXT]        [CLASS]  Node    [METHOD]  replaceWith  [RETURN_TYPE]  void      Node  in  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    parentNode    
Validate.notNull  (  in  )  ;	[BUGGY]  Validate.notEmpty(  attributeKey);Validate.notNull(  in);  [CONTEXT]        [CLASS]  Node    [METHOD]  replaceWith  [RETURN_TYPE]  void      Node  in  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    parentNode    
Validate.notNull  (  in  )  ;	[BUGGY]  Validate.notNull(  nodes);Validate.notNull(  in);  [CONTEXT]        [CLASS]  Node    [METHOD]  replaceWith  [RETURN_TYPE]  void      Node  in  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    parentNode    
Validate.notNull  (  parentNode  )  ;	[BUGGY]  Validate.notNull(  in);  [CONTEXT]  public  void  replaceWith(Node  in)  {  Validate.notNull(in);  [BUGGY]  Validate.notNull  (  in  )  ;  parentNode.replaceChild(this,  in);  }        [CLASS]  Node    [METHOD]  replaceWith  [RETURN_TYPE]  void      Node  in  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    parentNode    
Validate.notNull  (  parentNode  )  ;  parentNode.replaceChild  (  this,  in  )  ;	[BUGGY]    [CONTEXT]  public  void  replaceWith(Node  in)  {  Validate.notNull(in);  [BUGGY]  Validate.notNull(parentNode);            [CLASS]  Node    [METHOD]  replaceWith  [RETURN_TYPE]  void      Node  in  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    parentNode    
Validate.notNull  (  parentNode  )  ;	[BUGGY]  parentNode.replaceChild(  this,  in);  Validate.notNull(  parentNode);  [CONTEXT]        [CLASS]  Node    [METHOD]  replaceWith  [RETURN_TYPE]  void      Node  in  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    parentNode    
Validate.notNull  (  parentNode  )  ;	[BUGGY]  Validate.notNull(  index);Validate.notNull(  parentNode);  [CONTEXT]        [CLASS]  Node    [METHOD]  replaceWith  [RETURN_TYPE]  void      Node  in  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    parentNode    
Validate.notNull  (  parentNode  )  ;	[BUGGY]  Validate.notNull(  baseUri);Validate.notNull(  parentNode);  [CONTEXT]        [CLASS]  Node    [METHOD]  replaceWith  [RETURN_TYPE]  void      Node  in  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    parentNode    
Validate.notNull  (  parentNode  )  ;	[BUGGY]  Validate.notNull(  attributeKey);Validate.notNull(  parentNode);  [CONTEXT]        [CLASS]  Node    [METHOD]  replaceWith  [RETURN_TYPE]  void      Node  in  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    parentNode    
Validate.notNull  (  parentNode  )  ;	[BUGGY]  Validate.notNull(  search);Validate.notNull(  parentNode);  [CONTEXT]        [CLASS]  Node    [METHOD]  replaceWith  [RETURN_TYPE]  void      Node  in  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    parentNode    
Validate.notNull  (  parentNode  )  ;	[BUGGY]  Validate.notNull(  attributes);Validate.notNull(  parentNode);  [CONTEXT]        [CLASS]  Node    [METHOD]  replaceWith  [RETURN_TYPE]  void      Node  in  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    parentNode    
Validate.notNull  (  parentNode  )  ;	[BUGGY]  Validate.notNull(  in);Validate.notNull(  parentNode);  [CONTEXT]        [CLASS]  Node    [METHOD]  replaceWith  [RETURN_TYPE]  void      Node  in  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    parentNode    
Validate.notNull  (  parentNode  )  ;	[BUGGY]  Validate.notEmpty(  attributeKey);Validate.notNull(  parentNode);  [CONTEXT]        [CLASS]  Node    [METHOD]  replaceWith  [RETURN_TYPE]  void      Node  in  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    parentNode    
Validate.notNull  (  parentNode  )  ;	[BUGGY]  Validate.notNull(  nodes);Validate.notNull(  parentNode);  [CONTEXT]        [CLASS]  Node    [METHOD]  replaceWith  [RETURN_TYPE]  void      Node  in  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    parentNode    
Validate.notNull  (  parentNode  )  ;	[BUGGY]  Validate.isTrue(  out.parentNode  ==  this);Validate.notNull(  parentNode);  [CONTEXT]        [CLASS]  Node    [METHOD]  replaceWith  [RETURN_TYPE]  void      Node  in  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    parentNode    
parentNode.replaceChild  (  this,  in  )  ;	[BUGGY]  parentNode.replaceChild(  this);  [CONTEXT]  public  void  replaceWith(Node  in)  {  Validate.notNull(in);  Validate.notNull(parentNode);  [BUGGY]  parentNode.replaceChild  (  this  )  ;  }        [CLASS]  Node    [METHOD]  replaceWith  [RETURN_TYPE]  void      Node  in  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    parentNode    
parentNode.replaceChild  (  this,  in  )  ;	[BUGGY]  parentNode.removeChild(  this,  in);  [CONTEXT]  public  void  replaceWith(Node  in)  {  Validate.notNull(in);  Validate.notNull(parentNode);  [BUGGY]  parentNode.removeChild  (  this,  in  )  ;  }        [CLASS]  Node    [METHOD]  replaceWith  [RETURN_TYPE]  void      Node  in  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    parentNode    
parentNode.replaceChild  (  this,  in  )  ;	[BUGGY]  parentNode  .removeChild(  in)  ;  [CONTEXT]  public  void  replaceWith(Node  in)  {  Validate.notNull(in);  Validate.notNull(parentNode);  [BUGGY]  parentNode  .removeChild  (  in  );  }        [CLASS]  Node    [METHOD]  replaceWith  [RETURN_TYPE]  void      Node  in  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    parentNode    
parentNode.replaceChild  (  this,  in  )  ;	[BUGGY]    [CONTEXT]  public  void  replaceWith(Node  in)  {  Validate.notNull(in);  Validate.notNull(parentNode);  [BUGGY]  parentNode.replaceChild(this,  in);          [CLASS]  Node    [METHOD]  replaceWith  [RETURN_TYPE]  void      Node  in  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    parentNode    
if  (  this.parentNode  !=  null  )  throw  new  NotImplementedException  ( "   ")  ;	[BUGGY]  if  (  this.parentNode  ==  null)throw  new  NotImplementedException  ( "   ")    ;  [CONTEXT]  protected  void  setParentNode(Node  parentNode)  {  [BUGGY]  if(  this.parentNode  ==  null  )  throw  new  NotImplementedException( "   ");    this.parentNode  =  parentNode;  }        [CLASS]  Node    [METHOD]  setParentNode  [RETURN_TYPE]  void      Node  parentNode  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    parentNode    
if  (  this.parentNode  !=  null  )  throw  new  NotImplementedException  ( "   ")  ;	[BUGGY]  if  (  parentNode  !=  null)throw  new  NotImplementedException  ( "   ")    ;  [CONTEXT]  protected  void  setParentNode(Node  parentNode)  {  [BUGGY]  if(  parentNode  !=  null  )  throw  new  NotImplementedException( "   ");    this.parentNode  =  parentNode;  }        [CLASS]  Node    [METHOD]  setParentNode  [RETURN_TYPE]  void      Node  parentNode  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    parentNode    
if  (  this.parentNode  !=  null  )  throw  new  NotImplementedException  ( "   ")  ;	[BUGGY]  if  (  parentNode  !=  false)throw  new  NotImplementedException  ( "   ")    ;  [CONTEXT]  protected  void  setParentNode(Node  parentNode)  {  [BUGGY]  if(  parentNode  !=  false  )  throw  new  NotImplementedException( "   ");    this.parentNode  =  parentNode;  }        [CLASS]  Node    [METHOD]  setParentNode  [RETURN_TYPE]  void      Node  parentNode  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    parentNode    
if  (  this.parentNode  !=  null  )  throw  new  NotImplementedException  ( "   ")  ;  this.parentNode  =  parentNode;  }	[BUGGY]  throw  new  org.apache.commons.lang.NotImplementedException( "Cannot(yet)  move  nodes  in  tree ");  [CONTEXT]  protected  void  setParentNode(Node  parentNode)  {  [BUGGY]  if  (this.parentNode  !=  null)    throw  new  org.apache.commons.lang.NotImplementedException( "Cannot  (yet)  move  nodes  in  tree ");          [CLASS]  Node    [METHOD]  setParentNode  [RETURN_TYPE]  void      Node  parentNode  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    parentNode    
if  (  this.parentNode  !=  null  )  throw  new  NotImplementedException  ( "   ")  ;  this.parentNode  =  parentNode;  }	[BUGGY]    [CONTEXT]  protected  void  setParentNode(Node  parentNode)  {  [BUGGY]  if  (this.parentNode  !=  null)              [CLASS]  Node    [METHOD]  setParentNode  [RETURN_TYPE]  void      Node  parentNode  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    parentNode    
this.parentNode  =  parentNode;	[BUGGY]  this.parentNode  =  in;  [CONTEXT]  protected  void  setParentNode(Node  parentNode)  {  if  (this.parentNode  !=  null)  throw  new  NotImplementedException( "Cannot  (yet)  move  nodes  in  tree ");  //  TODO:  remove  from  prev  node  children  [BUGGY]  this.parentNode  =  in;  }        [CLASS]  Node    [METHOD]  setParentNode  [RETURN_TYPE]  void      Node  parentNode  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    parentNode    
Validate.isTrue  (  out.parentNode  ==  this  )  ;	[BUGGY]  Validate.isTrue(  out.parentNode  !=  this);  [CONTEXT]  protected  void  replaceChild(Node  out,  Node  in)  {  [BUGGY]  Validate.isTrue  (  out.parentNode  !=  this  )  ;  Validate.notNull(in);  if  (in.parentNode  !=  null)  in.parentNode.removeChild(in);    Integer  index  =  indexInList(out,  childNodes);  childNodes.set(index,  in);  in.parentNode  =  this;  out.parentNode  =  null;  }        [CLASS]  Node    [METHOD]  replaceChild  [RETURN_TYPE]  void      Node  out  Node  in  [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
Validate.isTrue  (  out.parentNode  ==  this  )  ;	[BUGGY]  Validate.isTrue(  parentNode.parentNode  ==  this);  [CONTEXT]  protected  void  replaceChild(Node  out,  Node  in)  {  [BUGGY]  Validate.isTrue  (  parentNode.parentNode  ==  this  )  ;  Validate.notNull(in);  if  (in.parentNode  !=  null)  in.parentNode.removeChild(in);    Integer  index  =  indexInList(out,  childNodes);  childNodes.set(index,  in);  in.parentNode  =  this;  out.parentNode  =  null;  }        [CLASS]  Node    [METHOD]  replaceChild  [RETURN_TYPE]  void      Node  out  Node  in  [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
Validate.isTrue  (  out.parentNode  ==  this  )  ;	[BUGGY]  Validate.isTrue(  parentNode  ==  this);  [CONTEXT]  protected  void  replaceChild(Node  out,  Node  in)  {  [BUGGY]  Validate.isTrue  (  parentNode  ==  this  )  ;  Validate.notNull(in);  if  (in.parentNode  !=  null)  in.parentNode.removeChild(in);    Integer  index  =  indexInList(out,  childNodes);  childNodes.set(index,  in);  in.parentNode  =  this;  out.parentNode  =  null;  }        [CLASS]  Node    [METHOD]  replaceChild  [RETURN_TYPE]  void      Node  out  Node  in  [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
Validate.isTrue  (  out.parentNode  ==  this  )  ;	[BUGGY]  Validate.isTrue(  out.parentNode.parentNode  ==  this);  [CONTEXT]  protected  void  replaceChild(Node  out,  Node  in)  {  [BUGGY]  Validate.isTrue  (  out.parentNode.parentNode  ==  this  )  ;  Validate.notNull(in);  if  (in.parentNode  !=  null)  in.parentNode.removeChild(in);    Integer  index  =  indexInList(out,  childNodes);  childNodes.set(index,  in);  in.parentNode  =  this;  out.parentNode  =  null;  }        [CLASS]  Node    [METHOD]  replaceChild  [RETURN_TYPE]  void      Node  out  Node  in  [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
Validate.isTrue  (  out.parentNode  ==  this  )  ;	[BUGGY]  Validate.isTrue(  out  ==  this);  [CONTEXT]  protected  void  replaceChild(Node  out,  Node  in)  {  [BUGGY]  Validate.isTrue  (  out  ==  this  )  ;  Validate.notNull(in);  if  (in.parentNode  !=  null)  in.parentNode.removeChild(in);    Integer  index  =  indexInList(out,  childNodes);  childNodes.set(index,  in);  in.parentNode  =  this;  out.parentNode  =  null;  }        [CLASS]  Node    [METHOD]  replaceChild  [RETURN_TYPE]  void      Node  out  Node  in  [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
Validate.isTrue  (  out.parentNode  ==  this  )  ;	[BUGGY]  Validate.notNull(  out.parentNode  ==  this);  [CONTEXT]  protected  void  replaceChild(Node  out,  Node  in)  {  [BUGGY]  Validate.notNull  (  out.parentNode  ==  this  )  ;  Validate.notNull(in);  if  (in.parentNode  !=  null)  in.parentNode.removeChild(in);    Integer  index  =  indexInList(out,  childNodes);  childNodes.set(index,  in);  in.parentNode  =  this;  out.parentNode  =  null;  }        [CLASS]  Node    [METHOD]  replaceChild  [RETURN_TYPE]  void      Node  out  Node  in  [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
Validate.isTrue  (  out.parentNode  ==  this  )  ;	[BUGGY]  Validate  .notNull(  attributeValue)  ;  [CONTEXT]  protected  void  replaceChild(Node  out,  Node  in)  {  [BUGGY]  Validate  .notNull  (  attributeValue  );  Validate.notNull(in);  if  (in.parentNode  !=  null)  in.parentNode.removeChild(in);    Integer  index  =  indexInList(out,  childNodes);  childNodes.set(index,  in);  in.parentNode  =  this;  out.parentNode  =  null;  }        [CLASS]  Node    [METHOD]  replaceChild  [RETURN_TYPE]  void      Node  out  Node  in  [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
Validate.isTrue  (  out.parentNode  ==  this  )  ;  Validate.notNull  (  in  )  ;	[BUGGY]    [CONTEXT]  protected  void  replaceChild(Node  out,  Node  in)  {  [BUGGY]  Validate.isTrue(out.parentNode  ==  this);      if  (in.parentNode  !=  null)  in.parentNode.removeChild(in);    Integer  index  =  indexInList(out,  childNodes);  childNodes.set(index,  in);  in.parentNode  =  this;  out.parentNode  =  null;        [CLASS]  Node    [METHOD]  replaceChild  [RETURN_TYPE]  void      Node  out  Node  in  [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
Validate.isTrue  (  out.parentNode  ==  this  )  ;	[BUGGY]  if  (  in.parentNode  !=  null)Validate.isTrue(  out.parentNode  ==  this);  [CONTEXT]        [CLASS]  Node    [METHOD]  replaceChild  [RETURN_TYPE]  void      Node  out  Node  in  [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
Validate.isTrue  (  out.parentNode  ==  this  )  ;	[BUGGY]  Validate.notNull(  parentNode);Validate.isTrue(  out.parentNode  ==  this);  [CONTEXT]        [CLASS]  Node    [METHOD]  replaceChild  [RETURN_TYPE]  void      Node  out  Node  in  [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
Validate.notNull  (  in  )  ;	[BUGGY]    [CONTEXT]  protected  void  replaceChild(Node  out,  Node  in)  {  Validate.isTrue(out.parentNode  ==  this);  [BUGGY]  Validate.notNull(in);    if  (in.parentNode  !=  null)  in.parentNode.removeChild(in);    Integer  index  =  indexInList(out,  childNodes);  childNodes.set(index,  in);  in.parentNode  =  this;  out.parentNode  =  null;        [CLASS]  Node    [METHOD]  replaceChild  [RETURN_TYPE]  void      Node  out  Node  in  [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
if  (  in.parentNode  !=  null  )  in.parentNode.removeChild  (  in  )  ;	[BUGGY]  if  (  in.parentNode  ==  null)in.parentNode.removeChild(  in);  [CONTEXT]  protected  void  replaceChild(Node  out,  Node  in)  {  Validate.isTrue(out.parentNode  ==  this);  Validate.notNull(in);  [BUGGY]  if(  in.parentNode  ==  null  )  in.parentNode.removeChild  (  in  )  ;      Integer  index  =  indexInList(out,  childNodes);  childNodes.set(index,  in);  in.parentNode  =  this;  out.parentNode  =  null;  }        [CLASS]  Node    [METHOD]  replaceChild  [RETURN_TYPE]  void      Node  out  Node  in  [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
if  (  in.parentNode  !=  null  )  in.parentNode.removeChild  (  in  )  ;	[BUGGY]  if  (  parentNode.parentNode  !=  null)in.parentNode.removeChild(  in);  [CONTEXT]  protected  void  replaceChild(Node  out,  Node  in)  {  Validate.isTrue(out.parentNode  ==  this);  Validate.notNull(in);  [BUGGY]  if(  parentNode.parentNode  !=  null  )  in.parentNode.removeChild  (  in  )  ;      Integer  index  =  indexInList(out,  childNodes);  childNodes.set(index,  in);  in.parentNode  =  this;  out.parentNode  =  null;  }        [CLASS]  Node    [METHOD]  replaceChild  [RETURN_TYPE]  void      Node  out  Node  in  [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
if  (  in.parentNode  !=  null  )  in.parentNode.removeChild  (  in  )  ;	[BUGGY]  if  (  parentNode  !=  null)in.parentNode.removeChild(  in);  [CONTEXT]  protected  void  replaceChild(Node  out,  Node  in)  {  Validate.isTrue(out.parentNode  ==  this);  Validate.notNull(in);  [BUGGY]  if(  parentNode  !=  null  )  in.parentNode.removeChild  (  in  )  ;      Integer  index  =  indexInList(out,  childNodes);  childNodes.set(index,  in);  in.parentNode  =  this;  out.parentNode  =  null;  }        [CLASS]  Node    [METHOD]  replaceChild  [RETURN_TYPE]  void      Node  out  Node  in  [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
if  (  in.parentNode  !=  null  )  in.parentNode.removeChild  (  in  )  ;	[BUGGY]  if  (  in.parentNode.parentNode  !=  null)in.removeChild(  in);  [CONTEXT]  protected  void  replaceChild(Node  out,  Node  in)  {  Validate.isTrue(out.parentNode  ==  this);  Validate.notNull(in);  [BUGGY]  if(  in.parentNode.parentNode  !=  null  )  in.removeChild  (  in  )  ;      Integer  index  =  indexInList(out,  childNodes);  childNodes.set(index,  in);  in.parentNode  =  this;  out.parentNode  =  null;  }        [CLASS]  Node    [METHOD]  replaceChild  [RETURN_TYPE]  void      Node  out  Node  in  [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
if  (  in.parentNode  !=  null  )  in.parentNode.removeChild  (  in  )  ;	[BUGGY]  if  (  in  !=  null)in.parentNode.parentNode.removeChild(  in);  [CONTEXT]  protected  void  replaceChild(Node  out,  Node  in)  {  Validate.isTrue(out.parentNode  ==  this);  Validate.notNull(in);  [BUGGY]  if(  in  !=  null  )  in.parentNode.parentNode.removeChild  (  in  )  ;      Integer  index  =  indexInList(out,  childNodes);  childNodes.set(index,  in);  in.parentNode  =  this;  out.parentNode  =  null;  }        [CLASS]  Node    [METHOD]  replaceChild  [RETURN_TYPE]  void      Node  out  Node  in  [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
if  (  in.parentNode  !=  null  )  in.parentNode.removeChild  (  in  )  ;	[BUGGY]  if  (  in.parentNode  !=  null)in.parentNode.replaceChild(  in);  [CONTEXT]  protected  void  replaceChild(Node  out,  Node  in)  {  Validate.isTrue(out.parentNode  ==  this);  Validate.notNull(in);  [BUGGY]  if(  in.parentNode  !=  null  )  in.parentNode.replaceChild  (  in  )  ;      Integer  index  =  indexInList(out,  childNodes);  childNodes.set(index,  in);  in.parentNode  =  this;  out.parentNode  =  null;  }        [CLASS]  Node    [METHOD]  replaceChild  [RETURN_TYPE]  void      Node  out  Node  in  [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
if  (  in.parentNode  !=  null  )  in.parentNode.removeChild  (  in  )  ;	[BUGGY]  if  (  in.parentNode  !=  null)in.parentNode  .replaceChild(  in  ,  parentNode)  ;  [CONTEXT]  protected  void  replaceChild(Node  out,  Node  in)  {  Validate.isTrue(out.parentNode  ==  this);  Validate.notNull(in);  [BUGGY]  if(  in.parentNode  !=  null  )  in.parentNode  .replaceChild  (  in  ,  parentNode  );      Integer  index  =  indexInList(out,  childNodes);  childNodes.set(index,  in);  in.parentNode  =  this;  out.parentNode  =  null;  }        [CLASS]  Node    [METHOD]  replaceChild  [RETURN_TYPE]  void      Node  out  Node  in  [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
if  (  in.parentNode  !=  null  )  in.parentNode.removeChild  (  in  )  ;	[BUGGY]  if  (  in.parentNode  !=  false)in.parentNode.removeChild(  in);  [CONTEXT]  protected  void  replaceChild(Node  out,  Node  in)  {  Validate.isTrue(out.parentNode  ==  this);  Validate.notNull(in);  [BUGGY]  if(  in.parentNode  !=  false  )  in.parentNode.removeChild  (  in  )  ;      Integer  index  =  indexInList(out,  childNodes);  childNodes.set(index,  in);  in.parentNode  =  this;  out.parentNode  =  null;  }        [CLASS]  Node    [METHOD]  replaceChild  [RETURN_TYPE]  void      Node  out  Node  in  [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
in.parentNode.removeChild  (  in  )  ;	[BUGGY]  in.parentNode.removeChild(  parentNode);  [CONTEXT]  protected  void  replaceChild(Node  out,  Node  in)  {  Validate.isTrue(out.parentNode  ==  this);  Validate.notNull(in);  if  (in.parentNode  !=  null)  [BUGGY]  in.parentNode.removeChild  (  parentNode  )  ;    Integer  index  =  indexInList(out,  childNodes);  childNodes.set(index,  in);  in.parentNode  =  this;  out.parentNode  =  null;  }        [CLASS]  Node    [METHOD]  replaceChild  [RETURN_TYPE]  void      Node  out  Node  in  [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
in.parentNode.removeChild  (  in  )  ;	[BUGGY]  in.parentNode.replaceChild(  in);  [CONTEXT]  protected  void  replaceChild(Node  out,  Node  in)  {  Validate.isTrue(out.parentNode  ==  this);  Validate.notNull(in);  if  (in.parentNode  !=  null)  [BUGGY]  in.parentNode.replaceChild  (  in  )  ;    Integer  index  =  indexInList(out,  childNodes);  childNodes.set(index,  in);  in.parentNode  =  this;  out.parentNode  =  null;  }        [CLASS]  Node    [METHOD]  replaceChild  [RETURN_TYPE]  void      Node  out  Node  in  [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
in.parentNode.removeChild  (  in  )  ;	[BUGGY]  in.parentNode  .replaceChild(  out  ,  in)  ;  [CONTEXT]  protected  void  replaceChild(Node  out,  Node  in)  {  Validate.isTrue(out.parentNode  ==  this);  Validate.notNull(in);  if  (in.parentNode  !=  null)  [BUGGY]  in.parentNode  .replaceChild  (  out  ,  in  );    Integer  index  =  indexInList(out,  childNodes);  childNodes.set(index,  in);  in.parentNode  =  this;  out.parentNode  =  null;  }        [CLASS]  Node    [METHOD]  replaceChild  [RETURN_TYPE]  void      Node  out  Node  in  [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
in.parentNode.removeChild  (  in  )  ;	[BUGGY]  in.parentNode.replaceChild(  parentNode);  [CONTEXT]  protected  void  replaceChild(Node  out,  Node  in)  {  Validate.isTrue(out.parentNode  ==  this);  Validate.notNull(in);  if  (in.parentNode  !=  null)  [BUGGY]  in.parentNode.replaceChild  (  parentNode  )  ;    Integer  index  =  indexInList(out,  childNodes);  childNodes.set(index,  in);  in.parentNode  =  this;  out.parentNode  =  null;  }        [CLASS]  Node    [METHOD]  replaceChild  [RETURN_TYPE]  void      Node  out  Node  in  [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
in.parentNode.removeChild  (  in  )  ;	[BUGGY]    [CONTEXT]  protected  void  replaceChild(Node  out,  Node  in)  {  Validate.isTrue(out.parentNode  ==  this);  Validate.notNull(in);  if  (in.parentNode  !=  null)  [BUGGY]  in.parentNode.removeChild(in);      Integer  index  =  indexInList(out,  childNodes);  childNodes.set(index,  in);  in.parentNode  =  this;  out.parentNode  =  null;        [CLASS]  Node    [METHOD]  replaceChild  [RETURN_TYPE]  void      Node  out  Node  in  [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
Integer  index  =  indexInList  (  out,  childNodes  )  ;	[BUGGY]  Integer  index  =  indexInList(  parentNode,  childNodes);  [CONTEXT]  protected  void  replaceChild(Node  out,  Node  in)  {  Validate.isTrue(out.parentNode  ==  this);  Validate.notNull(in);  if  (in.parentNode  !=  null)  in.parentNode.removeChild(in);    [BUGGY]  Integer  index  =  indexInList  (  parentNode,  childNodes  )  ;  childNodes.set(index,  in);  in.parentNode  =  this;  out.parentNode  =  null;  }        [CLASS]  Node    [METHOD]  replaceChild  [RETURN_TYPE]  void      Node  out  Node  in  [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
Integer  index  =  indexInList  (  out,  childNodes  )  ;	[BUGGY]  Integer  index  =  indexInList(  childNodes,  out);  [CONTEXT]  protected  void  replaceChild(Node  out,  Node  in)  {  Validate.isTrue(out.parentNode  ==  this);  Validate.notNull(in);  if  (in.parentNode  !=  null)  in.parentNode.removeChild(in);    [BUGGY]  Integer  index  =  indexInList  (  childNodes,  out  )  ;  childNodes.set(index,  in);  in.parentNode  =  this;  out.parentNode  =  null;  }        [CLASS]  Node    [METHOD]  replaceChild  [RETURN_TYPE]  void      Node  out  Node  in  [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
Integer  index  =  indexInList  (  out,  childNodes  )  ;	[BUGGY]  Integer  index  =  indexInList(    childNodes);  [CONTEXT]  protected  void  replaceChild(Node  out,  Node  in)  {  Validate.isTrue(out.parentNode  ==  this);  Validate.notNull(in);  if  (in.parentNode  !=  null)  in.parentNode.removeChild(in);    [BUGGY]  Integer  index  =  indexInList  (childNodes  )  ;  childNodes.set(index,  in);  in.parentNode  =  this;  out.parentNode  =  null;  }        [CLASS]  Node    [METHOD]  replaceChild  [RETURN_TYPE]  void      Node  out  Node  in  [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
Integer  index  =  indexInList  (  out,  childNodes  )  ;	[BUGGY]  Integer  index  =  indexInList(  out);  [CONTEXT]  protected  void  replaceChild(Node  out,  Node  in)  {  Validate.isTrue(out.parentNode  ==  this);  Validate.notNull(in);  if  (in.parentNode  !=  null)  in.parentNode.removeChild(in);    [BUGGY]  Integer  index  =  indexInList  (  out  )  ;  childNodes.set(index,  in);  in.parentNode  =  this;  out.parentNode  =  null;  }        [CLASS]  Node    [METHOD]  replaceChild  [RETURN_TYPE]  void      Node  out  Node  in  [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
Integer  index  =  indexInList  (  out,  childNodes  )  ;	[BUGGY]  Integer  index  =  indent(  out,  childNodes);  [CONTEXT]  protected  void  replaceChild(Node  out,  Node  in)  {  Validate.isTrue(out.parentNode  ==  this);  Validate.notNull(in);  if  (in.parentNode  !=  null)  in.parentNode.removeChild(in);    [BUGGY]  Integer  index  =  indent  (  out,  childNodes  )  ;  childNodes.set(index,  in);  in.parentNode  =  this;  out.parentNode  =  null;  }        [CLASS]  Node    [METHOD]  replaceChild  [RETURN_TYPE]  void      Node  out  Node  in  [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
Integer  index  =  indexInList  (  out,  childNodes  )  ;	[BUGGY]  Integer  index  =  indent(  parentNode,  childNodes);  [CONTEXT]  protected  void  replaceChild(Node  out,  Node  in)  {  Validate.isTrue(out.parentNode  ==  this);  Validate.notNull(in);  if  (in.parentNode  !=  null)  in.parentNode.removeChild(in);    [BUGGY]  Integer  index  =  indent  (  parentNode,  childNodes  )  ;  childNodes.set(index,  in);  in.parentNode  =  this;  out.parentNode  =  null;  }        [CLASS]  Node    [METHOD]  replaceChild  [RETURN_TYPE]  void      Node  out  Node  in  [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
Integer  index  =  indexInList  (  out,  childNodes  )  ;  childNodes.set  (  index,  in  )  ;	[BUGGY]  childNodes.set(  index,  in);  Integer  index  =  indexInList(  out,  childNodes);  [CONTEXT]        [CLASS]  Node    [METHOD]  replaceChild  [RETURN_TYPE]  void      Node  out  Node  in  [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
Integer  index  =  indexInList  (  out,  childNodes  )  ;  childNodes.set  (  index,  in  )  ;	[BUGGY]  Integer  index  =  indexInList(  this,  siblings);Integer  index  =  indexInList(  out,  childNodes);  childNodes.set(  index,  in);  [CONTEXT]        [CLASS]  Node    [METHOD]  replaceChild  [RETURN_TYPE]  void      Node  out  Node  in  [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
Integer  index  =  indexInList  (  out,  childNodes  )  ;  childNodes.set  (  index,  in  )  ;	[BUGGY]  Integer  index  =  indexInList(  out,  childNodes);Integer  index  =  indexInList(  out,  childNodes);  childNodes.set(  index,  in);  [CONTEXT]        [CLASS]  Node    [METHOD]  replaceChild  [RETURN_TYPE]  void      Node  out  Node  in  [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
Integer  index  =  indexInList  (  out,  childNodes  )  ;  childNodes.set  (  index,  in  )  ;	[BUGGY]  int  index  =  indexInList(  out,  childNodes);Integer  index  =  indexInList(  out,  childNodes);  childNodes.set(  index,  in);  [CONTEXT]        [CLASS]  Node    [METHOD]  replaceChild  [RETURN_TYPE]  void      Node  out  Node  in  [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
Integer  index  =  indexInList  (  out,  childNodes  )  ;  childNodes.set  (  index,  in  )  ;	[BUGGY]    [CONTEXT]  protected  void  replaceChild(Node  out,  Node  in)  {  Validate.isTrue(out.parentNode  ==  this);  Validate.notNull(in);  if  (in.parentNode  !=  null)  in.parentNode.removeChild(in);    [BUGGY]  Integer  index  =  indexInList(out,  childNodes);      in.parentNode  =  this;  out.parentNode  =  null;        [CLASS]  Node    [METHOD]  replaceChild  [RETURN_TYPE]  void      Node  out  Node  in  [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
Integer  index  =  indexInList  (  out,  childNodes  )  ;	[BUGGY]  Integer  index  =  indexInList(  this,  siblings);Integer  index  =  indexInList(  out,  childNodes);  [CONTEXT]        [CLASS]  Node    [METHOD]  replaceChild  [RETURN_TYPE]  void      Node  out  Node  in  [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
Integer  index  =  indexInList  (  out,  childNodes  )  ;	[BUGGY]  int  index  =  indexInList(  out,  childNodes);Integer  index  =  indexInList(  out,  childNodes);  [CONTEXT]        [CLASS]  Node    [METHOD]  replaceChild  [RETURN_TYPE]  void      Node  out  Node  in  [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
childNodes.set  (  index,  in  )  ;	[BUGGY]  childNodes.set(  parentNodedex,  in);  [CONTEXT]  protected  void  replaceChild(Node  out,  Node  in)  {  Validate.isTrue(out.parentNode  ==  this);  Validate.notNull(in);  if  (in.parentNode  !=  null)  in.parentNode.removeChild(in);    Integer  index  =  indexInList(out,  childNodes);  [BUGGY]  childNodes.set  (  parentNodedex,  in  )  ;  in.parentNode  =  this;  out.parentNode  =  null;  }        [CLASS]  Node    [METHOD]  replaceChild  [RETURN_TYPE]  void      Node  out  Node  in  [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
childNodes.set  (  index,  in  )  ;	[BUGGY]  childNodes.set(  in,  index);  [CONTEXT]  protected  void  replaceChild(Node  out,  Node  in)  {  Validate.isTrue(out.parentNode  ==  this);  Validate.notNull(in);  if  (in.parentNode  !=  null)  in.parentNode.removeChild(in);    Integer  index  =  indexInList(out,  childNodes);  [BUGGY]  childNodes.set  (  in,  index  )  ;  in.parentNode  =  this;  out.parentNode  =  null;  }        [CLASS]  Node    [METHOD]  replaceChild  [RETURN_TYPE]  void      Node  out  Node  in  [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
childNodes.set  (  index,  in  )  ;	[BUGGY]  childNodes.set(    in);  [CONTEXT]  protected  void  replaceChild(Node  out,  Node  in)  {  Validate.isTrue(out.parentNode  ==  this);  Validate.notNull(in);  if  (in.parentNode  !=  null)  in.parentNode.removeChild(in);    Integer  index  =  indexInList(out,  childNodes);  [BUGGY]  childNodes.set  (in  )  ;  in.parentNode  =  this;  out.parentNode  =  null;  }        [CLASS]  Node    [METHOD]  replaceChild  [RETURN_TYPE]  void      Node  out  Node  in  [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
childNodes.set  (  index,  in  )  ;	[BUGGY]  childNodes.set(  index);  [CONTEXT]  protected  void  replaceChild(Node  out,  Node  in)  {  Validate.isTrue(out.parentNode  ==  this);  Validate.notNull(in);  if  (in.parentNode  !=  null)  in.parentNode.removeChild(in);    Integer  index  =  indexInList(out,  childNodes);  [BUGGY]  childNodes.set  (  index  )  ;  in.parentNode  =  this;  out.parentNode  =  null;  }        [CLASS]  Node    [METHOD]  replaceChild  [RETURN_TYPE]  void      Node  out  Node  in  [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
childNodes.set  (  index,  in  )  ;	[BUGGY]    [CONTEXT]  protected  void  replaceChild(Node  out,  Node  in)  {  Validate.isTrue(out.parentNode  ==  this);  Validate.notNull(in);  if  (in.parentNode  !=  null)  in.parentNode.removeChild(in);    Integer  index  =  indexInList(out,  childNodes);  [BUGGY]  childNodes.set(index,  in);    in.parentNode  =  this;  out.parentNode  =  null;        [CLASS]  Node    [METHOD]  replaceChild  [RETURN_TYPE]  void      Node  out  Node  in  [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
childNodes.set  (  index,  in  )  ;	[BUGGY]  childNodes.add(  in);childNodes.set(  index,  in);  [CONTEXT]        [CLASS]  Node    [METHOD]  replaceChild  [RETURN_TYPE]  void      Node  out  Node  in  [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
childNodes.set  (  index,  in  )  ;	[BUGGY]  childNodes.remove(  index);childNodes.set(  index,  in);  [CONTEXT]        [CLASS]  Node    [METHOD]  replaceChild  [RETURN_TYPE]  void      Node  out  Node  in  [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
childNodes.set  (  index,  in  )  ;	[BUGGY]  return  childNodes.get(  index);childNodes.set(  index,  in);  [CONTEXT]        [CLASS]  Node    [METHOD]  replaceChild  [RETURN_TYPE]  void      Node  out  Node  in  [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
in.parentNode  =  this;	[BUGGY]  in.parentNode  =    this;  [CONTEXT]  protected  void  replaceChild(Node  out,  Node  in)  {  Validate.isTrue(out.parentNode  ==  this);  Validate.notNull(in);  if  (in.parentNode  !=  null)  in.parentNode.removeChild(in);    Integer  index  =  indexInList(out,  childNodes);  childNodes.set(index,  in);  [BUGGY]  in.parentNode  =this;  out.parentNode  =  null;  }        [CLASS]  Node    [METHOD]  replaceChild  [RETURN_TYPE]  void      Node  out  Node  in  [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
in.parentNode  =  this;	[BUGGY]    in.parentNode  =  this;  [CONTEXT]        [CLASS]  Node    [METHOD]  replaceChild  [RETURN_TYPE]  void      Node  out  Node  in  [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
in.parentNode  =  this;	[BUGGY]  out.parentNode  =  null;in.parentNode  =  this;  [CONTEXT]        [CLASS]  Node    [METHOD]  replaceChild  [RETURN_TYPE]  void      Node  out  Node  in  [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
in.parentNode  =  this;	[BUGGY]  this.parentNode  =  parentNode;in.parentNode  =  this;  [CONTEXT]        [CLASS]  Node    [METHOD]  replaceChild  [RETURN_TYPE]  void      Node  out  Node  in  [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
out.parentNode  =  null;	[BUGGY]  out.parentNode  =  this;  [CONTEXT]  protected  void  replaceChild(Node  out,  Node  in)  {  Validate.isTrue(out.parentNode  ==  this);  Validate.notNull(in);  if  (in.parentNode  !=  null)  in.parentNode.removeChild(in);    Integer  index  =  indexInList(out,  childNodes);  childNodes.set(index,  in);  in.parentNode  =  this;  [BUGGY]  out.parentNode  =  this;  }        [CLASS]  Node    [METHOD]  replaceChild  [RETURN_TYPE]  void      Node  out  Node  in  [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
Validate.isTrue  (  out.parentNode  ==  this  )  ;	[BUGGY]  Validate.isTrue(  out.parentNode  <  this);  [CONTEXT]  protected  void  removeChild(Node  out)  {  [BUGGY]  Validate.isTrue  (  out.parentNode  <  this  )  ;  int  index  =  indexInList(out,  childNodes);  childNodes.remove(index);  out.parentNode  =  null;  }        [CLASS]  Node    [METHOD]  removeChild  [RETURN_TYPE]  void      Node  out  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    int    index    Node    in    out    parentNode    
Validate.isTrue  (  out.parentNode  ==  this  )  ;	[BUGGY]  Validate.isTrue(  parentNode.parentNode  ==  this);  [CONTEXT]  protected  void  removeChild(Node  out)  {  [BUGGY]  Validate.isTrue  (  parentNode.parentNode  ==  this  )  ;  int  index  =  indexInList(out,  childNodes);  childNodes.remove(index);  out.parentNode  =  null;  }        [CLASS]  Node    [METHOD]  removeChild  [RETURN_TYPE]  void      Node  out  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    int    index    Node    in    out    parentNode    
Validate.isTrue  (  out.parentNode  ==  this  )  ;	[BUGGY]  Validate.isTrue(  parentNode  ==  this);  [CONTEXT]  protected  void  removeChild(Node  out)  {  [BUGGY]  Validate.isTrue  (  parentNode  ==  this  )  ;  int  index  =  indexInList(out,  childNodes);  childNodes.remove(index);  out.parentNode  =  null;  }        [CLASS]  Node    [METHOD]  removeChild  [RETURN_TYPE]  void      Node  out  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    int    index    Node    in    out    parentNode    
Validate.isTrue  (  out.parentNode  ==  this  )  ;	[BUGGY]  Validate.isTrue(  out.parentNode.parentNode  ==  this);  [CONTEXT]  protected  void  removeChild(Node  out)  {  [BUGGY]  Validate.isTrue  (  out.parentNode.parentNode  ==  this  )  ;  int  index  =  indexInList(out,  childNodes);  childNodes.remove(index);  out.parentNode  =  null;  }        [CLASS]  Node    [METHOD]  removeChild  [RETURN_TYPE]  void      Node  out  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    int    index    Node    in    out    parentNode    
Validate.isTrue  (  out.parentNode  ==  this  )  ;	[BUGGY]  Validate.isTrue(  out  ==  this);  [CONTEXT]  protected  void  removeChild(Node  out)  {  [BUGGY]  Validate.isTrue  (  out  ==  this  )  ;  int  index  =  indexInList(out,  childNodes);  childNodes.remove(index);  out.parentNode  =  null;  }        [CLASS]  Node    [METHOD]  removeChild  [RETURN_TYPE]  void      Node  out  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    int    index    Node    in    out    parentNode    
Validate.isTrue  (  out.parentNode  ==  this  )  ;	[BUGGY]  Validate.notNull(  out.parentNode  ==  this);  [CONTEXT]  protected  void  removeChild(Node  out)  {  [BUGGY]  Validate.notNull  (  out.parentNode  ==  this  )  ;  int  index  =  indexInList(out,  childNodes);  childNodes.remove(index);  out.parentNode  =  null;  }        [CLASS]  Node    [METHOD]  removeChild  [RETURN_TYPE]  void      Node  out  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    int    index    Node    in    out    parentNode    
Validate.isTrue  (  out.parentNode  ==  this  )  ;	[BUGGY]    [CONTEXT]  protected  void  removeChild(Node  out)  {  [BUGGY]  Validate.isTrue(out.parentNode  ==  this);    int  index  =  indexInList(out,  childNodes);  childNodes.remove(index);  out.parentNode  =  null;        [CLASS]  Node    [METHOD]  removeChild  [RETURN_TYPE]  void      Node  out  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    int    index    Node    in    out    parentNode    
Validate.isTrue  (  out.parentNode  ==  this  )  ;	[BUGGY]  Validate.notNull(  parentNode);Validate.isTrue(  out.parentNode  ==  this);  [CONTEXT]        [CLASS]  Node    [METHOD]  removeChild  [RETURN_TYPE]  void      Node  out  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    int    index    Node    in    out    parentNode    
int  index  =  indexInList  (  out,  childNodes  )  ;	[BUGGY]  short    index  =  indexInList(  out,  childNodes);  [CONTEXT]  protected  void  removeChild(Node  out)  {  Validate.isTrue(out.parentNode  ==  this);  [BUGGY]  shortindex  =  indexInList  (  out,  childNodes  )  ;  childNodes.remove(index);  out.parentNode  =  null;  }        [CLASS]  Node    [METHOD]  removeChild  [RETURN_TYPE]  void      Node  out  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    int    index    Node    in    out    parentNode    
int  index  =  indexInList  (  out,  childNodes  )  ;	[BUGGY]  int  index  =  indexInList(  parentNode,  childNodes);  [CONTEXT]  protected  void  removeChild(Node  out)  {  Validate.isTrue(out.parentNode  ==  this);  [BUGGY]  int  index  =  indexInList  (  parentNode,  childNodes  )  ;  childNodes.remove(index);  out.parentNode  =  null;  }        [CLASS]  Node    [METHOD]  removeChild  [RETURN_TYPE]  void      Node  out  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    int    index    Node    in    out    parentNode    
int  index  =  indexInList  (  out,  childNodes  )  ;	[BUGGY]  int  index  =  indexInList(  childNodes,  out);  [CONTEXT]  protected  void  removeChild(Node  out)  {  Validate.isTrue(out.parentNode  ==  this);  [BUGGY]  int  index  =  indexInList  (  childNodes,  out  )  ;  childNodes.remove(index);  out.parentNode  =  null;  }        [CLASS]  Node    [METHOD]  removeChild  [RETURN_TYPE]  void      Node  out  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    int    index    Node    in    out    parentNode    
int  index  =  indexInList  (  out,  childNodes  )  ;	[BUGGY]  int  index  =  indexInList(    childNodes);  [CONTEXT]  protected  void  removeChild(Node  out)  {  Validate.isTrue(out.parentNode  ==  this);  [BUGGY]  int  index  =  indexInList  (childNodes  )  ;  childNodes.remove(index);  out.parentNode  =  null;  }        [CLASS]  Node    [METHOD]  removeChild  [RETURN_TYPE]  void      Node  out  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    int    index    Node    in    out    parentNode    
int  index  =  indexInList  (  out,  childNodes  )  ;	[BUGGY]  int  index  =  indexInList(  out);  [CONTEXT]  protected  void  removeChild(Node  out)  {  Validate.isTrue(out.parentNode  ==  this);  [BUGGY]  int  index  =  indexInList  (  out  )  ;  childNodes.remove(index);  out.parentNode  =  null;  }        [CLASS]  Node    [METHOD]  removeChild  [RETURN_TYPE]  void      Node  out  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    int    index    Node    in    out    parentNode    
int  index  =  indexInList  (  out,  childNodes  )  ;	[BUGGY]  int  index  =  indent(  out,  childNodes);  [CONTEXT]  protected  void  removeChild(Node  out)  {  Validate.isTrue(out.parentNode  ==  this);  [BUGGY]  int  index  =  indent  (  out,  childNodes  )  ;  childNodes.remove(index);  out.parentNode  =  null;  }        [CLASS]  Node    [METHOD]  removeChild  [RETURN_TYPE]  void      Node  out  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    int    index    Node    in    out    parentNode    
int  index  =  indexInList  (  out,  childNodes  )  ;	[BUGGY]  childNodes.remove(  index);  int  index  =  indexInList(  out,  childNodes);  [CONTEXT]        [CLASS]  Node    [METHOD]  removeChild  [RETURN_TYPE]  void      Node  out  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    int    index    Node    in    out    parentNode    
int  index  =  indexInList  (  out,  childNodes  )  ;	[BUGGY]  Integer  index  =  indexInList(  this,  siblings);int  index  =  indexInList(  out,  childNodes);  [CONTEXT]        [CLASS]  Node    [METHOD]  removeChild  [RETURN_TYPE]  void      Node  out  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    int    index    Node    in    out    parentNode    
int  index  =  indexInList  (  out,  childNodes  )  ;	[BUGGY]  Integer  index  =  indexInList(  out,  childNodes);int  index  =  indexInList(  out,  childNodes);  [CONTEXT]        [CLASS]  Node    [METHOD]  removeChild  [RETURN_TYPE]  void      Node  out  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    int    index    Node    in    out    parentNode    
int  index  =  indexInList  (  out,  childNodes  )  ;  childNodes.remove  (  index  )  ;	[BUGGY]    [CONTEXT]  protected  void  removeChild(Node  out)  {  Validate.isTrue(out.parentNode  ==  this);  [BUGGY]  int  index  =  indexInList(out,  childNodes);      out.parentNode  =  null;        [CLASS]  Node    [METHOD]  removeChild  [RETURN_TYPE]  void      Node  out  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    int    index    Node    in    out    parentNode    
int  index  =  indexInList  (  out,  childNodes  )  ;	[BUGGY]  return  indexInList(  this,  parent(  ).childNodes);int  index  =  indexInList(  out,  childNodes);  [CONTEXT]        [CLASS]  Node    [METHOD]  removeChild  [RETURN_TYPE]  void      Node  out  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    int    index    Node    in    out    parentNode    
childNodes.remove  (  index  )  ;	[BUGGY]  childNodes.get(  index);  [CONTEXT]  protected  void  removeChild(Node  out)  {  Validate.isTrue(out.parentNode  ==  this);  int  index  =  indexInList(out,  childNodes);  [BUGGY]  childNodes.get  (  index  )  ;  out.parentNode  =  null;  }        [CLASS]  Node    [METHOD]  removeChild  [RETURN_TYPE]  void      Node  out  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    int    index    Node    in    out    parentNode    
childNodes.remove  (  index  )  ;	[BUGGY]    [CONTEXT]  protected  void  removeChild(Node  out)  {  Validate.isTrue(out.parentNode  ==  this);  int  index  =  indexInList(out,  childNodes);  [BUGGY]  childNodes.remove(index);    out.parentNode  =  null;        [CLASS]  Node    [METHOD]  removeChild  [RETURN_TYPE]  void      Node  out  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    int    index    Node    in    out    parentNode    
childNodes.remove  (  index  )  ;  out.parentNode  =  null;	[BUGGY]  out.parentNode  =  null;  childNodes.remove(  index);  [CONTEXT]        [CLASS]  Node    [METHOD]  removeChild  [RETURN_TYPE]  void      Node  out  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    int    index    Node    in    out    parentNode    
childNodes.remove  (  index  )  ;  out.parentNode  =  null;	[BUGGY]  childNodes.remove(  index);childNodes.remove(  index);  out.parentNode  =  null;  [CONTEXT]        [CLASS]  Node    [METHOD]  removeChild  [RETURN_TYPE]  void      Node  out  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    int    index    Node    in    out    parentNode    
out.parentNode  =  null;	[BUGGY]  out.parentNode  =  false;  [CONTEXT]  protected  void  removeChild(Node  out)  {  Validate.isTrue(out.parentNode  ==  this);  int  index  =  indexInList(out,  childNodes);  childNodes.remove(index);  [BUGGY]  out.parentNode  =  false;  }        [CLASS]  Node    [METHOD]  removeChild  [RETURN_TYPE]  void      Node  out  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    int    index    Node    in    out    parentNode    
Validate.notNull  (  in  )  ;	[BUGGY]  Validate.notNull(  parentNode);  [CONTEXT]  protected  void  addChild(Node  in)  {  [BUGGY]  Validate.notNull  (  parentNode  )  ;  if  (in.parentNode  !=  null)  in.parentNode.removeChild(in);    childNodes.add(in);  in.parentNode  =  this;  }        [CLASS]  Node    [METHOD]  addChild  [RETURN_TYPE]  void      Node  in  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
Validate.notNull  (  in  )  ;	[BUGGY]    [CONTEXT]  protected  void  addChild(Node  in)  {  [BUGGY]  Validate.notNull(in);    if  (in.parentNode  !=  null)  in.parentNode.removeChild(in);    childNodes.add(in);  in.parentNode  =  this;        [CLASS]  Node    [METHOD]  addChild  [RETURN_TYPE]  void      Node  in  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
if  (  in.parentNode  !=  null  )  in.parentNode.removeChild  (  in  )  ;	[BUGGY]  if  (  in.parentNode  ==  null)in.parentNode.removeChild(  in);  [CONTEXT]  protected  void  addChild(Node  in)  {  Validate.notNull(in);  [BUGGY]  if(  in.parentNode  ==  null  )  in.parentNode.removeChild  (  in  )  ;      childNodes.add(in);  in.parentNode  =  this;  }        [CLASS]  Node    [METHOD]  addChild  [RETURN_TYPE]  void      Node  in  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
if  (  in.parentNode  !=  null  )  in.parentNode.removeChild  (  in  )  ;	[BUGGY]  if  (  parentNode.parentNode  !=  null)in.parentNode.removeChild(  in);  [CONTEXT]  protected  void  addChild(Node  in)  {  Validate.notNull(in);  [BUGGY]  if(  parentNode.parentNode  !=  null  )  in.parentNode.removeChild  (  in  )  ;      childNodes.add(in);  in.parentNode  =  this;  }        [CLASS]  Node    [METHOD]  addChild  [RETURN_TYPE]  void      Node  in  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
if  (  in.parentNode  !=  null  )  in.parentNode.removeChild  (  in  )  ;	[BUGGY]  if  (  parentNode  !=  null)in.parentNode.removeChild(  in);  [CONTEXT]  protected  void  addChild(Node  in)  {  Validate.notNull(in);  [BUGGY]  if(  parentNode  !=  null  )  in.parentNode.removeChild  (  in  )  ;      childNodes.add(in);  in.parentNode  =  this;  }        [CLASS]  Node    [METHOD]  addChild  [RETURN_TYPE]  void      Node  in  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
if  (  in.parentNode  !=  null  )  in.parentNode.removeChild  (  in  )  ;	[BUGGY]  if  (  in.parentNode.parentNode  !=  null)in.removeChild(  in);  [CONTEXT]  protected  void  addChild(Node  in)  {  Validate.notNull(in);  [BUGGY]  if(  in.parentNode.parentNode  !=  null  )  in.removeChild  (  in  )  ;      childNodes.add(in);  in.parentNode  =  this;  }        [CLASS]  Node    [METHOD]  addChild  [RETURN_TYPE]  void      Node  in  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
if  (  in.parentNode  !=  null  )  in.parentNode.removeChild  (  in  )  ;	[BUGGY]  if  (  in  !=  null)in.parentNode.parentNode.removeChild(  in);  [CONTEXT]  protected  void  addChild(Node  in)  {  Validate.notNull(in);  [BUGGY]  if(  in  !=  null  )  in.parentNode.parentNode.removeChild  (  in  )  ;      childNodes.add(in);  in.parentNode  =  this;  }        [CLASS]  Node    [METHOD]  addChild  [RETURN_TYPE]  void      Node  in  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
if  (  in.parentNode  !=  null  )  in.parentNode.removeChild  (  in  )  ;	[BUGGY]  if  (  in.parentNode  !=  null)in.parentNode.replaceChild(  in);  [CONTEXT]  protected  void  addChild(Node  in)  {  Validate.notNull(in);  [BUGGY]  if(  in.parentNode  !=  null  )  in.parentNode.replaceChild  (  in  )  ;      childNodes.add(in);  in.parentNode  =  this;  }        [CLASS]  Node    [METHOD]  addChild  [RETURN_TYPE]  void      Node  in  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
if  (  in.parentNode  !=  null  )  in.parentNode.removeChild  (  in  )  ;	[BUGGY]  if  (  in.parentNode  !=  null)in.parentNode  .replaceChild(  out  ,  parentNode)  ;  [CONTEXT]  protected  void  addChild(Node  in)  {  Validate.notNull(in);  [BUGGY]  if(  in.parentNode  !=  null  )  in.parentNode  .replaceChild  (  out  ,  parentNode  );      childNodes.add(in);  in.parentNode  =  this;  }        [CLASS]  Node    [METHOD]  addChild  [RETURN_TYPE]  void      Node  in  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
if  (  in.parentNode  !=  null  )  in.parentNode.removeChild  (  in  )  ;	[BUGGY]  if  (  in.parentNode  !=  false)in.parentNode.replaceChild(  in);  [CONTEXT]  protected  void  addChild(Node  in)  {  Validate.notNull(in);  [BUGGY]  if(  in.parentNode  !=  false  )  in.parentNode.replaceChild  (  in  )  ;      childNodes.add(in);  in.parentNode  =  this;  }        [CLASS]  Node    [METHOD]  addChild  [RETURN_TYPE]  void      Node  in  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
if  (  in.parentNode  !=  null  )  in.parentNode.removeChild  (  in  )  ;  childNodes.add  (  in  )  ;  in.parentNode  =  this;  }	[BUGGY]  in.parentNode.removeChild(in);  [CONTEXT]  protected  void  addChild(Node  in)  {  Validate.notNull(in);  [BUGGY]  if  (in.parentNode  !=  null)    in.parentNode.removeChild(in);              [CLASS]  Node    [METHOD]  addChild  [RETURN_TYPE]  void      Node  in  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
if  (  in.parentNode  !=  null  )  in.parentNode.removeChild  (  in  )  ;  childNodes.add  (  in  )  ;  in.parentNode  =  this;  }	[BUGGY]    [CONTEXT]  protected  void  addChild(Node  in)  {  Validate.notNull(in);  [BUGGY]  if  (in.parentNode  !=  null)                  [CLASS]  Node    [METHOD]  addChild  [RETURN_TYPE]  void      Node  in  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
in.parentNode.removeChild  (  in  )  ;	[BUGGY]  in.parentNode.removeChild(  parentNode);  [CONTEXT]  protected  void  addChild(Node  in)  {  Validate.notNull(in);  if  (in.parentNode  !=  null)  [BUGGY]  in.parentNode.removeChild  (  parentNode  )  ;    childNodes.add(in);  in.parentNode  =  this;  }        [CLASS]  Node    [METHOD]  addChild  [RETURN_TYPE]  void      Node  in  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
in.parentNode.removeChild  (  in  )  ;	[BUGGY]  in.parentNode.replaceChild(  in);  [CONTEXT]  protected  void  addChild(Node  in)  {  Validate.notNull(in);  if  (in.parentNode  !=  null)  [BUGGY]  in.parentNode.replaceChild  (  in  )  ;    childNodes.add(in);  in.parentNode  =  this;  }        [CLASS]  Node    [METHOD]  addChild  [RETURN_TYPE]  void      Node  in  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
in.parentNode.removeChild  (  in  )  ;	[BUGGY]    [CONTEXT]  protected  void  addChild(Node  in)  {  Validate.notNull(in);  if  (in.parentNode  !=  null)  [BUGGY]  in.parentNode.removeChild(in);      childNodes.add(in);  in.parentNode  =  this;        [CLASS]  Node    [METHOD]  addChild  [RETURN_TYPE]  void      Node  in  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
in.parentNode.removeChild  (  in  )  ;	[BUGGY]  in.parentNode  .replaceChild(  out  ,  in)  ;  [CONTEXT]  protected  void  addChild(Node  in)  {  Validate.notNull(in);  if  (in.parentNode  !=  null)  [BUGGY]  in.parentNode  .replaceChild  (  out  ,  in  );    childNodes.add(in);  in.parentNode  =  this;  }        [CLASS]  Node    [METHOD]  addChild  [RETURN_TYPE]  void      Node  in  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
in.parentNode.removeChild  (  in  )  ;	[BUGGY]  in.parentNode  .replaceChild(  parentNode  ,  out)  ;  [CONTEXT]  protected  void  addChild(Node  in)  {  Validate.notNull(in);  if  (in.parentNode  !=  null)  [BUGGY]  in.parentNode  .replaceChild  (  parentNode  ,  out  );    childNodes.add(in);  in.parentNode  =  this;  }        [CLASS]  Node    [METHOD]  addChild  [RETURN_TYPE]  void      Node  in  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
childNodes.add  (  in  )  ;	[BUGGY]  childNodes.add(  parentNode);  [CONTEXT]  protected  void  addChild(Node  in)  {  Validate.notNull(in);  if  (in.parentNode  !=  null)  in.parentNode.removeChild(in);    [BUGGY]  childNodes.add  (  parentNode  )  ;  in.parentNode  =  this;  }        [CLASS]  Node    [METHOD]  addChild  [RETURN_TYPE]  void      Node  in  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
childNodes.add  (  in  )  ;	[BUGGY]  childNodes.remove(  in);  [CONTEXT]  protected  void  addChild(Node  in)  {  Validate.notNull(in);  if  (in.parentNode  !=  null)  in.parentNode.removeChild(in);    [BUGGY]  childNodes.remove  (  in  )  ;  in.parentNode  =  this;  }        [CLASS]  Node    [METHOD]  addChild  [RETURN_TYPE]  void      Node  in  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
childNodes.add  (  in  )  ;	[BUGGY]    [CONTEXT]  protected  void  addChild(Node  in)  {  Validate.notNull(in);  if  (in.parentNode  !=  null)  in.parentNode.removeChild(in);    [BUGGY]  childNodes.add(in);    in.parentNode  =  this;        [CLASS]  Node    [METHOD]  addChild  [RETURN_TYPE]  void      Node  in  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
childNodes.add  (  in  )  ;	[BUGGY]    childNodes.add(  in);  [CONTEXT]        [CLASS]  Node    [METHOD]  addChild  [RETURN_TYPE]  void      Node  in  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
childNodes.add  (  in  )  ;	[BUGGY]  N  node  =  nodes.get(  i);childNodes.add(  in);  [CONTEXT]        [CLASS]  Node    [METHOD]  addChild  [RETURN_TYPE]  void      Node  in  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
childNodes.add  (  in  )  ;	[BUGGY]  childNodes.remove(  index);childNodes.add(  in);  [CONTEXT]        [CLASS]  Node    [METHOD]  addChild  [RETURN_TYPE]  void      Node  in  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
childNodes.add  (  in  )  ;	[BUGGY]  return  childNodes.get(  index);childNodes.add(  in);  [CONTEXT]        [CLASS]  Node    [METHOD]  addChild  [RETURN_TYPE]  void      Node  in  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
childNodes.add  (  in  )  ;	[BUGGY]  childNodes.set(  index,  in);childNodes.add(  in);  [CONTEXT]        [CLASS]  Node    [METHOD]  addChild  [RETURN_TYPE]  void      Node  in  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
in.parentNode  =  this;	[BUGGY]  in.parentNode  =    this;  [CONTEXT]  protected  void  addChild(Node  in)  {  Validate.notNull(in);  if  (in.parentNode  !=  null)  in.parentNode.removeChild(in);    childNodes.add(in);  [BUGGY]  in.parentNode  =this;  }        [CLASS]  Node    [METHOD]  addChild  [RETURN_TYPE]  void      Node  in  [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
if  (  parentNode  ==  null  )  return  0;	[BUGGY]  if  (  parentNode  !=  null)return  0;  [CONTEXT]  protected  int  nodeDepth()  {  [BUGGY]  if(  parentNode  !=  null  )  return  0;    else  return  parentNode.nodeDepth()  +  1;  }        [CLASS]  Node    [METHOD]  nodeDepth  [RETURN_TYPE]  int      [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
if  (  parentNode  ==  null  )  return  0;	[BUGGY]  if  (  parentNode  ==  null)return  2;  [CONTEXT]  protected  int  nodeDepth()  {  [BUGGY]  if(  parentNode  ==  null  )  return  2;    else  return  parentNode.nodeDepth()  +  1;  }        [CLASS]  Node    [METHOD]  nodeDepth  [RETURN_TYPE]  int      [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
if  (  parentNode  ==  null  )  return  0;	[BUGGY]  if  (  out  ==  null)return  0;  [CONTEXT]  protected  int  nodeDepth()  {  [BUGGY]  if(  out  ==  null  )  return  0;    else  return  parentNode.nodeDepth()  +  1;  }        [CLASS]  Node    [METHOD]  nodeDepth  [RETURN_TYPE]  int      [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
if  (  parentNode  ==  null  )  return  0;	[BUGGY]  if  (  parentNode.nodeDepth()  +  1)return  0;  [CONTEXT]  protected  int  nodeDepth()  {  [BUGGY]  if(  parentNode.nodeDepth()  +  1  )  return  0;    else  return  parentNode.nodeDepth()  +  1;  }        [CLASS]  Node    [METHOD]  nodeDepth  [RETURN_TYPE]  int      [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
if  (  parentNode  ==  null  )  return  0;	[BUGGY]  if  (  parentNode  ==  this)return  0;  [CONTEXT]  protected  int  nodeDepth()  {  [BUGGY]  if(  parentNode  ==  this  )  return  0;    else  return  parentNode.nodeDepth()  +  1;  }        [CLASS]  Node    [METHOD]  nodeDepth  [RETURN_TYPE]  int      [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
if  (  parentNode  ==  null  )  return  0;  else  return  parentNode.nodeDepth  (  )  +  1;  }	[BUGGY]  return  0;  [CONTEXT]  protected  int  nodeDepth()  {  [BUGGY]  if  (parentNode  ==  null)    return  0;            [CLASS]  Node    [METHOD]  nodeDepth  [RETURN_TYPE]  int      [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
if  (  parentNode  ==  null  )  return  0;  else  return  parentNode.nodeDepth  (  )  +  1;  }	[BUGGY]    [CONTEXT]  protected  int  nodeDepth()  {  [BUGGY]  if  (parentNode  ==  null)                [CLASS]  Node    [METHOD]  nodeDepth  [RETURN_TYPE]  int      [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
return  parentNode.nodeDepth  (  )  +  1;	[BUGGY]  return  parentNode.nodeDepth(    <<  )  +  1;  [CONTEXT]  protected  int  nodeDepth()  {  if  (parentNode  ==  null)  return  0;  else  [BUGGY]  return  parentNode.nodeDepth  (<<)+  1;  }        [CLASS]  Node    [METHOD]  nodeDepth  [RETURN_TYPE]  int      [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
return  parentNode.nodeDepth  (  )  +  1;	[BUGGY]  return  parentNode.nodeDepth(  )  ;  [CONTEXT]  protected  int  nodeDepth()  {  if  (parentNode  ==  null)  return  0;  else  [BUGGY]  return  parentNode.nodeDepth  ();  }        [CLASS]  Node    [METHOD]  nodeDepth  [RETURN_TYPE]  int      [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
return  parentNode.nodeDepth  (  )  +  1;	[BUGGY]  return  out.nodeDepth(  )  +  1;  [CONTEXT]  protected  int  nodeDepth()  {  if  (parentNode  ==  null)  return  0;  else  [BUGGY]  return  out.nodeDepth  ()+  1;  }        [CLASS]  Node    [METHOD]  nodeDepth  [RETURN_TYPE]  int      [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
return  parentNode.nodeDepth  (  )  +  1;	[BUGGY]  return  parentNode.parent(  )  +  1;  [CONTEXT]  protected  int  nodeDepth()  {  if  (parentNode  ==  null)  return  0;  else  [BUGGY]  return  parentNode.parent  ()+  1;  }        [CLASS]  Node    [METHOD]  nodeDepth  [RETURN_TYPE]  int      [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
return  parentNode.nodeDepth  (  )  +  1;	[BUGGY]  return  parentNode  .Node(  attributeKey  ,  attributes)    +  1;  [CONTEXT]  protected  int  nodeDepth()  {  if  (parentNode  ==  null)  return  0;  else  [BUGGY]  return  parentNode  .Node  (  attributeKey  ,  attributes  )  +  1;  }        [CLASS]  Node    [METHOD]  nodeDepth  [RETURN_TYPE]  int      [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
return  parentNode.nodeDepth  (  )  +  1;	[BUGGY]    [CONTEXT]  protected  int  nodeDepth()  {  if  (parentNode  ==  null)  return  0;  else  [BUGGY]  return  parentNode.nodeDepth()  +  1;          [CLASS]  Node    [METHOD]  nodeDepth  [RETURN_TYPE]  int      [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
return  0;	[BUGGY]  return  -8;  [CONTEXT]  protected  int  nodeDepth()  {  if  (parentNode  ==  null)  [BUGGY]  return  -8;  else  return  parentNode.nodeDepth()  +  1;  }        [CLASS]  Node    [METHOD]  nodeDepth  [RETURN_TYPE]  int      [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
return  0;	[BUGGY]  return  1;  [CONTEXT]  protected  int  nodeDepth()  {  if  (parentNode  ==  null)  [BUGGY]  return  1;  else  return  parentNode.nodeDepth()  +  1;  }        [CLASS]  Node    [METHOD]  nodeDepth  [RETURN_TYPE]  int      [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
return  0;	[BUGGY]  return  -5;  [CONTEXT]  protected  int  nodeDepth()  {  if  (parentNode  ==  null)  [BUGGY]  return  -5;  else  return  parentNode.nodeDepth()  +  1;  }        [CLASS]  Node    [METHOD]  nodeDepth  [RETURN_TYPE]  int      [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
return  0;	[BUGGY]  return  4;  [CONTEXT]  protected  int  nodeDepth()  {  if  (parentNode  ==  null)  [BUGGY]  return  4;  else  return  parentNode.nodeDepth()  +  1;  }        [CLASS]  Node    [METHOD]  nodeDepth  [RETURN_TYPE]  int      [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
return  parentNode.nodeDepth  (  )  +  1;	[BUGGY]  return  parentNode.nodeDepth(    >  )  +  1;  [CONTEXT]  protected  int  nodeDepth()  {  if  (parentNode  ==  null)  return  0;  else  [BUGGY]  return  parentNode.nodeDepth  (>)+  1;  }        [CLASS]  Node    [METHOD]  nodeDepth  [RETURN_TYPE]  int      [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
return  parent  (  )  .childNodes  (  )  ;	[BUGGY]  return  parent(  ).hashCode(  );  [CONTEXT]  public  List<Node>  siblingNodes()  {  [BUGGY]  return  parent  ()  .hashCode  ()  ;  }        [CLASS]  Node    [METHOD]  siblingNodes  [RETURN_TYPE]  List      [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
return  parent  (  )  .childNodes  (  )  ;	[BUGGY]  return  nodeDepth(  ).childNodes(  );  [CONTEXT]  public  List<Node>  siblingNodes()  {  [BUGGY]  return  nodeDepth  ()  .childNodes  ()  ;  }        [CLASS]  Node    [METHOD]  siblingNodes  [RETURN_TYPE]  List      [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
return  parent  (  )  .childNodes  (  )  ;	[BUGGY]    [CONTEXT]  public  List<Node>  siblingNodes()  {  [BUGGY]  return  parent().childNodes();  //  TODO:  should  this  strip  out  this  node?  i.e.  not  a  sibling  of  self?          [CLASS]  Node    [METHOD]  siblingNodes  [RETURN_TYPE]  List      [VARIABLES]  Attributes    attributes    List    childNodes    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
List<Node>  siblings  =  parentNode.childNodes;	[BUGGY]  List<Node>  siblings  =  parentNode;  [CONTEXT]  public  Node  nextSibling()  {  [BUGGY]  List<Node>  siblings  =  parentNode;  Integer  index  =  indexInList(this,  siblings);  Validate.notNull(index);  if  (siblings.size()  >  index+1)  return  siblings.get(index+1);  else  return  null;  }        [CLASS]  Node    [METHOD]  nextSibling  [RETURN_TYPE]  Node      [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
List<Node>  siblings  =  parentNode.childNodes;	[BUGGY]  List<Node>  siblings  =  parentNode.childNodes.childNodes;  [CONTEXT]  public  Node  nextSibling()  {  [BUGGY]  List<Node>  siblings  =  parentNode.childNodes.childNodes;  Integer  index  =  indexInList(this,  siblings);  Validate.notNull(index);  if  (siblings.size()  >  index+1)  return  siblings.get(index+1);  else  return  null;  }        [CLASS]  Node    [METHOD]  nextSibling  [RETURN_TYPE]  Node      [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
List<Node>  siblings  =  parentNode.childNodes;	[BUGGY]  List<Node>  siblings  =  out.childNodes;  [CONTEXT]  public  Node  nextSibling()  {  [BUGGY]  List<Node>  siblings  =  out.childNodes;  Integer  index  =  indexInList(this,  siblings);  Validate.notNull(index);  if  (siblings.size()  >  index+1)  return  siblings.get(index+1);  else  return  null;  }        [CLASS]  Node    [METHOD]  nextSibling  [RETURN_TYPE]  Node      [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
Integer  index  =  indexInList  (  this,  siblings  )  ;	[BUGGY]  Integer  index  =  indent(  this,  siblings);  [CONTEXT]  public  Node  nextSibling()  {  List<Node>  siblings  =  parentNode.childNodes;  [BUGGY]  Integer  index  =  indent  (  this,  siblings  )  ;  Validate.notNull(index);  if  (siblings.size()  >  index+1)  return  siblings.get(index+1);  else  return  null;  }        [CLASS]  Node    [METHOD]  nextSibling  [RETURN_TYPE]  Node      [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
Integer  index  =  indexInList  (  this,  siblings  )  ;	[BUGGY]  if  (  siblings.size(  )  >  index+1)Integer  index  =  indexInList(  this,  siblings);  [CONTEXT]        [CLASS]  Node    [METHOD]  nextSibling  [RETURN_TYPE]  Node      [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
Integer  index  =  indexInList  (  this,  siblings  )  ;	[BUGGY]  Integer  index  =  indexInList(  out,  childNodes);Integer  index  =  indexInList(  this,  siblings);  [CONTEXT]        [CLASS]  Node    [METHOD]  nextSibling  [RETURN_TYPE]  Node      [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
Integer  index  =  indexInList  (  this,  siblings  )  ;	[BUGGY]  int  index  =  indexInList(  out,  childNodes);Integer  index  =  indexInList(  this,  siblings);  [CONTEXT]        [CLASS]  Node    [METHOD]  nextSibling  [RETURN_TYPE]  Node      [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
Integer  index  =  indexInList  (  this,  siblings  )  ;  Validate.notNull  (  index  )  ;	[BUGGY]    [CONTEXT]  public  Node  nextSibling()  {  List<Node>  siblings  =  parentNode.childNodes;  [BUGGY]  Integer  index  =  indexInList(this,  siblings);      if  (siblings.size()  >  index+1)  return  siblings.get(index+1);  else  return  null;        [CLASS]  Node    [METHOD]  nextSibling  [RETURN_TYPE]  Node      [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
Validate.notNull  (  index  )  ;	[BUGGY]  Validate  .notEmpty(  attributeValue)  ;  [CONTEXT]  public  Node  nextSibling()  {  List<Node>  siblings  =  parentNode.childNodes;  Integer  index  =  indexInList(this,  siblings);  [BUGGY]  Validate  .notEmpty  (  attributeValue  );  if  (siblings.size()  >  index+1)  return  siblings.get(index+1);  else  return  null;  }        [CLASS]  Node    [METHOD]  nextSibling  [RETURN_TYPE]  Node      [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
Validate.notNull  (  index  )  ;	[BUGGY]    [CONTEXT]  public  Node  nextSibling()  {  List<Node>  siblings  =  parentNode.childNodes;  Integer  index  =  indexInList(this,  siblings);  [BUGGY]  Validate.notNull(index);    if  (siblings.size()  >  index+1)  return  siblings.get(index+1);  else  return  null;        [CLASS]  Node    [METHOD]  nextSibling  [RETURN_TYPE]  Node      [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
if  (  siblings.size  (  )  >  index+1  )  return  siblings.get  (  index+1  )  ;	[BUGGY]  if  (  siblings.size(  )  <  index+1)return  siblings.get(  index+1);  [CONTEXT]  public  Node  nextSibling()  {  List<Node>  siblings  =  parentNode.childNodes;  Integer  index  =  indexInList(this,  siblings);  Validate.notNull(index);  [BUGGY]  if(  siblings.size  ()<  index+1  )  return  siblings.get  (  index+1  )  ;    else  return  null;  }        [CLASS]  Node    [METHOD]  nextSibling  [RETURN_TYPE]  Node      [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
if  (  siblings.size  (  )  >  index+1  )  return  siblings.get  (  index+1  )  ;	[BUGGY]  if    &  (  siblings.size(  )  >  index+1)return  siblings.get(  index+1);  [CONTEXT]  public  Node  nextSibling()  {  List<Node>  siblings  =  parentNode.childNodes;  Integer  index  =  indexInList(this,  siblings);  Validate.notNull(index);  [BUGGY]  if&(  siblings.size  ()>  index+1  )  return  siblings.get  (  index+1  )  ;    else  return  null;  }        [CLASS]  Node    [METHOD]  nextSibling  [RETURN_TYPE]  Node      [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
if  (  siblings.size  (  )  >  index+1  )  return  siblings.get  (  index+1  )  ;	[BUGGY]  if  (  siblings.size(  )  >  index+4)return  siblings.get(  index+4);  [CONTEXT]  public  Node  nextSibling()  {  List<Node>  siblings  =  parentNode.childNodes;  Integer  index  =  indexInList(this,  siblings);  Validate.notNull(index);  [BUGGY]  if(  siblings.size  ()>  index+4  )  return  siblings.get  (  index+4  )  ;    else  return  null;  }        [CLASS]  Node    [METHOD]  nextSibling  [RETURN_TYPE]  Node      [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
if  (  siblings.size  (  )  >  index+1  )  return  siblings.get  (  index+1  )  ;	[BUGGY]  if  (  siblings.size(  )  >  index+-3)return  siblings.get(  index+-3);  [CONTEXT]  public  Node  nextSibling()  {  List<Node>  siblings  =  parentNode.childNodes;  Integer  index  =  indexInList(this,  siblings);  Validate.notNull(index);  [BUGGY]  if(  siblings.size  ()>  index+-3  )  return  siblings.get  (  index+-3  )  ;    else  return  null;  }        [CLASS]  Node    [METHOD]  nextSibling  [RETURN_TYPE]  Node      [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
if  (  siblings.size  (  )  >  index+1  )  return  siblings.get  (  index+1  )  ;	[BUGGY]  if  (  siblings.size()  -  5    >  index+1)return  siblings.get(  index+1);  [CONTEXT]  public  Node  nextSibling()  {  List<Node>  siblings  =  parentNode.childNodes;  Integer  index  =  indexInList(this,  siblings);  Validate.notNull(index);  [BUGGY]  if(  siblings.size()  -  5>  index+1  )  return  siblings.get  (  index+1  )  ;    else  return  null;  }        [CLASS]  Node    [METHOD]  nextSibling  [RETURN_TYPE]  Node      [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
if  (  siblings.size  (  )  >  index+1  )  return  siblings.get  (  index+1  )  ;	[BUGGY]  if  (  index.size(  )  >  siblings+1)return  siblings.get(  index+1);  [CONTEXT]  public  Node  nextSibling()  {  List<Node>  siblings  =  parentNode.childNodes;  Integer  index  =  indexInList(this,  siblings);  Validate.notNull(index);  [BUGGY]  if(  index.size  ()>  siblings+1  )  return  siblings.get  (  index+1  )  ;    else  return  null;  }        [CLASS]  Node    [METHOD]  nextSibling  [RETURN_TYPE]  Node      [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
if  (  siblings.size  (  )  >  index+1  )  return  siblings.get  (  index+1  )  ;	[BUGGY]  if  (  index  +  1);  [CONTEXT]  public  Node  nextSibling()  {  List<Node>  siblings  =  parentNode.childNodes;  Integer  index  =  indexInList(this,  siblings);  Validate.notNull(index);  [BUGGY]  if(  index  +  1  )  ;    else  return  null;  }        [CLASS]  Node    [METHOD]  nextSibling  [RETURN_TYPE]  Node      [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
if  (  siblings.size  (  )  >  index+1  )  return  siblings.get  (  index+1  )  ;	[BUGGY]  if  (  siblings.get(  )  >  index+1)return  siblings.get(  index+1);  [CONTEXT]  public  Node  nextSibling()  {  List<Node>  siblings  =  parentNode.childNodes;  Integer  index  =  indexInList(this,  siblings);  Validate.notNull(index);  [BUGGY]  if(  siblings.get  ()>  index+1  )  return  siblings.get  (  index+1  )  ;    else  return  null;  }        [CLASS]  Node    [METHOD]  nextSibling  [RETURN_TYPE]  Node      [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
if  (  siblings.size  (  )  >  index+1  )  return  siblings.get  (  index+1  )  ;	[BUGGY]  if  (  siblings.size(  )  >  index+0  )return  siblings.get(  index+0  );  [CONTEXT]  public  Node  nextSibling()  {  List<Node>  siblings  =  parentNode.childNodes;  Integer  index  =  indexInList(this,  siblings);  Validate.notNull(index);  [BUGGY]  if(  siblings.size  ()>  index+0)  return  siblings.get  (  index+0)  ;    else  return  null;  }        [CLASS]  Node    [METHOD]  nextSibling  [RETURN_TYPE]  Node      [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
if  (  siblings.size  (  )  >  index+1  )  return  siblings.get  (  index+1  )  ;  else  return  null;  }	[BUGGY]  return  siblings.get((index  +  1));  [CONTEXT]  public  Node  nextSibling()  {  List<Node>  siblings  =  parentNode.childNodes;  Integer  index  =  indexInList(this,  siblings);  Validate.notNull(index);  [BUGGY]  if  (siblings.size()  >  index+1)    return  siblings.get((index  +  1));            [CLASS]  Node    [METHOD]  nextSibling  [RETURN_TYPE]  Node      [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
if  (  siblings.size  (  )  >  index+1  )  return  siblings.get  (  index+1  )  ;  else  return  null;  }	[BUGGY]    [CONTEXT]  public  Node  nextSibling()  {  List<Node>  siblings  =  parentNode.childNodes;  Integer  index  =  indexInList(this,  siblings);  Validate.notNull(index);  [BUGGY]  if  (siblings.size()  >  index+1)                [CLASS]  Node    [METHOD]  nextSibling  [RETURN_TYPE]  Node      [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
return  null;	[BUGGY]  return  false;  [CONTEXT]  public  Node  nextSibling()  {  List<Node>  siblings  =  parentNode.childNodes;  Integer  index  =  indexInList(this,  siblings);  Validate.notNull(index);  if  (siblings.size()  >  index+1)  return  siblings.get(index+1);  else  [BUGGY]  return  false;  }        [CLASS]  Node    [METHOD]  nextSibling  [RETURN_TYPE]  Node      [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
return  siblings.get  (  index+1  )  ;	[BUGGY]  return  siblings.get(  index+-7);  [CONTEXT]  public  Node  nextSibling()  {  List<Node>  siblings  =  parentNode.childNodes;  Integer  index  =  indexInList(this,  siblings);  Validate.notNull(index);  if  (siblings.size()  >  index+1)  [BUGGY]  return  siblings.get  (  index+-7  )  ;  else  return  null;  }        [CLASS]  Node    [METHOD]  nextSibling  [RETURN_TYPE]  Node      [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
return  siblings.get  (  index+1  )  ;	[BUGGY]  return  index.get(  siblings+1);  [CONTEXT]  public  Node  nextSibling()  {  List<Node>  siblings  =  parentNode.childNodes;  Integer  index  =  indexInList(this,  siblings);  Validate.notNull(index);  if  (siblings.size()  >  index+1)  [BUGGY]  return  index.get  (  siblings+1  )  ;  else  return  null;  }        [CLASS]  Node    [METHOD]  nextSibling  [RETURN_TYPE]  Node      [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
return  siblings.get  (  index+1  )  ;	[BUGGY]  return  siblings  .get(  attributeKey)  ;  [CONTEXT]  public  Node  nextSibling()  {  List<Node>  siblings  =  parentNode.childNodes;  Integer  index  =  indexInList(this,  siblings);  Validate.notNull(index);  if  (siblings.size()  >  index+1)  [BUGGY]  return  siblings  .get  (  attributeKey  );  else  return  null;  }        [CLASS]  Node    [METHOD]  nextSibling  [RETURN_TYPE]  Node      [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
return  siblings.get  (  index+1  )  ;	[BUGGY]  return  null  .get(  attributeKey)  ;  [CONTEXT]  public  Node  nextSibling()  {  List<Node>  siblings  =  parentNode.childNodes;  Integer  index  =  indexInList(this,  siblings);  Validate.notNull(index);  if  (siblings.size()  >  index+1)  [BUGGY]  return  null  .get  (  attributeKey  );  else  return  null;  }        [CLASS]  Node    [METHOD]  nextSibling  [RETURN_TYPE]  Node      [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
return  siblings.get  (  index+1  )  ;	[BUGGY]  return  siblings.get(  index+7);  [CONTEXT]  public  Node  nextSibling()  {  List<Node>  siblings  =  parentNode.childNodes;  Integer  index  =  indexInList(this,  siblings);  Validate.notNull(index);  if  (siblings.size()  >  index+1)  [BUGGY]  return  siblings.get  (  index+7  )  ;  else  return  null;  }        [CLASS]  Node    [METHOD]  nextSibling  [RETURN_TYPE]  Node      [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
return  siblings.get  (  index+1  )  ;	[BUGGY]    [CONTEXT]  public  Node  nextSibling()  {  List<Node>  siblings  =  parentNode.childNodes;  Integer  index  =  indexInList(this,  siblings);  Validate.notNull(index);  if  (siblings.size()  >  index+1)  [BUGGY]  return  siblings.get(index+1);    else  return  null;        [CLASS]  Node    [METHOD]  nextSibling  [RETURN_TYPE]  Node      [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
return  siblings.get  (  index+1  )  ;	[BUGGY]  return  siblings.get(  index  ;  [CONTEXT]  public  Node  nextSibling()  {  List<Node>  siblings  =  parentNode.childNodes;  Integer  index  =  indexInList(this,  siblings);  Validate.notNull(index);  if  (siblings.size()  >  index+1)  [BUGGY]  return  siblings.get  (  index  ;  else  return  null;  }        [CLASS]  Node    [METHOD]  nextSibling  [RETURN_TYPE]  Node      [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
if  (  siblings.size  (  )  >  index+1  )  return  siblings.get  (  index+1  )  ;	[BUGGY]  if  (  siblings.size()  +  2    >  index+1)return  siblings.get(  index+1);  [CONTEXT]  public  Node  nextSibling()  {  List<Node>  siblings  =  parentNode.childNodes;  Integer  index  =  indexInList(this,  siblings);  Validate.notNull(index);  [BUGGY]  if(  siblings.size()  +  2>  index+1  )  return  siblings.get  (  index+1  )  ;    else  return  null;  }        [CLASS]  Node    [METHOD]  nextSibling  [RETURN_TYPE]  Node      [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
return  siblings.get  (  index+1  )  ;	[BUGGY]  return  siblings.get(  index+8);  [CONTEXT]  public  Node  nextSibling()  {  List<Node>  siblings  =  parentNode.childNodes;  Integer  index  =  indexInList(this,  siblings);  Validate.notNull(index);  if  (siblings.size()  >  index+1)  [BUGGY]  return  siblings.get  (  index+8  )  ;  else  return  null;  }        [CLASS]  Node    [METHOD]  nextSibling  [RETURN_TYPE]  Node      [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
return  siblings.get  (  index+1  )  ;	[BUGGY]  return  siblings  .get(  attributeValue)  ;  [CONTEXT]  public  Node  nextSibling()  {  List<Node>  siblings  =  parentNode.childNodes;  Integer  index  =  indexInList(this,  siblings);  Validate.notNull(index);  if  (siblings.size()  >  index+1)  [BUGGY]  return  siblings  .get  (  attributeValue  );  else  return  null;  }        [CLASS]  Node    [METHOD]  nextSibling  [RETURN_TYPE]  Node      [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
List<Node>  siblings  =  parentNode.childNodes;	[BUGGY]  List<Node>  siblings  =  out.childNodes;  [CONTEXT]  public  Node  previousSibling()  {  [BUGGY]  List<Node>  siblings  =  out.childNodes;  Integer  index  =  indexInList(this,  siblings);  Validate.notNull(index);  if  (index  >  0)  return  siblings.get(index-1);  else  return  null;  }        [CLASS]  Node    [METHOD]  previousSibling  [RETURN_TYPE]  Node      [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
List<Node>  siblings  =  parentNode.childNodes;	[BUGGY]  List<Node>  siblings  =  parentNode;  [CONTEXT]  public  Node  previousSibling()  {  [BUGGY]  List<Node>  siblings  =  parentNode;  Integer  index  =  indexInList(this,  siblings);  Validate.notNull(index);  if  (index  >  0)  return  siblings.get(index-1);  else  return  null;  }        [CLASS]  Node    [METHOD]  previousSibling  [RETURN_TYPE]  Node      [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
List<Node>  siblings  =  parentNode.childNodes;	[BUGGY]  List<Node>  siblings  =  parentNode.childNodes.childNodes;  [CONTEXT]  public  Node  previousSibling()  {  [BUGGY]  List<Node>  siblings  =  parentNode.childNodes.childNodes;  Integer  index  =  indexInList(this,  siblings);  Validate.notNull(index);  if  (index  >  0)  return  siblings.get(index-1);  else  return  null;  }        [CLASS]  Node    [METHOD]  previousSibling  [RETURN_TYPE]  Node      [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
Integer  index  =  indexInList  (  this,  siblings  )  ;	[BUGGY]  Integer  index  =  indent(  this,  siblings);  [CONTEXT]  public  Node  previousSibling()  {  List<Node>  siblings  =  parentNode.childNodes;  [BUGGY]  Integer  index  =  indent  (  this,  siblings  )  ;  Validate.notNull(index);  if  (index  >  0)  return  siblings.get(index-1);  else  return  null;  }        [CLASS]  Node    [METHOD]  previousSibling  [RETURN_TYPE]  Node      [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
Integer  index  =  indexInList  (  this,  siblings  )  ;	[BUGGY]  Validate.notNull(  index);  Integer  index  =  indexInList(  this,  siblings);  [CONTEXT]        [CLASS]  Node    [METHOD]  previousSibling  [RETURN_TYPE]  Node      [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
Integer  index  =  indexInList  (  this,  siblings  )  ;	[BUGGY]  Integer  index  =  indexInList(  out,  childNodes);Integer  index  =  indexInList(  this,  siblings);  [CONTEXT]        [CLASS]  Node    [METHOD]  previousSibling  [RETURN_TYPE]  Node      [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
Integer  index  =  indexInList  (  this,  siblings  )  ;	[BUGGY]  int  index  =  indexInList(  out,  childNodes);Integer  index  =  indexInList(  this,  siblings);  [CONTEXT]        [CLASS]  Node    [METHOD]  previousSibling  [RETURN_TYPE]  Node      [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
Integer  index  =  indexInList  (  this,  siblings  )  ;  Validate.notNull  (  index  )  ;	[BUGGY]    [CONTEXT]  public  Node  previousSibling()  {  List<Node>  siblings  =  parentNode.childNodes;  [BUGGY]  Integer  index  =  indexInList(this,  siblings);      if  (index  >  0)  return  siblings.get(index-1);  else  return  null;        [CLASS]  Node    [METHOD]  previousSibling  [RETURN_TYPE]  Node      [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
Integer  index  =  indexInList  (  this,  siblings  )  ;	[BUGGY]  if  (  index  >  0)Integer  index  =  indexInList(  this,  siblings);  [CONTEXT]        [CLASS]  Node    [METHOD]  previousSibling  [RETURN_TYPE]  Node      [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
Validate.notNull  (  index  )  ;	[BUGGY]  Validate  .notEmpty(  attributeKey)  ;  [CONTEXT]  public  Node  previousSibling()  {  List<Node>  siblings  =  parentNode.childNodes;  Integer  index  =  indexInList(this,  siblings);  [BUGGY]  Validate  .notEmpty  (  attributeKey  );  if  (index  >  0)  return  siblings.get(index-1);  else  return  null;  }        [CLASS]  Node    [METHOD]  previousSibling  [RETURN_TYPE]  Node      [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
Validate.notNull  (  index  )  ;	[BUGGY]    [CONTEXT]  public  Node  previousSibling()  {  List<Node>  siblings  =  parentNode.childNodes;  Integer  index  =  indexInList(this,  siblings);  [BUGGY]  Validate.notNull(index);    if  (index  >  0)  return  siblings.get(index-1);  else  return  null;        [CLASS]  Node    [METHOD]  previousSibling  [RETURN_TYPE]  Node      [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
if  (  index  >  0  )  return  siblings.get  (  index-1  )  ;	[BUGGY]  if  (  index  ==  0)return  siblings.get(  index-1);  [CONTEXT]  public  Node  previousSibling()  {  List<Node>  siblings  =  parentNode.childNodes;  Integer  index  =  indexInList(this,  siblings);  Validate.notNull(index);  [BUGGY]  if(  index  ==  0  )  return  siblings.get  (  index-1  )  ;    else  return  null;  }        [CLASS]  Node    [METHOD]  previousSibling  [RETURN_TYPE]  Node      [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
if  (  index  >  0  )  return  siblings.get  (  index-1  )  ;	[BUGGY]  if  (  index  >  -2)return  siblings.get(  index-1);  [CONTEXT]  public  Node  previousSibling()  {  List<Node>  siblings  =  parentNode.childNodes;  Integer  index  =  indexInList(this,  siblings);  Validate.notNull(index);  [BUGGY]  if(  index  >  -2  )  return  siblings.get  (  index-1  )  ;    else  return  null;  }        [CLASS]  Node    [METHOD]  previousSibling  [RETURN_TYPE]  Node      [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
if  (  index  >  0  )  return  siblings.get  (  index-1  )  ;	[BUGGY]  if  (  index  >  0)return  siblings.get(  index--2);  [CONTEXT]  public  Node  previousSibling()  {  List<Node>  siblings  =  parentNode.childNodes;  Integer  index  =  indexInList(this,  siblings);  Validate.notNull(index);  [BUGGY]  if(  index  >  0  )  return  siblings.get  (  index--2  )  ;    else  return  null;  }        [CLASS]  Node    [METHOD]  previousSibling  [RETURN_TYPE]  Node      [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
if  (  index  >  0  )  return  siblings.get  (  index-1  )  ;	[BUGGY]  if  (  siblings  >  0)return  index.get(  index-1);  [CONTEXT]  public  Node  previousSibling()  {  List<Node>  siblings  =  parentNode.childNodes;  Integer  index  =  indexInList(this,  siblings);  Validate.notNull(index);  [BUGGY]  if(  siblings  >  0  )  return  index.get  (  index-1  )  ;    else  return  null;  }        [CLASS]  Node    [METHOD]  previousSibling  [RETURN_TYPE]  Node      [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
if  (  index  >  0  )  return  siblings.get  (  index-1  )  ;	[BUGGY]  if  (  index  -  1);  [CONTEXT]  public  Node  previousSibling()  {  List<Node>  siblings  =  parentNode.childNodes;  Integer  index  =  indexInList(this,  siblings);  Validate.notNull(index);  [BUGGY]  if(  index  -  1  )  ;    else  return  null;  }        [CLASS]  Node    [METHOD]  previousSibling  [RETURN_TYPE]  Node      [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
if  (  index  >  0  )  return  siblings.get  (  index-1  )  ;	[BUGGY]  if  (  index  >  0  -  3)return  siblings.get(  index-1);  [CONTEXT]  public  Node  previousSibling()  {  List<Node>  siblings  =  parentNode.childNodes;  Integer  index  =  indexInList(this,  siblings);  Validate.notNull(index);  [BUGGY]  if(  index  >  0  -  3  )  return  siblings.get  (  index-1  )  ;    else  return  null;  }        [CLASS]  Node    [METHOD]  previousSibling  [RETURN_TYPE]  Node      [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
if  (  index  >  0  )  return  siblings.get  (  index-1  )  ;  else  return  null;  }	[BUGGY]  return  siblings.get((index  -  1));  [CONTEXT]  public  Node  previousSibling()  {  List<Node>  siblings  =  parentNode.childNodes;  Integer  index  =  indexInList(this,  siblings);  Validate.notNull(index);  [BUGGY]  if  (index  >  0)    return  siblings.get((index  -  1));            [CLASS]  Node    [METHOD]  previousSibling  [RETURN_TYPE]  Node      [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
if  (  index  >  0  )  return  siblings.get  (  index-1  )  ;  else  return  null;  }	[BUGGY]    [CONTEXT]  public  Node  previousSibling()  {  List<Node>  siblings  =  parentNode.childNodes;  Integer  index  =  indexInList(this,  siblings);  Validate.notNull(index);  [BUGGY]  if  (index  >  0)                [CLASS]  Node    [METHOD]  previousSibling  [RETURN_TYPE]  Node      [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
return  null;	[BUGGY]  return  this;  [CONTEXT]  public  Node  previousSibling()  {  List<Node>  siblings  =  parentNode.childNodes;  Integer  index  =  indexInList(this,  siblings);  Validate.notNull(index);  if  (index  >  0)  return  siblings.get(index-1);  else  [BUGGY]  return  this;  }        [CLASS]  Node    [METHOD]  previousSibling  [RETURN_TYPE]  Node      [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
return  siblings.get  (  index-1  )  ;	[BUGGY]  return  siblings.get(  index-0);  [CONTEXT]  public  Node  previousSibling()  {  List<Node>  siblings  =  parentNode.childNodes;  Integer  index  =  indexInList(this,  siblings);  Validate.notNull(index);  if  (index  >  0)  [BUGGY]  return  siblings.get  (  index-0  )  ;  else  return  null;  }        [CLASS]  Node    [METHOD]  previousSibling  [RETURN_TYPE]  Node      [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
return  siblings.get  (  index-1  )  ;	[BUGGY]  return  index.get(  siblings-1);  [CONTEXT]  public  Node  previousSibling()  {  List<Node>  siblings  =  parentNode.childNodes;  Integer  index  =  indexInList(this,  siblings);  Validate.notNull(index);  if  (index  >  0)  [BUGGY]  return  index.get  (  siblings-1  )  ;  else  return  null;  }        [CLASS]  Node    [METHOD]  previousSibling  [RETURN_TYPE]  Node      [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
return  siblings.get  (  index-1  )  ;	[BUGGY]  return  siblings  .get(  baseUri)  ;  [CONTEXT]  public  Node  previousSibling()  {  List<Node>  siblings  =  parentNode.childNodes;  Integer  index  =  indexInList(this,  siblings);  Validate.notNull(index);  if  (index  >  0)  [BUGGY]  return  siblings  .get  (  baseUri  );  else  return  null;  }        [CLASS]  Node    [METHOD]  previousSibling  [RETURN_TYPE]  Node      [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
return  siblings.get  (  index-1  )  ;	[BUGGY]  return  siblings  .get(  attributeKey)  ;  [CONTEXT]  public  Node  previousSibling()  {  List<Node>  siblings  =  parentNode.childNodes;  Integer  index  =  indexInList(this,  siblings);  Validate.notNull(index);  if  (index  >  0)  [BUGGY]  return  siblings  .get  (  attributeKey  );  else  return  null;  }        [CLASS]  Node    [METHOD]  previousSibling  [RETURN_TYPE]  Node      [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
return  siblings.get  (  index-1  )  ;	[BUGGY]  return  siblings.get(  index-10);  [CONTEXT]  public  Node  previousSibling()  {  List<Node>  siblings  =  parentNode.childNodes;  Integer  index  =  indexInList(this,  siblings);  Validate.notNull(index);  if  (index  >  0)  [BUGGY]  return  siblings.get  (  index-10  )  ;  else  return  null;  }        [CLASS]  Node    [METHOD]  previousSibling  [RETURN_TYPE]  Node      [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
return  siblings.get  (  index-1  )  ;	[BUGGY]    [CONTEXT]  public  Node  previousSibling()  {  List<Node>  siblings  =  parentNode.childNodes;  Integer  index  =  indexInList(this,  siblings);  Validate.notNull(index);  if  (index  >  0)  [BUGGY]  return  siblings.get(index-1);    else  return  null;        [CLASS]  Node    [METHOD]  previousSibling  [RETURN_TYPE]  Node      [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
return  siblings.get  (  index-1  )  ;	[BUGGY]  return  siblings.get(  index--3);  [CONTEXT]  public  Node  previousSibling()  {  List<Node>  siblings  =  parentNode.childNodes;  Integer  index  =  indexInList(this,  siblings);  Validate.notNull(index);  if  (index  >  0)  [BUGGY]  return  siblings.get  (  index--3  )  ;  else  return  null;  }        [CLASS]  Node    [METHOD]  previousSibling  [RETURN_TYPE]  Node      [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
return  siblings.get  (  index-1  )  ;	[BUGGY]  return  siblings.get(  index  !=  1);;  [CONTEXT]  public  Node  previousSibling()  {  List<Node>  siblings  =  parentNode.childNodes;  Integer  index  =  indexInList(this,  siblings);  Validate.notNull(index);  if  (index  >  0)  [BUGGY]  return  siblings.get  (  index  !=  1  )  ;;  else  return  null;  }        [CLASS]  Node    [METHOD]  previousSibling  [RETURN_TYPE]  Node      [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
return  null;	[BUGGY]  return  true;  [CONTEXT]  public  Node  previousSibling()  {  List<Node>  siblings  =  parentNode.childNodes;  Integer  index  =  indexInList(this,  siblings);  Validate.notNull(index);  if  (index  >  0)  return  siblings.get(index-1);  else  [BUGGY]  return  true;  }        [CLASS]  Node    [METHOD]  previousSibling  [RETURN_TYPE]  Node      [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
return  siblings.get  (  index-1  )  ;	[BUGGY]  return  siblings.get(  index-8);  [CONTEXT]  public  Node  previousSibling()  {  List<Node>  siblings  =  parentNode.childNodes;  Integer  index  =  indexInList(this,  siblings);  Validate.notNull(index);  if  (index  >  0)  [BUGGY]  return  siblings.get  (  index-8  )  ;  else  return  null;  }        [CLASS]  Node    [METHOD]  previousSibling  [RETURN_TYPE]  Node      [VARIABLES]  Attributes    attributes    Integer    index    List    childNodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
return  indexInList  (  this,  parent  (  )  .childNodes  )  ;	[BUGGY]  return  childNodes(  this,  parent(  ).childNodes);  [CONTEXT]  public  Integer  siblingIndex()  {  [BUGGY]  return  childNodes  (  this,  parent  ()  .childNodes  )  ;  }        [CLASS]  Node    [METHOD]  siblingIndex  [RETURN_TYPE]  Integer      [VARIABLES]  Attributes    attributes    List    childNodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
return  indexInList  (  this,  parent  (  )  .childNodes  )  ;	[BUGGY]  return  indexInList(  this,  nodeDepth(  ).childNodes);  [CONTEXT]  public  Integer  siblingIndex()  {  [BUGGY]  return  indexInList  (  this,  nodeDepth  ()  .childNodes  )  ;  }        [CLASS]  Node    [METHOD]  siblingIndex  [RETURN_TYPE]  Integer      [VARIABLES]  Attributes    attributes    List    childNodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
return  indexInList  (  this,  parent  (  )  .childNodes  )  ;	[BUGGY]    [CONTEXT]  public  Integer  siblingIndex()  {  [BUGGY]  return  indexInList(this,  parent().childNodes);          [CLASS]  Node    [METHOD]  siblingIndex  [RETURN_TYPE]  Integer      [VARIABLES]  Attributes    attributes    List    childNodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
Validate.notNull  (  search  )  ;	[BUGGY]  Validate  .notEmpty(  relUrl)  ;  [CONTEXT]  protected  static  <N  extends  Node>  Integer  indexInList(N  search,  List<N>  nodes)  {  [BUGGY]  Validate  .notEmpty  (  relUrl  );  Validate.notNull(nodes);    for  (int  i  =  0;  i  <  nodes.size();  i++)  {  N  node  =  nodes.get(i);  if  (node.equals(search))  return  i;  }  return  null;  }        [CLASS]  Node    [METHOD]  indexInList  [RETURN_TYPE]  <N      N  search  List<N>  nodes  [VARIABLES]  boolean    Node    in    out    parentNode    Attributes    attributes    List    childNodes    nodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    N    node    search    int    i    
Validate.notNull  (  search  )  ;	[BUGGY]  Validate.notNull(  node);  [CONTEXT]  protected  static  <N  extends  Node>  Integer  indexInList(N  search,  List<N>  nodes)  {  [BUGGY]  Validate.notNull  (  node  )  ;  Validate.notNull(nodes);    for  (int  i  =  0;  i  <  nodes.size();  i++)  {  N  node  =  nodes.get(i);  if  (node.equals(search))  return  i;  }  return  null;  }        [CLASS]  Node    [METHOD]  indexInList  [RETURN_TYPE]  <N      N  search  List<N>  nodes  [VARIABLES]  boolean    Node    in    out    parentNode    Attributes    attributes    List    childNodes    nodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    N    node    search    int    i    
Validate.notNull  (  search  )  ;	[BUGGY]    [CONTEXT]  protected  static  <N  extends  Node>  Integer  indexInList(N  search,  List<N>  nodes)  {  [BUGGY]  Validate.notNull(search);    Validate.notNull(nodes);    for  (int  i  =  0;  i  <  nodes.size();  i++)  {  N  node  =  nodes.get(i);  if  (node.equals(search))  return  i;  }  return  null;        [CLASS]  Node    [METHOD]  indexInList  [RETURN_TYPE]  <N      N  search  List<N>  nodes  [VARIABLES]  boolean    Node    in    out    parentNode    Attributes    attributes    List    childNodes    nodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    N    node    search    int    i    
Validate.notNull  (  search  )  ;	[BUGGY]  Validate.notNull(  index);Validate.notNull(  search);  [CONTEXT]        [CLASS]  Node    [METHOD]  indexInList  [RETURN_TYPE]  <N      N  search  List<N>  nodes  [VARIABLES]  boolean    Node    in    out    parentNode    Attributes    attributes    List    childNodes    nodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    N    node    search    int    i    
Validate.notNull  (  search  )  ;	[BUGGY]  Validate.notNull(  parentNode);Validate.notNull(  search);  [CONTEXT]        [CLASS]  Node    [METHOD]  indexInList  [RETURN_TYPE]  <N      N  search  List<N>  nodes  [VARIABLES]  boolean    Node    in    out    parentNode    Attributes    attributes    List    childNodes    nodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    N    node    search    int    i    
Validate.notNull  (  search  )  ;	[BUGGY]  Validate.notNull(  baseUri);Validate.notNull(  search);  [CONTEXT]        [CLASS]  Node    [METHOD]  indexInList  [RETURN_TYPE]  <N      N  search  List<N>  nodes  [VARIABLES]  boolean    Node    in    out    parentNode    Attributes    attributes    List    childNodes    nodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    N    node    search    int    i    
Validate.notNull  (  search  )  ;	[BUGGY]  Validate.notNull(  attributeKey);Validate.notNull(  search);  [CONTEXT]        [CLASS]  Node    [METHOD]  indexInList  [RETURN_TYPE]  <N      N  search  List<N>  nodes  [VARIABLES]  boolean    Node    in    out    parentNode    Attributes    attributes    List    childNodes    nodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    N    node    search    int    i    
Validate.notNull  (  search  )  ;	[BUGGY]  Validate.notNull(  attributes);Validate.notNull(  search);  [CONTEXT]        [CLASS]  Node    [METHOD]  indexInList  [RETURN_TYPE]  <N      N  search  List<N>  nodes  [VARIABLES]  boolean    Node    in    out    parentNode    Attributes    attributes    List    childNodes    nodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    N    node    search    int    i    
Validate.notNull  (  search  )  ;	[BUGGY]  Validate.notNull(  in);Validate.notNull(  search);  [CONTEXT]        [CLASS]  Node    [METHOD]  indexInList  [RETURN_TYPE]  <N      N  search  List<N>  nodes  [VARIABLES]  boolean    Node    in    out    parentNode    Attributes    attributes    List    childNodes    nodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    N    node    search    int    i    
Validate.notNull  (  search  )  ;	[BUGGY]  Validate.notEmpty(  attributeKey);Validate.notNull(  search);  [CONTEXT]        [CLASS]  Node    [METHOD]  indexInList  [RETURN_TYPE]  <N      N  search  List<N>  nodes  [VARIABLES]  boolean    Node    in    out    parentNode    Attributes    attributes    List    childNodes    nodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    N    node    search    int    i    
Validate.notNull  (  search  )  ;	[BUGGY]  Validate.notNull(  nodes);Validate.notNull(  search);  [CONTEXT]        [CLASS]  Node    [METHOD]  indexInList  [RETURN_TYPE]  <N      N  search  List<N>  nodes  [VARIABLES]  boolean    Node    in    out    parentNode    Attributes    attributes    List    childNodes    nodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    N    node    search    int    i    
Validate.notNull  (  nodes  )  ;	[BUGGY]  Validate.notNull(  this);  [CONTEXT]  protected  static  <N  extends  Node>  Integer  indexInList(N  search,  List<N>  nodes)  {  Validate.notNull(search);  [BUGGY]  Validate.notNull  (  this  )  ;    for  (int  i  =  0;  i  <  nodes.size();  i++)  {  N  node  =  nodes.get(i);  if  (node.equals(search))  return  i;  }  return  null;  }        [CLASS]  Node    [METHOD]  indexInList  [RETURN_TYPE]  <N      N  search  List<N>  nodes  [VARIABLES]  boolean    Node    in    out    parentNode    Attributes    attributes    List    childNodes    nodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    N    node    search    int    i    
Validate.notNull  (  nodes  )  ;	[BUGGY]    [CONTEXT]  protected  static  <N  extends  Node>  Integer  indexInList(N  search,  List<N>  nodes)  {  Validate.notNull(search);  [BUGGY]  Validate.notNull(nodes);      for  (int  i  =  0;  i  <  nodes.size();  i++)  {  N  node  =  nodes.get(i);  if  (node.equals(search))  return  i;  }  return  null;        [CLASS]  Node    [METHOD]  indexInList  [RETURN_TYPE]  <N      N  search  List<N>  nodes  [VARIABLES]  boolean    Node    in    out    parentNode    Attributes    attributes    List    childNodes    nodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    N    node    search    int    i    
if  (  node.equals  (  search  )  )  return  i;	[BUGGY]  if  (  search.equals(  node))return  i;  [CONTEXT]  protected  static  <N  extends  Node>  Integer  indexInList(N  search,  List<N>  nodes)  {  Validate.notNull(search);  Validate.notNull(nodes);    for  (int  i  =  0;  i  <  nodes.size();  i++)  {  N  node  =  nodes.get(i);  [BUGGY]  if(  search.equals  (  node  ))  return  i;    }  return  null;  }        [CLASS]  Node    [METHOD]  indexInList  [RETURN_TYPE]  <N      N  search  List<N>  nodes  [VARIABLES]  boolean    Node    in    out    parentNode    Attributes    attributes    List    childNodes    nodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    N    node    search    int    i    
if  (  node.equals  (  search  )  )  return  i;	[BUGGY]  if  (  node.equals(  i))return  search;  [CONTEXT]  protected  static  <N  extends  Node>  Integer  indexInList(N  search,  List<N>  nodes)  {  Validate.notNull(search);  Validate.notNull(nodes);    for  (int  i  =  0;  i  <  nodes.size();  i++)  {  N  node  =  nodes.get(i);  [BUGGY]  if(  node.equals  (  i  ))  return  search;    }  return  null;  }        [CLASS]  Node    [METHOD]  indexInList  [RETURN_TYPE]  <N      N  search  List<N>  nodes  [VARIABLES]  boolean    Node    in    out    parentNode    Attributes    attributes    List    childNodes    nodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    N    node    search    int    i    
if  (  node.equals  (  search  )  )  return  i;	[BUGGY]  if  (  i.equals(  search))return  node;  [CONTEXT]  protected  static  <N  extends  Node>  Integer  indexInList(N  search,  List<N>  nodes)  {  Validate.notNull(search);  Validate.notNull(nodes);    for  (int  i  =  0;  i  <  nodes.size();  i++)  {  N  node  =  nodes.get(i);  [BUGGY]  if(  i.equals  (  search  ))  return  node;    }  return  null;  }        [CLASS]  Node    [METHOD]  indexInList  [RETURN_TYPE]  <N      N  search  List<N>  nodes  [VARIABLES]  boolean    Node    in    out    parentNode    Attributes    attributes    List    childNodes    nodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    N    node    search    int    i    
if  (  node.equals  (  search  )  )  return  i;	[BUGGY]  if  (  node.replaceChild(  search))return  i;  [CONTEXT]  protected  static  <N  extends  Node>  Integer  indexInList(N  search,  List<N>  nodes)  {  Validate.notNull(search);  Validate.notNull(nodes);    for  (int  i  =  0;  i  <  nodes.size();  i++)  {  N  node  =  nodes.get(i);  [BUGGY]  if(  node.replaceChild  (  search  ))  return  i;    }  return  null;  }        [CLASS]  Node    [METHOD]  indexInList  [RETURN_TYPE]  <N      N  search  List<N>  nodes  [VARIABLES]  boolean    Node    in    out    parentNode    Attributes    attributes    List    childNodes    nodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    N    node    search    int    i    
if  (  node.equals  (  search  )  )  return  i;  }	[BUGGY]  return  i;  [CONTEXT]  protected  static  <N  extends  Node>  Integer  indexInList(N  search,  List<N>  nodes)  {  Validate.notNull(search);  Validate.notNull(nodes);    for  (int  i  =  0;  i  <  nodes.size();  i++)  {  N  node  =  nodes.get(i);  [BUGGY]  if  (node.equals(search))    return  i;    return  null;        [CLASS]  Node    [METHOD]  indexInList  [RETURN_TYPE]  <N      N  search  List<N>  nodes  [VARIABLES]  boolean    Node    in    out    parentNode    Attributes    attributes    List    childNodes    nodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    N    node    search    int    i    
if  (  node.equals  (  search  )  )  return  i;  }	[BUGGY]    [CONTEXT]  protected  static  <N  extends  Node>  Integer  indexInList(N  search,  List<N>  nodes)  {  Validate.notNull(search);  Validate.notNull(nodes);    for  (int  i  =  0;  i  <  nodes.size();  i++)  {  N  node  =  nodes.get(i);  [BUGGY]  if  (node.equals(search))        return  null;        [CLASS]  Node    [METHOD]  indexInList  [RETURN_TYPE]  <N      N  search  List<N>  nodes  [VARIABLES]  boolean    Node    in    out    parentNode    Attributes    attributes    List    childNodes    nodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    N    node    search    int    i    
for  (  int  i  =  0;  i  <  nodes.size  (  )  ;  i++  )  {	[BUGGY]  for  (    long    i  =  0;  i  <  nodes.size(  );  i++)  {  [CONTEXT]  protected  static  <N  extends  Node>  Integer  indexInList(N  search,  List<N>  nodes)  {  Validate.notNull(search);  Validate.notNull(nodes);    [BUGGY]  for(longi  =  0;  i  <  nodes.size  ()  ;  i++  ){  N  node  =  nodes.get(i);  if  (node.equals(search))  return  i;  }  return  null;  }        [CLASS]  Node    [METHOD]  indexInList  [RETURN_TYPE]  <N      N  search  List<N>  nodes  [VARIABLES]  boolean    Node    in    out    parentNode    Attributes    attributes    List    childNodes    nodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    N    node    search    int    i    
for  (  int  i  =  0;  i  <  nodes.size  (  )  ;  i++  )  {	[BUGGY]  for  (  int  i  =  0;  i  ==  nodes.size(  );  i++)  {  [CONTEXT]  protected  static  <N  extends  Node>  Integer  indexInList(N  search,  List<N>  nodes)  {  Validate.notNull(search);  Validate.notNull(nodes);    [BUGGY]  for(  int  i  =  0;  i  ==  nodes.size  ()  ;  i++  ){  N  node  =  nodes.get(i);  if  (node.equals(search))  return  i;  }  return  null;  }        [CLASS]  Node    [METHOD]  indexInList  [RETURN_TYPE]  <N      N  search  List<N>  nodes  [VARIABLES]  boolean    Node    in    out    parentNode    Attributes    attributes    List    childNodes    nodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    N    node    search    int    i    
for  (  int  i  =  0;  i  <  nodes.size  (  )  ;  i++  )  {	[BUGGY]  for  (  int  i  =  6;  i  <  nodes.size(  );  i++)  {  [CONTEXT]  protected  static  <N  extends  Node>  Integer  indexInList(N  search,  List<N>  nodes)  {  Validate.notNull(search);  Validate.notNull(nodes);    [BUGGY]  for(  int  i  =  6;  i  <  nodes.size  ()  ;  i++  ){  N  node  =  nodes.get(i);  if  (node.equals(search))  return  i;  }  return  null;  }        [CLASS]  Node    [METHOD]  indexInList  [RETURN_TYPE]  <N      N  search  List<N>  nodes  [VARIABLES]  boolean    Node    in    out    parentNode    Attributes    attributes    List    childNodes    nodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    N    node    search    int    i    
for  (  int  i  =  0;  i  <  nodes.size  (  )  ;  i++  )  {	[BUGGY]  for  (  int  i  =  0;  i  <  nodes.size()  -  3  ;  i++)  {  [CONTEXT]  protected  static  <N  extends  Node>  Integer  indexInList(N  search,  List<N>  nodes)  {  Validate.notNull(search);  Validate.notNull(nodes);    [BUGGY]  for(  int  i  =  0;  i  <  nodes.size()  -  3  ;  i++  ){  N  node  =  nodes.get(i);  if  (node.equals(search))  return  i;  }  return  null;  }        [CLASS]  Node    [METHOD]  indexInList  [RETURN_TYPE]  <N      N  search  List<N>  nodes  [VARIABLES]  boolean    Node    in    out    parentNode    Attributes    attributes    List    childNodes    nodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    N    node    search    int    i    
for  (  int  i  =  0;  i  <  nodes.size  (  )  ;  i++  )  {	[BUGGY]  for  (  int  i  =  0;  i  <  searchs.size(  );  i++)  {  [CONTEXT]  protected  static  <N  extends  Node>  Integer  indexInList(N  search,  List<N>  nodes)  {  Validate.notNull(search);  Validate.notNull(nodes);    [BUGGY]  for(  int  i  =  0;  i  <  searchs.size  ()  ;  i++  ){  N  node  =  nodes.get(i);  if  (node.equals(search))  return  i;  }  return  null;  }        [CLASS]  Node    [METHOD]  indexInList  [RETURN_TYPE]  <N      N  search  List<N>  nodes  [VARIABLES]  boolean    Node    in    out    parentNode    Attributes    attributes    List    childNodes    nodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    N    node    search    int    i    
for  (  int  i  =  0;  i  <  nodes.size  (  )  ;  i++  )  {	[BUGGY]  for  (  nodent  i  =  0;  i  <  is.size(  );  i++)  {  [CONTEXT]  protected  static  <N  extends  Node>  Integer  indexInList(N  search,  List<N>  nodes)  {  Validate.notNull(search);  Validate.notNull(nodes);    [BUGGY]  for(  nodent  i  =  0;  i  <  is.size  ()  ;  i++  ){  N  node  =  nodes.get(i);  if  (node.equals(search))  return  i;  }  return  null;  }        [CLASS]  Node    [METHOD]  indexInList  [RETURN_TYPE]  <N      N  search  List<N>  nodes  [VARIABLES]  boolean    Node    in    out    parentNode    Attributes    attributes    List    childNodes    nodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    N    node    search    int    i    
for  (  int  i  =  0;  i  <  nodes.size  (  )  ;  i++  )  {	[BUGGY]  for  (  nodesnt  i  =  0;  i  <  i.size(  );  i++)  {  [CONTEXT]  protected  static  <N  extends  Node>  Integer  indexInList(N  search,  List<N>  nodes)  {  Validate.notNull(search);  Validate.notNull(nodes);    [BUGGY]  for(  nodesnt  i  =  0;  i  <  i.size  ()  ;  i++  ){  N  node  =  nodes.get(i);  if  (node.equals(search))  return  i;  }  return  null;  }        [CLASS]  Node    [METHOD]  indexInList  [RETURN_TYPE]  <N      N  search  List<N>  nodes  [VARIABLES]  boolean    Node    in    out    parentNode    Attributes    attributes    List    childNodes    nodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    N    node    search    int    i    
for  (  int  i  =  0;  i  <  nodes.size  (  )  ;  i++  )  {	[BUGGY]  for  (  int  i  =  0;  i  <  nodes.get(  );  i++)  {  [CONTEXT]  protected  static  <N  extends  Node>  Integer  indexInList(N  search,  List<N>  nodes)  {  Validate.notNull(search);  Validate.notNull(nodes);    [BUGGY]  for(  int  i  =  0;  i  <  nodes.get  ()  ;  i++  ){  N  node  =  nodes.get(i);  if  (node.equals(search))  return  i;  }  return  null;  }        [CLASS]  Node    [METHOD]  indexInList  [RETURN_TYPE]  <N      N  search  List<N>  nodes  [VARIABLES]  boolean    Node    in    out    parentNode    Attributes    attributes    List    childNodes    nodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    N    node    search    int    i    
if  (  node.equals  (  search  )  )  return  i;	[BUGGY]  if  (  search.equals(  search))return  i;  [CONTEXT]  protected  static  <N  extends  Node>  Integer  indexInList(N  search,  List<N>  nodes)  {  Validate.notNull(search);  Validate.notNull(nodes);    for  (int  i  =  0;  i  <  nodes.size();  i++)  {  N  node  =  nodes.get(i);  [BUGGY]  if(  search.equals  (  search  ))  return  i;    }  return  null;  }        [CLASS]  Node    [METHOD]  indexInList  [RETURN_TYPE]  <N      N  search  List<N>  nodes  [VARIABLES]  boolean    Node    in    out    parentNode    Attributes    attributes    List    childNodes    nodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    N    node    search    int    i    
if  (  node.equals  (  search  )  )  return  i;	[BUGGY]  if  (  node.equals(  node))return  i;  [CONTEXT]  protected  static  <N  extends  Node>  Integer  indexInList(N  search,  List<N>  nodes)  {  Validate.notNull(search);  Validate.notNull(nodes);    for  (int  i  =  0;  i  <  nodes.size();  i++)  {  N  node  =  nodes.get(i);  [BUGGY]  if(  node.equals  (  node  ))  return  i;    }  return  null;  }        [CLASS]  Node    [METHOD]  indexInList  [RETURN_TYPE]  <N      N  search  List<N>  nodes  [VARIABLES]  boolean    Node    in    out    parentNode    Attributes    attributes    List    childNodes    nodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    N    node    search    int    i    
N  node  =  nodes.get  (  i  )  ;	[BUGGY]  N  node  =  i.get(  nodes);  [CONTEXT]  protected  static  <N  extends  Node>  Integer  indexInList(N  search,  List<N>  nodes)  {  Validate.notNull(search);  Validate.notNull(nodes);    for  (int  i  =  0;  i  <  nodes.size();  i++)  {  [BUGGY]  N  node  =  i.get  (  nodes  )  ;  if  (node.equals(search))  return  i;  }  return  null;  }        [CLASS]  Node    [METHOD]  indexInList  [RETURN_TYPE]  <N      N  search  List<N>  nodes  [VARIABLES]  boolean    Node    in    out    parentNode    Attributes    attributes    List    childNodes    nodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    N    node    search    int    i    
N  node  =  nodes.get  (  i  )  ;	[BUGGY]  N  node  =  nodes.set(  i);  [CONTEXT]  protected  static  <N  extends  Node>  Integer  indexInList(N  search,  List<N>  nodes)  {  Validate.notNull(search);  Validate.notNull(nodes);    for  (int  i  =  0;  i  <  nodes.size();  i++)  {  [BUGGY]  N  node  =  nodes.set  (  i  )  ;  if  (node.equals(search))  return  i;  }  return  null;  }        [CLASS]  Node    [METHOD]  indexInList  [RETURN_TYPE]  <N      N  search  List<N>  nodes  [VARIABLES]  boolean    Node    in    out    parentNode    Attributes    attributes    List    childNodes    nodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    N    node    search    int    i    
N  node  =  nodes.get  (  i  )  ;	[BUGGY]  N  node  =  nodes  .get(  attributeKey)  ;  [CONTEXT]  protected  static  <N  extends  Node>  Integer  indexInList(N  search,  List<N>  nodes)  {  Validate.notNull(search);  Validate.notNull(nodes);    for  (int  i  =  0;  i  <  nodes.size();  i++)  {  [BUGGY]  N  node  =  nodes  .get  (  attributeKey  );  if  (node.equals(search))  return  i;  }  return  null;  }        [CLASS]  Node    [METHOD]  indexInList  [RETURN_TYPE]  <N      N  search  List<N>  nodes  [VARIABLES]  boolean    Node    in    out    parentNode    Attributes    attributes    List    childNodes    nodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    N    node    search    int    i    
N  node  =  nodes.get  (  i  )  ;	[BUGGY]    [CONTEXT]  protected  static  <N  extends  Node>  Integer  indexInList(N  search,  List<N>  nodes)  {  Validate.notNull(search);  Validate.notNull(nodes);    for  (int  i  =  0;  i  <  nodes.size();  i++)  {  [BUGGY]  N  node  =  nodes.get(i);    if  (node.equals(search))  return  i;  }  return  null;        [CLASS]  Node    [METHOD]  indexInList  [RETURN_TYPE]  <N      N  search  List<N>  nodes  [VARIABLES]  boolean    Node    in    out    parentNode    Attributes    attributes    List    childNodes    nodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    N    node    search    int    i    
for  (  int  i  =  0;  i  <  nodes.size  (  )  ;  i++  )  {	[BUGGY]  for  (  int  i  =  4;  i  <  nodes.size(  );  i++)  {  [CONTEXT]  protected  static  <N  extends  Node>  Integer  indexInList(N  search,  List<N>  nodes)  {  Validate.notNull(search);  Validate.notNull(nodes);    [BUGGY]  for(  int  i  =  4;  i  <  nodes.size  ()  ;  i++  ){  N  node  =  nodes.get(i);  if  (node.equals(search))  return  i;  }  return  null;  }        [CLASS]  Node    [METHOD]  indexInList  [RETURN_TYPE]  <N      N  search  List<N>  nodes  [VARIABLES]  boolean    Node    in    out    parentNode    Attributes    attributes    List    childNodes    nodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    N    node    search    int    i    
for  (  int  i  =  0;  i  <  nodes.size  (  )  ;  i++  )  {	[BUGGY]  for  (  int  i  =  0;  i  <  nodes.size()  +  0  ;  i++)  {  [CONTEXT]  protected  static  <N  extends  Node>  Integer  indexInList(N  search,  List<N>  nodes)  {  Validate.notNull(search);  Validate.notNull(nodes);    [BUGGY]  for(  int  i  =  0;  i  <  nodes.size()  +  0  ;  i++  ){  N  node  =  nodes.get(i);  if  (node.equals(search))  return  i;  }  return  null;  }        [CLASS]  Node    [METHOD]  indexInList  [RETURN_TYPE]  <N      N  search  List<N>  nodes  [VARIABLES]  boolean    Node    in    out    parentNode    Attributes    attributes    List    childNodes    nodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    N    node    search    int    i    
for  (  int  i  =  0;  i  <  nodes.size  (  )  ;  i++  )  {	[BUGGY]  for  (  int  i  =  0;  i  <  nodes.size()  +  4  ;  i++)  {  [CONTEXT]  protected  static  <N  extends  Node>  Integer  indexInList(N  search,  List<N>  nodes)  {  Validate.notNull(search);  Validate.notNull(nodes);    [BUGGY]  for(  int  i  =  0;  i  <  nodes.size()  +  4  ;  i++  ){  N  node  =  nodes.get(i);  if  (node.equals(search))  return  i;  }  return  null;  }        [CLASS]  Node    [METHOD]  indexInList  [RETURN_TYPE]  <N      N  search  List<N>  nodes  [VARIABLES]  boolean    Node    in    out    parentNode    Attributes    attributes    List    childNodes    nodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    N    node    search    int    i    
for  (  int  i  =  0;  i  <  nodes.size  (  )  ;  i++  )  {  N  node  =  nodes.get  (  i  )  ;  if  (  node.equals  (  search  )  )  return  i;  }	[BUGGY]    [CONTEXT]  protected  static  <N  extends  Node>  Integer  indexInList(N  search,  List<N>  nodes)  {  Validate.notNull(search);  Validate.notNull(nodes);    [BUGGY]  for  (int  i  =  0;  i  <  nodes.size();  i++)  {            return  null;        [CLASS]  Node    [METHOD]  indexInList  [RETURN_TYPE]  <N      N  search  List<N>  nodes  [VARIABLES]  boolean    Node    in    out    parentNode    Attributes    attributes    List    childNodes    nodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    N    node    search    int    i    
return  null;	[BUGGY]  return  this;  [CONTEXT]  protected  static  <N  extends  Node>  Integer  indexInList(N  search,  List<N>  nodes)  {  Validate.notNull(search);  Validate.notNull(nodes);    for  (int  i  =  0;  i  <  nodes.size();  i++)  {  N  node  =  nodes.get(i);  if  (node.equals(search))  return  i;  }  [BUGGY]  return  this;  }        [CLASS]  Node    [METHOD]  indexInList  [RETURN_TYPE]  <N      N  search  List<N>  nodes  [VARIABLES]  boolean    Node    in    out    parentNode    Attributes    attributes    List    childNodes    nodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    N    node    search    int    i    
outerHtml  (  accum  )  ;	[BUGGY]  indent(  accum);  [CONTEXT]  public  String  outerHtml()  {  StringBuilder  accum  =  new  StringBuilder();  [BUGGY]  indent  (  accum  )  ;  return  accum.toString();  }        [CLASS]  Node    [METHOD]  outerHtml  [RETURN_TYPE]  String      [VARIABLES]  Attributes    attributes    List    childNodes    nodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    StringBuilder    accum    Node    in    out    parentNode    
outerHtml  (  accum  )  ;	[BUGGY]    [CONTEXT]  public  String  outerHtml()  {  StringBuilder  accum  =  new  StringBuilder();  [BUGGY]  outerHtml(accum);    return  accum.toString();        [CLASS]  Node    [METHOD]  outerHtml  [RETURN_TYPE]  String      [VARIABLES]  Attributes    attributes    List    childNodes    nodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    StringBuilder    accum    Node    in    out    parentNode    
return  accum.toString  (  )  ;	[BUGGY]  return  accum.append(  );  [CONTEXT]  public  String  outerHtml()  {  StringBuilder  accum  =  new  StringBuilder();  outerHtml(accum);  [BUGGY]  return  accum.append  ()  ;  }        [CLASS]  Node    [METHOD]  outerHtml  [RETURN_TYPE]  String      [VARIABLES]  Attributes    attributes    List    childNodes    nodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    StringBuilder    accum    Node    in    out    parentNode    
return  accum.toString  (  )  ;	[BUGGY]  return  accum  .append(  relUrl)  ;  [CONTEXT]  public  String  outerHtml()  {  StringBuilder  accum  =  new  StringBuilder();  outerHtml(accum);  [BUGGY]  return  accum  .append  (  relUrl  );  }        [CLASS]  Node    [METHOD]  outerHtml  [RETURN_TYPE]  String      [VARIABLES]  Attributes    attributes    List    childNodes    nodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    StringBuilder    accum    Node    in    out    parentNode    
return  accum.toString  (  )  ;	[BUGGY]  return  accum  .append(  baseUri)  ;  [CONTEXT]  public  String  outerHtml()  {  StringBuilder  accum  =  new  StringBuilder();  outerHtml(accum);  [BUGGY]  return  accum  .append  (  baseUri  );  }        [CLASS]  Node    [METHOD]  outerHtml  [RETURN_TYPE]  String      [VARIABLES]  Attributes    attributes    List    childNodes    nodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    StringBuilder    accum    Node    in    out    parentNode    
return  accum.toString  (  )  ;	[BUGGY]    [CONTEXT]  public  String  outerHtml()  {  StringBuilder  accum  =  new  StringBuilder();  outerHtml(accum);  [BUGGY]  return  accum.toString();          [CLASS]  Node    [METHOD]  outerHtml  [RETURN_TYPE]  String      [VARIABLES]  Attributes    attributes    List    childNodes    nodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    StringBuilder    accum    Node    in    out    parentNode    
return  outerHtml  (  )  ;	[BUGGY]  return  parent(  );  [CONTEXT]  public  String  toString()  {  [BUGGY]  return  parent  ()  ;  }        [CLASS]  Node    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  Attributes    attributes    List    childNodes    nodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
return  outerHtml  (  )  ;	[BUGGY]    [CONTEXT]  public  String  toString()  {  [BUGGY]  return  outerHtml();          [CLASS]  Node    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  Attributes    attributes    List    childNodes    nodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
accum.append  (   "\n "  )  .append  (  StringUtils.leftPad  (   " ",  nodeDepth  (  )  -1  *  2  )  )  ;	[BUGGY]  accum.append(   "\n ").append(  StringUtils.leftPad(   " ",  nodeDepth(  )  -1  +  2));  [CONTEXT]  protected  void  indent(StringBuilder  accum)  {  [BUGGY]  accum.append  (   "\n "  )  .append  (  StringUtils.leftPad  (   " ",  nodeDepth  ()-1  +  2  ))  ;  }        [CLASS]  Node    [METHOD]  indent  [RETURN_TYPE]  void      StringBuilder  accum  [VARIABLES]  Attributes    attributes    List    childNodes    nodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    StringBuilder    accum    Node    in    out    parentNode    
accum.append  (   "\n "  )  .append  (  StringUtils.leftPad  (   " ",  nodeDepth  (  )  -1  *  2  )  )  ;	[BUGGY]  accum.append(   "\n\ ").append(  StringUtils.leftPad(   " ",  nodeDepth(  )  -1  *  2));  [CONTEXT]  protected  void  indent(StringBuilder  accum)  {  [BUGGY]  accum.append  (   "\n\ "  )  .append  (  StringUtils.leftPad  (   " ",  nodeDepth  ()-1  *  2  ))  ;  }        [CLASS]  Node    [METHOD]  indent  [RETURN_TYPE]  void      StringBuilder  accum  [VARIABLES]  Attributes    attributes    List    childNodes    nodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    StringBuilder    accum    Node    in    out    parentNode    
accum.append  (   "\n "  )  .append  (  StringUtils.leftPad  (   " ",  nodeDepth  (  )  -1  *  2  )  )  ;	[BUGGY]  accum.append(   "\n ").append(  StringUtils.leftPad(   " ",  nodeDepth(  )  -null  *  2));  [CONTEXT]  protected  void  indent(StringBuilder  accum)  {  [BUGGY]  accum.append  (   "\n "  )  .append  (  StringUtils.leftPad  (   " ",  nodeDepth  ()-null  *  2  ))  ;  }        [CLASS]  Node    [METHOD]  indent  [RETURN_TYPE]  void      StringBuilder  accum  [VARIABLES]  Attributes    attributes    List    childNodes    nodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    StringBuilder    accum    Node    in    out    parentNode    
accum.append  (   "\n "  )  .append  (  StringUtils.leftPad  (   " ",  nodeDepth  (  )  -1  *  2  )  )  ;	[BUGGY]  accum.append(   "\n ").append(  StringUtils.leftPad(   " ",  nodeDepth(  )  -1  *  ));  [CONTEXT]  protected  void  indent(StringBuilder  accum)  {  [BUGGY]  accum.append  (   "\n "  )  .append  (  StringUtils.leftPad  (   " ",  nodeDepth  ()-1  *))  ;  }        [CLASS]  Node    [METHOD]  indent  [RETURN_TYPE]  void      StringBuilder  accum  [VARIABLES]  Attributes    attributes    List    childNodes    nodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    StringBuilder    accum    Node    in    out    parentNode    
accum.append  (   "\n "  )  .append  (  StringUtils.leftPad  (   " ",  nodeDepth  (  )  -1  *  2  )  )  ;	[BUGGY]  accum  .append(  attributeKey  )  [CONTEXT]  protected  void  indent(StringBuilder  accum)  {  [BUGGY]  accum  .append  (  attributeKey  )  }        [CLASS]  Node    [METHOD]  indent  [RETURN_TYPE]  void      StringBuilder  accum  [VARIABLES]  Attributes    attributes    List    childNodes    nodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    StringBuilder    accum    Node    in    out    parentNode    
accum.append  (   "\n "  )  .append  (  StringUtils.leftPad  (   " ",  nodeDepth  (  )  -1  *  2  )  )  ;	[BUGGY]  accum.append(   "\n ").append(  StringUtils.leftPad(   " ",  parent(  )  -1  *  2));  [CONTEXT]  protected  void  indent(StringBuilder  accum)  {  [BUGGY]  accum.append  (   "\n "  )  .append  (  StringUtils.leftPad  (   " ",  parent  ()-1  *  2  ))  ;  }        [CLASS]  Node    [METHOD]  indent  [RETURN_TYPE]  void      StringBuilder  accum  [VARIABLES]  Attributes    attributes    List    childNodes    nodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    StringBuilder    accum    Node    in    out    parentNode    
accum.append  (   "\n "  )  .append  (  StringUtils.leftPad  (   " ",  nodeDepth  (  )  -1  *  2  )  )  ;	[BUGGY]    [CONTEXT]  protected  void  indent(StringBuilder  accum)  {  [BUGGY]  accum.append( "\n ").append(StringUtils.leftPad( " ",  nodeDepth()  -1  *  2));          [CLASS]  Node    [METHOD]  indent  [RETURN_TYPE]  void      StringBuilder  accum  [VARIABLES]  Attributes    attributes    List    childNodes    nodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    StringBuilder    accum    Node    in    out    parentNode    
accum.append  (   "\n "  )  .append  (  StringUtils.leftPad  (   " ",  nodeDepth  (  )  -1  *  2  )  )  ;	[BUGGY]  accum.append(   "\n ").append(  StringUtils.leftPad(   " ",  nodeDepth(  )  --8  *  2));  [CONTEXT]  protected  void  indent(StringBuilder  accum)  {  [BUGGY]  accum.append  (   "\n "  )  .append  (  StringUtils.leftPad  (   " ",  nodeDepth  ()--8  *  2  ))  ;  }        [CLASS]  Node    [METHOD]  indent  [RETURN_TYPE]  void      StringBuilder  accum  [VARIABLES]  Attributes    attributes    List    childNodes    nodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    StringBuilder    accum    Node    in    out    parentNode    
accum.append  (   "\n "  )  .append  (  StringUtils.leftPad  (   " ",  nodeDepth  (  )  -1  *  2  )  )  ;	[BUGGY]  accum.append(   "\n ").append(  StringUtils.leftPad(   " ",  nodeDepth(  )  -1  *  -4));  [CONTEXT]  protected  void  indent(StringBuilder  accum)  {  [BUGGY]  accum.append  (   "\n "  )  .append  (  StringUtils.leftPad  (   " ",  nodeDepth  ()-1  *  -4  ))  ;  }        [CLASS]  Node    [METHOD]  indent  [RETURN_TYPE]  void      StringBuilder  accum  [VARIABLES]  Attributes    attributes    List    childNodes    nodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    StringBuilder    accum    Node    in    out    parentNode    
if  (  this  ==  o  )  return  true;	[BUGGY]  if  (  this  >=  o)  return  true;  [CONTEXT]  public  boolean  equals(Object  o)  {  [BUGGY]  if(  this  >=  o  )return  true;      return  false;  }        [CLASS]  Node    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  Attributes    attributes    List    childNodes    nodes    siblings    Object    o    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
if  (  this  ==  o  )  return  true;	[BUGGY]  if  (  this  ==  o)  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  [BUGGY]  if(  this  ==  o  )return  false;      return  false;  }        [CLASS]  Node    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  Attributes    attributes    List    childNodes    nodes    siblings    Object    o    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
if  (  this  ==  o  )  return  true;  return  false;  }	[BUGGY]  return  true;  [CONTEXT]  public  boolean  equals(Object  o)  {  [BUGGY]  if  (this  ==  o)  return  true;    return  true;          [CLASS]  Node    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  Attributes    attributes    List    childNodes    nodes    siblings    Object    o    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
if  (  this  ==  o  )  return  true;  return  false;  }	[BUGGY]    [CONTEXT]  public  boolean  equals(Object  o)  {  [BUGGY]  if  (this  ==  o)  return  true;              [CLASS]  Node    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  Attributes    attributes    List    childNodes    nodes    siblings    Object    o    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
return  false;	[BUGGY]  return  true;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;      [BUGGY]  return  true;  }        [CLASS]  Node    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  Attributes    attributes    List    childNodes    nodes    siblings    Object    o    String    attributeKey    attributeValue    baseUri    relUrl    boolean    Node    in    out    parentNode    
int  result  =  parentNode  !=  null  ?  parentNode.hashCode  (  )  :  0;	[BUGGY]  long    result  =  parentNode  !=  null  ?  parentNode.hashCode(  )  :  0;  [CONTEXT]  public  int  hashCode()  {  [BUGGY]  longresult  =  parentNode  !=  null  ?  parentNode.hashCode  ():  0;      result  =  31  *  result  +  (attributes  !=  null  ?  attributes.hashCode()  :  0);  return  result;  }        [CLASS]  Node    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  Attributes    attributes    List    childNodes    nodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    int    result    Node    in    out    parentNode    
int  result  =  parentNode  !=  null  ?  parentNode.hashCode  (  )  :  0;	[BUGGY]  int  result  =  parentNode  ==  null  ?  parentNode.hashCode(  )  :  0;  [CONTEXT]  public  int  hashCode()  {  [BUGGY]  int  result  =  parentNode  ==  null  ?  parentNode.hashCode  ():  0;      result  =  31  *  result  +  (attributes  !=  null  ?  attributes.hashCode()  :  0);  return  result;  }        [CLASS]  Node    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  Attributes    attributes    List    childNodes    nodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    int    result    Node    in    out    parentNode    
int  result  =  parentNode  !=  null  ?  parentNode.hashCode  (  )  :  0;	[BUGGY]  int  result  =  out  !=  null  ?  parentNode.hashCode(  )  :  0;  [CONTEXT]  public  int  hashCode()  {  [BUGGY]  int  result  =  out  !=  null  ?  parentNode.hashCode  ():  0;      result  =  31  *  result  +  (attributes  !=  null  ?  attributes.hashCode()  :  0);  return  result;  }        [CLASS]  Node    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  Attributes    attributes    List    childNodes    nodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    int    result    Node    in    out    parentNode    
int  result  =  parentNode  !=  null  ?  parentNode.hashCode  (  )  :  0;	[BUGGY]  int  result    =    0;  [CONTEXT]  public  int  hashCode()  {  [BUGGY]  int  result=0;      result  =  31  *  result  +  (attributes  !=  null  ?  attributes.hashCode()  :  0);  return  result;  }        [CLASS]  Node    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  Attributes    attributes    List    childNodes    nodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    int    result    Node    in    out    parentNode    
int  result  =  parentNode  !=  null  ?  parentNode.hashCode  (  )  :  0;	[BUGGY]  int  result    =    parentNode.hashCode(  )  ;  [CONTEXT]  public  int  hashCode()  {  [BUGGY]  int  result=parentNode.hashCode  ();      result  =  31  *  result  +  (attributes  !=  null  ?  attributes.hashCode()  :  0);  return  result;  }        [CLASS]  Node    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  Attributes    attributes    List    childNodes    nodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    int    result    Node    in    out    parentNode    
int  result  =  parentNode  !=  null  ?  parentNode.hashCode  (  )  :  0;	[BUGGY]  int  result  =  parentNode  !=  null  ?  parentNode.childNodes(  )  :  0;  [CONTEXT]  public  int  hashCode()  {  [BUGGY]  int  result  =  parentNode  !=  null  ?  parentNode.childNodes  ():  0;      result  =  31  *  result  +  (attributes  !=  null  ?  attributes.hashCode()  :  0);  return  result;  }        [CLASS]  Node    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  Attributes    attributes    List    childNodes    nodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    int    result    Node    in    out    parentNode    
int  result  =  parentNode  !=  null  ?  parentNode.hashCode  (  )  :  0;	[BUGGY]  int  result  =  parentNode  !=  null  ?  parentNode  .childNode(  result)    :  0;  [CONTEXT]  public  int  hashCode()  {  [BUGGY]  int  result  =  parentNode  !=  null  ?  parentNode  .childNode  (  result  )  :  0;      result  =  31  *  result  +  (attributes  !=  null  ?  attributes.hashCode()  :  0);  return  result;  }        [CLASS]  Node    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  Attributes    attributes    List    childNodes    nodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    int    result    Node    in    out    parentNode    
int  result  =  parentNode  !=  null  ?  parentNode.hashCode  (  )  :  0;	[BUGGY]  int  result  =  out  !=  null  ?  parentNode.childNodes(  )  :  0;  [CONTEXT]  public  int  hashCode()  {  [BUGGY]  int  result  =  out  !=  null  ?  parentNode.childNodes  ():  0;      result  =  31  *  result  +  (attributes  !=  null  ?  attributes.hashCode()  :  0);  return  result;  }        [CLASS]  Node    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  Attributes    attributes    List    childNodes    nodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    int    result    Node    in    out    parentNode    
int  result  =  parentNode  !=  null  ?  parentNode.hashCode  (  )  :  0;	[BUGGY]    [CONTEXT]  public  int  hashCode()  {  [BUGGY]  int  result  =  parentNode  !=  null  ?  parentNode.hashCode()  :  0;        result  =  31  *  result  +  (attributes  !=  null  ?  attributes.hashCode()  :  0);  return  result;        [CLASS]  Node    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  Attributes    attributes    List    childNodes    nodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    int    result    Node    in    out    parentNode    
result  =  31  *  result  +  (  attributes  !=  null  ?  attributes.hashCode  (  )  :  0  )  ;	[BUGGY]  result  =  31  *  result  +    ==  (  attributes  !=  null  ?  attributes.hashCode(  )  :  0);  [CONTEXT]  public  int  hashCode()  {  int  result  =  parentNode  !=  null  ?  parentNode.hashCode()  :  0;      [BUGGY]  result  =  31  *  result  +==(  attributes  !=  null  ?  attributes.hashCode  ():  0  )  ;  return  result;  }        [CLASS]  Node    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  Attributes    attributes    List    childNodes    nodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    int    result    Node    in    out    parentNode    
result  =  31  *  result  +  (  attributes  !=  null  ?  attributes.hashCode  (  )  :  0  )  ;	[BUGGY]  result  =  31  -  result  +  (  attributes  !=  null  ?  attributes.hashCode(  )  :  0);  [CONTEXT]  public  int  hashCode()  {  int  result  =  parentNode  !=  null  ?  parentNode.hashCode()  :  0;      [BUGGY]  result  =  31  -  result  +(  attributes  !=  null  ?  attributes.hashCode  ():  0  )  ;  return  result;  }        [CLASS]  Node    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  Attributes    attributes    List    childNodes    nodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    int    result    Node    in    out    parentNode    
result  =  31  *  result  +  (  attributes  !=  null  ?  attributes.hashCode  (  )  :  0  )  ;	[BUGGY]  result  =  31  *  result  +  (  attributes  ==  null  ?  attributes.hashCode(  )  :  0);  [CONTEXT]  public  int  hashCode()  {  int  result  =  parentNode  !=  null  ?  parentNode.hashCode()  :  0;      [BUGGY]  result  =  31  *  result  +(  attributes  ==  null  ?  attributes.hashCode  ():  0  )  ;  return  result;  }        [CLASS]  Node    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  Attributes    attributes    List    childNodes    nodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    int    result    Node    in    out    parentNode    
result  =  31  *  result  +  (  attributes  !=  null  ?  attributes.hashCode  (  )  :  0  )  ;	[BUGGY]  result  =  22  *  result  +  (  attributes  !=  null  ?  attributes.hashCode(  )  :  0);  [CONTEXT]  public  int  hashCode()  {  int  result  =  parentNode  !=  null  ?  parentNode.hashCode()  :  0;      [BUGGY]  result  =  22  *  result  +(  attributes  !=  null  ?  attributes.hashCode  ():  0  )  ;  return  result;  }        [CLASS]  Node    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  Attributes    attributes    List    childNodes    nodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    int    result    Node    in    out    parentNode    
result  =  31  *  result  +  (  attributes  !=  null  ?  attributes.hashCode  (  )  :  0  )  ;	[BUGGY]  result  =  31  *  result  +  (  attributes  !=  null  ?  attributes.hashCode(  )  :  -3);  [CONTEXT]  public  int  hashCode()  {  int  result  =  parentNode  !=  null  ?  parentNode.hashCode()  :  0;      [BUGGY]  result  =  31  *  result  +(  attributes  !=  null  ?  attributes.hashCode  ():  -3  )  ;  return  result;  }        [CLASS]  Node    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  Attributes    attributes    List    childNodes    nodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    int    result    Node    in    out    parentNode    
result  =  31  *  result  +  (  attributes  !=  null  ?  attributes.hashCode  (  )  :  0  )  ;	[BUGGY]  result  =  31  *  attributes  +  (  result  !=  null  ?  attributes.hashCode(  )  :  0);  [CONTEXT]  public  int  hashCode()  {  int  result  =  parentNode  !=  null  ?  parentNode.hashCode()  :  0;      [BUGGY]  result  =  31  *  attributes  +(  result  !=  null  ?  attributes.hashCode  ():  0  )  ;  return  result;  }        [CLASS]  Node    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  Attributes    attributes    List    childNodes    nodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    int    result    Node    in    out    parentNode    
result  =  31  *  result  +  (  attributes  !=  null  ?  attributes.hashCode  (  )  :  0  )  ;	[BUGGY]  result    =    0);  [CONTEXT]  public  int  hashCode()  {  int  result  =  parentNode  !=  null  ?  parentNode.hashCode()  :  0;      [BUGGY]  result=0  )  ;  return  result;  }        [CLASS]  Node    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  Attributes    attributes    List    childNodes    nodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    int    result    Node    in    out    parentNode    
result  =  31  *  result  +  (  attributes  !=  null  ?  attributes.hashCode  (  )  :  0  )  ;	[BUGGY]  result    =    attributes.hashCode(  )  ;  [CONTEXT]  public  int  hashCode()  {  int  result  =  parentNode  !=  null  ?  parentNode.hashCode()  :  0;      [BUGGY]  result=attributes.hashCode  ();  return  result;  }        [CLASS]  Node    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  Attributes    attributes    List    childNodes    nodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    int    result    Node    in    out    parentNode    
result  =  31  *  result  +  (  attributes  !=  null  ?  attributes.hashCode  (  )  :  0  )  ;	[BUGGY]  result  =  31  *  result  +  (  attributes  !=  null  ?  attributes.Attributes(  )  :  0);  [CONTEXT]  public  int  hashCode()  {  int  result  =  parentNode  !=  null  ?  parentNode.hashCode()  :  0;      [BUGGY]  result  =  31  *  result  +(  attributes  !=  null  ?  attributes.Attributes  ():  0  )  ;  return  result;  }        [CLASS]  Node    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  Attributes    attributes    List    childNodes    nodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    int    result    Node    in    out    parentNode    
result  =  31  *  result  +  (  attributes  !=  null  ?  attributes.hashCode  (  )  :  0  )  ;	[BUGGY]  result  =  31L  *  result  +  (  attributes  !=  null  ?  attributes.hashCode(  )  :  0);  [CONTEXT]  public  int  hashCode()  {  int  result  =  parentNode  !=  null  ?  parentNode.hashCode()  :  0;      [BUGGY]  result  =  31L  *  result  +(  attributes  !=  null  ?  attributes.hashCode  ():  0  )  ;  return  result;  }        [CLASS]  Node    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  Attributes    attributes    List    childNodes    nodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    int    result    Node    in    out    parentNode    
result  =  31  *  result  +  (  attributes  !=  null  ?  attributes.hashCode  (  )  :  0  )  ;	[BUGGY]    [CONTEXT]  public  int  hashCode()  {  int  result  =  parentNode  !=  null  ?  parentNode.hashCode()  :  0;      [BUGGY]  result  =  31  *  result  +  (attributes  !=  null  ?  attributes.hashCode()  :  0);    return  result;        [CLASS]  Node    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  Attributes    attributes    List    childNodes    nodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    int    result    Node    in    out    parentNode    
result  =  31  *  result  +  (  attributes  !=  null  ?  attributes.hashCode  (  )  :  0  )  ;	[BUGGY]    result  =  31  *  result  +  (  attributes  !=  null  ?  attributes.hashCode(  )  :  0);  [CONTEXT]        [CLASS]  Node    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  Attributes    attributes    List    childNodes    nodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    int    result    Node    in    out    parentNode    
result  =  31  *  result  +  (  attributes  !=  null  ?  attributes.hashCode  (  )  :  0  )  ;	[BUGGY]  int  result  =  parentNode  !=  null  ?  parentNode.hashCode(  )  :  0;result  =  31  *  result  +  (  attributes  !=  null  ?  attributes.hashCode(  )  :  0);  [CONTEXT]        [CLASS]  Node    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  Attributes    attributes    List    childNodes    nodes    siblings    String    attributeKey    attributeValue    baseUri    relUrl    boolean    int    result    Node    in    out    parentNode    
private  String  key;	[BUGGY]  private  char  key;  [CONTEXT]      A  single  key  +  value  attribute.  Keys  are  trimmed  and  normalised  to  lower-case.    @author  Jonathan  Hedley,  jonathan@hedley.net  */  public  class  Attribute  {  [BUGGY]  private  char  key;  private  String  value;                      [CLASS]  Attribute      [VARIABLES]  
private  String  value;	[BUGGY]  private  char  value;  [CONTEXT]  A  single  key  +  value  attribute.  Keys  are  trimmed  and  normalised  to  lower-case.    @author  Jonathan  Hedley,  jonathan@hedley.net  */  public  class  Attribute  {  private  String  key;  [BUGGY]  private  char  value;                          [CLASS]  Attribute      [VARIABLES]  
Validate.notEmpty  (  key  )  ;	[BUGGY]  Validate.notEmpty(  value);  [CONTEXT]  public  Attribute(String  key,  String  value)  {  [BUGGY]  Validate.notEmpty  (  value  )  ;  Validate.notNull(value);  this.key  =  key.trim().toLowerCase();  this.value  =  value;  }        [CLASS]  Attribute    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  String    key    value    boolean    
Validate.notEmpty  (  key  )  ;	[BUGGY]  Validate.notNull(  key);  [CONTEXT]  public  Attribute(String  key,  String  value)  {  [BUGGY]  Validate.notNull  (  key  )  ;  Validate.notNull(value);  this.key  =  key.trim().toLowerCase();  this.value  =  value;  }        [CLASS]  Attribute    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  String    key    value    boolean    
Validate.notEmpty  (  key  )  ;	[BUGGY]  Validate  .notNull(  value)  ;  [CONTEXT]  public  Attribute(String  key,  String  value)  {  [BUGGY]  Validate  .notNull  (  value  );  Validate.notNull(value);  this.key  =  key.trim().toLowerCase();  this.value  =  value;  }        [CLASS]  Attribute    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  String    key    value    boolean    
Validate.notEmpty  (  key  )  ;	[BUGGY]    [CONTEXT]  public  Attribute(String  key,  String  value)  {  [BUGGY]  Validate.notEmpty(key);    Validate.notNull(value);  this.key  =  key.trim().toLowerCase();  this.value  =  value;        [CLASS]  Attribute    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  String    key    value    boolean    
Validate.notEmpty  (  key  )  ;	[BUGGY]  Validate.notNull(  value);  Validate.notEmpty(  key);  [CONTEXT]        [CLASS]  Attribute    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  String    key    value    boolean    
Validate.notNull  (  value  )  ;	[BUGGY]  Validate.notNull(  key);  [CONTEXT]  public  Attribute(String  key,  String  value)  {  Validate.notEmpty(key);  [BUGGY]  Validate.notNull  (  key  )  ;  this.key  =  key.trim().toLowerCase();  this.value  =  value;  }        [CLASS]  Attribute    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  String    key    value    boolean    
Validate.notNull  (  value  )  ;	[BUGGY]  Validate.notEmpty(  value);  [CONTEXT]  public  Attribute(String  key,  String  value)  {  Validate.notEmpty(key);  [BUGGY]  Validate.notEmpty  (  value  )  ;  this.key  =  key.trim().toLowerCase();  this.value  =  value;  }        [CLASS]  Attribute    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  String    key    value    boolean    
Validate.notNull  (  value  )  ;	[BUGGY]    [CONTEXT]  public  Attribute(String  key,  String  value)  {  Validate.notEmpty(key);  [BUGGY]  Validate.notNull(value);    this.key  =  key.trim().toLowerCase();  this.value  =  value;        [CLASS]  Attribute    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  String    key    value    boolean    
Validate.notNull  (  value  )  ;	[BUGGY]  this.key  =  key.trim(  ).toLowerCase(  );  Validate.notNull(  value);  [CONTEXT]        [CLASS]  Attribute    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  String    key    value    boolean    
Validate.notNull  (  value  )  ;	[BUGGY]  Validate.notEmpty(  key);Validate.notNull(  value);  [CONTEXT]        [CLASS]  Attribute    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  String    key    value    boolean    
this.key  =  key.trim  (  )  .toLowerCase  (  )  ;	[BUGGY]  this.key  =  value.trim(  ).toLowerCase(  );  [CONTEXT]  public  Attribute(String  key,  String  value)  {  Validate.notEmpty(key);  Validate.notNull(value);  [BUGGY]  this.key  =  value.trim  ()  .toLowerCase  ()  ;  this.value  =  value;  }        [CLASS]  Attribute    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  String    key    value    boolean    
this.key  =  key.trim  (  )  .toLowerCase  (  )  ;	[BUGGY]  this.key  =  key.equals(  ).toLowerCase(  );  [CONTEXT]  public  Attribute(String  key,  String  value)  {  Validate.notEmpty(key);  Validate.notNull(value);  [BUGGY]  this.key  =  key.equals  ()  .toLowerCase  ()  ;  this.value  =  value;  }        [CLASS]  Attribute    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  String    key    value    boolean    
this.key  =  key.trim  (  )  .toLowerCase  (  )  ;	[BUGGY]    [CONTEXT]  public  Attribute(String  key,  String  value)  {  Validate.notEmpty(key);  Validate.notNull(value);  [BUGGY]  this.key  =  key.trim().toLowerCase();    this.value  =  value;        [CLASS]  Attribute    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  String    key    value    boolean    
this.value  =  value;	[BUGGY]  this.value  =  key;  [CONTEXT]  public  Attribute(String  key,  String  value)  {  Validate.notEmpty(key);  Validate.notNull(value);  this.key  =  key.trim().toLowerCase();  [BUGGY]  this.value  =  key;  }        [CLASS]  Attribute    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  String    key    value    boolean    
return  key;	[BUGGY]  return  value;  [CONTEXT]  public  String  getKey()  {  [BUGGY]  return  value;  }        [CLASS]  Attribute    [METHOD]  getKey  [RETURN_TYPE]  String      [VARIABLES]  String    key    value    boolean    
Validate.notEmpty  (  key  )  ;	[BUGGY]  Validate.notEmpty(  value);  [CONTEXT]  public  void  setKey(String  key)  {  [BUGGY]  Validate.notEmpty  (  value  )  ;  this.key  =  key.trim().toLowerCase();  }        [CLASS]  Attribute    [METHOD]  setKey  [RETURN_TYPE]  void      String  key  [VARIABLES]  String    key    value    boolean    
Validate.notEmpty  (  key  )  ;	[BUGGY]  Validate.notNull(  key);  [CONTEXT]  public  void  setKey(String  key)  {  [BUGGY]  Validate.notNull  (  key  )  ;  this.key  =  key.trim().toLowerCase();  }        [CLASS]  Attribute    [METHOD]  setKey  [RETURN_TYPE]  void      String  key  [VARIABLES]  String    key    value    boolean    
Validate.notEmpty  (  key  )  ;  this.key  =  key.trim  (  )  .toLowerCase  (  )  ;	[BUGGY]    [CONTEXT]  public  void  setKey(String  key)  {  [BUGGY]  Validate.notEmpty(key);            [CLASS]  Attribute    [METHOD]  setKey  [RETURN_TYPE]  void      String  key  [VARIABLES]  String    key    value    boolean    
Validate.notEmpty  (  key  )  ;  this.key  =  key.trim  (  )  .toLowerCase  (  )  ;	[BUGGY]  this.key  =  key.trim(  ).toLowerCase(  );  Validate.notEmpty(  key);  [CONTEXT]        [CLASS]  Attribute    [METHOD]  setKey  [RETURN_TYPE]  void      String  key  [VARIABLES]  String    key    value    boolean    
Validate.notEmpty  (  key  )  ;  this.key  =  key.trim  (  )  .toLowerCase  (  )  ;	[BUGGY]  this.key  =  key.trim(  ).toLowerCase(  );Validate.notEmpty(  key);  this.key  =  key.trim(  ).toLowerCase(  );  [CONTEXT]        [CLASS]  Attribute    [METHOD]  setKey  [RETURN_TYPE]  void      String  key  [VARIABLES]  String    key    value    boolean    
this.key  =  key.trim  (  )  .toLowerCase  (  )  ;	[BUGGY]  this.key  =  value.trim(  ).toLowerCase(  );  [CONTEXT]  public  void  setKey(String  key)  {  Validate.notEmpty(key);  [BUGGY]  this.key  =  value.trim  ()  .toLowerCase  ()  ;  }        [CLASS]  Attribute    [METHOD]  setKey  [RETURN_TYPE]  void      String  key  [VARIABLES]  String    key    value    boolean    
this.key  =  key.trim  (  )  .toLowerCase  (  )  ;	[BUGGY]  this.key  =  key.equals(  ).toLowerCase(  );  [CONTEXT]  public  void  setKey(String  key)  {  Validate.notEmpty(key);  [BUGGY]  this.key  =  key.equals  ()  .toLowerCase  ()  ;  }        [CLASS]  Attribute    [METHOD]  setKey  [RETURN_TYPE]  void      String  key  [VARIABLES]  String    key    value    boolean    
this.key  =  key.trim  (  )  .toLowerCase  (  )  ;	[BUGGY]    [CONTEXT]  public  void  setKey(String  key)  {  Validate.notEmpty(key);  [BUGGY]  this.key  =  key.trim().toLowerCase();          [CLASS]  Attribute    [METHOD]  setKey  [RETURN_TYPE]  void      String  key  [VARIABLES]  String    key    value    boolean    
this.key  =  key.trim  (  )  .toLowerCase  (  )  ;	[BUGGY]  this.key  =  value.equals(  ).toLowerCase(  );  [CONTEXT]  public  void  setKey(String  key)  {  Validate.notEmpty(key);  [BUGGY]  this.key  =  value.equals  ()  .toLowerCase  ()  ;  }        [CLASS]  Attribute    [METHOD]  setKey  [RETURN_TYPE]  void      String  key  [VARIABLES]  String    key    value    boolean    
return  value;	[BUGGY]  return  key;  [CONTEXT]  public  String  getValue()  {  [BUGGY]  return  key;  }        [CLASS]  Attribute    [METHOD]  getValue  [RETURN_TYPE]  String      [VARIABLES]  String    key    value    boolean    
Validate.notNull  (  value  )  ;	[BUGGY]  Validate.notNull(  key);  [CONTEXT]  public  void  setValue(String  value)  {  [BUGGY]  Validate.notNull  (  key  )  ;  this.value  =  value;  }        [CLASS]  Attribute    [METHOD]  setValue  [RETURN_TYPE]  void      String  value  [VARIABLES]  String    key    value    boolean    
Validate.notNull  (  value  )  ;	[BUGGY]  Validate.notEmpty(  value);  [CONTEXT]  public  void  setValue(String  value)  {  [BUGGY]  Validate.notEmpty  (  value  )  ;  this.value  =  value;  }        [CLASS]  Attribute    [METHOD]  setValue  [RETURN_TYPE]  void      String  value  [VARIABLES]  String    key    value    boolean    
Validate.notNull  (  value  )  ;  this.value  =  value;	[BUGGY]    [CONTEXT]  public  void  setValue(String  value)  {  [BUGGY]  Validate.notNull(value);            [CLASS]  Attribute    [METHOD]  setValue  [RETURN_TYPE]  void      String  value  [VARIABLES]  String    key    value    boolean    
Validate.notNull  (  value  )  ;	[BUGGY]    Validate.notNull(  value);  [CONTEXT]        [CLASS]  Attribute    [METHOD]  setValue  [RETURN_TYPE]  void      String  value  [VARIABLES]  String    key    value    boolean    
Validate.notNull  (  value  )  ;	[BUGGY]  Validate.notEmpty(  key);Validate.notNull(  value);  [CONTEXT]        [CLASS]  Attribute    [METHOD]  setValue  [RETURN_TYPE]  void      String  value  [VARIABLES]  String    key    value    boolean    
this.value  =  value;	[BUGGY]  this.value  =  key;  [CONTEXT]  public  void  setValue(String  value)  {  Validate.notNull(value);  [BUGGY]  this.value  =  key;  }        [CLASS]  Attribute    [METHOD]  setValue  [RETURN_TYPE]  void      String  value  [VARIABLES]  String    key    value    boolean    
return  String.format  (   "%s=\ "%s\ " ",  key,  StringEscapeUtils.escapeHtml  (  value  )  )  ;	[BUGGY]  return  String.format(   "%s=\ "%s\ "=\ ",  key,  StringEscapeUtils.escapeHtml(  value));  [CONTEXT]  public  String  html()  {  [BUGGY]  return  String.format  (   "%s=\ "%s\ "=\ ",  key,  StringEscapeUtils.escapeHtml  (  value  ))  ;  }        [CLASS]  Attribute    [METHOD]  html  [RETURN_TYPE]  String      [VARIABLES]  String    key    value    boolean    
return  String.format  (   "%s=\ "%s\ " ",  key,  StringEscapeUtils.escapeHtml  (  value  )  )  ;	[BUGGY]  return  String.format(   "%s=\ "%s\ " ",  value,  StringEscapeUtils.escapeHtml(  key));  [CONTEXT]  public  String  html()  {  [BUGGY]  return  String.format  (   "%s=\ "%s\ " ",  value,  StringEscapeUtils.escapeHtml  (  key  ))  ;  }        [CLASS]  Attribute    [METHOD]  html  [RETURN_TYPE]  String      [VARIABLES]  String    key    value    boolean    
return  String.format  (   "%s=\ "%s\ " ",  key,  StringEscapeUtils.escapeHtml  (  value  )  )  ;	[BUGGY]  return  String.format(   "%s=\ "%s\ " ",    StringEscapeUtils.escapeHtml(  value));  [CONTEXT]  public  String  html()  {  [BUGGY]  return  String.format  (   "%s=\ "%s\ " ",StringEscapeUtils.escapeHtml  (  value  ))  ;  }        [CLASS]  Attribute    [METHOD]  html  [RETURN_TYPE]  String      [VARIABLES]  String    key    value    boolean    
return  String.format  (   "%s=\ "%s\ " ",  key,  StringEscapeUtils.escapeHtml  (  value  )  )  ;	[BUGGY]  return  String.format(   "= ",  key,  StringEscapeUtils.escapeHtml(  value));  [CONTEXT]  public  String  html()  {  [BUGGY]  return  String.format  (   "= ",  key,  StringEscapeUtils.escapeHtml  (  value  ))  ;  }        [CLASS]  Attribute    [METHOD]  html  [RETURN_TYPE]  String      [VARIABLES]  String    key    value    boolean    
return  String.format  (   "%s=\ "%s\ " ",  key,  StringEscapeUtils.escapeHtml  (  value  )  )  ;	[BUGGY]  return  String.format(   "%s=\ "%s\ " ",  key,  StringEscapeUtils  .unescapeHtml(  value)  );  [CONTEXT]  public  String  html()  {  [BUGGY]  return  String.format  (   "%s=\ "%s\ " ",  key,  StringEscapeUtils  .unescapeHtml  (  value  )  )  ;  }        [CLASS]  Attribute    [METHOD]  html  [RETURN_TYPE]  String      [VARIABLES]  String    key    value    boolean    
return  String.format  (   "%s=\ "%s\ " ",  key,  StringEscapeUtils.escapeHtml  (  value  )  )  ;  }	[BUGGY]    [CONTEXT]  public  String  html()  {  [BUGGY]  return  String.format( "%s=\ "%s\ " ",  key,  StringEscapeUtils.escapeHtml(value));          [CLASS]  Attribute    [METHOD]  html  [RETURN_TYPE]  String      [VARIABLES]  String    key    value    boolean    
return  String.format  (   "%s=\ "%s\ " ",  key,  StringEscapeUtils.escapeHtml  (  value  )  )  ;	[BUGGY]  return  String.format(   "%s=\ "%s\ " ",  key,  StringEscapeUtils.escapeHtml(  key));  [CONTEXT]  public  String  html()  {  [BUGGY]  return  String.format  (   "%s=\ "%s\ " ",  key,  StringEscapeUtils.escapeHtml  (  key  ))  ;  }        [CLASS]  Attribute    [METHOD]  html  [RETURN_TYPE]  String      [VARIABLES]  String    key    value    boolean    
return  html  (  )  ;	[BUGGY]    [CONTEXT]  public  String  toString()  {  [BUGGY]  return  html();          [CLASS]  Attribute    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  String    key    value    boolean    
String  value  =  StringEscapeUtils.unescapeHtml  (  encodedValue  )  ;	[BUGGY]  char  value  =  StringEscapeUtils.unescapeHtml(  encodedValue);  [CONTEXT]  public  static  Attribute  createFromEncoded(String  unencodedKey,  String  encodedValue)  {  [BUGGY]  char  value  =  StringEscapeUtils.unescapeHtml  (  encodedValue  )  ;  return  new  Attribute(unencodedKey,  value);  }        [CLASS]  Attribute    [METHOD]  createFromEncoded  [RETURN_TYPE]  Attribute      String  unencodedKey  String  encodedValue  [VARIABLES]  String    encodedValue    key    unencodedKey    value    boolean    
String  value  =  StringEscapeUtils.unescapeHtml  (  encodedValue  )  ;	[BUGGY]  String  value  =  StringEscapeUtils.unescapeHtml(  unencodedKey);  [CONTEXT]  public  static  Attribute  createFromEncoded(String  unencodedKey,  String  encodedValue)  {  [BUGGY]  String  value  =  StringEscapeUtils.unescapeHtml  (  unencodedKey  )  ;  return  new  Attribute(unencodedKey,  value);  }        [CLASS]  Attribute    [METHOD]  createFromEncoded  [RETURN_TYPE]  Attribute      String  unencodedKey  String  encodedValue  [VARIABLES]  String    encodedValue    key    unencodedKey    value    boolean    
String  value  =  StringEscapeUtils.unescapeHtml  (  encodedValue  )  ;	[BUGGY]  String  value  =  StringEscapeUtils.escapeHtml(  encodedValue);  [CONTEXT]  public  static  Attribute  createFromEncoded(String  unencodedKey,  String  encodedValue)  {  [BUGGY]  String  value  =  StringEscapeUtils.escapeHtml  (  encodedValue  )  ;  return  new  Attribute(unencodedKey,  value);  }        [CLASS]  Attribute    [METHOD]  createFromEncoded  [RETURN_TYPE]  Attribute      String  unencodedKey  String  encodedValue  [VARIABLES]  String    encodedValue    key    unencodedKey    value    boolean    
String  value  =  StringEscapeUtils.unescapeHtml  (  encodedValue  )  ;	[BUGGY]  String  value  =  StringEscapeUtils  .escapeHtml(  unencodedKey)  ;  [CONTEXT]  public  static  Attribute  createFromEncoded(String  unencodedKey,  String  encodedValue)  {  [BUGGY]  String  value  =  StringEscapeUtils  .escapeHtml  (  unencodedKey  );  return  new  Attribute(unencodedKey,  value);  }        [CLASS]  Attribute    [METHOD]  createFromEncoded  [RETURN_TYPE]  Attribute      String  unencodedKey  String  encodedValue  [VARIABLES]  String    encodedValue    key    unencodedKey    value    boolean    
String  value  =  StringEscapeUtils.unescapeHtml  (  encodedValue  )  ;  return  new  Attribute  (  unencodedKey,  value  )  ;	[BUGGY]  return  new  Attribute(  unencodedKey,  value);  String  value  =  StringEscapeUtils.unescapeHtml(  encodedValue);  [CONTEXT]        [CLASS]  Attribute    [METHOD]  createFromEncoded  [RETURN_TYPE]  Attribute      String  unencodedKey  String  encodedValue  [VARIABLES]  String    encodedValue    key    unencodedKey    value    boolean    
String  value  =  StringEscapeUtils.unescapeHtml  (  encodedValue  )  ;  return  new  Attribute  (  unencodedKey,  value  )  ;	[BUGGY]  String  value  =  StringEscapeUtils.unescapeHtml(  encodedValue);String  value  =  StringEscapeUtils.unescapeHtml(  encodedValue);  return  new  Attribute(  unencodedKey,  value);  [CONTEXT]        [CLASS]  Attribute    [METHOD]  createFromEncoded  [RETURN_TYPE]  Attribute      String  unencodedKey  String  encodedValue  [VARIABLES]  String    encodedValue    key    unencodedKey    value    boolean    
String  value  =  StringEscapeUtils.unescapeHtml  (  encodedValue  )  ;	[BUGGY]  String  value  =  StringEscapeUtils.unescapeHtml(  value);  [CONTEXT]  public  static  Attribute  createFromEncoded(String  unencodedKey,  String  encodedValue)  {  [BUGGY]  String  value  =  StringEscapeUtils.unescapeHtml  (  value  )  ;  return  new  Attribute(unencodedKey,  value);  }        [CLASS]  Attribute    [METHOD]  createFromEncoded  [RETURN_TYPE]  Attribute      String  unencodedKey  String  encodedValue  [VARIABLES]  String    encodedValue    key    unencodedKey    value    boolean    
String  value  =  StringEscapeUtils.unescapeHtml  (  encodedValue  )  ;	[BUGGY]    [CONTEXT]  public  static  Attribute  createFromEncoded(String  unencodedKey,  String  encodedValue)  {  [BUGGY]  String  value  =  StringEscapeUtils.unescapeHtml(encodedValue);    return  new  Attribute(unencodedKey,  value);        [CLASS]  Attribute    [METHOD]  createFromEncoded  [RETURN_TYPE]  Attribute      String  unencodedKey  String  encodedValue  [VARIABLES]  String    encodedValue    key    unencodedKey    value    boolean    
return  new  Attribute  (  unencodedKey,  value  )  ;	[BUGGY]  return  new  Attribute(    value);  [CONTEXT]  public  static  Attribute  createFromEncoded(String  unencodedKey,  String  encodedValue)  {  String  value  =  StringEscapeUtils.unescapeHtml(encodedValue);  [BUGGY]  return  new  Attribute  (value  )  ;  }        [CLASS]  Attribute    [METHOD]  createFromEncoded  [RETURN_TYPE]  Attribute      String  unencodedKey  String  encodedValue  [VARIABLES]  String    encodedValue    key    unencodedKey    value    boolean    
return  new  Attribute  (  unencodedKey,  value  )  ;	[BUGGY]  return  new  Attribute(  unencodedKey);  [CONTEXT]  public  static  Attribute  createFromEncoded(String  unencodedKey,  String  encodedValue)  {  String  value  =  StringEscapeUtils.unescapeHtml(encodedValue);  [BUGGY]  return  new  Attribute  (  unencodedKey  )  ;  }        [CLASS]  Attribute    [METHOD]  createFromEncoded  [RETURN_TYPE]  Attribute      String  unencodedKey  String  encodedValue  [VARIABLES]  String    encodedValue    key    unencodedKey    value    boolean    
return  new  Attribute  (  unencodedKey,  value  )  ;	[BUGGY]  return  new  Attribute(  key,  value);  [CONTEXT]  public  static  Attribute  createFromEncoded(String  unencodedKey,  String  encodedValue)  {  String  value  =  StringEscapeUtils.unescapeHtml(encodedValue);  [BUGGY]  return  new  Attribute  (  key,  value  )  ;  }        [CLASS]  Attribute    [METHOD]  createFromEncoded  [RETURN_TYPE]  Attribute      String  unencodedKey  String  encodedValue  [VARIABLES]  String    encodedValue    key    unencodedKey    value    boolean    
return  new  Attribute  (  unencodedKey,  value  )  ;	[BUGGY]  return  new  Attribute(  unencodedKey,  key);  [CONTEXT]  public  static  Attribute  createFromEncoded(String  unencodedKey,  String  encodedValue)  {  String  value  =  StringEscapeUtils.unescapeHtml(encodedValue);  [BUGGY]  return  new  Attribute  (  unencodedKey,  key  )  ;  }        [CLASS]  Attribute    [METHOD]  createFromEncoded  [RETURN_TYPE]  Attribute      String  unencodedKey  String  encodedValue  [VARIABLES]  String    encodedValue    key    unencodedKey    value    boolean    
return  new  Attribute  (  unencodedKey,  value  )  ;	[BUGGY]  return  new  Attribute(  value,  unencodedKey);  [CONTEXT]  public  static  Attribute  createFromEncoded(String  unencodedKey,  String  encodedValue)  {  String  value  =  StringEscapeUtils.unescapeHtml(encodedValue);  [BUGGY]  return  new  Attribute  (  value,  unencodedKey  )  ;  }        [CLASS]  Attribute    [METHOD]  createFromEncoded  [RETURN_TYPE]  Attribute      String  unencodedKey  String  encodedValue  [VARIABLES]  String    encodedValue    key    unencodedKey    value    boolean    
if  (  this  ==  o  )  return  true;	[BUGGY]  if  (  this  >  o)  return  true;  [CONTEXT]  public  boolean  equals(Object  o)  {  [BUGGY]  if(  this  >  o  )return  true;  if  (!(o  instanceof  Attribute))  return  false;    Attribute  attribute  =  (Attribute)  o;    if  (key  !=  null  ?  !key.equals(attribute.key)  :  attribute.key  !=  null)  return  false;  if  (value  !=  null  ?  !value.equals(attribute.value)  :  attribute.value  !=  null)  return  false;    return  true;  }        [CLASS]  Attribute    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  Object    o    String    encodedValue    key    unencodedKey    value    boolean    Attribute    attribute    
if  (  this  ==  o  )  return  true;	[BUGGY]  if  (  this  ==  o)  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  [BUGGY]  if(  this  ==  o  )return  false;  if  (!(o  instanceof  Attribute))  return  false;    Attribute  attribute  =  (Attribute)  o;    if  (key  !=  null  ?  !key.equals(attribute.key)  :  attribute.key  !=  null)  return  false;  if  (value  !=  null  ?  !value.equals(attribute.value)  :  attribute.value  !=  null)  return  false;    return  true;  }        [CLASS]  Attribute    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  Object    o    String    encodedValue    key    unencodedKey    value    boolean    Attribute    attribute    
if  (  !  (  o  instanceof  Attribute  )  )  return  false;	[BUGGY]  if  (  !(  o    !=    Attribute))  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  [BUGGY]  if(  !  (  o!=Attribute  ))return  false;    Attribute  attribute  =  (Attribute)  o;    if  (key  !=  null  ?  !key.equals(attribute.key)  :  attribute.key  !=  null)  return  false;  if  (value  !=  null  ?  !value.equals(attribute.value)  :  attribute.value  !=  null)  return  false;    return  true;  }        [CLASS]  Attribute    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  Object    o    String    encodedValue    key    unencodedKey    value    boolean    Attribute    attribute    
if  (  !  (  o  instanceof  Attribute  )  )  return  false;	[BUGGY]  if  (  !(  o  instanceof  Attribute))  return  true;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  [BUGGY]  if(  !  (  o  instanceof  Attribute  ))return  true;    Attribute  attribute  =  (Attribute)  o;    if  (key  !=  null  ?  !key.equals(attribute.key)  :  attribute.key  !=  null)  return  false;  if  (value  !=  null  ?  !value.equals(attribute.value)  :  attribute.value  !=  null)  return  false;    return  true;  }        [CLASS]  Attribute    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  Object    o    String    encodedValue    key    unencodedKey    value    boolean    Attribute    attribute    
if  (  key  !=  null  ?  !key.equals  (  attribute.key  )  :  attribute.key  !=  null  )  return  false;	[BUGGY]  if  (  key  ==  null  ?  !key.equals(  attribute.key)  :  attribute.key  ==  null)  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (!(o  instanceof  Attribute))  return  false;    Attribute  attribute  =  (Attribute)  o;    [BUGGY]  if(  key  ==  null  ?  !key.equals  (  attribute.key  ):  attribute.key  ==  null  )return  false;  if  (value  !=  null  ?  !value.equals(attribute.value)  :  attribute.value  !=  null)  return  false;    return  true;  }        [CLASS]  Attribute    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  Object    o    String    encodedValue    key    unencodedKey    value    boolean    Attribute    attribute    
if  (  key  !=  null  ?  !key.equals  (  attribute.key  )  :  attribute.key  !=  null  )  return  false;	[BUGGY]  if  (  key  !=  null  ?  !key.equals(  attribute.key)  :  attribute.key  ==  null)  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (!(o  instanceof  Attribute))  return  false;    Attribute  attribute  =  (Attribute)  o;    [BUGGY]  if(  key  !=  null  ?  !key.equals  (  attribute.key  ):  attribute.key  ==  null  )return  false;  if  (value  !=  null  ?  !value.equals(attribute.value)  :  attribute.value  !=  null)  return  false;    return  true;  }        [CLASS]  Attribute    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  Object    o    String    encodedValue    key    unencodedKey    value    boolean    Attribute    attribute    
if  (  key  !=  null  ?  !key.equals  (  attribute.key  )  :  attribute.key  !=  null  )  return  false;	[BUGGY]  if  (  key  !=  null  ?  !key.equals(  attribute.key)  :  attribute.key  !=  null)  return  true;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (!(o  instanceof  Attribute))  return  false;    Attribute  attribute  =  (Attribute)  o;    [BUGGY]  if(  key  !=  null  ?  !key.equals  (  attribute.key  ):  attribute.key  !=  null  )return  true;  if  (value  !=  null  ?  !value.equals(attribute.value)  :  attribute.value  !=  null)  return  false;    return  true;  }        [CLASS]  Attribute    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  Object    o    String    encodedValue    key    unencodedKey    value    boolean    Attribute    attribute    
if  (  key  !=  null  ?  !key.equals  (  attribute.key  )  :  attribute.key  !=  null  )  return  false;	[BUGGY]  if  (  value  !=  null  ?  !key.equals(  attribute.key)  :  attribute.key  !=  null)  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (!(o  instanceof  Attribute))  return  false;    Attribute  attribute  =  (Attribute)  o;    [BUGGY]  if(  value  !=  null  ?  !key.equals  (  attribute.key  ):  attribute.key  !=  null  )return  false;  if  (value  !=  null  ?  !value.equals(attribute.value)  :  attribute.value  !=  null)  return  false;    return  true;  }        [CLASS]  Attribute    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  Object    o    String    encodedValue    key    unencodedKey    value    boolean    Attribute    attribute    
if  (  key  !=  null  ?  !key.equals  (  attribute.key  )  :  attribute.key  !=  null  )  return  false;	[BUGGY]  if  (  key  !=  null  ?  !key.equals(  unencodedKey)  :  attribute.key  !=  null)  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (!(o  instanceof  Attribute))  return  false;    Attribute  attribute  =  (Attribute)  o;    [BUGGY]  if(  key  !=  null  ?  !key.equals  (  unencodedKey  ):  attribute.key  !=  null  )return  false;  if  (value  !=  null  ?  !value.equals(attribute.value)  :  attribute.value  !=  null)  return  false;    return  true;  }        [CLASS]  Attribute    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  Object    o    String    encodedValue    key    unencodedKey    value    boolean    Attribute    attribute    
if  (  key  !=  null  ?  !key.equals  (  attribute.key  )  :  attribute.key  !=  null  )  return  false;	[BUGGY]  if  (  attribute  !=  null  ?  !key.equals(  key.key)  :  attribute.key  !=  null)  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (!(o  instanceof  Attribute))  return  false;    Attribute  attribute  =  (Attribute)  o;    [BUGGY]  if(  attribute  !=  null  ?  !key.equals  (  key.key  ):  attribute.key  !=  null  )return  false;  if  (value  !=  null  ?  !value.equals(attribute.value)  :  attribute.value  !=  null)  return  false;    return  true;  }        [CLASS]  Attribute    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  Object    o    String    encodedValue    key    unencodedKey    value    boolean    Attribute    attribute    
if  (  key  !=  null  ?  !key.equals  (  attribute.key  )  :  attribute.key  !=  null  )  return  false;	[BUGGY]  if  (  attribute.key  !=  null  ?  !key.equals(  key)  :  attribute.key  !=  null)  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (!(o  instanceof  Attribute))  return  false;    Attribute  attribute  =  (Attribute)  o;    [BUGGY]  if(  attribute.key  !=  null  ?  !key.equals  (  key  ):  attribute.key  !=  null  )return  false;  if  (value  !=  null  ?  !value.equals(attribute.value)  :  attribute.value  !=  null)  return  false;    return  true;  }        [CLASS]  Attribute    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  Object    o    String    encodedValue    key    unencodedKey    value    boolean    Attribute    attribute    
if  (  key  !=  null  ?  !key.equals  (  attribute.key  )  :  attribute.key  !=  null  )  return  false;	[BUGGY]  if  (  key  !=  null  ?  !key.equals(  attribute)  :  attribute.key.key  !=  null)  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (!(o  instanceof  Attribute))  return  false;    Attribute  attribute  =  (Attribute)  o;    [BUGGY]  if(  key  !=  null  ?  !key.equals  (  attribute  ):  attribute.key.key  !=  null  )return  false;  if  (value  !=  null  ?  !value.equals(attribute.value)  :  attribute.value  !=  null)  return  false;    return  true;  }        [CLASS]  Attribute    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  Object    o    String    encodedValue    key    unencodedKey    value    boolean    Attribute    attribute    
if  (  key  !=  null  ?  !key.equals  (  attribute.key  )  :  attribute.key  !=  null  )  return  false;	[BUGGY]  if  (  attribute.key  !=  null)  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (!(o  instanceof  Attribute))  return  false;    Attribute  attribute  =  (Attribute)  o;    [BUGGY]  if(  attribute.key  !=  null  )return  false;  if  (value  !=  null  ?  !value.equals(attribute.value)  :  attribute.value  !=  null)  return  false;    return  true;  }        [CLASS]  Attribute    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  Object    o    String    encodedValue    key    unencodedKey    value    boolean    Attribute    attribute    
if  (  key  !=  null  ?  !key.equals  (  attribute.key  )  :  attribute.key  !=  null  )  return  false;	[BUGGY]  if  (  key  !=  false  ?  !key.equals(  attribute.key)  :  attribute.key  !=  false)  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (!(o  instanceof  Attribute))  return  false;    Attribute  attribute  =  (Attribute)  o;    [BUGGY]  if(  key  !=  false  ?  !key.equals  (  attribute.key  ):  attribute.key  !=  false  )return  false;  if  (value  !=  null  ?  !value.equals(attribute.value)  :  attribute.value  !=  null)  return  false;    return  true;  }        [CLASS]  Attribute    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  Object    o    String    encodedValue    key    unencodedKey    value    boolean    Attribute    attribute    
if  (  key  !=  null  ?  !key.equals  (  attribute.key  )  :  attribute.key  !=  null  )  return  false;  if  (  value  !=  null  ?  !value.equals  (  attribute.value  )  :  attribute.value  !=  null  )  return  false;  return  true;  }	[BUGGY]  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (!(o  instanceof  Attribute))  return  false;    Attribute  attribute  =  (Attribute)  o;    [BUGGY]  if  (key  !=  null  ?  !key.equals(attribute.key)  :  attribute.key  !=  null)  return  false;    return  false;            [CLASS]  Attribute    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  Object    o    String    encodedValue    key    unencodedKey    value    boolean    Attribute    attribute    
if  (  key  !=  null  ?  !key.equals  (  attribute.key  )  :  attribute.key  !=  null  )  return  false;  if  (  value  !=  null  ?  !value.equals  (  attribute.value  )  :  attribute.value  !=  null  )  return  false;  return  true;  }	[BUGGY]    [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (!(o  instanceof  Attribute))  return  false;    Attribute  attribute  =  (Attribute)  o;    [BUGGY]  if  (key  !=  null  ?  !key.equals(attribute.key)  :  attribute.key  !=  null)  return  false;                [CLASS]  Attribute    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  Object    o    String    encodedValue    key    unencodedKey    value    boolean    Attribute    attribute    
if  (  key  !=  null  ?  !key.equals  (  attribute.key  )  :  attribute.key  !=  null  )  return  false;	[BUGGY]  if  (  key  !  =    attribute.key  !=  null)  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (!(o  instanceof  Attribute))  return  false;    Attribute  attribute  =  (Attribute)  o;    [BUGGY]  if(  key  !  =attribute.key  !=  null  )return  false;  if  (value  !=  null  ?  !value.equals(attribute.value)  :  attribute.value  !=  null)  return  false;    return  true;  }        [CLASS]  Attribute    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  Object    o    String    encodedValue    key    unencodedKey    value    boolean    Attribute    attribute    
if  (  key  !=  null  ?  !key.equals  (  attribute.key  )  :  attribute.key  !=  null  )  return  false;	[BUGGY]  if  (  key  !  =    !key.equals(  attribute.key)  ;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (!(o  instanceof  Attribute))  return  false;    Attribute  attribute  =  (Attribute)  o;    [BUGGY]  if(  key  !  =!key.equals  (  attribute.key  );  if  (value  !=  null  ?  !value.equals(attribute.value)  :  attribute.value  !=  null)  return  false;    return  true;  }        [CLASS]  Attribute    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  Object    o    String    encodedValue    key    unencodedKey    value    boolean    Attribute    attribute    
if  (  key  !=  null  ?  !key.equals  (  attribute.key  )  :  attribute.key  !=  null  )  return  false;	[BUGGY]  if  (  key  !=  null  ?  !key.equals(  value)  :  attribute.key  !=  null)  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (!(o  instanceof  Attribute))  return  false;    Attribute  attribute  =  (Attribute)  o;    [BUGGY]  if(  key  !=  null  ?  !key.equals  (  value  ):  attribute.key  !=  null  )return  false;  if  (value  !=  null  ?  !value.equals(attribute.value)  :  attribute.value  !=  null)  return  false;    return  true;  }        [CLASS]  Attribute    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  Object    o    String    encodedValue    key    unencodedKey    value    boolean    Attribute    attribute    
if  (  value  !=  null  ?  !value.equals  (  attribute.value  )  :  attribute.value  !=  null  )  return  false;	[BUGGY]  if  (  value  ==  null  ?  !value.equals(  attribute.value)  :  attribute.value  ==  null)  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (!(o  instanceof  Attribute))  return  false;    Attribute  attribute  =  (Attribute)  o;    if  (key  !=  null  ?  !key.equals(attribute.key)  :  attribute.key  !=  null)  return  false;  [BUGGY]  if(  value  ==  null  ?  !value.equals  (  attribute.value  ):  attribute.value  ==  null  )return  false;    return  true;  }        [CLASS]  Attribute    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  Object    o    String    encodedValue    key    unencodedKey    value    boolean    Attribute    attribute    
if  (  value  !=  null  ?  !value.equals  (  attribute.value  )  :  attribute.value  !=  null  )  return  false;	[BUGGY]  if  (  value  !=  null  ?  !value.equals(  attribute.value)  :  attribute.value  ==  null)  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (!(o  instanceof  Attribute))  return  false;    Attribute  attribute  =  (Attribute)  o;    if  (key  !=  null  ?  !key.equals(attribute.key)  :  attribute.key  !=  null)  return  false;  [BUGGY]  if(  value  !=  null  ?  !value.equals  (  attribute.value  ):  attribute.value  ==  null  )return  false;    return  true;  }        [CLASS]  Attribute    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  Object    o    String    encodedValue    key    unencodedKey    value    boolean    Attribute    attribute    
if  (  value  !=  null  ?  !value.equals  (  attribute.value  )  :  attribute.value  !=  null  )  return  false;	[BUGGY]  if  (  value  !=  null  ?  !value.equals(  attribute.value)  :  attribute.value  !=  null)  return  true;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (!(o  instanceof  Attribute))  return  false;    Attribute  attribute  =  (Attribute)  o;    if  (key  !=  null  ?  !key.equals(attribute.key)  :  attribute.key  !=  null)  return  false;  [BUGGY]  if(  value  !=  null  ?  !value.equals  (  attribute.value  ):  attribute.value  !=  null  )return  true;    return  true;  }        [CLASS]  Attribute    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  Object    o    String    encodedValue    key    unencodedKey    value    boolean    Attribute    attribute    
if  (  value  !=  null  ?  !value.equals  (  attribute.value  )  :  attribute.value  !=  null  )  return  false;	[BUGGY]  if  (  unencodedKey  !=  null  ?  !value.equals(  attribute.value)  :  attribute.value  !=  null)  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (!(o  instanceof  Attribute))  return  false;    Attribute  attribute  =  (Attribute)  o;    if  (key  !=  null  ?  !key.equals(attribute.key)  :  attribute.key  !=  null)  return  false;  [BUGGY]  if(  unencodedKey  !=  null  ?  !value.equals  (  attribute.value  ):  attribute.value  !=  null  )return  false;    return  true;  }        [CLASS]  Attribute    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  Object    o    String    encodedValue    key    unencodedKey    value    boolean    Attribute    attribute    
if  (  value  !=  null  ?  !value.equals  (  attribute.value  )  :  attribute.value  !=  null  )  return  false;	[BUGGY]  if  (  value  !=  null  ?  !value.equals(  unencodedKey)  :  attribute.value  !=  null)  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (!(o  instanceof  Attribute))  return  false;    Attribute  attribute  =  (Attribute)  o;    if  (key  !=  null  ?  !key.equals(attribute.key)  :  attribute.key  !=  null)  return  false;  [BUGGY]  if(  value  !=  null  ?  !value.equals  (  unencodedKey  ):  attribute.value  !=  null  )return  false;    return  true;  }        [CLASS]  Attribute    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  Object    o    String    encodedValue    key    unencodedKey    value    boolean    Attribute    attribute    
if  (  value  !=  null  ?  !value.equals  (  attribute.value  )  :  attribute.value  !=  null  )  return  false;	[BUGGY]  if  (  value  !=  null  ?  !value.equals(  attribute.value.value)  :  attribute  !=  null)  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (!(o  instanceof  Attribute))  return  false;    Attribute  attribute  =  (Attribute)  o;    if  (key  !=  null  ?  !key.equals(attribute.key)  :  attribute.key  !=  null)  return  false;  [BUGGY]  if(  value  !=  null  ?  !value.equals  (  attribute.value.value  ):  attribute  !=  null  )return  false;    return  true;  }        [CLASS]  Attribute    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  Object    o    String    encodedValue    key    unencodedKey    value    boolean    Attribute    attribute    
if  (  value  !=  null  ?  !value.equals  (  attribute.value  )  :  attribute.value  !=  null  )  return  false;	[BUGGY]  if  (  attribute.value  !=  null  ?  !value.equals(  value)  :  attribute.value  !=  null)  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (!(o  instanceof  Attribute))  return  false;    Attribute  attribute  =  (Attribute)  o;    if  (key  !=  null  ?  !key.equals(attribute.key)  :  attribute.key  !=  null)  return  false;  [BUGGY]  if(  attribute.value  !=  null  ?  !value.equals  (  value  ):  attribute.value  !=  null  )return  false;    return  true;  }        [CLASS]  Attribute    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  Object    o    String    encodedValue    key    unencodedKey    value    boolean    Attribute    attribute    
if  (  value  !=  null  ?  !value.equals  (  attribute.value  )  :  attribute.value  !=  null  )  return  false;	[BUGGY]  if  (  attribute.value  !=  null)  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (!(o  instanceof  Attribute))  return  false;    Attribute  attribute  =  (Attribute)  o;    if  (key  !=  null  ?  !key.equals(attribute.key)  :  attribute.key  !=  null)  return  false;  [BUGGY]  if(  attribute.value  !=  null  )return  false;    return  true;  }        [CLASS]  Attribute    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  Object    o    String    encodedValue    key    unencodedKey    value    boolean    Attribute    attribute    
if  (  value  !=  null  ?  !value.equals  (  attribute.value  )  :  attribute.value  !=  null  )  return  false;	[BUGGY]  if  (  value  !=  this  ?  !value.equals(  attribute.value)  :  attribute.value  !=  this)  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (!(o  instanceof  Attribute))  return  false;    Attribute  attribute  =  (Attribute)  o;    if  (key  !=  null  ?  !key.equals(attribute.key)  :  attribute.key  !=  null)  return  false;  [BUGGY]  if(  value  !=  this  ?  !value.equals  (  attribute.value  ):  attribute.value  !=  this  )return  false;    return  true;  }        [CLASS]  Attribute    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  Object    o    String    encodedValue    key    unencodedKey    value    boolean    Attribute    attribute    
if  (  value  !=  null  ?  !value.equals  (  attribute.value  )  :  attribute.value  !=  null  )  return  false;  return  true;  }	[BUGGY]  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (!(o  instanceof  Attribute))  return  false;    Attribute  attribute  =  (Attribute)  o;    if  (key  !=  null  ?  !key.equals(attribute.key)  :  attribute.key  !=  null)  return  false;  [BUGGY]  if  (value  !=  null  ?  !value.equals(attribute.value)  :  attribute.value  !=  null)  return  false;    return  false;          [CLASS]  Attribute    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  Object    o    String    encodedValue    key    unencodedKey    value    boolean    Attribute    attribute    
if  (  value  !=  null  ?  !value.equals  (  attribute.value  )  :  attribute.value  !=  null  )  return  false;  return  true;  }	[BUGGY]    [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (!(o  instanceof  Attribute))  return  false;    Attribute  attribute  =  (Attribute)  o;    if  (key  !=  null  ?  !key.equals(attribute.key)  :  attribute.key  !=  null)  return  false;  [BUGGY]  if  (value  !=  null  ?  !value.equals(attribute.value)  :  attribute.value  !=  null)  return  false;              [CLASS]  Attribute    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  Object    o    String    encodedValue    key    unencodedKey    value    boolean    Attribute    attribute    
if  (  value  !=  null  ?  !value.equals  (  attribute.value  )  :  attribute.value  !=  null  )  return  false;	[BUGGY]  if  (  value  !  =    attribute.value  !=  null)  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (!(o  instanceof  Attribute))  return  false;    Attribute  attribute  =  (Attribute)  o;    if  (key  !=  null  ?  !key.equals(attribute.key)  :  attribute.key  !=  null)  return  false;  [BUGGY]  if(  value  !  =attribute.value  !=  null  )return  false;    return  true;  }        [CLASS]  Attribute    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  Object    o    String    encodedValue    key    unencodedKey    value    boolean    Attribute    attribute    
if  (  value  !=  null  ?  !value.equals  (  attribute.value  )  :  attribute.value  !=  null  )  return  false;	[BUGGY]  if  (  value  !  =    !value.equals(  attribute.value)  ;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (!(o  instanceof  Attribute))  return  false;    Attribute  attribute  =  (Attribute)  o;    if  (key  !=  null  ?  !key.equals(attribute.key)  :  attribute.key  !=  null)  return  false;  [BUGGY]  if(  value  !  =!value.equals  (  attribute.value  );    return  true;  }        [CLASS]  Attribute    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  Object    o    String    encodedValue    key    unencodedKey    value    boolean    Attribute    attribute    
if  (  value  !=  null  ?  !value.equals  (  attribute.value  )  :  attribute.value  !=  null  )  return  false;	[BUGGY]  if  (  attribute  !=  null  ?  !value.equals(  value.value)  :  attribute.value  !=  null)  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (!(o  instanceof  Attribute))  return  false;    Attribute  attribute  =  (Attribute)  o;    if  (key  !=  null  ?  !key.equals(attribute.key)  :  attribute.key  !=  null)  return  false;  [BUGGY]  if(  attribute  !=  null  ?  !value.equals  (  value.value  ):  attribute.value  !=  null  )return  false;    return  true;  }        [CLASS]  Attribute    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  Object    o    String    encodedValue    key    unencodedKey    value    boolean    Attribute    attribute    
if  (  value  !=  null  ?  !value.equals  (  attribute.value  )  :  attribute.value  !=  null  )  return  false;	[BUGGY]  if  (  value  !=  null  ?  !value  .setValue(  key)    :  attribute.value  !=  null)  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (!(o  instanceof  Attribute))  return  false;    Attribute  attribute  =  (Attribute)  o;    if  (key  !=  null  ?  !key.equals(attribute.key)  :  attribute.key  !=  null)  return  false;  [BUGGY]  if(  value  !=  null  ?  !value  .setValue  (  key  )  :  attribute.value  !=  null  )return  false;    return  true;  }        [CLASS]  Attribute    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  Object    o    String    encodedValue    key    unencodedKey    value    boolean    Attribute    attribute    
return  true;	[BUGGY]  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (!(o  instanceof  Attribute))  return  false;    Attribute  attribute  =  (Attribute)  o;    if  (key  !=  null  ?  !key.equals(attribute.key)  :  attribute.key  !=  null)  return  false;  if  (value  !=  null  ?  !value.equals(attribute.value)  :  attribute.value  !=  null)  return  false;    [BUGGY]  return  false;  }        [CLASS]  Attribute    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  Object    o    String    encodedValue    key    unencodedKey    value    boolean    Attribute    attribute    
int  result  =  key  !=  null  ?  key.hashCode  (  )  :  0;	[BUGGY]  long    result  =  key  !=  null  ?  key.hashCode(  )  :  0;  [CONTEXT]  public  int  hashCode()  {  [BUGGY]  longresult  =  key  !=  null  ?  key.hashCode  ():  0;  result  =  31  *  result  +  (value  !=  null  ?  value.hashCode()  :  0);  return  result;  }        [CLASS]  Attribute    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  int    result    String    encodedValue    key    unencodedKey    value    boolean    
int  result  =  key  !=  null  ?  key.hashCode  (  )  :  0;	[BUGGY]  int  result  =  key  ==  null  ?  key.hashCode(  )  :  0;  [CONTEXT]  public  int  hashCode()  {  [BUGGY]  int  result  =  key  ==  null  ?  key.hashCode  ():  0;  result  =  31  *  result  +  (value  !=  null  ?  value.hashCode()  :  0);  return  result;  }        [CLASS]  Attribute    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  int    result    String    encodedValue    key    unencodedKey    value    boolean    
int  result  =  key  !=  null  ?  key.hashCode  (  )  :  0;	[BUGGY]  int  result  =  value  !=  null  ?  key.hashCode(  )  :  0;  [CONTEXT]  public  int  hashCode()  {  [BUGGY]  int  result  =  value  !=  null  ?  key.hashCode  ():  0;  result  =  31  *  result  +  (value  !=  null  ?  value.hashCode()  :  0);  return  result;  }        [CLASS]  Attribute    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  int    result    String    encodedValue    key    unencodedKey    value    boolean    
int  result  =  key  !=  null  ?  key.hashCode  (  )  :  0;	[BUGGY]  int  result    =    0;  [CONTEXT]  public  int  hashCode()  {  [BUGGY]  int  result=0;  result  =  31  *  result  +  (value  !=  null  ?  value.hashCode()  :  0);  return  result;  }        [CLASS]  Attribute    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  int    result    String    encodedValue    key    unencodedKey    value    boolean    
int  result  =  key  !=  null  ?  key.hashCode  (  )  :  0;	[BUGGY]  int  result    =    key.hashCode(  )  ;  [CONTEXT]  public  int  hashCode()  {  [BUGGY]  int  result=key.hashCode  ();  result  =  31  *  result  +  (value  !=  null  ?  value.hashCode()  :  0);  return  result;  }        [CLASS]  Attribute    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  int    result    String    encodedValue    key    unencodedKey    value    boolean    
int  result  =  key  !=  null  ?  key.hashCode  (  )  :  0;	[BUGGY]  int  result  =  key  !=  null  ?  key.trim(  )  :  0;  [CONTEXT]  public  int  hashCode()  {  [BUGGY]  int  result  =  key  !=  null  ?  key.trim  ():  0;  result  =  31  *  result  +  (value  !=  null  ?  value.hashCode()  :  0);  return  result;  }        [CLASS]  Attribute    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  int    result    String    encodedValue    key    unencodedKey    value    boolean    
int  result  =  key  !=  null  ?  key.hashCode  (  )  :  0;	[BUGGY]  int  result  =  value  !=  null  ?  key.trim(  )  :  0;  [CONTEXT]  public  int  hashCode()  {  [BUGGY]  int  result  =  value  !=  null  ?  key.trim  ():  0;  result  =  31  *  result  +  (value  !=  null  ?  value.hashCode()  :  0);  return  result;  }        [CLASS]  Attribute    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  int    result    String    encodedValue    key    unencodedKey    value    boolean    
int  result  =  key  !=  null  ?  key.hashCode  (  )  :  0;	[BUGGY]  int  result  =  key  !=  null  ?  key  .hashCode(  )    :  0;  [CONTEXT]  public  int  hashCode()  {  [BUGGY]  int  result  =  key  !=  null  ?  key  .hashCode  ()  :  0;  result  =  31  *  result  +  (value  !=  null  ?  value.hashCode()  :  0);  return  result;  }        [CLASS]  Attribute    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  int    result    String    encodedValue    key    unencodedKey    value    boolean    
int  result  =  key  !=  null  ?  key.hashCode  (  )  :  0;  result  =  31  *  result  +  (  value  !=  null  ?  value.hashCode  (  )  :  0  )  ;	[BUGGY]    [CONTEXT]  public  int  hashCode()  {  [BUGGY]  int  result  =  key  !=  null  ?  key.hashCode()  :  0;      return  result;        [CLASS]  Attribute    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  int    result    String    encodedValue    key    unencodedKey    value    boolean    
int  result  =  key  !=  null  ?  key.hashCode  (  )  :  0;	[BUGGY]  result  =  31  *  result  +  (  value  !=  null  ?  value.hashCode(  )  :  0);int  result  =  key  !=  null  ?  key.hashCode(  )  :  0;  [CONTEXT]        [CLASS]  Attribute    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  int    result    String    encodedValue    key    unencodedKey    value    boolean    
result  =  31  *  result  +  (  value  !=  null  ?  value.hashCode  (  )  :  0  )  ;	[BUGGY]  result  =  31  *  result  +    >  (  value  !=  null  ?  value.hashCode(  )  :  0);  [CONTEXT]  public  int  hashCode()  {  int  result  =  key  !=  null  ?  key.hashCode()  :  0;  [BUGGY]  result  =  31  *  result  +>(  value  !=  null  ?  value.hashCode  ():  0  )  ;  return  result;  }        [CLASS]  Attribute    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  int    result    String    encodedValue    key    unencodedKey    value    boolean    
result  =  31  *  result  +  (  value  !=  null  ?  value.hashCode  (  )  :  0  )  ;	[BUGGY]  result  =  31  /  result  +  (  value  !=  null  ?  value.hashCode(  )  :  0);  [CONTEXT]  public  int  hashCode()  {  int  result  =  key  !=  null  ?  key.hashCode()  :  0;  [BUGGY]  result  =  31  /  result  +(  value  !=  null  ?  value.hashCode  ():  0  )  ;  return  result;  }        [CLASS]  Attribute    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  int    result    String    encodedValue    key    unencodedKey    value    boolean    
result  =  31  *  result  +  (  value  !=  null  ?  value.hashCode  (  )  :  0  )  ;	[BUGGY]  result  =  31  *  result  +  (  value  ==  null  ?  value.hashCode(  )  :  0);  [CONTEXT]  public  int  hashCode()  {  int  result  =  key  !=  null  ?  key.hashCode()  :  0;  [BUGGY]  result  =  31  *  result  +(  value  ==  null  ?  value.hashCode  ():  0  )  ;  return  result;  }        [CLASS]  Attribute    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  int    result    String    encodedValue    key    unencodedKey    value    boolean    
result  =  31  *  result  +  (  value  !=  null  ?  value.hashCode  (  )  :  0  )  ;	[BUGGY]  result  =  36  *  result  +  (  value  !=  null  ?  value.hashCode(  )  :  0);  [CONTEXT]  public  int  hashCode()  {  int  result  =  key  !=  null  ?  key.hashCode()  :  0;  [BUGGY]  result  =  36  *  result  +(  value  !=  null  ?  value.hashCode  ():  0  )  ;  return  result;  }        [CLASS]  Attribute    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  int    result    String    encodedValue    key    unencodedKey    value    boolean    
result  =  31  *  result  +  (  value  !=  null  ?  value.hashCode  (  )  :  0  )  ;	[BUGGY]  result  =  31  *  result  +  (  value  !=  null  ?  value.hashCode(  )  :  );  [CONTEXT]  public  int  hashCode()  {  int  result  =  key  !=  null  ?  key.hashCode()  :  0;  [BUGGY]  result  =  31  *  result  +(  value  !=  null  ?  value.hashCode  ():)  ;  return  result;  }        [CLASS]  Attribute    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  int    result    String    encodedValue    key    unencodedKey    value    boolean    
result  =  31  *  result  +  (  value  !=  null  ?  value.hashCode  (  )  :  0  )  ;	[BUGGY]  result  =  31  *  result  +  (  unencodedKey  !=  null  ?  value.hashCode(  )  :  0);  [CONTEXT]  public  int  hashCode()  {  int  result  =  key  !=  null  ?  key.hashCode()  :  0;  [BUGGY]  result  =  31  *  result  +(  unencodedKey  !=  null  ?  value.hashCode  ():  0  )  ;  return  result;  }        [CLASS]  Attribute    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  int    result    String    encodedValue    key    unencodedKey    value    boolean    
result  =  31  *  result  +  (  value  !=  null  ?  value.hashCode  (  )  :  0  )  ;	[BUGGY]  result  =  31  *  value  +  (  result  !=  null  ?  value.hashCode(  )  :  0);  [CONTEXT]  public  int  hashCode()  {  int  result  =  key  !=  null  ?  key.hashCode()  :  0;  [BUGGY]  result  =  31  *  value  +(  result  !=  null  ?  value.hashCode  ():  0  )  ;  return  result;  }        [CLASS]  Attribute    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  int    result    String    encodedValue    key    unencodedKey    value    boolean    
result  =  31  *  result  +  (  value  !=  null  ?  value.hashCode  (  )  :  0  )  ;	[BUGGY]  result    =    0);  [CONTEXT]  public  int  hashCode()  {  int  result  =  key  !=  null  ?  key.hashCode()  :  0;  [BUGGY]  result=0  )  ;  return  result;  }        [CLASS]  Attribute    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  int    result    String    encodedValue    key    unencodedKey    value    boolean    
result  =  31  *  result  +  (  value  !=  null  ?  value.hashCode  (  )  :  0  )  ;	[BUGGY]  result    =    value.hashCode(  )  ;  [CONTEXT]  public  int  hashCode()  {  int  result  =  key  !=  null  ?  key.hashCode()  :  0;  [BUGGY]  result=value.hashCode  ();  return  result;  }        [CLASS]  Attribute    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  int    result    String    encodedValue    key    unencodedKey    value    boolean    
result  =  31  *  result  +  (  value  !=  null  ?  value.hashCode  (  )  :  0  )  ;	[BUGGY]  result  =  31  *  result  +  (  value  !=  null  ?  value.trim(  )  :  0);  [CONTEXT]  public  int  hashCode()  {  int  result  =  key  !=  null  ?  key.hashCode()  :  0;  [BUGGY]  result  =  31  *  result  +(  value  !=  null  ?  value.trim  ():  0  )  ;  return  result;  }        [CLASS]  Attribute    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  int    result    String    encodedValue    key    unencodedKey    value    boolean    
result  =  31  *  result  +  (  value  !=  null  ?  value.hashCode  (  )  :  0  )  ;	[BUGGY]  result  =  31  -  3  *  result  +  (  value  !=  null  ?  value.hashCode(  )  :  0);  [CONTEXT]  public  int  hashCode()  {  int  result  =  key  !=  null  ?  key.hashCode()  :  0;  [BUGGY]  result  =  31  -  3  *  result  +(  value  !=  null  ?  value.hashCode  ():  0  )  ;  return  result;  }        [CLASS]  Attribute    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  int    result    String    encodedValue    key    unencodedKey    value    boolean    
result  =  31  *  result  +  (  value  !=  null  ?  value.hashCode  (  )  :  0  )  ;  return  result;	[BUGGY]    [CONTEXT]  public  int  hashCode()  {  int  result  =  key  !=  null  ?  key.hashCode()  :  0;  [BUGGY]  result  =  31  *  result  +  (value  !=  null  ?  value.hashCode()  :  0);            [CLASS]  Attribute    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  int    result    String    encodedValue    key    unencodedKey    value    boolean    
result  =  31  *  result  +  (  value  !=  null  ?  value.hashCode  (  )  :  0  )  ;	[BUGGY]  return  result;  result  =  31  *  result  +  (  value  !=  null  ?  value.hashCode(  )  :  0);  [CONTEXT]        [CLASS]  Attribute    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  int    result    String    encodedValue    key    unencodedKey    value    boolean    
result  =  31  *  result  +  (  value  !=  null  ?  value.hashCode  (  )  :  0  )  ;	[BUGGY]  int  result  =  key  !=  null  ?  key.hashCode(  )  :  0;result  =  31  *  result  +  (  value  !=  null  ?  value.hashCode(  )  :  0);  [CONTEXT]        [CLASS]  Attribute    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  int    result    String    encodedValue    key    unencodedKey    value    boolean    
private  String  tagName;	[BUGGY]  private  char  tagName;  [CONTEXT]          public  abstract  boolean  matches(Element  element);    static  final  class  Tag  extends  Evaluator  {  [BUGGY]  private  char  tagName;  Tag  (String  tagName)  {  this.tagName  =  tagName;  }    public  boolean  matches(Element  element)  {        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator      [VARIABLES]  
private  String  id;	[BUGGY]  private  char  id;  [CONTEXT]  return  (element.tagName().equals(tagName));  }  }    static  final  class  Id  extends  Evaluator  {  [BUGGY]  private  char  id;  Id  (String  id)  {  this.id  =  id;  }    public  boolean  matches(Element  element)  {        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator      [VARIABLES]  
private  String  className;	[BUGGY]  private  char  className;  [CONTEXT]  return  (id.equals(element.id()));  }  }    static  final  class  Class  extends  Evaluator  {  [BUGGY]  private  char  className;  Class(String  className)  {  this.className  =  className;  }    public  boolean  matches(Element  element)  {        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator      [VARIABLES]  
private  String  key;	[BUGGY]  private  char  key;  [CONTEXT]  return  (element.hasClass(className));  }  }    static  final  class  Attribute  extends  Evaluator  {  [BUGGY]  private  char  key;    Attribute  (String  key)  {  this.key  =  key;  }          [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator      [VARIABLES]  
protected  String  key;	[BUGGY]  protected  char  key;  [CONTEXT]  return  element.attr(key).toLowerCase().contains(value);  //  value  is  lower  case  }  }    abstract  static  class  AttributeKeyPair  extends  Evaluator  {  [BUGGY]  protected  char  key;  protected  String  value;    AttributeKeyPair(String  key,  String  value)  {  Validate.notEmpty(key);  Validate.notEmpty(value);        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator      [VARIABLES]  
protected  String  value;	[BUGGY]  protected  char  value;  [CONTEXT]  }  }    abstract  static  class  AttributeKeyPair  extends  Evaluator  {  protected  String  key;  [BUGGY]  protected  char  value;    AttributeKeyPair(String  key,  String  value)  {  Validate.notEmpty(key);  Validate.notEmpty(value);          [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator      [VARIABLES]  
protected  int  index;	[BUGGY]  protected    short    index;  [CONTEXT]  return  element.elementSiblingIndex()  ==  index;  }  }    abstract  static  class  IndexEvaluator  extends  Evaluator  {  [BUGGY]  protectedshortindex;    IndexEvaluator(int  index)  {  this.index  =  index;  }  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator      [VARIABLES]  
protected  int  index;	[BUGGY]  private    long    index;  [CONTEXT]  return  element.elementSiblingIndex()  ==  index;  }  }    abstract  static  class  IndexEvaluator  extends  Evaluator  {  [BUGGY]  privatelongindex;    IndexEvaluator(int  index)  {  this.index  =  index;  }  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator      [VARIABLES]  
this.tagName  =  tagName;	[BUGGY]  this.tagName  =  key;  [CONTEXT]  Tag  (String  tagName)  {  [BUGGY]  this.tagName  =  key;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  <init>  [RETURN_TYPE]  String)      String  tagName  [VARIABLES]  int    index    String    className    id    key    tagName    value    boolean    
this.tagName  =  tagName;	[BUGGY]  this.tagName  =    value;  [CONTEXT]  Tag  (String  tagName)  {  [BUGGY]  this.tagName  =value;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  <init>  [RETURN_TYPE]  String)      String  tagName  [VARIABLES]  int    index    String    className    id    key    tagName    value    boolean    
this.id  =  id;	[BUGGY]  this.id  =  tagName;  [CONTEXT]  Id  (String  id)  {  [BUGGY]  this.id  =  tagName;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  <init>  [RETURN_TYPE]  String)      String  id  [VARIABLES]  int    index    String    className    id    key    tagName    value    boolean    
this.id  =  id;	[BUGGY]  this.id  =    null;  [CONTEXT]  Id  (String  id)  {  [BUGGY]  this.id  =null;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  <init>  [RETURN_TYPE]  String)      String  id  [VARIABLES]  int    index    String    className    id    key    tagName    value    boolean    
this.className  =  className;	[BUGGY]  this.className  =  value;  [CONTEXT]  Class(String  className)  {  [BUGGY]  this.className  =  value;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  <init>  [RETURN_TYPE]  String)      String  className  [VARIABLES]  int    index    String    className    id    key    tagName    value    boolean    
this.key  =  key;	[BUGGY]  this.key  =  tagName;  [CONTEXT]  Attribute  (String  key)  {  [BUGGY]  this.key  =  tagName;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  [VARIABLES]  int    index    String    className    id    key    tagName    value    boolean    
this.key  =  key;	[BUGGY]  this.key  =    value;  [CONTEXT]  Attribute  (String  key)  {  [BUGGY]  this.key  =value;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  [VARIABLES]  int    index    String    className    id    key    tagName    value    boolean    
super  (  key,  value  )  ;	[BUGGY]  super(  tagName,  value);  [CONTEXT]  AttributeWithValue(String  key,  String  value)  {  [BUGGY]  super  (  tagName,  value  )  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  int    index    String    className    id    key    tagName    value    boolean    
super  (  key,  value  )  ;	[BUGGY]  super(  key,  tagName);  [CONTEXT]  AttributeWithValue(String  key,  String  value)  {  [BUGGY]  super  (  key,  tagName  )  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  int    index    String    className    id    key    tagName    value    boolean    
super  (  key,  value  )  ;	[BUGGY]  super(  value,  key);  [CONTEXT]  AttributeWithValue(String  key,  String  value)  {  [BUGGY]  super  (  value,  key  )  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  int    index    String    className    id    key    tagName    value    boolean    
super  (  key,  value  )  ;	[BUGGY]  super(    value);  [CONTEXT]  AttributeWithValue(String  key,  String  value)  {  [BUGGY]  super  (value  )  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  int    index    String    className    id    key    tagName    value    boolean    
super  (  key,  value  )  ;	[BUGGY]  super(  key);  [CONTEXT]  AttributeWithValue(String  key,  String  value)  {  [BUGGY]  super  (  key  )  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  int    index    String    className    id    key    tagName    value    boolean    
super  (  key,  value  )  ;	[BUGGY]    [CONTEXT]  AttributeWithValue(String  key,  String  value)  {  [BUGGY]  super(key,  value);          [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  int    index    String    className    id    key    tagName    value    boolean    
super  (  key,  value  )  ;	[BUGGY]  super(  tagName,  value);  [CONTEXT]  AttributeWithValueNot(String  key,  String  value)  {  [BUGGY]  super  (  tagName,  value  )  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  int    index    String    className    id    key    tagName    value    boolean    
super  (  key,  value  )  ;	[BUGGY]  super(  key,  tagName);  [CONTEXT]  AttributeWithValueNot(String  key,  String  value)  {  [BUGGY]  super  (  key,  tagName  )  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  int    index    String    className    id    key    tagName    value    boolean    
super  (  key,  value  )  ;	[BUGGY]  super(  value,  key);  [CONTEXT]  AttributeWithValueNot(String  key,  String  value)  {  [BUGGY]  super  (  value,  key  )  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  int    index    String    className    id    key    tagName    value    boolean    
super  (  key,  value  )  ;	[BUGGY]  super(    value);  [CONTEXT]  AttributeWithValueNot(String  key,  String  value)  {  [BUGGY]  super  (value  )  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  int    index    String    className    id    key    tagName    value    boolean    
super  (  key,  value  )  ;	[BUGGY]  super(  key);  [CONTEXT]  AttributeWithValueNot(String  key,  String  value)  {  [BUGGY]  super  (  key  )  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  int    index    String    className    id    key    tagName    value    boolean    
super  (  key,  value  )  ;	[BUGGY]    [CONTEXT]  AttributeWithValueNot(String  key,  String  value)  {  [BUGGY]  super(key,  value);          [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  int    index    String    className    id    key    tagName    value    boolean    
super  (  key,  value  )  ;	[BUGGY]  super(  tagName,  value);  [CONTEXT]  AttributeWithValueStarting(String  key,  String  value)  {  [BUGGY]  super  (  tagName,  value  )  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  int    index    String    className    id    key    tagName    value    boolean    
super  (  key,  value  )  ;	[BUGGY]  super(  key,  tagName);  [CONTEXT]  AttributeWithValueStarting(String  key,  String  value)  {  [BUGGY]  super  (  key,  tagName  )  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  int    index    String    className    id    key    tagName    value    boolean    
super  (  key,  value  )  ;	[BUGGY]  super(  value,  key);  [CONTEXT]  AttributeWithValueStarting(String  key,  String  value)  {  [BUGGY]  super  (  value,  key  )  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  int    index    String    className    id    key    tagName    value    boolean    
super  (  key,  value  )  ;	[BUGGY]  super(    value);  [CONTEXT]  AttributeWithValueStarting(String  key,  String  value)  {  [BUGGY]  super  (value  )  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  int    index    String    className    id    key    tagName    value    boolean    
super  (  key,  value  )  ;	[BUGGY]  super(  key);  [CONTEXT]  AttributeWithValueStarting(String  key,  String  value)  {  [BUGGY]  super  (  key  )  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  int    index    String    className    id    key    tagName    value    boolean    
super  (  key,  value  )  ;	[BUGGY]    [CONTEXT]  AttributeWithValueStarting(String  key,  String  value)  {  [BUGGY]  super(key,  value);          [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  int    index    String    className    id    key    tagName    value    boolean    
super  (  key,  value  )  ;	[BUGGY]  super(  tagName,  value);  [CONTEXT]  AttributeWithValueEnding(String  key,  String  value)  {  [BUGGY]  super  (  tagName,  value  )  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  int    index    String    className    id    key    tagName    value    boolean    
super  (  key,  value  )  ;	[BUGGY]  super(  key,  tagName);  [CONTEXT]  AttributeWithValueEnding(String  key,  String  value)  {  [BUGGY]  super  (  key,  tagName  )  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  int    index    String    className    id    key    tagName    value    boolean    
super  (  key,  value  )  ;	[BUGGY]  super(  value,  key);  [CONTEXT]  AttributeWithValueEnding(String  key,  String  value)  {  [BUGGY]  super  (  value,  key  )  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  int    index    String    className    id    key    tagName    value    boolean    
super  (  key,  value  )  ;	[BUGGY]  super(    value);  [CONTEXT]  AttributeWithValueEnding(String  key,  String  value)  {  [BUGGY]  super  (value  )  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  int    index    String    className    id    key    tagName    value    boolean    
super  (  key,  value  )  ;	[BUGGY]  super(  key);  [CONTEXT]  AttributeWithValueEnding(String  key,  String  value)  {  [BUGGY]  super  (  key  )  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  int    index    String    className    id    key    tagName    value    boolean    
super  (  key,  value  )  ;	[BUGGY]    [CONTEXT]  AttributeWithValueEnding(String  key,  String  value)  {  [BUGGY]  super(key,  value);          [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  int    index    String    className    id    key    tagName    value    boolean    
super  (  key,  value  )  ;	[BUGGY]  super(  tagName,  value);  [CONTEXT]  AttributeWithValueContaining(String  key,  String  value)  {  [BUGGY]  super  (  tagName,  value  )  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  int    index    String    className    id    key    tagName    value    boolean    
super  (  key,  value  )  ;	[BUGGY]  super(  key,  tagName);  [CONTEXT]  AttributeWithValueContaining(String  key,  String  value)  {  [BUGGY]  super  (  key,  tagName  )  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  int    index    String    className    id    key    tagName    value    boolean    
super  (  key,  value  )  ;	[BUGGY]  super(  value,  key);  [CONTEXT]  AttributeWithValueContaining(String  key,  String  value)  {  [BUGGY]  super  (  value,  key  )  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  int    index    String    className    id    key    tagName    value    boolean    
super  (  key,  value  )  ;	[BUGGY]  super(    value);  [CONTEXT]  AttributeWithValueContaining(String  key,  String  value)  {  [BUGGY]  super  (value  )  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  int    index    String    className    id    key    tagName    value    boolean    
super  (  key,  value  )  ;	[BUGGY]  super(  key);  [CONTEXT]  AttributeWithValueContaining(String  key,  String  value)  {  [BUGGY]  super  (  key  )  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  int    index    String    className    id    key    tagName    value    boolean    
super  (  key,  value  )  ;	[BUGGY]    [CONTEXT]  AttributeWithValueContaining(String  key,  String  value)  {  [BUGGY]  super(key,  value);          [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  int    index    String    className    id    key    tagName    value    boolean    
Validate.notEmpty  (  key  )  ;	[BUGGY]  Validate.notEmpty(  value);  [CONTEXT]  AttributeKeyPair(String  key,  String  value)  {  [BUGGY]  Validate.notEmpty  (  value  )  ;  Validate.notEmpty(value);    this.key  =  key.trim().toLowerCase();  this.value  =  value.trim().toLowerCase();  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  int    index    String    className    id    key    tagName    value    boolean    
Validate.notEmpty  (  key  )  ;  Validate.notEmpty  (  value  )  ;	[BUGGY]    [CONTEXT]  AttributeKeyPair(String  key,  String  value)  {  [BUGGY]  Validate.notEmpty(key);        this.key  =  key.trim().toLowerCase();  this.value  =  value.trim().toLowerCase();        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  int    index    String    className    id    key    tagName    value    boolean    
Validate.notEmpty  (  key  )  ;	[BUGGY]  Validate.notEmpty(  value);Validate.notEmpty(  key);  [CONTEXT]        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  int    index    String    className    id    key    tagName    value    boolean    
Validate.notEmpty  (  value  )  ;	[BUGGY]  Validate.notEmpty(  tagName);  [CONTEXT]  AttributeKeyPair(String  key,  String  value)  {  Validate.notEmpty(key);  [BUGGY]  Validate.notEmpty  (  tagName  )  ;    this.key  =  key.trim().toLowerCase();  this.value  =  value.trim().toLowerCase();  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  int    index    String    className    id    key    tagName    value    boolean    
Validate.notEmpty  (  value  )  ;	[BUGGY]    [CONTEXT]  AttributeKeyPair(String  key,  String  value)  {  Validate.notEmpty(key);  [BUGGY]  Validate.notEmpty(value);      this.key  =  key.trim().toLowerCase();  this.value  =  value.trim().toLowerCase();        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  int    index    String    className    id    key    tagName    value    boolean    
this.key  =  key.trim  (  )  .toLowerCase  (  )  ;	[BUGGY]  this.key  =  value.trim(  ).toLowerCase(  );  [CONTEXT]  AttributeKeyPair(String  key,  String  value)  {  Validate.notEmpty(key);  Validate.notEmpty(value);    [BUGGY]  this.key  =  value.trim  ()  .toLowerCase  ()  ;  this.value  =  value.trim().toLowerCase();  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  int    index    String    className    id    key    tagName    value    boolean    
this.key  =  key.trim  (  )  .toLowerCase  (  )  ;	[BUGGY]  this.key  =  key.trim(  ).startsWith(  );  [CONTEXT]  AttributeKeyPair(String  key,  String  value)  {  Validate.notEmpty(key);  Validate.notEmpty(value);    [BUGGY]  this.key  =  key.trim  ()  .startsWith  ()  ;  this.value  =  value.trim().toLowerCase();  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  int    index    String    className    id    key    tagName    value    boolean    
this.key  =  key.trim  (  )  .toLowerCase  (  )  ;	[BUGGY]  this.key  =  key.trim(  )  .equals(  key)  ;  [CONTEXT]  AttributeKeyPair(String  key,  String  value)  {  Validate.notEmpty(key);  Validate.notEmpty(value);    [BUGGY]  this.key  =  key.trim  ().equals  (  key  );  this.value  =  value.trim().toLowerCase();  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  int    index    String    className    id    key    tagName    value    boolean    
this.key  =  key.trim  (  )  .toLowerCase  (  )  ;	[BUGGY]    this.key  =  key.trim(  ).toLowerCase(  );  [CONTEXT]        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  int    index    String    className    id    key    tagName    value    boolean    
this.key  =  key.trim  (  )  .toLowerCase  (  )  ;	[BUGGY]  this.value  =  value.trim(  ).toLowerCase(  );this.key  =  key.trim(  ).toLowerCase(  );  [CONTEXT]        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  int    index    String    className    id    key    tagName    value    boolean    
this.key  =  key.trim  (  )  .toLowerCase  (  )  ;	[BUGGY]    [CONTEXT]  AttributeKeyPair(String  key,  String  value)  {  Validate.notEmpty(key);  Validate.notEmpty(value);    [BUGGY]  this.key  =  key.trim().toLowerCase();    this.value  =  value.trim().toLowerCase();        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  int    index    String    className    id    key    tagName    value    boolean    
this.key  =  key.trim  (  )  .toLowerCase  (  )  ;  this.value  =  value.trim  (  )  .toLowerCase  (  )  ;	[BUGGY]    [CONTEXT]  AttributeKeyPair(String  key,  String  value)  {  Validate.notEmpty(key);  Validate.notEmpty(value);    [BUGGY]  this.key  =  key.trim().toLowerCase();            [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  int    index    String    className    id    key    tagName    value    boolean    
this.key  =  key.trim  (  )  .toLowerCase  (  )  ;  this.value  =  value.trim  (  )  .toLowerCase  (  )  ;	[BUGGY]  this.value  =  value.trim(  ).toLowerCase(  );  this.key  =  key.trim(  ).toLowerCase(  );  [CONTEXT]        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  int    index    String    className    id    key    tagName    value    boolean    
this.key  =  key.trim  (  )  .toLowerCase  (  )  ;  this.value  =  value.trim  (  )  .toLowerCase  (  )  ;	[BUGGY]  this.value  =  value.trim(  ).toLowerCase(  );this.key  =  key.trim(  ).toLowerCase(  );  this.value  =  value.trim(  ).toLowerCase(  );  [CONTEXT]        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  int    index    String    className    id    key    tagName    value    boolean    
this.value  =  value.trim  (  )  .toLowerCase  (  )  ;	[BUGGY]  this.value  =  tagName.trim(  ).toLowerCase(  );  [CONTEXT]  AttributeKeyPair(String  key,  String  value)  {  Validate.notEmpty(key);  Validate.notEmpty(value);    this.key  =  key.trim().toLowerCase();  [BUGGY]  this.value  =  tagName.trim  ()  .toLowerCase  ()  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  int    index    String    className    id    key    tagName    value    boolean    
this.value  =  value.trim  (  )  .toLowerCase  (  )  ;	[BUGGY]  this.value  =  value.trim(  ).startsWith(  );  [CONTEXT]  AttributeKeyPair(String  key,  String  value)  {  Validate.notEmpty(key);  Validate.notEmpty(value);    this.key  =  key.trim().toLowerCase();  [BUGGY]  this.value  =  value.trim  ()  .startsWith  ()  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  int    index    String    className    id    key    tagName    value    boolean    
this.value  =  value.trim  (  )  .toLowerCase  (  )  ;	[BUGGY]  this.value  =  value.trim(  )  .equals(  value)  ;  [CONTEXT]  AttributeKeyPair(String  key,  String  value)  {  Validate.notEmpty(key);  Validate.notEmpty(value);    this.key  =  key.trim().toLowerCase();  [BUGGY]  this.value  =  value.trim  ().equals  (  value  );  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  int    index    String    className    id    key    tagName    value    boolean    
this.value  =  value.trim  (  )  .toLowerCase  (  )  ;	[BUGGY]  this.value  =  value  .equalsIgnoreCase(  )  .toLowerCase(  );  [CONTEXT]  AttributeKeyPair(String  key,  String  value)  {  Validate.notEmpty(key);  Validate.notEmpty(value);    this.key  =  key.trim().toLowerCase();  [BUGGY]  this.value  =  value  .equalsIgnoreCase  ().toLowerCase  ()  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  int    index    String    className    id    key    tagName    value    boolean    
this.value  =  value.trim  (  )  .toLowerCase  (  )  ;	[BUGGY]  this.value  =    key.trim(  ).toLowerCase(  );  [CONTEXT]  AttributeKeyPair(String  key,  String  value)  {  Validate.notEmpty(key);  Validate.notEmpty(value);    this.key  =  key.trim().toLowerCase();  [BUGGY]  this.value  =key.trim  ()  .toLowerCase  ()  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  int    index    String    className    id    key    tagName    value    boolean    
this.value  =  value.trim  (  )  .toLowerCase  (  )  ;	[BUGGY]  this.value  =  key.trim(  ).startsWith(  );  [CONTEXT]  AttributeKeyPair(String  key,  String  value)  {  Validate.notEmpty(key);  Validate.notEmpty(value);    this.key  =  key.trim().toLowerCase();  [BUGGY]  this.value  =  key.trim  ()  .startsWith  ()  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  int    index    String    className    id    key    tagName    value    boolean    
this.value  =  value.trim  (  )  .toLowerCase  (  )  ;	[BUGGY]    [CONTEXT]  AttributeKeyPair(String  key,  String  value)  {  Validate.notEmpty(key);  Validate.notEmpty(value);    this.key  =  key.trim().toLowerCase();  [BUGGY]  this.value  =  value.trim().toLowerCase();          [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  int    index    String    className    id    key    tagName    value    boolean    
super  (  index  )  ;	[BUGGY]    [CONTEXT]  IndexLessThan(int  index)  {  [BUGGY]  super(index);          [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  <init>  [RETURN_TYPE]  Evaluator$IndexLessThan(int)      int  index  [VARIABLES]  int    index    String    className    id    key    tagName    value    boolean    
super  (  index  )  ;	[BUGGY]    [CONTEXT]  IndexGreaterThan(int  index)  {  [BUGGY]  super(index);          [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  <init>  [RETURN_TYPE]  Evaluator$IndexGreaterThan(int)      int  index  [VARIABLES]  int    index    String    className    id    key    tagName    value    boolean    
super  (  index  )  ;	[BUGGY]    [CONTEXT]  IndexEquals(int  index)  {  [BUGGY]  super(index);          [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  <init>  [RETURN_TYPE]  Evaluator$IndexEquals(int)      int  index  [VARIABLES]  int    index    String    className    id    key    tagName    value    boolean    
this.index  =  index;	[BUGGY]  this.index  =    null;  [CONTEXT]  IndexEvaluator(int  index)  {  [BUGGY]  this.index  =null;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  <init>  [RETURN_TYPE]  Evaluator$IndexEvaluator(int)      int  index  [VARIABLES]  int    index    String    className    id    key    tagName    value    boolean    
return  (  element.tagName  (  )  .equals  (  tagName  )  )  ;	[BUGGY]  return  (  element.tagName(  ).equals(  value));  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return(  element.tagName  ()  .equals  (  value  ))  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  (  element.tagName  (  )  .equals  (  tagName  )  )  ;	[BUGGY]  return  (  tagName.tagName(  ).equals(  element));  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return(  tagName.tagName  ()  .equals  (  element  ))  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  (  element.tagName  (  )  .equals  (  tagName  )  )  ;	[BUGGY]  return  (  element.tagName(  ).contains(  tagName));  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return(  element.tagName  ()  .contains  (  tagName  ))  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  (  element.tagName  (  )  .equals  (  tagName  )  )  ;	[BUGGY]  return  (  element.attr(  ).equals(  tagName));  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return(  element.attr  ()  .equals  (  tagName  ))  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  (  element.tagName  (  )  .equals  (  tagName  )  )  ;	[BUGGY]  return  (  element.attr(  ).equals(  key));  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return(  element.attr  ()  .equals  (  key  ))  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  (  element.tagName  (  )  .equals  (  tagName  )  )  ;	[BUGGY]  return  (  element.tagName(  ).contains(  value));  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return(  element.tagName  ()  .contains  (  value  ))  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  (  element.tagName  (  )  .equals  (  tagName  )  )  ;	[BUGGY]    [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  (element.tagName().equals(tagName));          [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  (  element.tagName  (  )  .equals  (  tagName  )  )  ;	[BUGGY]  return  (  element  .hasClass(  value)  .equals(  tagName));  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return(  element  .hasClass  (  value  ).equals  (  tagName  ))  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  (  id.equals  (  element.id  (  )  )  )  ;	[BUGGY]  return  (  tagName.equals(  element.id(  )));  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return(  tagName.equals  (  element.id  ()))  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  (  id.equals  (  element.id  (  )  )  )  ;	[BUGGY]  return  (  element.equals(  id.id(  )));  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return(  element.equals  (  id.id  ()))  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  (  id.equals  (  element.id  (  )  )  )  ;	[BUGGY]  return  (  id  .contains(  value)  );  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return(  id  .contains  (  value  )  )  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  (  id.equals  (  element.id  (  )  )  )  ;	[BUGGY]  return  (  id.equals(  element.attr(  )));  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return(  id.equals  (  element.attr  ()))  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  (  id.equals  (  element.id  (  )  )  )  ;	[BUGGY]  return  (  id.equals(  element  .elementSiblingIndex(  )  ));  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return(  id.equals  (  element  .elementSiblingIndex  ()  ))  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  (  id.equals  (  element.id  (  )  )  )  ;	[BUGGY]  return  (  value.equals(  element.id(  )));  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return(  value.equals  (  element.id  ()))  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  (  id.equals  (  element.id  (  )  )  )  ;	[BUGGY]  return  (  id  .contains(  tagName)  );  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return(  id  .contains  (  tagName  )  )  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  (  id.equals  (  element.id  (  )  )  )  ;	[BUGGY]    [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  (id.equals(element.id()));          [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  (  element.hasClass  (  className  )  )  ;	[BUGGY]  return  (  element.hasClass(  tagName));  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return(  element.hasClass  (  tagName  ))  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  (  element.hasClass  (  className  )  )  ;	[BUGGY]  return  (  className.hasClass(  element));  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return(  className.hasClass  (  element  ))  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  (  element.hasClass  (  className  )  )  ;	[BUGGY]  return  (  element.hasAttr(  className));  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return(  element.hasAttr  (  className  ))  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  (  element.hasClass  (  className  )  )  ;	[BUGGY]  return  (  element  .hasAttr(  tagName)  );  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return(  element  .hasAttr  (  tagName  )  )  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  (  element.hasClass  (  className  )  )  ;	[BUGGY]  return  (  element  .hasAttr(  value)  );  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return(  element  .hasAttr  (  value  )  )  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  (  element.hasClass  (  className  )  )  ;	[BUGGY]  return  (  element.hasClass(  value));  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return(  element.hasClass  (  value  ))  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  (  element.hasClass  (  className  )  )  ;	[BUGGY]    [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  (element.hasClass(className));          [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  (  element.hasAttr  (  key  )  )  ;	[BUGGY]  return  (  element.hasAttr(  tagName));  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return(  element.hasAttr  (  tagName  ))  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  (  element.hasAttr  (  key  )  )  ;	[BUGGY]  return  (  key.hasAttr(  element));  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return(  key.hasAttr  (  element  ))  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  (  element.hasAttr  (  key  )  )  ;	[BUGGY]  return  (  element.attr(  key));  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return(  element.attr  (  key  ))  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  (  element.hasAttr  (  key  )  )  ;	[BUGGY]  return  (  element.hasAttr(  value));  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return(  element.hasAttr  (  value  ))  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  (  element.hasAttr  (  key  )  )  ;	[BUGGY]    [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  (element.hasAttr(key));          [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  (  value.equalsIgnoreCase  (  element.attr  (  key  )  )  )  ;	[BUGGY]  return  (  key.equalsIgnoreCase(  element.attr(  key)));  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return(  key.equalsIgnoreCase  (  element.attr  (  key  )))  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  (  value.equalsIgnoreCase  (  element.attr  (  key  )  )  )  ;	[BUGGY]  return  (  value.equalsIgnoreCase(  element.attr(  tagName)));  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return(  value.equalsIgnoreCase  (  element.attr  (  tagName  )))  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  (  value.equalsIgnoreCase  (  element.attr  (  key  )  )  )  ;	[BUGGY]  return  (  element.equalsIgnoreCase(  value.attr(  key)));  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return(  element.equalsIgnoreCase  (  value.attr  (  key  )))  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  (  value.equalsIgnoreCase  (  element.attr  (  key  )  )  )  ;	[BUGGY]  return  (  key.equalsIgnoreCase(  element.attr(  value)));  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return(  key.equalsIgnoreCase  (  element.attr  (  value  )))  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  (  value.equalsIgnoreCase  (  element.attr  (  key  )  )  )  ;	[BUGGY]  return  (  value.equalsIgnoreCase(  key.attr(  element)));  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return(  value.equalsIgnoreCase  (  key.attr  (  element  )))  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  (  value.equalsIgnoreCase  (  element.attr  (  key  )  )  )  ;	[BUGGY]  return  (  value.equalsIgnoreCase(  element.hasAttr(  key)));  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return(  value.equalsIgnoreCase  (  element.hasAttr  (  key  )))  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  (  value.equalsIgnoreCase  (  element.attr  (  key  )  )  )  ;	[BUGGY]  return  (  value.equalsIgnoreCase(  element  .hasAttr(  tagName)  ));  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return(  value.equalsIgnoreCase  (  element  .hasAttr  (  tagName  )  ))  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  (  value.equalsIgnoreCase  (  element.attr  (  key  )  )  )  ;	[BUGGY]  return  (  value.equalsIgnoreCase(  element  .hasAttr(  value)  ));  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return(  value.equalsIgnoreCase  (  element  .hasAttr  (  value  )  ))  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  (  value.equalsIgnoreCase  (  element.attr  (  key  )  )  )  ;	[BUGGY]  return  (  tagName.equalsIgnoreCase(  element.attr(  key)));  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return(  tagName.equalsIgnoreCase  (  element.attr  (  key  )))  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  (  value.equalsIgnoreCase  (  element.attr  (  key  )  )  )  ;	[BUGGY]  return  (  value.equalsIgnoreCase(  element  .hasAttr(  className)  ));  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return(  value.equalsIgnoreCase  (  element  .hasAttr  (  className  )  ))  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  (  value.equalsIgnoreCase  (  element.attr  (  key  )  )  )  ;	[BUGGY]  return  (  value.equalsIgnoreCase(  element.attr(  value)));  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return(  value.equalsIgnoreCase  (  element.attr  (  value  )))  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  (  value.equalsIgnoreCase  (  element.attr  (  key  )  )  )  ;	[BUGGY]    [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  (value.equalsIgnoreCase(element.attr(key)));          [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  (  value.equalsIgnoreCase  (  element.attr  (  key  )  )  )  ;	[BUGGY]  return  (  value.equalsIgnoreCase(  element  .hasAttr(  id)  ));  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return(  value.equalsIgnoreCase  (  element  .hasAttr  (  id  )  ))  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  (  !value.equalsIgnoreCase  (  element.attr  (  key  )  )  )  ;	[BUGGY]  return  (  !value.equalsIgnoreCase(  element.attr(  tagName)));  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return(  !value.equalsIgnoreCase  (  element.attr  (  tagName  )))  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  (  !value.equalsIgnoreCase  (  element.attr  (  key  )  )  )  ;	[BUGGY]  return  (  !value.equalsIgnoreCase(  key.attr(  element)));  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return(  !value.equalsIgnoreCase  (  key.attr  (  element  )))  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  (  !value.equalsIgnoreCase  (  element.attr  (  key  )  )  )  ;	[BUGGY]  return  (  !value.equalsIgnoreCase(  element.hasAttr(  key)));  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return(  !value.equalsIgnoreCase  (  element.hasAttr  (  key  )))  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  (  !value.equalsIgnoreCase  (  element.attr  (  key  )  )  )  ;	[BUGGY]  return  (  !value.equalsIgnoreCase(  element.hasAttr(  value)));  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return(  !value.equalsIgnoreCase  (  element.hasAttr  (  value  )))  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  (  !value.equalsIgnoreCase  (  element.attr  (  key  )  )  )  ;	[BUGGY]    [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  (!value.equalsIgnoreCase(element.attr(key)));          [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  element.attr  (  key  )  .toLowerCase  (  )  .startsWith  (  value  )  ;	[BUGGY]  return  element.attr(  value).toLowerCase(  ).startsWith(  value);  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  element.attr  (  value  )  .toLowerCase  ()  .startsWith  (  value  )  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  element.attr  (  key  )  .toLowerCase  (  )  .startsWith  (  value  )  ;	[BUGGY]  return  element.attr(  key).toLowerCase(  ).startsWith(  tagName);  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  element.attr  (  key  )  .toLowerCase  ()  .startsWith  (  tagName  )  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  element.attr  (  key  )  .toLowerCase  (  )  .startsWith  (  value  )  ;	[BUGGY]  return  key.attr(  element).toLowerCase(  ).startsWith(  value);  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  key.attr  (  element  )  .toLowerCase  ()  .startsWith  (  value  )  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  element.attr  (  key  )  .toLowerCase  (  )  .startsWith  (  value  )  ;	[BUGGY]  return  element.attr(  value).toLowerCase(  ).startsWith(  key);  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  element.attr  (  value  )  .toLowerCase  ()  .startsWith  (  key  )  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  element.attr  (  key  )  .toLowerCase  (  )  .startsWith  (  value  )  ;	[BUGGY]  return  element.attr(  key).toLowerCase(  ).endsWith(  value);  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  element.attr  (  key  )  .toLowerCase  ()  .endsWith  (  value  )  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  element.attr  (  key  )  .toLowerCase  (  )  .startsWith  (  value  )  ;	[BUGGY]  return  element.attr(  key).toLowerCase(  )  .endsWith(  tagName)  ;  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  element.attr  (  key  )  .toLowerCase  ().endsWith  (  tagName  );  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  element.attr  (  key  )  .toLowerCase  (  )  .startsWith  (  value  )  ;	[BUGGY]  return  element.attr(  key).startsWith(  ).startsWith(  value);  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  element.attr  (  key  )  .startsWith  ()  .startsWith  (  value  )  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  element.attr  (  key  )  .toLowerCase  (  )  .startsWith  (  value  )  ;	[BUGGY]  return  element.attr(  key)  .equals(  className)  .startsWith(  value);  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  element.attr  (  key  ).equals  (  className  ).startsWith  (  value  )  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  element.attr  (  key  )  .toLowerCase  (  )  .startsWith  (  value  )  ;	[BUGGY]  return  element.hasAttr(  key).toLowerCase(  ).startsWith(  value);  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  element.hasAttr  (  key  )  .toLowerCase  ()  .startsWith  (  value  )  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  element.attr  (  key  )  .toLowerCase  (  )  .startsWith  (  value  )  ;	[BUGGY]  return  element.attr(  key).startsWith(  ).startsWith(  tagName);  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  element.attr  (  key  )  .startsWith  ()  .startsWith  (  tagName  )  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  element.attr  (  key  )  .toLowerCase  (  )  .startsWith  (  value  )  ;	[BUGGY]  return  element.attr(  tagName).toLowerCase(  ).startsWith(  value);  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  element.attr  (  tagName  )  .toLowerCase  ()  .startsWith  (  value  )  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  element.attr  (  key  )  .toLowerCase  (  )  .startsWith  (  value  )  ;	[BUGGY]  return  value.attr(  key).toLowerCase(  ).startsWith(  element);  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  value.attr  (  key  )  .toLowerCase  ()  .startsWith  (  element  )  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  element.attr  (  key  )  .toLowerCase  (  )  .startsWith  (  value  )  ;	[BUGGY]    [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  element.attr(key).toLowerCase().startsWith(value);  //  value  is  lower  case  already          [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  element.attr  (  key  )  .toLowerCase  (  )  .startsWith  (  value  )  ;	[BUGGY]  return  element.attr(  key)  .equals(  value)  .startsWith(  value);  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  element.attr  (  key  ).equals  (  value  ).startsWith  (  value  )  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  element.attr  (  key  )  .toLowerCase  (  )  .startsWith  (  value  )  ;	[BUGGY]  return  element  .hasAttr(  className)  .toLowerCase(  ).startsWith(  value);  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  element  .hasAttr  (  className  ).toLowerCase  ()  .startsWith  (  value  )  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  element.attr  (  key  )  .toLowerCase  (  )  .startsWith  (  value  )  ;	[BUGGY]  return  element.hasAttr(  value).toLowerCase(  ).startsWith(  value);  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  element.hasAttr  (  value  )  .toLowerCase  ()  .startsWith  (  value  )  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  element.attr  (  key  )  .toLowerCase  (  )  .startsWith  (  value  )  ;	[BUGGY]  return  element  .hasAttr(  id)  .toLowerCase(  ).startsWith(  value);  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  element  .hasAttr  (  id  ).toLowerCase  ()  .startsWith  (  value  )  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  element.attr  (  key  )  .toLowerCase  (  )  .endsWith  (  value  )  ;	[BUGGY]  return  element.attr(  tagName).toLowerCase(  ).endsWith(  value);  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  element.attr  (  tagName  )  .toLowerCase  ()  .endsWith  (  value  )  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  element.attr  (  key  )  .toLowerCase  (  )  .endsWith  (  value  )  ;	[BUGGY]  return  element.attr(  key).toLowerCase(  ).endsWith(  tagName);  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  element.attr  (  key  )  .toLowerCase  ()  .endsWith  (  tagName  )  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  element.attr  (  key  )  .toLowerCase  (  )  .endsWith  (  value  )  ;	[BUGGY]  return  key.attr(  element).toLowerCase(  ).endsWith(  value);  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  key.attr  (  element  )  .toLowerCase  ()  .endsWith  (  value  )  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  element.attr  (  key  )  .toLowerCase  (  )  .endsWith  (  value  )  ;	[BUGGY]  return  element.attr(  value).toLowerCase(  ).endsWith(  key);  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  element.attr  (  value  )  .toLowerCase  ()  .endsWith  (  key  )  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  element.attr  (  key  )  .toLowerCase  (  )  .endsWith  (  value  )  ;	[BUGGY]  return  element.attr(  key).toLowerCase(  ).startsWith(  value);  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  element.attr  (  key  )  .toLowerCase  ()  .startsWith  (  value  )  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  element.attr  (  key  )  .toLowerCase  (  )  .endsWith  (  value  )  ;	[BUGGY]  return  element.attr(  key).toLowerCase(  )  .startsWith(  key)  ;  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  element.attr  (  key  )  .toLowerCase  ().startsWith  (  key  );  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  element.attr  (  key  )  .toLowerCase  (  )  .endsWith  (  value  )  ;	[BUGGY]  return  element.attr(  key).startsWith(  ).endsWith(  value);  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  element.attr  (  key  )  .startsWith  ()  .endsWith  (  value  )  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  element.attr  (  key  )  .toLowerCase  (  )  .endsWith  (  value  )  ;	[BUGGY]  return  element.attr(  key)  .equals(  key)  .endsWith(  value);  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  element.attr  (  key  ).equals  (  key  ).endsWith  (  value  )  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  element.attr  (  key  )  .toLowerCase  (  )  .endsWith  (  value  )  ;	[BUGGY]  return  element.hasAttr(  key).toLowerCase(  ).endsWith(  value);  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  element.hasAttr  (  key  )  .toLowerCase  ()  .endsWith  (  value  )  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  element.attr  (  key  )  .toLowerCase  (  )  .endsWith  (  value  )  ;	[BUGGY]  return  element.attr(  key).toLowerCase(  ).startsWith(  tagName);  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  element.attr  (  key  )  .toLowerCase  ()  .startsWith  (  tagName  )  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  element.attr  (  key  )  .toLowerCase  (  )  .endsWith  (  value  )  ;	[BUGGY]  return  value.attr(  key).toLowerCase(  ).endsWith(  element);  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  value.attr  (  key  )  .toLowerCase  ()  .endsWith  (  element  )  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  element.attr  (  key  )  .toLowerCase  (  )  .endsWith  (  value  )  ;	[BUGGY]  return  element.attr(  key)  .equals(  id)  .endsWith(  value);  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  element.attr  (  key  ).equals  (  id  ).endsWith  (  value  )  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  element.attr  (  key  )  .toLowerCase  (  )  .endsWith  (  value  )  ;	[BUGGY]  return  element  .hasAttr(  value)  .toLowerCase(  ).endsWith(  value);  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  element  .hasAttr  (  value  ).toLowerCase  ()  .endsWith  (  value  )  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  element.attr  (  key  )  .toLowerCase  (  )  .endsWith  (  value  )  ;	[BUGGY]    [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  element.attr(key).toLowerCase().endsWith(value);  //  value  is  lower  case          [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  element.attr  (  key  )  .toLowerCase  (  )  .endsWith  (  value  )  ;	[BUGGY]  return  element.attr(  value).toLowerCase(  ).endsWith(  value);  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  element.attr  (  value  )  .toLowerCase  ()  .endsWith  (  value  )  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  element.attr  (  key  )  .toLowerCase  (  )  .endsWith  (  value  )  ;	[BUGGY]  return  element  .hasAttr(  className)  .toLowerCase(  ).endsWith(  value);  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  element  .hasAttr  (  className  ).toLowerCase  ()  .endsWith  (  value  )  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  element.attr  (  key  )  .toLowerCase  (  )  .contains  (  value  )  ;	[BUGGY]  return  value.attr(  key).toLowerCase(  ).contains(  element);  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  value.attr  (  key  )  .toLowerCase  ()  .contains  (  element  )  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  element.attr  (  key  )  .toLowerCase  (  )  .contains  (  value  )  ;	[BUGGY]  return  key.attr(  element).toLowerCase(  ).contains(  value);  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  key.attr  (  element  )  .toLowerCase  ()  .contains  (  value  )  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  element.attr  (  key  )  .toLowerCase  (  )  .contains  (  value  )  ;	[BUGGY]  return  element.attr(  value).toLowerCase(  ).contains(  key);  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  element.attr  (  value  )  .toLowerCase  ()  .contains  (  key  )  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  element.attr  (  key  )  .toLowerCase  (  )  .contains  (  value  )  ;	[BUGGY]  return  element.attr(  key).toLowerCase(  ).equals(  value);  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  element.attr  (  key  )  .toLowerCase  ()  .equals  (  value  )  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  element.attr  (  key  )  .toLowerCase  (  )  .contains  (  value  )  ;	[BUGGY]  return  element.attr(  key).startsWith(  ).contains(  value);  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  element.attr  (  key  )  .startsWith  ()  .contains  (  value  )  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  element.attr  (  key  )  .toLowerCase  (  )  .contains  (  value  )  ;	[BUGGY]  return  element.hasAttr(  key).toLowerCase(  ).contains(  value);  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  element.hasAttr  (  key  )  .toLowerCase  ()  .contains  (  value  )  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  element.attr  (  key  )  .toLowerCase  (  )  .contains  (  value  )  ;	[BUGGY]  return  element  .hasAttr(  tagName)  .toLowerCase(  ).contains(  value);  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  element  .hasAttr  (  tagName  ).toLowerCase  ()  .contains  (  value  )  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  element.attr  (  key  )  .toLowerCase  (  )  .contains  (  value  )  ;	[BUGGY]  return  element.hasAttr(  key).toLowerCase(  ).contains(  tagName);  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  element.hasAttr  (  key  )  .toLowerCase  ()  .contains  (  tagName  )  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  element.attr  (  key  )  .toLowerCase  (  )  .contains  (  value  )  ;	[BUGGY]  return  element.attr(  value).toLowerCase(  ).contains(  value);  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  element.attr  (  value  )  .toLowerCase  ()  .contains  (  value  )  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  element.attr  (  key  )  .toLowerCase  (  )  .contains  (  value  )  ;	[BUGGY]  return  element.attr(  key).toLowerCase(  ).contains(  tagName);  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  element.attr  (  key  )  .toLowerCase  ()  .contains  (  tagName  )  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  element.attr  (  key  )  .toLowerCase  (  )  .contains  (  value  )  ;	[BUGGY]  return  element.attr(  tagName).toLowerCase(  ).contains(  value);  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  element.attr  (  tagName  )  .toLowerCase  ()  .contains  (  value  )  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  element.attr  (  key  )  .toLowerCase  (  )  .contains  (  value  )  ;	[BUGGY]    [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  element.attr(key).toLowerCase().contains(value);  //  value  is  lower  case          [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  element.attr  (  key  )  .toLowerCase  (  )  .contains  (  value  )  ;	[BUGGY]  return  element.hasAttr(  value).toLowerCase(  ).contains(  value);  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  element.hasAttr  (  value  )  .toLowerCase  ()  .contains  (  value  )  ;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  true;	[BUGGY]  return  false;  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  false;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  element.elementSiblingIndex  (  )  <  index;	[BUGGY]  return  element.elementSiblingIndex(  )  <=  index;  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  element.elementSiblingIndex  ()<=  index;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  element.elementSiblingIndex  (  )  <  index;	[BUGGY]  return  index.elementSiblingIndex(  )  <  element;  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  index.elementSiblingIndex  ()<  element;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  element.elementSiblingIndex  (  )  <  index;	[BUGGY]  return  element.attr(  )  <  index;  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  element.attr  ()<  index;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  element.elementSiblingIndex  (  )  <  index;	[BUGGY]  return  element  .tagName(  )    <  index;  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  element  .tagName  ()  <  index;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  element.elementSiblingIndex  (  )  <  index;	[BUGGY]    [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  element.elementSiblingIndex()  <  index;          [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  element.elementSiblingIndex  (  )  >  index;	[BUGGY]  return  element.elementSiblingIndex(  )  >=  index;  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  element.elementSiblingIndex  ()>=  index;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  element.elementSiblingIndex  (  )  >  index;	[BUGGY]  return  index.elementSiblingIndex(  )  >  element;  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  index.elementSiblingIndex  ()>  element;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  element.elementSiblingIndex  (  )  >  index;	[BUGGY]  return  element.attr(  )  >  index;  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  element.attr  ()>  index;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  element.elementSiblingIndex  (  )  >  index;	[BUGGY]  return  element  .tagName(  )    >  index;  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  element  .tagName  ()  >  index;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  element.elementSiblingIndex  (  )  >  index;	[BUGGY]    [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  element.elementSiblingIndex()  >  index;          [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  element.elementSiblingIndex  (  )  ==  index;	[BUGGY]  return  element.elementSiblingIndex(  )  <  index;  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  element.elementSiblingIndex  ()<  index;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  element.elementSiblingIndex  (  )  ==  index;	[BUGGY]  return  index.elementSiblingIndex(  )  ==  element;  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  index.elementSiblingIndex  ()==  element;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  element.elementSiblingIndex  (  )  ==  index;	[BUGGY]  return  element.attr(  )  ==  index;  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  element.attr  ()==  index;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  element.elementSiblingIndex  (  )  ==  index;	[BUGGY]  return  element  .tagName(  )    ==  index;  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  element  .tagName  ()  ==  index;  }        [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
return  element.elementSiblingIndex  (  )  ==  index;	[BUGGY]    [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  element.elementSiblingIndex()  ==  index;          [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
private  String  tagName;	[BUGGY]  private  char  tagName;  [CONTEXT]          public  abstract  boolean  matches(Element  element);    static  final  class  Tag  extends  Evaluator  {  [BUGGY]  private  char  tagName;  Tag  (String  tagName)  {  this.tagName  =  tagName;  }    public  boolean  matches(Element  element)  {        [CLASS]  Tag    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    id    key    tagName    value    boolean    int    index    Element    element    
this.tagName  =  tagName;	[BUGGY]  this.tagName  =    null;  [CONTEXT]  Tag  (String  tagName)  {  [BUGGY]  this.tagName  =null;  }        [CLASS]  Tag    [METHOD]  <init>  [RETURN_TYPE]  String)      String  tagName  [VARIABLES]  String    tagName    boolean    
return  (  element.tagName  (  )  .equals  (  tagName  )  )  ;	[BUGGY]  return  (  tagName.tagName(  ).equals(  element));  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return(  tagName.tagName  ()  .equals  (  element  ))  ;  }        [CLASS]  Tag    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    tagName    Element    element    boolean    
return  (  element.tagName  (  )  .equals  (  tagName  )  )  ;	[BUGGY]    [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  (element.tagName().equals(tagName));          [CLASS]  Tag    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    tagName    Element    element    boolean    
private  String  id;	[BUGGY]  private  char  id;  [CONTEXT]  return  (element.tagName().equals(tagName));  }  }    static  final  class  Id  extends  Evaluator  {  [BUGGY]  private  char  id;  Id  (String  id)  {  this.id  =  id;  }    public  boolean  matches(Element  element)  {        [CLASS]  Id    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    tagName    Element    element    boolean    
this.id  =  id;	[BUGGY]  this.id  =    null;  [CONTEXT]  Id  (String  id)  {  [BUGGY]  this.id  =null;  }        [CLASS]  Id    [METHOD]  <init>  [RETURN_TYPE]  String)      String  id  [VARIABLES]  String    id    boolean    
return  (  id.equals  (  element.id  (  )  )  )  ;	[BUGGY]  return  (  element.equals(  id.id(  )));  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return(  element.equals  (  id.id  ()))  ;  }        [CLASS]  Id    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    id    Element    element    boolean    
return  (  id.equals  (  element.id  (  )  )  )  ;	[BUGGY]    [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  (id.equals(element.id()));          [CLASS]  Id    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    id    Element    element    boolean    
private  String  className;	[BUGGY]  private  char  className;  [CONTEXT]  return  (id.equals(element.id()));  }  }    static  final  class  Class  extends  Evaluator  {  [BUGGY]  private  char  className;  Class(String  className)  {  this.className  =  className;  }    public  boolean  matches(Element  element)  {        [CLASS]  Class    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    id    Element    element    boolean    
this.className  =  className;	[BUGGY]  this.className  =    null;  [CONTEXT]  Class(String  className)  {  [BUGGY]  this.className  =null;  }        [CLASS]  Class    [METHOD]  <init>  [RETURN_TYPE]  String)      String  className  [VARIABLES]  String    className    boolean    
return  (  element.hasClass  (  className  )  )  ;	[BUGGY]  return  (  className.hasClass(  element));  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return(  className.hasClass  (  element  ))  ;  }        [CLASS]  Class    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    Element    element    boolean    
return  (  element.hasClass  (  className  )  )  ;	[BUGGY]    [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  (element.hasClass(className));          [CLASS]  Class    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    Element    element    boolean    
private  String  key;	[BUGGY]  private  char  key;  [CONTEXT]  return  (element.hasClass(className));  }  }    static  final  class  Attribute  extends  Evaluator  {  [BUGGY]  private  char  key;    Attribute  (String  key)  {  this.key  =  key;  }          [CLASS]  Attribute    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    className    Element    element    boolean    
this.key  =  key;	[BUGGY]  this.key  =    null;  [CONTEXT]  Attribute  (String  key)  {  [BUGGY]  this.key  =null;  }        [CLASS]  Attribute    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  [VARIABLES]  String    key    boolean    
return  (  element.hasAttr  (  key  )  )  ;	[BUGGY]  return  (  key.hasAttr(  element));  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return(  key.hasAttr  (  element  ))  ;  }        [CLASS]  Attribute    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    key    Element    element    boolean    
return  (  element.hasAttr  (  key  )  )  ;	[BUGGY]    [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  (element.hasAttr(key));          [CLASS]  Attribute    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  String    key    Element    element    boolean    
super  (  key,  value  )  ;	[BUGGY]  super(  value,  key);  [CONTEXT]  AttributeWithValue(String  key,  String  value)  {  [BUGGY]  super  (  value,  key  )  ;  }        [CLASS]  AttributeWithValue    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  boolean    String    key    value    
super  (  key,  value  )  ;	[BUGGY]  super(    value);  [CONTEXT]  AttributeWithValue(String  key,  String  value)  {  [BUGGY]  super  (value  )  ;  }        [CLASS]  AttributeWithValue    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  boolean    String    key    value    
super  (  key,  value  )  ;	[BUGGY]  super(  key);  [CONTEXT]  AttributeWithValue(String  key,  String  value)  {  [BUGGY]  super  (  key  )  ;  }        [CLASS]  AttributeWithValue    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  boolean    String    key    value    
super  (  key,  value  )  ;	[BUGGY]    [CONTEXT]  AttributeWithValue(String  key,  String  value)  {  [BUGGY]  super(key,  value);          [CLASS]  AttributeWithValue    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  boolean    String    key    value    
return  (  value.equalsIgnoreCase  (  element.attr  (  key  )  )  )  ;	[BUGGY]  return  (  2.equalsIgnoreCase(  element.attr(  key)));  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return(  2.equalsIgnoreCase  (  element.attr  (  key  )))  ;  }        [CLASS]  AttributeWithValue    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  boolean    Element    element    
return  (  value.equalsIgnoreCase  (  element.attr  (  key  )  )  )  ;	[BUGGY]  return  (  element.equalsIgnoreCase(  value.attr(  key)));  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return(  element.equalsIgnoreCase  (  value.attr  (  key  )))  ;  }        [CLASS]  AttributeWithValue    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  boolean    Element    element    
return  (  value.equalsIgnoreCase  (  element.attr  (  key  )  )  )  ;	[BUGGY]  return  (  key.equalsIgnoreCase(  element.attr(  value)));  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return(  key.equalsIgnoreCase  (  element.attr  (  value  )))  ;  }        [CLASS]  AttributeWithValue    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  boolean    Element    element    
return  (  value.equalsIgnoreCase  (  element.attr  (  key  )  )  )  ;	[BUGGY]  return  (  1.equalsIgnoreCase(  element.attr(  key)));  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return(  1.equalsIgnoreCase  (  element.attr  (  key  )))  ;  }        [CLASS]  AttributeWithValue    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  boolean    Element    element    
return  (  value.equalsIgnoreCase  (  element.attr  (  key  )  )  )  ;	[BUGGY]  return  (  value.equalsIgnoreCase(  key.attr(  element)));  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return(  value.equalsIgnoreCase  (  key.attr  (  element  )))  ;  }        [CLASS]  AttributeWithValue    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  boolean    Element    element    
return  (  value.equalsIgnoreCase  (  element.attr  (  key  )  )  )  ;	[BUGGY]    [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  (value.equalsIgnoreCase(element.attr(key)));          [CLASS]  AttributeWithValue    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  boolean    Element    element    
super  (  key,  value  )  ;	[BUGGY]  super(  value,  key);  [CONTEXT]  AttributeWithValueNot(String  key,  String  value)  {  [BUGGY]  super  (  value,  key  )  ;  }        [CLASS]  AttributeWithValueNot    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  boolean    String    key    value    
super  (  key,  value  )  ;	[BUGGY]  super(    value);  [CONTEXT]  AttributeWithValueNot(String  key,  String  value)  {  [BUGGY]  super  (value  )  ;  }        [CLASS]  AttributeWithValueNot    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  boolean    String    key    value    
super  (  key,  value  )  ;	[BUGGY]  super(  key);  [CONTEXT]  AttributeWithValueNot(String  key,  String  value)  {  [BUGGY]  super  (  key  )  ;  }        [CLASS]  AttributeWithValueNot    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  boolean    String    key    value    
super  (  key,  value  )  ;	[BUGGY]    [CONTEXT]  AttributeWithValueNot(String  key,  String  value)  {  [BUGGY]  super(key,  value);          [CLASS]  AttributeWithValueNot    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  boolean    String    key    value    
return  (  !value.equalsIgnoreCase  (  element.attr  (  key  )  )  )  ;	[BUGGY]  return  (  !value.equalsIgnoreCase(  key.attr(  element)));  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return(  !value.equalsIgnoreCase  (  key.attr  (  element  )))  ;  }        [CLASS]  AttributeWithValueNot    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  boolean    Element    element    
return  (  !value.equalsIgnoreCase  (  element.attr  (  key  )  )  )  ;	[BUGGY]    [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  (!value.equalsIgnoreCase(element.attr(key)));          [CLASS]  AttributeWithValueNot    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  boolean    Element    element    
super  (  key,  value  )  ;	[BUGGY]  super(  value,  key);  [CONTEXT]  AttributeWithValueStarting(String  key,  String  value)  {  [BUGGY]  super  (  value,  key  )  ;  }        [CLASS]  AttributeWithValueStarting    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  boolean    String    key    value    
super  (  key,  value  )  ;	[BUGGY]  super(    value);  [CONTEXT]  AttributeWithValueStarting(String  key,  String  value)  {  [BUGGY]  super  (value  )  ;  }        [CLASS]  AttributeWithValueStarting    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  boolean    String    key    value    
super  (  key,  value  )  ;	[BUGGY]  super(  key);  [CONTEXT]  AttributeWithValueStarting(String  key,  String  value)  {  [BUGGY]  super  (  key  )  ;  }        [CLASS]  AttributeWithValueStarting    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  boolean    String    key    value    
super  (  key,  value  )  ;	[BUGGY]    [CONTEXT]  AttributeWithValueStarting(String  key,  String  value)  {  [BUGGY]  super(key,  value);          [CLASS]  AttributeWithValueStarting    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  boolean    String    key    value    
return  element.attr  (  key  )  .toLowerCase  (  )  .startsWith  (  value  )  ;	[BUGGY]  return  key.attr(  element).toLowerCase(  ).startsWith(  value);  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  key.attr  (  element  )  .toLowerCase  ()  .startsWith  (  value  )  ;  }        [CLASS]  AttributeWithValueStarting    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  boolean    Element    element    
return  element.attr  (  key  )  .toLowerCase  (  )  .startsWith  (  value  )  ;	[BUGGY]  return  element.attr(  value).toLowerCase(  ).startsWith(  key);  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  element.attr  (  value  )  .toLowerCase  ()  .startsWith  (  key  )  ;  }        [CLASS]  AttributeWithValueStarting    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  boolean    Element    element    
return  element.attr  (  key  )  .toLowerCase  (  )  .startsWith  (  value  )  ;	[BUGGY]  return  element.attr(  key).startsWith(  ).startsWith(  value);  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  element.attr  (  key  )  .startsWith  ()  .startsWith  (  value  )  ;  }        [CLASS]  AttributeWithValueStarting    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  boolean    Element    element    
return  element.attr  (  key  )  .toLowerCase  (  )  .startsWith  (  value  )  ;	[BUGGY]  return  value.attr(  key).toLowerCase(  ).startsWith(  element);  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  value.attr  (  key  )  .toLowerCase  ()  .startsWith  (  element  )  ;  }        [CLASS]  AttributeWithValueStarting    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  boolean    Element    element    
return  element.attr  (  key  )  .toLowerCase  (  )  .startsWith  (  value  )  ;	[BUGGY]  return  element.attr(  key).toLowerCase(  ).startsWith(  3);  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  element.attr  (  key  )  .toLowerCase  ()  .startsWith  (  3  )  ;  }        [CLASS]  AttributeWithValueStarting    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  boolean    Element    element    
return  element.attr  (  key  )  .toLowerCase  (  )  .startsWith  (  value  )  ;	[BUGGY]    [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  element.attr(key).toLowerCase().startsWith(value);  //  value  is  lower  case  already          [CLASS]  AttributeWithValueStarting    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  boolean    Element    element    
super  (  key,  value  )  ;	[BUGGY]  super(  value,  key);  [CONTEXT]  AttributeWithValueEnding(String  key,  String  value)  {  [BUGGY]  super  (  value,  key  )  ;  }        [CLASS]  AttributeWithValueEnding    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  boolean    String    key    value    
super  (  key,  value  )  ;	[BUGGY]  super(    value);  [CONTEXT]  AttributeWithValueEnding(String  key,  String  value)  {  [BUGGY]  super  (value  )  ;  }        [CLASS]  AttributeWithValueEnding    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  boolean    String    key    value    
super  (  key,  value  )  ;	[BUGGY]  super(  key);  [CONTEXT]  AttributeWithValueEnding(String  key,  String  value)  {  [BUGGY]  super  (  key  )  ;  }        [CLASS]  AttributeWithValueEnding    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  boolean    String    key    value    
super  (  key,  value  )  ;	[BUGGY]    [CONTEXT]  AttributeWithValueEnding(String  key,  String  value)  {  [BUGGY]  super(key,  value);          [CLASS]  AttributeWithValueEnding    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  boolean    String    key    value    
return  element.attr  (  key  )  .toLowerCase  (  )  .endsWith  (  value  )  ;	[BUGGY]  return  key.attr(  element).toLowerCase(  ).endsWith(  value);  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  key.attr  (  element  )  .toLowerCase  ()  .endsWith  (  value  )  ;  }        [CLASS]  AttributeWithValueEnding    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  boolean    Element    element    
return  element.attr  (  key  )  .toLowerCase  (  )  .endsWith  (  value  )  ;	[BUGGY]  return  element.attr(  value).toLowerCase(  ).endsWith(  key);  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  element.attr  (  value  )  .toLowerCase  ()  .endsWith  (  key  )  ;  }        [CLASS]  AttributeWithValueEnding    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  boolean    Element    element    
return  element.attr  (  key  )  .toLowerCase  (  )  .endsWith  (  value  )  ;	[BUGGY]  return  element.attr(  key).endsWith(  ).endsWith(  value);  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  element.attr  (  key  )  .endsWith  ()  .endsWith  (  value  )  ;  }        [CLASS]  AttributeWithValueEnding    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  boolean    Element    element    
return  element.attr  (  key  )  .toLowerCase  (  )  .endsWith  (  value  )  ;	[BUGGY]  return  element.attr(  key).toLowerCase(  )  .toLowerCase(  )  ;  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  element.attr  (  key  )  .toLowerCase  ().toLowerCase  ();  }        [CLASS]  AttributeWithValueEnding    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  boolean    Element    element    
return  element.attr  (  key  )  .toLowerCase  (  )  .endsWith  (  value  )  ;	[BUGGY]  return  value.attr(  key).toLowerCase(  ).endsWith(  element);  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  value.attr  (  key  )  .toLowerCase  ()  .endsWith  (  element  )  ;  }        [CLASS]  AttributeWithValueEnding    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  boolean    Element    element    
return  element.attr  (  key  )  .toLowerCase  (  )  .endsWith  (  value  )  ;	[BUGGY]    [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  element.attr(key).toLowerCase().endsWith(value);  //  value  is  lower  case          [CLASS]  AttributeWithValueEnding    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  boolean    Element    element    
super  (  key,  value  )  ;	[BUGGY]  super(  value,  key);  [CONTEXT]  AttributeWithValueContaining(String  key,  String  value)  {  [BUGGY]  super  (  value,  key  )  ;  }        [CLASS]  AttributeWithValueContaining    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  boolean    String    key    value    
super  (  key,  value  )  ;	[BUGGY]  super(    value);  [CONTEXT]  AttributeWithValueContaining(String  key,  String  value)  {  [BUGGY]  super  (value  )  ;  }        [CLASS]  AttributeWithValueContaining    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  boolean    String    key    value    
super  (  key,  value  )  ;	[BUGGY]  super(  key);  [CONTEXT]  AttributeWithValueContaining(String  key,  String  value)  {  [BUGGY]  super  (  key  )  ;  }        [CLASS]  AttributeWithValueContaining    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  boolean    String    key    value    
super  (  key,  value  )  ;	[BUGGY]    [CONTEXT]  AttributeWithValueContaining(String  key,  String  value)  {  [BUGGY]  super(key,  value);          [CLASS]  AttributeWithValueContaining    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  boolean    String    key    value    
return  element.attr  (  key  )  .toLowerCase  (  )  .contains  (  value  )  ;	[BUGGY]  return  value.attr(  key).toLowerCase(  ).contains(  element);  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  value.attr  (  key  )  .toLowerCase  ()  .contains  (  element  )  ;  }        [CLASS]  AttributeWithValueContaining    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  boolean    Element    element    
return  element.attr  (  key  )  .toLowerCase  (  )  .contains  (  value  )  ;	[BUGGY]  return  element.attr(  value).toLowerCase(  ).contains(  key);  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  element.attr  (  value  )  .toLowerCase  ()  .contains  (  key  )  ;  }        [CLASS]  AttributeWithValueContaining    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  boolean    Element    element    
return  element.attr  (  key  )  .toLowerCase  (  )  .contains  (  value  )  ;	[BUGGY]  return  element.attr(  key).contains(  ).contains(  value);  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  element.attr  (  key  )  .contains  ()  .contains  (  value  )  ;  }        [CLASS]  AttributeWithValueContaining    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  boolean    Element    element    
return  element.attr  (  key  )  .toLowerCase  (  )  .contains  (  value  )  ;	[BUGGY]  return  element.attr(  key).toLowerCase(  )  .toLowerCase(  )  ;  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  element.attr  (  key  )  .toLowerCase  ().toLowerCase  ();  }        [CLASS]  AttributeWithValueContaining    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  boolean    Element    element    
return  element.attr  (  key  )  .toLowerCase  (  )  .contains  (  value  )  ;	[BUGGY]    [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  element.attr(key).toLowerCase().contains(value);  //  value  is  lower  case          [CLASS]  AttributeWithValueContaining    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  boolean    Element    element    
return  element.attr  (  key  )  .toLowerCase  (  )  .contains  (  value  )  ;	[BUGGY]  return  key.attr(  element).toLowerCase(  ).contains(  value);  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  key.attr  (  element  )  .toLowerCase  ()  .contains  (  value  )  ;  }        [CLASS]  AttributeWithValueContaining    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  boolean    Element    element    
protected  String  key;	[BUGGY]  protected  char  key;  [CONTEXT]  return  element.attr(key).toLowerCase().contains(value);  //  value  is  lower  case  }  }    abstract  static  class  AttributeKeyPair  extends  Evaluator  {  [BUGGY]  protected  char  key;  protected  String  value;    AttributeKeyPair(String  key,  String  value)  {  Validate.notEmpty(key);  Validate.notEmpty(value);        [CLASS]  AttributeKeyPair    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  boolean    Element    element    
protected  String  value;	[BUGGY]  protected  char  value;  [CONTEXT]  }  }    abstract  static  class  AttributeKeyPair  extends  Evaluator  {  protected  String  key;  [BUGGY]  protected  char  value;    AttributeKeyPair(String  key,  String  value)  {  Validate.notEmpty(key);  Validate.notEmpty(value);          [CLASS]  AttributeKeyPair    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  boolean    Element    element    
Validate.notEmpty  (  key  )  ;	[BUGGY]  Validate.notEmpty(  value);  [CONTEXT]  AttributeKeyPair(String  key,  String  value)  {  [BUGGY]  Validate.notEmpty  (  value  )  ;  Validate.notEmpty(value);    this.key  =  key.trim().toLowerCase();  this.value  =  value.trim().toLowerCase();  }        [CLASS]  AttributeKeyPair    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  String    key    value    boolean    
Validate.notEmpty  (  key  )  ;  Validate.notEmpty  (  value  )  ;	[BUGGY]    [CONTEXT]  AttributeKeyPair(String  key,  String  value)  {  [BUGGY]  Validate.notEmpty(key);        this.key  =  key.trim().toLowerCase();  this.value  =  value.trim().toLowerCase();        [CLASS]  AttributeKeyPair    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  String    key    value    boolean    
Validate.notEmpty  (  key  )  ;  Validate.notEmpty  (  value  )  ;	[BUGGY]  Validate.notEmpty(  value);  Validate.notEmpty(  key);  [CONTEXT]        [CLASS]  AttributeKeyPair    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  String    key    value    boolean    
Validate.notEmpty  (  key  )  ;  Validate.notEmpty  (  value  )  ;	[BUGGY]  Validate.notEmpty(  value);Validate.notEmpty(  key);  Validate.notEmpty(  value);  [CONTEXT]        [CLASS]  AttributeKeyPair    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  String    key    value    boolean    
Validate.notEmpty  (  value  )  ;	[BUGGY]  Validate.notEmpty(  key);  [CONTEXT]  AttributeKeyPair(String  key,  String  value)  {  Validate.notEmpty(key);  [BUGGY]  Validate.notEmpty  (  key  )  ;    this.key  =  key.trim().toLowerCase();  this.value  =  value.trim().toLowerCase();  }        [CLASS]  AttributeKeyPair    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  String    key    value    boolean    
Validate.notEmpty  (  value  )  ;	[BUGGY]    [CONTEXT]  AttributeKeyPair(String  key,  String  value)  {  Validate.notEmpty(key);  [BUGGY]  Validate.notEmpty(value);      this.key  =  key.trim().toLowerCase();  this.value  =  value.trim().toLowerCase();        [CLASS]  AttributeKeyPair    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  String    key    value    boolean    
this.key  =  key.trim  (  )  .toLowerCase  (  )  ;	[BUGGY]  this.key  =  value.trim(  ).toLowerCase(  );  [CONTEXT]  AttributeKeyPair(String  key,  String  value)  {  Validate.notEmpty(key);  Validate.notEmpty(value);    [BUGGY]  this.key  =  value.trim  ()  .toLowerCase  ()  ;  this.value  =  value.trim().toLowerCase();  }        [CLASS]  AttributeKeyPair    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  String    key    value    boolean    
this.key  =  key.trim  (  )  .toLowerCase  (  )  ;	[BUGGY]    this.key  =  key.trim(  ).toLowerCase(  );  [CONTEXT]        [CLASS]  AttributeKeyPair    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  String    key    value    boolean    
this.key  =  key.trim  (  )  .toLowerCase  (  )  ;	[BUGGY]  this.value  =  value.trim(  ).toLowerCase(  );this.key  =  key.trim(  ).toLowerCase(  );  [CONTEXT]        [CLASS]  AttributeKeyPair    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  String    key    value    boolean    
this.key  =  key.trim  (  )  .toLowerCase  (  )  ;  this.value  =  value.trim  (  )  .toLowerCase  (  )  ;	[BUGGY]    [CONTEXT]  AttributeKeyPair(String  key,  String  value)  {  Validate.notEmpty(key);  Validate.notEmpty(value);    [BUGGY]  this.key  =  key.trim().toLowerCase();            [CLASS]  AttributeKeyPair    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  String    key    value    boolean    
this.key  =  key.trim  (  )  .toLowerCase  (  )  ;  this.value  =  value.trim  (  )  .toLowerCase  (  )  ;	[BUGGY]  this.value  =  value.trim(  ).toLowerCase(  );  this.key  =  key.trim(  ).toLowerCase(  );  [CONTEXT]        [CLASS]  AttributeKeyPair    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  String    key    value    boolean    
this.key  =  key.trim  (  )  .toLowerCase  (  )  ;  this.value  =  value.trim  (  )  .toLowerCase  (  )  ;	[BUGGY]  this.value  =  value.trim(  ).toLowerCase(  );this.key  =  key.trim(  ).toLowerCase(  );  this.value  =  value.trim(  ).toLowerCase(  );  [CONTEXT]        [CLASS]  AttributeKeyPair    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  String    key    value    boolean    
this.key  =  key.trim  (  )  .toLowerCase  (  )  ;	[BUGGY]    [CONTEXT]  AttributeKeyPair(String  key,  String  value)  {  Validate.notEmpty(key);  Validate.notEmpty(value);    [BUGGY]  this.key  =  key.trim().toLowerCase();    this.value  =  value.trim().toLowerCase();        [CLASS]  AttributeKeyPair    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  String    key    value    boolean    
this.value  =  value.trim  (  )  .toLowerCase  (  )  ;	[BUGGY]  this.value  =  key.trim(  ).toLowerCase(  );  [CONTEXT]  AttributeKeyPair(String  key,  String  value)  {  Validate.notEmpty(key);  Validate.notEmpty(value);    this.key  =  key.trim().toLowerCase();  [BUGGY]  this.value  =  key.trim  ()  .toLowerCase  ()  ;  }        [CLASS]  AttributeKeyPair    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  String    key    value    boolean    
this.value  =  value.trim  (  )  .toLowerCase  (  )  ;	[BUGGY]  this.value  =    null.trim(  ).toLowerCase(  );  [CONTEXT]  AttributeKeyPair(String  key,  String  value)  {  Validate.notEmpty(key);  Validate.notEmpty(value);    this.key  =  key.trim().toLowerCase();  [BUGGY]  this.value  =null.trim  ()  .toLowerCase  ()  ;  }        [CLASS]  AttributeKeyPair    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  String    key    value    boolean    
this.value  =  value.trim  (  )  .toLowerCase  (  )  ;	[BUGGY]    [CONTEXT]  AttributeKeyPair(String  key,  String  value)  {  Validate.notEmpty(key);  Validate.notEmpty(value);    this.key  =  key.trim().toLowerCase();  [BUGGY]  this.value  =  value.trim().toLowerCase();          [CLASS]  AttributeKeyPair    [METHOD]  <init>  [RETURN_TYPE]  String)      String  key  String  value  [VARIABLES]  String    key    value    boolean    
return  true;	[BUGGY]  return  false;  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  false;  }        [CLASS]  AllElements    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  boolean    Element    element    
super  (  index  )  ;	[BUGGY]    [CONTEXT]  IndexLessThan(int  index)  {  [BUGGY]  super(index);          [CLASS]  IndexLessThan    [METHOD]  <init>  [RETURN_TYPE]  Evaluator$IndexLessThan(int)      int  index  [VARIABLES]  boolean    int    index    
return  element.elementSiblingIndex  (  )  <  index;	[BUGGY]  return  element.elementSiblingIndex(  )  <=  index;  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  element.elementSiblingIndex  ()<=  index;  }        [CLASS]  IndexLessThan    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  boolean    Element    element    
return  element.elementSiblingIndex  (  )  <  index;	[BUGGY]  return  index.elementSiblingIndex(  )  <  element;  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  index.elementSiblingIndex  ()<  element;  }        [CLASS]  IndexLessThan    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  boolean    Element    element    
return  element.elementSiblingIndex  (  )  <  index;	[BUGGY]  return  element.elementSiblingIndex(  )    ;  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  element.elementSiblingIndex  ()  ;  }        [CLASS]  IndexLessThan    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  boolean    Element    element    
return  element.elementSiblingIndex  (  )  <  index;	[BUGGY]    [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  element.elementSiblingIndex()  <  index;          [CLASS]  IndexLessThan    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  boolean    Element    element    
super  (  index  )  ;	[BUGGY]    [CONTEXT]  IndexGreaterThan(int  index)  {  [BUGGY]  super(index);          [CLASS]  IndexGreaterThan    [METHOD]  <init>  [RETURN_TYPE]  Evaluator$IndexGreaterThan(int)      int  index  [VARIABLES]  boolean    int    index    
return  element.elementSiblingIndex  (  )  >  index;	[BUGGY]  return  element.elementSiblingIndex(  )  >=  index;  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  element.elementSiblingIndex  ()>=  index;  }        [CLASS]  IndexGreaterThan    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  boolean    Element    element    
return  element.elementSiblingIndex  (  )  >  index;	[BUGGY]  return  index.elementSiblingIndex(  )  >  element;  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  index.elementSiblingIndex  ()>  element;  }        [CLASS]  IndexGreaterThan    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  boolean    Element    element    
return  element.elementSiblingIndex  (  )  >  index;	[BUGGY]  return  element.elementSiblingIndex(  )    ;  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  element.elementSiblingIndex  ()  ;  }        [CLASS]  IndexGreaterThan    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  boolean    Element    element    
return  element.elementSiblingIndex  (  )  >  index;	[BUGGY]    [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  element.elementSiblingIndex()  >  index;          [CLASS]  IndexGreaterThan    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  boolean    Element    element    
super  (  index  )  ;	[BUGGY]    [CONTEXT]  IndexEquals(int  index)  {  [BUGGY]  super(index);          [CLASS]  IndexEquals    [METHOD]  <init>  [RETURN_TYPE]  Evaluator$IndexEquals(int)      int  index  [VARIABLES]  boolean    int    index    
return  element.elementSiblingIndex  (  )  ==  index;	[BUGGY]  return  element.elementSiblingIndex(  )  !=  index;  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  element.elementSiblingIndex  ()!=  index;  }        [CLASS]  IndexEquals    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  boolean    Element    element    
return  element.elementSiblingIndex  (  )  ==  index;	[BUGGY]  return  index.elementSiblingIndex(  )  ==  element;  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  index.elementSiblingIndex  ()==  element;  }        [CLASS]  IndexEquals    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  boolean    Element    element    
return  element.elementSiblingIndex  (  )  ==  index;	[BUGGY]  return  element.elementSiblingIndex(  )    &&    index;  [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  element.elementSiblingIndex  ()  &&index;  }        [CLASS]  IndexEquals    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  boolean    Element    element    
return  element.elementSiblingIndex  (  )  ==  index;	[BUGGY]    [CONTEXT]  public  boolean  matches(Element  element)  {  [BUGGY]  return  element.elementSiblingIndex()  ==  index;          [CLASS]  IndexEquals    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  boolean    Element    element    
protected  int  index;	[BUGGY]  protected    short    index;  [CONTEXT]  return  element.elementSiblingIndex()  ==  index;  }  }    abstract  static  class  IndexEvaluator  extends  Evaluator  {  [BUGGY]  protectedshortindex;    IndexEvaluator(int  index)  {  this.index  =  index;  }  }        [CLASS]  IndexEvaluator    [METHOD]  matches  [RETURN_TYPE]  boolean      Element  element  [VARIABLES]  boolean    Element    element    
this.index  =  index;	[BUGGY]  this.index  =    null;  [CONTEXT]  IndexEvaluator(int  index)  {  [BUGGY]  this.index  =null;  }        [CLASS]  IndexEvaluator    [METHOD]  <init>  [RETURN_TYPE]  Evaluator$IndexEvaluator(int)      int  index  [VARIABLES]  int    index    boolean    
private  LinkedHashMap<String,  Attribute>  attributes  =  new  LinkedHashMap<String,  Attribute>  (  )  ;	[BUGGY]  private  LinkedHashMap<String,  Attribute>  attributes  ;  [CONTEXT]                  public  class  Attributes  implements  Iterable<Attribute>  {  [BUGGY]  private  LinkedHashMap<String,  Attribute>  attributes  ;            Get  an  attribute  value  by  key.  @param  key  the  attribute  key        [CLASS]  Attributes      [VARIABLES]  
Validate.notEmpty  (  key  )  ;	[BUGGY]  Validate.notNull(  key);  [CONTEXT]  public  String  get(String  key)  {  [BUGGY]  Validate.notNull  (  key  )  ;    Attribute  attr  =  attributes.get(key.toLowerCase());  return  attr  !=  null  ?  attr.getValue()  :   " ";  }        [CLASS]  Attributes    [METHOD]  get  [RETURN_TYPE]  String      String  key  [VARIABLES]  String    key    boolean    Attribute    attr    LinkedHashMap    attributes    
Validate.notEmpty  (  key  )  ;	[BUGGY]    [CONTEXT]  public  String  get(String  key)  {  [BUGGY]  Validate.notEmpty(key);      Attribute  attr  =  attributes.get(key.toLowerCase());  return  attr  !=  null  ?  attr.getValue()  :   " ";        [CLASS]  Attributes    [METHOD]  get  [RETURN_TYPE]  String      String  key  [VARIABLES]  String    key    boolean    Attribute    attr    LinkedHashMap    attributes    
Attribute  attr  =  attributes.get  (  key.toLowerCase  (  )  )  ;	[BUGGY]  Attribute  attr  =  null.get(  key.toLowerCase(  ));  [CONTEXT]  public  String  get(String  key)  {  Validate.notEmpty(key);    [BUGGY]  Attribute  attr  =  null.get  (  key.toLowerCase  ())  ;  return  attr  !=  null  ?  attr.getValue()  :   " ";  }        [CLASS]  Attributes    [METHOD]  get  [RETURN_TYPE]  String      String  key  [VARIABLES]  String    key    boolean    Attribute    attr    LinkedHashMap    attributes    
Attribute  attr  =  attributes.get  (  key.toLowerCase  (  )  )  ;	[BUGGY]  Attribute  attr  =  key.get(  attributes.toLowerCase(  ));  [CONTEXT]  public  String  get(String  key)  {  Validate.notEmpty(key);    [BUGGY]  Attribute  attr  =  key.get  (  attributes.toLowerCase  ())  ;  return  attr  !=  null  ?  attr.getValue()  :   " ";  }        [CLASS]  Attributes    [METHOD]  get  [RETURN_TYPE]  String      String  key  [VARIABLES]  String    key    boolean    Attribute    attr    LinkedHashMap    attributes    
Attribute  attr  =  attributes.get  (  key.toLowerCase  (  )  )  ;	[BUGGY]  Attribute  attr  =  attributes.put(  key.toLowerCase(  ));  [CONTEXT]  public  String  get(String  key)  {  Validate.notEmpty(key);    [BUGGY]  Attribute  attr  =  attributes.put  (  key.toLowerCase  ())  ;  return  attr  !=  null  ?  attr.getValue()  :   " ";  }        [CLASS]  Attributes    [METHOD]  get  [RETURN_TYPE]  String      String  key  [VARIABLES]  String    key    boolean    Attribute    attr    LinkedHashMap    attributes    
Attribute  attr  =  attributes.get  (  key.toLowerCase  (  )  )  ;	[BUGGY]    Attribute  attr  =  attributes.get(  key.toLowerCase(  ));  [CONTEXT]        [CLASS]  Attributes    [METHOD]  get  [RETURN_TYPE]  String      String  key  [VARIABLES]  String    key    boolean    Attribute    attr    LinkedHashMap    attributes    
Attribute  attr  =  attributes.get  (  key.toLowerCase  (  )  )  ;	[BUGGY]  Attribute  attr  =  new  Attribute(  key,  value);Attribute  attr  =  attributes.get(  key.toLowerCase(  ));  [CONTEXT]        [CLASS]  Attributes    [METHOD]  get  [RETURN_TYPE]  String      String  key  [VARIABLES]  String    key    boolean    Attribute    attr    LinkedHashMap    attributes    
Attribute  attr  =  attributes.get  (  key.toLowerCase  (  )  )  ;	[BUGGY]  Attribute  attr  =  attributes  .put(  key  ,  key)  ;  [CONTEXT]  public  String  get(String  key)  {  Validate.notEmpty(key);    [BUGGY]  Attribute  attr  =  attributes  .put  (  key  ,  key  );  return  attr  !=  null  ?  attr.getValue()  :   " ";  }        [CLASS]  Attributes    [METHOD]  get  [RETURN_TYPE]  String      String  key  [VARIABLES]  String    key    boolean    Attribute    attr    LinkedHashMap    attributes    
Attribute  attr  =  attributes.get  (  key.toLowerCase  (  )  )  ;  return  attr  !=  null  ?  attr.getValue  (  )  :   " ";	[BUGGY]    [CONTEXT]  public  String  get(String  key)  {  Validate.notEmpty(key);    [BUGGY]  Attribute  attr  =  attributes.get(key.toLowerCase());            [CLASS]  Attributes    [METHOD]  get  [RETURN_TYPE]  String      String  key  [VARIABLES]  String    key    boolean    Attribute    attr    LinkedHashMap    attributes    
Attribute  attr  =  attributes.get  (  key.toLowerCase  (  )  )  ;	[BUGGY]  attributes.put(  attribute.getKey(  ),  attribute);Attribute  attr  =  attributes.get(  key.toLowerCase(  ));  [CONTEXT]        [CLASS]  Attributes    [METHOD]  get  [RETURN_TYPE]  String      String  key  [VARIABLES]  String    key    boolean    Attribute    attr    LinkedHashMap    attributes    
Attribute  attr  =  attributes.get  (  key.toLowerCase  (  )  )  ;	[BUGGY]  attributes.remove(  key.toLowerCase(  ));Attribute  attr  =  attributes.get(  key.toLowerCase(  ));  [CONTEXT]        [CLASS]  Attributes    [METHOD]  get  [RETURN_TYPE]  String      String  key  [VARIABLES]  String    key    boolean    Attribute    attr    LinkedHashMap    attributes    
Attribute  attr  =  attributes.get  (  key.toLowerCase  (  )  )  ;	[BUGGY]  return  attributes.containsKey(  key.toLowerCase(  ));Attribute  attr  =  attributes.get(  key.toLowerCase(  ));  [CONTEXT]        [CLASS]  Attributes    [METHOD]  get  [RETURN_TYPE]  String      String  key  [VARIABLES]  String    key    boolean    Attribute    attr    LinkedHashMap    attributes    
return  attr  !=  null  ?  attr.getValue  (  )  :   " ";	[BUGGY]  return  attr  ==  null  ?  attr.getValue(  )  :   " ";  [CONTEXT]  public  String  get(String  key)  {  Validate.notEmpty(key);    Attribute  attr  =  attributes.get(key.toLowerCase());  [BUGGY]  return  attr  ==  null  ?  attr.getValue  ():   " ";  }        [CLASS]  Attributes    [METHOD]  get  [RETURN_TYPE]  String      String  key  [VARIABLES]  String    key    boolean    Attribute    attr    LinkedHashMap    attributes    
return  attr  !=  null  ?  attr.getValue  (  )  :   " ";	[BUGGY]  return  attr  !  =     " ";  [CONTEXT]  public  String  get(String  key)  {  Validate.notEmpty(key);    Attribute  attr  =  attributes.get(key.toLowerCase());  [BUGGY]  return  attr  !  = " ";  }        [CLASS]  Attributes    [METHOD]  get  [RETURN_TYPE]  String      String  key  [VARIABLES]  String    key    boolean    Attribute    attr    LinkedHashMap    attributes    
return  attr  !=  null  ?  attr.getValue  (  )  :   " ";	[BUGGY]  return  attr  !  =    attr.getValue(  )  ;  [CONTEXT]  public  String  get(String  key)  {  Validate.notEmpty(key);    Attribute  attr  =  attributes.get(key.toLowerCase());  [BUGGY]  return  attr  !  =attr.getValue  ();  }        [CLASS]  Attributes    [METHOD]  get  [RETURN_TYPE]  String      String  key  [VARIABLES]  String    key    boolean    Attribute    attr    LinkedHashMap    attributes    
return  attr  !=  null  ?  attr.getValue  (  )  :   " ";	[BUGGY]  return  attr  !=  null  ?  attr  .getKey(  )    :   " ";  [CONTEXT]  public  String  get(String  key)  {  Validate.notEmpty(key);    Attribute  attr  =  attributes.get(key.toLowerCase());  [BUGGY]  return  attr  !=  null  ?  attr  .getKey  ()  :   " ";  }        [CLASS]  Attributes    [METHOD]  get  [RETURN_TYPE]  String      String  key  [VARIABLES]  String    key    boolean    Attribute    attr    LinkedHashMap    attributes    
return  attr  !=  null  ?  attr.getValue  (  )  :   " ";	[BUGGY]    [CONTEXT]  public  String  get(String  key)  {  Validate.notEmpty(key);    Attribute  attr  =  attributes.get(key.toLowerCase());  [BUGGY]  return  attr  !=  null  ?  attr.getValue()  :   " ";          [CLASS]  Attributes    [METHOD]  get  [RETURN_TYPE]  String      String  key  [VARIABLES]  String    key    boolean    Attribute    attr    LinkedHashMap    attributes    
Attribute  attr  =  new  Attribute  (  key,  value  )  ;	[BUGGY]  Attribute  attr  =  new  Attribute(    value);  [CONTEXT]  public  void  put(String  key,  String  value)  {  [BUGGY]  Attribute  attr  =  new  Attribute  (value  )  ;  put(attr);  }        [CLASS]  Attributes    [METHOD]  put  [RETURN_TYPE]  void      String  key  String  value  [VARIABLES]  String    key    value    boolean    Attribute    attr    LinkedHashMap    attributes    
Attribute  attr  =  new  Attribute  (  key,  value  )  ;	[BUGGY]  Attribute  attr  =  new  Attribute(  key);  [CONTEXT]  public  void  put(String  key,  String  value)  {  [BUGGY]  Attribute  attr  =  new  Attribute  (  key  )  ;  put(attr);  }        [CLASS]  Attributes    [METHOD]  put  [RETURN_TYPE]  void      String  key  String  value  [VARIABLES]  String    key    value    boolean    Attribute    attr    LinkedHashMap    attributes    
Attribute  attr  =  new  Attribute  (  key,  value  )  ;	[BUGGY]  Attribute  attr  =  new  Attribute(  value,  key);  [CONTEXT]  public  void  put(String  key,  String  value)  {  [BUGGY]  Attribute  attr  =  new  Attribute  (  value,  key  )  ;  put(attr);  }        [CLASS]  Attributes    [METHOD]  put  [RETURN_TYPE]  void      String  key  String  value  [VARIABLES]  String    key    value    boolean    Attribute    attr    LinkedHashMap    attributes    
Attribute  attr  =  new  Attribute  (  key,  value  )  ;	[BUGGY]  Attribute  attr  =  new  Attribute(  value,  value);  [CONTEXT]  public  void  put(String  key,  String  value)  {  [BUGGY]  Attribute  attr  =  new  Attribute  (  value,  value  )  ;  put(attr);  }        [CLASS]  Attributes    [METHOD]  put  [RETURN_TYPE]  void      String  key  String  value  [VARIABLES]  String    key    value    boolean    Attribute    attr    LinkedHashMap    attributes    
Attribute  attr  =  new  Attribute  (  key,  value  )  ;	[BUGGY]  Attribute  attr  =  new  Attribute(  key,  key);  [CONTEXT]  public  void  put(String  key,  String  value)  {  [BUGGY]  Attribute  attr  =  new  Attribute  (  key,  key  )  ;  put(attr);  }        [CLASS]  Attributes    [METHOD]  put  [RETURN_TYPE]  void      String  key  String  value  [VARIABLES]  String    key    value    boolean    Attribute    attr    LinkedHashMap    attributes    
Attribute  attr  =  new  Attribute  (  key,  value  )  ;  put  (  attr  )  ;	[BUGGY]  put(  attr);  Attribute  attr  =  new  Attribute(  key,  value);  [CONTEXT]        [CLASS]  Attributes    [METHOD]  put  [RETURN_TYPE]  void      String  key  String  value  [VARIABLES]  String    key    value    boolean    Attribute    attr    LinkedHashMap    attributes    
Attribute  attr  =  new  Attribute  (  key,  value  )  ;  put  (  attr  )  ;	[BUGGY]  Attribute  attr  =  attributes.get(  key.toLowerCase(  ));Attribute  attr  =  new  Attribute(  key,  value);  put(  attr);  [CONTEXT]        [CLASS]  Attributes    [METHOD]  put  [RETURN_TYPE]  void      String  key  String  value  [VARIABLES]  String    key    value    boolean    Attribute    attr    LinkedHashMap    attributes    
Attribute  attr  =  new  Attribute  (  key,  value  )  ;  put  (  attr  )  ;	[BUGGY]  Attribute  attr  =  new  Attribute(  key,  value);Attribute  attr  =  new  Attribute(  key,  value);  put(  attr);  [CONTEXT]        [CLASS]  Attributes    [METHOD]  put  [RETURN_TYPE]  void      String  key  String  value  [VARIABLES]  String    key    value    boolean    Attribute    attr    LinkedHashMap    attributes    
put  (  attr  )  ;	[BUGGY]  addAll(  attr);  [CONTEXT]  public  void  put(String  key,  String  value)  {  Attribute  attr  =  new  Attribute(key,  value);  [BUGGY]  addAll  (  attr  )  ;  }        [CLASS]  Attributes    [METHOD]  put  [RETURN_TYPE]  void      String  key  String  value  [VARIABLES]  String    key    value    boolean    Attribute    attr    LinkedHashMap    attributes    
put  (  attr  )  ;	[BUGGY]    [CONTEXT]  public  void  put(String  key,  String  value)  {  Attribute  attr  =  new  Attribute(key,  value);  [BUGGY]  put(attr);          [CLASS]  Attributes    [METHOD]  put  [RETURN_TYPE]  void      String  key  String  value  [VARIABLES]  String    key    value    boolean    Attribute    attr    LinkedHashMap    attributes    
Validate.notNull  (  attribute  )  ;	[BUGGY]  Validate.notEmpty(  attribute);  [CONTEXT]  public  void  put(Attribute  attribute)  {  [BUGGY]  Validate.notEmpty  (  attribute  )  ;  attributes.put(attribute.getKey(),  attribute);  }        [CLASS]  Attributes    [METHOD]  put  [RETURN_TYPE]  void      Attribute  attribute  [VARIABLES]  Attribute    attribute    LinkedHashMap    attributes    boolean    
Validate.notNull  (  attribute  )  ;  attributes.put  (  attribute.getKey  (  )  ,  attribute  )  ;	[BUGGY]    [CONTEXT]  public  void  put(Attribute  attribute)  {  [BUGGY]  Validate.notNull(attribute);            [CLASS]  Attributes    [METHOD]  put  [RETURN_TYPE]  void      Attribute  attribute  [VARIABLES]  Attribute    attribute    LinkedHashMap    attributes    boolean    
Validate.notNull  (  attribute  )  ;	[BUGGY]    Validate.notNull(  attribute);  [CONTEXT]        [CLASS]  Attributes    [METHOD]  put  [RETURN_TYPE]  void      Attribute  attribute  [VARIABLES]  Attribute    attribute    LinkedHashMap    attributes    boolean    
Validate.notNull  (  attribute  )  ;	[BUGGY]  attributes.putAll(  incoming.attributes);Validate.notNull(  attribute);  [CONTEXT]        [CLASS]  Attributes    [METHOD]  put  [RETURN_TYPE]  void      Attribute  attribute  [VARIABLES]  Attribute    attribute    LinkedHashMap    attributes    boolean    
Validate.notNull  (  attribute  )  ;	[BUGGY]  Validate.notEmpty(  key);Validate.notNull(  attribute);  [CONTEXT]        [CLASS]  Attributes    [METHOD]  put  [RETURN_TYPE]  void      Attribute  attribute  [VARIABLES]  Attribute    attribute    LinkedHashMap    attributes    boolean    
attributes.put  (  attribute.getKey  (  )  ,  attribute  )  ;	[BUGGY]  attributes.put(  attribute.getKey(  ));  [CONTEXT]  public  void  put(Attribute  attribute)  {  Validate.notNull(attribute);  [BUGGY]  attributes.put  (  attribute.getKey  ())  ;  }        [CLASS]  Attributes    [METHOD]  put  [RETURN_TYPE]  void      Attribute  attribute  [VARIABLES]  Attribute    attribute    LinkedHashMap    attributes    boolean    
attributes.put  (  attribute.getKey  (  )  ,  attribute  )  ;	[BUGGY]  attributes  .put(  attribute)  ;  [CONTEXT]  public  void  put(Attribute  attribute)  {  Validate.notNull(attribute);  [BUGGY]  attributes  .put  (  attribute  );  }        [CLASS]  Attributes    [METHOD]  put  [RETURN_TYPE]  void      Attribute  attribute  [VARIABLES]  Attribute    attribute    LinkedHashMap    attributes    boolean    
attributes.put  (  attribute.getKey  (  )  ,  attribute  )  ;	[BUGGY]  attributes.put(  attribute  .getValue(  )  ,  attribute);  [CONTEXT]  public  void  put(Attribute  attribute)  {  Validate.notNull(attribute);  [BUGGY]  attributes.put  (  attribute  .getValue  (),  attribute  )  ;  }        [CLASS]  Attributes    [METHOD]  put  [RETURN_TYPE]  void      Attribute  attribute  [VARIABLES]  Attribute    attribute    LinkedHashMap    attributes    boolean    
attributes.put  (  attribute.getKey  (  )  ,  attribute  )  ;	[BUGGY]    [CONTEXT]  public  void  put(Attribute  attribute)  {  Validate.notNull(attribute);  [BUGGY]  attributes.put(attribute.getKey(),  attribute);          [CLASS]  Attributes    [METHOD]  put  [RETURN_TYPE]  void      Attribute  attribute  [VARIABLES]  Attribute    attribute    LinkedHashMap    attributes    boolean    
Validate.notEmpty  (  key  )  ;	[BUGGY]  Validate.notNull(  key);  [CONTEXT]  public  void  remove(String  key)  {  [BUGGY]  Validate.notNull  (  key  )  ;  attributes.remove(key.toLowerCase());  }        [CLASS]  Attributes    [METHOD]  remove  [RETURN_TYPE]  void      String  key  [VARIABLES]  LinkedHashMap    attributes    String    key    boolean    
Validate.notEmpty  (  key  )  ;  attributes.remove  (  key.toLowerCase  (  )  )  ;	[BUGGY]    [CONTEXT]  public  void  remove(String  key)  {  [BUGGY]  Validate.notEmpty(key);            [CLASS]  Attributes    [METHOD]  remove  [RETURN_TYPE]  void      String  key  [VARIABLES]  LinkedHashMap    attributes    String    key    boolean    
Validate.notEmpty  (  key  )  ;	[BUGGY]    Validate.notEmpty(  key);  [CONTEXT]        [CLASS]  Attributes    [METHOD]  remove  [RETURN_TYPE]  void      String  key  [VARIABLES]  LinkedHashMap    attributes    String    key    boolean    
Validate.notEmpty  (  key  )  ;	[BUGGY]  Validate.notNull(  attribute);Validate.notEmpty(  key);  [CONTEXT]        [CLASS]  Attributes    [METHOD]  remove  [RETURN_TYPE]  void      String  key  [VARIABLES]  LinkedHashMap    attributes    String    key    boolean    
attributes.remove  (  key.toLowerCase  (  )  )  ;	[BUGGY]  attributes.put(  key.toLowerCase(  ));  [CONTEXT]  public  void  remove(String  key)  {  Validate.notEmpty(key);  [BUGGY]  attributes.put  (  key.toLowerCase  ())  ;  }        [CLASS]  Attributes    [METHOD]  remove  [RETURN_TYPE]  void      String  key  [VARIABLES]  LinkedHashMap    attributes    String    key    boolean    
attributes.remove  (  key.toLowerCase  (  )  )  ;	[BUGGY]    [CONTEXT]  public  void  remove(String  key)  {  Validate.notEmpty(key);  [BUGGY]  attributes.remove(key.toLowerCase());          [CLASS]  Attributes    [METHOD]  remove  [RETURN_TYPE]  void      String  key  [VARIABLES]  LinkedHashMap    attributes    String    key    boolean    
return  attributes.containsKey  (  key.toLowerCase  (  )  )  ;	[BUGGY]  return  key.containsKey(  attributes.toLowerCase(  ));  [CONTEXT]  public  boolean  hasKey(String  key)  {  [BUGGY]  return  key.containsKey  (  attributes.toLowerCase  ())  ;  }        [CLASS]  Attributes    [METHOD]  hasKey  [RETURN_TYPE]  boolean      String  key  [VARIABLES]  LinkedHashMap    attributes    String    key    boolean    
return  attributes.containsKey  (  key.toLowerCase  (  )  )  ;	[BUGGY]  return  attributes.put(  key.toLowerCase(  ));  [CONTEXT]  public  boolean  hasKey(String  key)  {  [BUGGY]  return  attributes.put  (  key.toLowerCase  ())  ;  }        [CLASS]  Attributes    [METHOD]  hasKey  [RETURN_TYPE]  boolean      String  key  [VARIABLES]  LinkedHashMap    attributes    String    key    boolean    
return  attributes.containsKey  (  key.toLowerCase  (  )  )  ;	[BUGGY]  return  attributes  .entrySet(  )  ;  [CONTEXT]  public  boolean  hasKey(String  key)  {  [BUGGY]  return  attributes  .entrySet  ();  }        [CLASS]  Attributes    [METHOD]  hasKey  [RETURN_TYPE]  boolean      String  key  [VARIABLES]  LinkedHashMap    attributes    String    key    boolean    
return  attributes.containsKey  (  key.toLowerCase  (  )  )  ;	[BUGGY]  return  0  .entrySet(  )  ;  [CONTEXT]  public  boolean  hasKey(String  key)  {  [BUGGY]  return  0  .entrySet  ();  }        [CLASS]  Attributes    [METHOD]  hasKey  [RETURN_TYPE]  boolean      String  key  [VARIABLES]  LinkedHashMap    attributes    String    key    boolean    
return  attributes.containsKey  (  key.toLowerCase  (  )  )  ;	[BUGGY]    [CONTEXT]  public  boolean  hasKey(String  key)  {  [BUGGY]  return  attributes.containsKey(key.toLowerCase());          [CLASS]  Attributes    [METHOD]  hasKey  [RETURN_TYPE]  boolean      String  key  [VARIABLES]  LinkedHashMap    attributes    String    key    boolean    
return  attributes.size  (  )  ;	[BUGGY]  return  attributes.size()  -  7  ;  [CONTEXT]  public  int  size()  {  [BUGGY]  return  attributes.size()  -  7  ;  }        [CLASS]  Attributes    [METHOD]  size  [RETURN_TYPE]  int      [VARIABLES]  LinkedHashMap    attributes    boolean    
return  attributes.size  (  )  ;	[BUGGY]  return  attributes.get(  );  [CONTEXT]  public  int  size()  {  [BUGGY]  return  attributes.get  ()  ;  }        [CLASS]  Attributes    [METHOD]  size  [RETURN_TYPE]  int      [VARIABLES]  LinkedHashMap    attributes    boolean    
return  attributes.size  (  )  ;	[BUGGY]  return  attributes.size()  -  8  ;  [CONTEXT]  public  int  size()  {  [BUGGY]  return  attributes.size()  -  8  ;  }        [CLASS]  Attributes    [METHOD]  size  [RETURN_TYPE]  int      [VARIABLES]  LinkedHashMap    attributes    boolean    
return  attributes.size  (  )  ;	[BUGGY]    [CONTEXT]  public  int  size()  {  [BUGGY]  return  attributes.size();          [CLASS]  Attributes    [METHOD]  size  [RETURN_TYPE]  int      [VARIABLES]  LinkedHashMap    attributes    boolean    
attributes.putAll  (  incoming.attributes  )  ;	[BUGGY]  attributes.putAll(  incoming.attributes.attributes);  [CONTEXT]  public  void  addAll(Attributes  incoming)  {  [BUGGY]  attributes.putAll  (  incoming.attributes.attributes  )  ;  }        [CLASS]  Attributes    [METHOD]  addAll  [RETURN_TYPE]  void      Attributes  incoming  [VARIABLES]  Attributes    incoming    LinkedHashMap    attributes    boolean    
attributes.putAll  (  incoming.attributes  )  ;	[BUGGY]  attributes.putAll(  incoming);  [CONTEXT]  public  void  addAll(Attributes  incoming)  {  [BUGGY]  attributes.putAll  (  incoming  )  ;  }        [CLASS]  Attributes    [METHOD]  addAll  [RETURN_TYPE]  void      Attributes  incoming  [VARIABLES]  Attributes    incoming    LinkedHashMap    attributes    boolean    
attributes.putAll  (  incoming.attributes  )  ;	[BUGGY]  attributes.equals(  incoming.attributes);  [CONTEXT]  public  void  addAll(Attributes  incoming)  {  [BUGGY]  attributes.equals  (  incoming.attributes  )  ;  }        [CLASS]  Attributes    [METHOD]  addAll  [RETURN_TYPE]  void      Attributes  incoming  [VARIABLES]  Attributes    incoming    LinkedHashMap    attributes    boolean    
attributes.putAll  (  incoming.attributes  )  ;	[BUGGY]  attributes.putAll(  2);  [CONTEXT]  public  void  addAll(Attributes  incoming)  {  [BUGGY]  attributes.putAll  (  2  )  ;  }        [CLASS]  Attributes    [METHOD]  addAll  [RETURN_TYPE]  void      Attributes  incoming  [VARIABLES]  Attributes    incoming    LinkedHashMap    attributes    boolean    
attributes.putAll  (  incoming.attributes  )  ;	[BUGGY]    [CONTEXT]  public  void  addAll(Attributes  incoming)  {  [BUGGY]  attributes.putAll(incoming.attributes);          [CLASS]  Attributes    [METHOD]  addAll  [RETURN_TYPE]  void      Attributes  incoming  [VARIABLES]  Attributes    incoming    LinkedHashMap    attributes    boolean    
return  asList  (  )  .iterator  (  )  ;	[BUGGY]  return  asList(  ).add(  );  [CONTEXT]  public  Iterator<Attribute>  iterator()  {  [BUGGY]  return  asList  ()  .add  ()  ;  }        [CLASS]  Attributes    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  LinkedHashMap    attributes    boolean    
return  asList  (  )  .iterator  (  )  ;	[BUGGY]  return  html(  ).iterator(  );  [CONTEXT]  public  Iterator<Attribute>  iterator()  {  [BUGGY]  return  html  ()  .iterator  ()  ;  }        [CLASS]  Attributes    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  LinkedHashMap    attributes    boolean    
return  asList  (  )  .iterator  (  )  ;	[BUGGY]    [CONTEXT]  public  Iterator<Attribute>  iterator()  {  [BUGGY]  return  asList().iterator();          [CLASS]  Attributes    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  LinkedHashMap    attributes    boolean    
List<Attribute>  list  =  new  ArrayList<Attribute>  (  attributes.size  (  )  )  ;	[BUGGY]  List<Attribute>  list  =  new  ArrayList<Attribute>(  attributes.size()  +  3  );  [CONTEXT]  public  List<Attribute>  asList()  {  [BUGGY]  List<Attribute>  list  =  new  ArrayList<Attribute>  (  attributes.size()  +  3)  ;  for  (Map.Entry<String,  Attribute>  entry  :  attributes.entrySet())  {  list.add(entry.getValue());  }  return  Collections.unmodifiableList(list);  }        [CLASS]  Attributes    [METHOD]  asList  [RETURN_TYPE]  List      [VARIABLES]  List    list    Entry    entry    boolean    LinkedHashMap    attributes    
List<Attribute>  list  =  new  ArrayList<Attribute>  (  attributes.size  (  )  )  ;	[BUGGY]  List<Attribute>  list  =  new  ArrayList<Attribute>(  null.size(  ));  [CONTEXT]  public  List<Attribute>  asList()  {  [BUGGY]  List<Attribute>  list  =  new  ArrayList<Attribute>  (  null.size  ())  ;  for  (Map.Entry<String,  Attribute>  entry  :  attributes.entrySet())  {  list.add(entry.getValue());  }  return  Collections.unmodifiableList(list);  }        [CLASS]  Attributes    [METHOD]  asList  [RETURN_TYPE]  List      [VARIABLES]  List    list    Entry    entry    boolean    LinkedHashMap    attributes    
List<Attribute>  list  =  new  ArrayList<Attribute>  (  attributes.size  (  )  )  ;	[BUGGY]  List<Attribute>  list  =  new  ArrayList<Attribute>(  attributes.get(  ));  [CONTEXT]  public  List<Attribute>  asList()  {  [BUGGY]  List<Attribute>  list  =  new  ArrayList<Attribute>  (  attributes.get  ())  ;  for  (Map.Entry<String,  Attribute>  entry  :  attributes.entrySet())  {  list.add(entry.getValue());  }  return  Collections.unmodifiableList(list);  }        [CLASS]  Attributes    [METHOD]  asList  [RETURN_TYPE]  List      [VARIABLES]  List    list    Entry    entry    boolean    LinkedHashMap    attributes    
List<Attribute>  list  =  new  ArrayList<Attribute>  (  attributes.size  (  )  )  ;	[BUGGY]  List<Attribute>  list  =  new  ArrayList<Attribute>(  attributes  .hashCode(  )  );  [CONTEXT]  public  List<Attribute>  asList()  {  [BUGGY]  List<Attribute>  list  =  new  ArrayList<Attribute>  (  attributes  .hashCode  ()  )  ;  for  (Map.Entry<String,  Attribute>  entry  :  attributes.entrySet())  {  list.add(entry.getValue());  }  return  Collections.unmodifiableList(list);  }        [CLASS]  Attributes    [METHOD]  asList  [RETURN_TYPE]  List      [VARIABLES]  List    list    Entry    entry    boolean    LinkedHashMap    attributes    
List<Attribute>  list  =  new  ArrayList<Attribute>  (  attributes.size  (  )  )  ;	[BUGGY]  List<Attribute>  list  =  new  ArrayList<Attribute>(  attributes.size()  +  0  );  [CONTEXT]  public  List<Attribute>  asList()  {  [BUGGY]  List<Attribute>  list  =  new  ArrayList<Attribute>  (  attributes.size()  +  0)  ;  for  (Map.Entry<String,  Attribute>  entry  :  attributes.entrySet())  {  list.add(entry.getValue());  }  return  Collections.unmodifiableList(list);  }        [CLASS]  Attributes    [METHOD]  asList  [RETURN_TYPE]  List      [VARIABLES]  List    list    Entry    entry    boolean    LinkedHashMap    attributes    
List<Attribute>  list  =  new  ArrayList<Attribute>  (  attributes.size  (  )  )  ;	[BUGGY]  List<Attribute>  list  =  new  ArrayList<Attribute>(  attributes.size()  -  9  );  [CONTEXT]  public  List<Attribute>  asList()  {  [BUGGY]  List<Attribute>  list  =  new  ArrayList<Attribute>  (  attributes.size()  -  9)  ;  for  (Map.Entry<String,  Attribute>  entry  :  attributes.entrySet())  {  list.add(entry.getValue());  }  return  Collections.unmodifiableList(list);  }        [CLASS]  Attributes    [METHOD]  asList  [RETURN_TYPE]  List      [VARIABLES]  List    list    Entry    entry    boolean    LinkedHashMap    attributes    
List<Attribute>  list  =  new  ArrayList<Attribute>  (  attributes.size  (  )  )  ;	[BUGGY]    [CONTEXT]  public  List<Attribute>  asList()  {  [BUGGY]  List<Attribute>  list  =  new  ArrayList<Attribute>(attributes.size());    for  (Map.Entry<String,  Attribute>  entry  :  attributes.entrySet())  {  list.add(entry.getValue());  }  return  Collections.unmodifiableList(list);        [CLASS]  Attributes    [METHOD]  asList  [RETURN_TYPE]  List      [VARIABLES]  List    list    Entry    entry    boolean    LinkedHashMap    attributes    
for  (  Map.Entry<String,  Attribute>  entry  :  attributes.entrySet  (  )  )  {	[BUGGY]  for  (  Map.Entry<String,  Attribute>  entry  :  attributes.get(  ))  {  [CONTEXT]  public  List<Attribute>  asList()  {  List<Attribute>  list  =  new  ArrayList<Attribute>(attributes.size());  [BUGGY]  for(  Map.Entry<String,  Attribute>  entry  :  attributes.get  ()){  list.add(entry.getValue());  }  return  Collections.unmodifiableList(list);  }        [CLASS]  Attributes    [METHOD]  asList  [RETURN_TYPE]  List      [VARIABLES]  List    list    Entry    entry    boolean    LinkedHashMap    attributes    
for  (  Map.Entry<String,  Attribute>  entry  :  attributes.entrySet  (  )  )  {  list.add  (  entry.getValue  (  )  )  ;  }	[BUGGY]    [CONTEXT]  public  List<Attribute>  asList()  {  List<Attribute>  list  =  new  ArrayList<Attribute>(attributes.size());  [BUGGY]  for  (Map.Entry<String,  Attribute>  entry  :  attributes.entrySet())  {        return  Collections.unmodifiableList(list);        [CLASS]  Attributes    [METHOD]  asList  [RETURN_TYPE]  List      [VARIABLES]  List    list    Entry    entry    boolean    LinkedHashMap    attributes    
list.add  (  entry.getValue  (  )  )  ;	[BUGGY]  list.add(  entry  .getKey(  )  );  [CONTEXT]  public  List<Attribute>  asList()  {  List<Attribute>  list  =  new  ArrayList<Attribute>(attributes.size());  for  (Map.Entry<String,  Attribute>  entry  :  attributes.entrySet())  {  [BUGGY]  list.add  (  entry  .getKey  ()  )  ;  }  return  Collections.unmodifiableList(list);  }        [CLASS]  Attributes    [METHOD]  asList  [RETURN_TYPE]  List      [VARIABLES]  List    list    Entry    entry    boolean    LinkedHashMap    attributes    
list.add  (  entry.getValue  (  )  )  ;	[BUGGY]    [CONTEXT]  public  List<Attribute>  asList()  {  List<Attribute>  list  =  new  ArrayList<Attribute>(attributes.size());  for  (Map.Entry<String,  Attribute>  entry  :  attributes.entrySet())  {  [BUGGY]  list.add(entry.getValue());    }  return  Collections.unmodifiableList(list);        [CLASS]  Attributes    [METHOD]  asList  [RETURN_TYPE]  List      [VARIABLES]  List    list    Entry    entry    boolean    LinkedHashMap    attributes    
return  Collections.unmodifiableList  (  list  )  ;  }	[BUGGY]    [CONTEXT]  public  List<Attribute>  asList()  {  List<Attribute>  list  =  new  ArrayList<Attribute>(attributes.size());  for  (Map.Entry<String,  Attribute>  entry  :  attributes.entrySet())  {  list.add(entry.getValue());  }  [BUGGY]  return  Collections.unmodifiableList(list);          [CLASS]  Attributes    [METHOD]  asList  [RETURN_TYPE]  List      [VARIABLES]  List    list    Entry    entry    boolean    LinkedHashMap    attributes    
accum.append  (   "   "  )  ;	[BUGGY]  accum.append(   " ");  [CONTEXT]  public  String  html()  {  StringBuilder  accum  =  new  StringBuilder();  for  (Attribute  attribute  :  this)  {  [BUGGY]  accum.append  (   " "  )  ;  accum.append(attribute.html());  }  return  accum.toString();  }        [CLASS]  Attributes    [METHOD]  html  [RETURN_TYPE]  String      [VARIABLES]  boolean    StringBuilder    accum    Attribute    attribute    LinkedHashMap    attributes    
accum.append  (   "   "  )  ;  accum.append  (  attribute.html  (  )  )  ;	[BUGGY]    [CONTEXT]  public  String  html()  {  StringBuilder  accum  =  new  StringBuilder();  for  (Attribute  attribute  :  this)  {  [BUGGY]  accum.append( "   ");      }  return  accum.toString();        [CLASS]  Attributes    [METHOD]  html  [RETURN_TYPE]  String      [VARIABLES]  boolean    StringBuilder    accum    Attribute    attribute    LinkedHashMap    attributes    
accum.append  (   "   "  )  ;  accum.append  (  attribute.html  (  )  )  ;	[BUGGY]  accum.append(  attribute.html(  ));  accum.append(   "   ");  [CONTEXT]        [CLASS]  Attributes    [METHOD]  html  [RETURN_TYPE]  String      [VARIABLES]  boolean    StringBuilder    accum    Attribute    attribute    LinkedHashMap    attributes    
accum.append  (   "   "  )  ;  accum.append  (  attribute.html  (  )  )  ;	[BUGGY]  accum.append(  attribute.html(  ));accum.append(   "   ");  accum.append(  attribute.html(  ));  [CONTEXT]        [CLASS]  Attributes    [METHOD]  html  [RETURN_TYPE]  String      [VARIABLES]  boolean    StringBuilder    accum    Attribute    attribute    LinkedHashMap    attributes    
accum.append  (  attribute.html  (  )  )  ;	[BUGGY]    [CONTEXT]  public  String  html()  {  StringBuilder  accum  =  new  StringBuilder();  for  (Attribute  attribute  :  this)  {  accum.append( "   ");  [BUGGY]  accum.append(attribute.html());    }  return  accum.toString();        [CLASS]  Attributes    [METHOD]  html  [RETURN_TYPE]  String      [VARIABLES]  boolean    StringBuilder    accum    Attribute    attribute    LinkedHashMap    attributes    
accum.append  (  attribute.html  (  )  )  ;	[BUGGY]  accum.append(  attribute  .getValue(  )  );  [CONTEXT]  public  String  html()  {  StringBuilder  accum  =  new  StringBuilder();  for  (Attribute  attribute  :  this)  {  accum.append( "   ");  [BUGGY]  accum.append  (  attribute  .getValue  ()  )  ;  }  return  accum.toString();  }        [CLASS]  Attributes    [METHOD]  html  [RETURN_TYPE]  String      [VARIABLES]  boolean    StringBuilder    accum    Attribute    attribute    LinkedHashMap    attributes    
return  accum.toString  (  )  ;	[BUGGY]  return  accum.append(  );  [CONTEXT]  public  String  html()  {  StringBuilder  accum  =  new  StringBuilder();  for  (Attribute  attribute  :  this)  {  accum.append( "   ");  accum.append(attribute.html());  }  [BUGGY]  return  accum.append  ()  ;  }        [CLASS]  Attributes    [METHOD]  html  [RETURN_TYPE]  String      [VARIABLES]  boolean    StringBuilder    accum    Attribute    attribute    LinkedHashMap    attributes    
return  accum.toString  (  )  ;	[BUGGY]    [CONTEXT]  public  String  html()  {  StringBuilder  accum  =  new  StringBuilder();  for  (Attribute  attribute  :  this)  {  accum.append( "   ");  accum.append(attribute.html());  }  [BUGGY]  return  accum.toString();          [CLASS]  Attributes    [METHOD]  html  [RETURN_TYPE]  String      [VARIABLES]  boolean    StringBuilder    accum    Attribute    attribute    LinkedHashMap    attributes    
return  html  (  )  ;	[BUGGY]  return  asList(  );  [CONTEXT]  public  String  toString()  {  [BUGGY]  return  asList  ()  ;  }        [CLASS]  Attributes    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  LinkedHashMap    attributes    boolean    
return  html  (  )  ;	[BUGGY]    [CONTEXT]  public  String  toString()  {  [BUGGY]  return  html();          [CLASS]  Attributes    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  LinkedHashMap    attributes    boolean    
if  (  this  ==  o  )  return  true;	[BUGGY]  if  (  this  !=  o)  return  true;  [CONTEXT]  public  boolean  equals(Object  o)  {  [BUGGY]  if(  this  !=  o  )return  true;  if  (!(o  instanceof  Attributes))  return  false;    Attributes  that  =  (Attributes)  o;    if  (attributes  !=  null  ?  !attributes.equals(that.attributes)  :  that.attributes  !=  null)  return  false;    return  true;  }        [CLASS]  Attributes    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  Attributes    that    Object    o    boolean    LinkedHashMap    attributes    
if  (  this  ==  o  )  return  true;	[BUGGY]  if  (  this  ==  o)  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  [BUGGY]  if(  this  ==  o  )return  false;  if  (!(o  instanceof  Attributes))  return  false;    Attributes  that  =  (Attributes)  o;    if  (attributes  !=  null  ?  !attributes.equals(that.attributes)  :  that.attributes  !=  null)  return  false;    return  true;  }        [CLASS]  Attributes    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  Attributes    that    Object    o    boolean    LinkedHashMap    attributes    
if  (  !  (  o  instanceof  Attributes  )  )  return  false;	[BUGGY]  if  (  !(  o    !=    Attributes))  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  [BUGGY]  if(  !  (  o!=Attributes  ))return  false;    Attributes  that  =  (Attributes)  o;    if  (attributes  !=  null  ?  !attributes.equals(that.attributes)  :  that.attributes  !=  null)  return  false;    return  true;  }        [CLASS]  Attributes    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  Attributes    that    Object    o    boolean    LinkedHashMap    attributes    
if  (  !  (  o  instanceof  Attributes  )  )  return  false;	[BUGGY]  if  (  !(  o  instanceof  Attributes))  return  true;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  [BUGGY]  if(  !  (  o  instanceof  Attributes  ))return  true;    Attributes  that  =  (Attributes)  o;    if  (attributes  !=  null  ?  !attributes.equals(that.attributes)  :  that.attributes  !=  null)  return  false;    return  true;  }        [CLASS]  Attributes    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  Attributes    that    Object    o    boolean    LinkedHashMap    attributes    
if  (  attributes  !=  null  ?  !attributes.equals  (  that.attributes  )  :  that.attributes  !=  null  )  return  false;	[BUGGY]  if  (  attributes  ==  null  ?  !attributes.equals(  that.attributes)  :  that.attributes  ==  null)  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (!(o  instanceof  Attributes))  return  false;    Attributes  that  =  (Attributes)  o;    [BUGGY]  if(  attributes  ==  null  ?  !attributes.equals  (  that.attributes  ):  that.attributes  ==  null  )return  false;    return  true;  }        [CLASS]  Attributes    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  Attributes    that    Object    o    boolean    LinkedHashMap    attributes    
if  (  attributes  !=  null  ?  !attributes.equals  (  that.attributes  )  :  that.attributes  !=  null  )  return  false;	[BUGGY]  if  (  attributes  !=  null  ?  !attributes.equals(  that.attributes)  :  that.attributes  ==  null)  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (!(o  instanceof  Attributes))  return  false;    Attributes  that  =  (Attributes)  o;    [BUGGY]  if(  attributes  !=  null  ?  !attributes.equals  (  that.attributes  ):  that.attributes  ==  null  )return  false;    return  true;  }        [CLASS]  Attributes    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  Attributes    that    Object    o    boolean    LinkedHashMap    attributes    
if  (  attributes  !=  null  ?  !attributes.equals  (  that.attributes  )  :  that.attributes  !=  null  )  return  false;	[BUGGY]  if  (  attributes  !=  null  ?  !attributes.equals(  that.attributes)  :  that.attributes  !=  null)  return  true;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (!(o  instanceof  Attributes))  return  false;    Attributes  that  =  (Attributes)  o;    [BUGGY]  if(  attributes  !=  null  ?  !attributes.equals  (  that.attributes  ):  that.attributes  !=  null  )return  true;    return  true;  }        [CLASS]  Attributes    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  Attributes    that    Object    o    boolean    LinkedHashMap    attributes    
if  (  attributes  !=  null  ?  !attributes.equals  (  that.attributes  )  :  that.attributes  !=  null  )  return  false;	[BUGGY]  if  (  attributes  !=  null  ?  !attributes.equals(  that.attributes.attributes)  :  that  !=  null)  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (!(o  instanceof  Attributes))  return  false;    Attributes  that  =  (Attributes)  o;    [BUGGY]  if(  attributes  !=  null  ?  !attributes.equals  (  that.attributes.attributes  ):  that  !=  null  )return  false;    return  true;  }        [CLASS]  Attributes    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  Attributes    that    Object    o    boolean    LinkedHashMap    attributes    
if  (  attributes  !=  null  ?  !attributes.equals  (  that.attributes  )  :  that.attributes  !=  null  )  return  false;	[BUGGY]  if  (  that.attributes  !=  null  ?  !attributes.equals(  attributes)  :  that.attributes  !=  null)  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (!(o  instanceof  Attributes))  return  false;    Attributes  that  =  (Attributes)  o;    [BUGGY]  if(  that.attributes  !=  null  ?  !attributes.equals  (  attributes  ):  that.attributes  !=  null  )return  false;    return  true;  }        [CLASS]  Attributes    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  Attributes    that    Object    o    boolean    LinkedHashMap    attributes    
if  (  attributes  !=  null  ?  !attributes.equals  (  that.attributes  )  :  that.attributes  !=  null  )  return  false;	[BUGGY]  if  (  attributes  !=  null  ?  !attributes.equals(  that)  :  that.attributes.attributes  !=  null)  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (!(o  instanceof  Attributes))  return  false;    Attributes  that  =  (Attributes)  o;    [BUGGY]  if(  attributes  !=  null  ?  !attributes.equals  (  that  ):  that.attributes.attributes  !=  null  )return  false;    return  true;  }        [CLASS]  Attributes    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  Attributes    that    Object    o    boolean    LinkedHashMap    attributes    
if  (  attributes  !=  null  ?  !attributes.equals  (  that.attributes  )  :  that.attributes  !=  null  )  return  false;	[BUGGY]  if  (  that.attributes  !=  null)  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (!(o  instanceof  Attributes))  return  false;    Attributes  that  =  (Attributes)  o;    [BUGGY]  if(  that.attributes  !=  null  )return  false;    return  true;  }        [CLASS]  Attributes    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  Attributes    that    Object    o    boolean    LinkedHashMap    attributes    
if  (  attributes  !=  null  ?  !attributes.equals  (  that.attributes  )  :  that.attributes  !=  null  )  return  false;	[BUGGY]  if  (  attributes  !=  null  ?  !attributes.putAll(  that.attributes)  :  that.attributes  !=  null)  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (!(o  instanceof  Attributes))  return  false;    Attributes  that  =  (Attributes)  o;    [BUGGY]  if(  attributes  !=  null  ?  !attributes.putAll  (  that.attributes  ):  that.attributes  !=  null  )return  false;    return  true;  }        [CLASS]  Attributes    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  Attributes    that    Object    o    boolean    LinkedHashMap    attributes    
if  (  attributes  !=  null  ?  !attributes.equals  (  that.attributes  )  :  that.attributes  !=  null  )  return  false;	[BUGGY]  if  (  attributes  !=  false  ?  !attributes.equals(  that.attributes)  :  that.attributes  !=  false)  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (!(o  instanceof  Attributes))  return  false;    Attributes  that  =  (Attributes)  o;    [BUGGY]  if(  attributes  !=  false  ?  !attributes.equals  (  that.attributes  ):  that.attributes  !=  false  )return  false;    return  true;  }        [CLASS]  Attributes    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  Attributes    that    Object    o    boolean    LinkedHashMap    attributes    
if  (  attributes  !=  null  ?  !attributes.equals  (  that.attributes  )  :  that.attributes  !=  null  )  return  false;  return  true;  }	[BUGGY]  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (!(o  instanceof  Attributes))  return  false;    Attributes  that  =  (Attributes)  o;    [BUGGY]  if  (attributes  !=  null  ?  !attributes.equals(that.attributes)  :  that.attributes  !=  null)  return  false;    return  false;          [CLASS]  Attributes    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  Attributes    that    Object    o    boolean    LinkedHashMap    attributes    
if  (  attributes  !=  null  ?  !attributes.equals  (  that.attributes  )  :  that.attributes  !=  null  )  return  false;  return  true;  }	[BUGGY]    [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (!(o  instanceof  Attributes))  return  false;    Attributes  that  =  (Attributes)  o;    [BUGGY]  if  (attributes  !=  null  ?  !attributes.equals(that.attributes)  :  that.attributes  !=  null)  return  false;              [CLASS]  Attributes    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  Attributes    that    Object    o    boolean    LinkedHashMap    attributes    
if  (  attributes  !=  null  ?  !attributes.equals  (  that.attributes  )  :  that.attributes  !=  null  )  return  false;	[BUGGY]  if  (  attributes  !  =    that.attributes  !=  null)  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (!(o  instanceof  Attributes))  return  false;    Attributes  that  =  (Attributes)  o;    [BUGGY]  if(  attributes  !  =that.attributes  !=  null  )return  false;    return  true;  }        [CLASS]  Attributes    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  Attributes    that    Object    o    boolean    LinkedHashMap    attributes    
if  (  attributes  !=  null  ?  !attributes.equals  (  that.attributes  )  :  that.attributes  !=  null  )  return  false;	[BUGGY]  if  (  attributes  !  =    !attributes.equals(  that.attributes)  ;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (!(o  instanceof  Attributes))  return  false;    Attributes  that  =  (Attributes)  o;    [BUGGY]  if(  attributes  !  =!attributes.equals  (  that.attributes  );    return  true;  }        [CLASS]  Attributes    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  Attributes    that    Object    o    boolean    LinkedHashMap    attributes    
if  (  attributes  !=  null  ?  !attributes.equals  (  that.attributes  )  :  that.attributes  !=  null  )  return  false;	[BUGGY]  if  (  that  !=  null  ?  !attributes.equals(  attributes.attributes)  :  that.attributes  !=  null)  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (!(o  instanceof  Attributes))  return  false;    Attributes  that  =  (Attributes)  o;    [BUGGY]  if(  that  !=  null  ?  !attributes.equals  (  attributes.attributes  ):  that.attributes  !=  null  )return  false;    return  true;  }        [CLASS]  Attributes    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  Attributes    that    Object    o    boolean    LinkedHashMap    attributes    
if  (  attributes  !=  null  ?  !attributes.equals  (  that.attributes  )  :  that.attributes  !=  null  )  return  false;	[BUGGY]  if  (  attributes  !=  null  ?  !attributes  .addAll(  that)    :  that.attributes  !=  null)  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (!(o  instanceof  Attributes))  return  false;    Attributes  that  =  (Attributes)  o;    [BUGGY]  if(  attributes  !=  null  ?  !attributes  .addAll  (  that  )  :  that.attributes  !=  null  )return  false;    return  true;  }        [CLASS]  Attributes    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  Attributes    that    Object    o    boolean    LinkedHashMap    attributes    
return  true;	[BUGGY]  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (!(o  instanceof  Attributes))  return  false;    Attributes  that  =  (Attributes)  o;    if  (attributes  !=  null  ?  !attributes.equals(that.attributes)  :  that.attributes  !=  null)  return  false;    [BUGGY]  return  false;  }        [CLASS]  Attributes    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  Attributes    that    Object    o    boolean    LinkedHashMap    attributes    
return  attributes  !=  null  ?  attributes.hashCode  (  )  :  0;	[BUGGY]  return  attributes  ==  null  ?  attributes.hashCode(  )  :  0;  [CONTEXT]  public  int  hashCode()  {  [BUGGY]  return  attributes  ==  null  ?  attributes.hashCode  ():  0;  }        [CLASS]  Attributes    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  LinkedHashMap    attributes    boolean    
return  attributes  !=  null  ?  attributes.hashCode  (  )  :  0;	[BUGGY]  return  attributes  !=  null  ?  attributes.hashCode(  )  :  -6;  [CONTEXT]  public  int  hashCode()  {  [BUGGY]  return  attributes  !=  null  ?  attributes.hashCode  ():  -6;  }        [CLASS]  Attributes    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  LinkedHashMap    attributes    boolean    
return  attributes  !=  null  ?  attributes.hashCode  (  )  :  0;	[BUGGY]  return  attributes  !  =    0;  [CONTEXT]  public  int  hashCode()  {  [BUGGY]  return  attributes  !  =0;  }        [CLASS]  Attributes    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  LinkedHashMap    attributes    boolean    
return  attributes  !=  null  ?  attributes.hashCode  (  )  :  0;	[BUGGY]  return  attributes  !  =    attributes.hashCode(  )  ;  [CONTEXT]  public  int  hashCode()  {  [BUGGY]  return  attributes  !  =attributes.hashCode  ();  }        [CLASS]  Attributes    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  LinkedHashMap    attributes    boolean    
return  attributes  !=  null  ?  attributes.hashCode  (  )  :  0;	[BUGGY]  return  attributes  !=  null  ?  attributes.remove(  )  :  0;  [CONTEXT]  public  int  hashCode()  {  [BUGGY]  return  attributes  !=  null  ?  attributes.remove  ():  0;  }        [CLASS]  Attributes    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  LinkedHashMap    attributes    boolean    
return  attributes  !=  null  ?  attributes.hashCode  (  )  :  0;	[BUGGY]  return  false  ;  [CONTEXT]  public  int  hashCode()  {  [BUGGY]  return  false  ;  }        [CLASS]  Attributes    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  LinkedHashMap    attributes    boolean    
return  attributes  !=  null  ?  attributes.hashCode  (  )  :  0;	[BUGGY]    [CONTEXT]  public  int  hashCode()  {  [BUGGY]  return  attributes  !=  null  ?  attributes.hashCode()  :  0;          [CLASS]  Attributes    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  LinkedHashMap    attributes    boolean    
Validate.isTrue  (  args.length  ==  1,   "usage:  supply  url  to  fetch "  )  ;	[BUGGY]  Validate.isTrue(  args.length  !=  1,   "usage:  supply  url  to  fetch ");  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  [BUGGY]  Validate.isTrue  (  args.length  !=  1,   "usage:  supply  url  to  fetch "  )  ;  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  print( "  *  %s:  <%s>  %sx%s  (%s) ",  src.tagName(),  src.attr( "abs:src "),  src.attr( "width "),  src.attr( "height "),  trim(src.attr( "alt "),  20));  else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
Validate.isTrue  (  args.length  ==  1,   "usage:  supply  url  to  fetch "  )  ;	[BUGGY]  Validate.isTrue(  args.length  ==  0,   "usage:  supply  url  to  fetch ");  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  [BUGGY]  Validate.isTrue  (  args.length  ==  0,   "usage:  supply  url  to  fetch "  )  ;  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  print( "  *  %s:  <%s>  %sx%s  (%s) ",  src.tagName(),  src.attr( "abs:src "),  src.attr( "width "),  src.attr( "height "),  trim(src.attr( "alt "),  20));  else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
Validate.isTrue  (  args.length  ==  1,   "usage:  supply  url  to  fetch "  )  ;	[BUGGY]  Validate.isTrue(  args.length  ==  1,   "pply  usage:  supply  url  to  fetch ");  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  [BUGGY]  Validate.isTrue  (  args.length  ==  1,   "pply  usage:  supply  url  to  fetch "  )  ;  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  print( "  *  %s:  <%s>  %sx%s  (%s) ",  src.tagName(),  src.attr( "abs:src "),  src.attr( "width "),  src.attr( "height "),  trim(src.attr( "alt "),  20));  else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
Validate.isTrue  (  args.length  ==  1,   "usage:  supply  url  to  fetch "  )  ;	[BUGGY]    [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  [BUGGY]  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");    URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  print( "  *  %s:  <%s>  %sx%s  (%s) ",  src.tagName(),  src.attr( "abs:src "),  src.attr( "width "),  src.attr( "height "),  trim(src.attr( "alt "),  20));  else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
URL  url  =  new  URL  (  args[0]  )  ;	[BUGGY]  URL  url  =  new  URL(  args[4]);  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  [BUGGY]  URL  url  =  new  URL  (  args[4]  )  ;  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  print( "  *  %s:  <%s>  %sx%s  (%s) ",  src.tagName(),  src.attr( "abs:src "),  src.attr( "width "),  src.attr( "height "),  trim(src.attr( "alt "),  20));  else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
URL  url  =  new  URL  (  args[0]  )  ;	[BUGGY]  URL  url  =  new  URL(  args[-7]);  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  [BUGGY]  URL  url  =  new  URL  (  args[-7]  )  ;  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  print( "  *  %s:  <%s>  %sx%s  (%s) ",  src.tagName(),  src.attr( "abs:src "),  src.attr( "width "),  src.attr( "height "),  trim(src.attr( "alt "),  20));  else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
print  (   "Fetching  %s... ",  url.toExternalForm  (  )  )  ;	[BUGGY]  trim(   "Fetching  %s... ",  url.toExternalForm(  ));  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  [BUGGY]  trim  (   "Fetching  %s... ",  url.toExternalForm  ())  ;    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  print( "  *  %s:  <%s>  %sx%s  (%s) ",  src.tagName(),  src.attr( "abs:src "),  src.attr( "width "),  src.attr( "height "),  trim(src.attr( "alt "),  20));  else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
print  (   "Fetching  %s... ",  url.toExternalForm  (  )  )  ;	[BUGGY]  print(   "Fetching  %s... ",  url  .URL(  )  );  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  [BUGGY]  print  (   "Fetching  %s... ",  url  .URL  ()  )  ;    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  print( "  *  %s:  <%s>  %sx%s  (%s) ",  src.tagName(),  src.attr( "abs:src "),  src.attr( "width "),  src.attr( "height "),  trim(src.attr( "alt "),  20));  else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
print  (   "Fetching  %s... ",  url.toExternalForm  (  )  )  ;	[BUGGY]    [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  [BUGGY]  print( "Fetching  %s... ",  url.toExternalForm());      Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  print( "  *  %s:  <%s>  %sx%s  (%s) ",  src.tagName(),  src.attr( "abs:src "),  src.attr( "width "),  src.attr( "height "),  trim(src.attr( "alt "),  20));  else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
Document  doc  =  Jsoup.parse  (  url,  3*1000  )  ;	[BUGGY]  Document  /  doc  =  Jsoup.parse(  url,  3*1000);  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    [BUGGY]  Document  /  doc  =  Jsoup.parse  (  url,  3*1000  )  ;  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  print( "  *  %s:  <%s>  %sx%s  (%s) ",  src.tagName(),  src.attr( "abs:src "),  src.attr( "width "),  src.attr( "height "),  trim(src.attr( "alt "),  20));  else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
Document  doc  =  Jsoup.parse  (  url,  3*1000  )  ;	[BUGGY]  Document  doc  =  Jsoup.parse(  url,  -4*1000);  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    [BUGGY]  Document  doc  =  Jsoup.parse  (  url,  -4*1000  )  ;  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  print( "  *  %s:  <%s>  %sx%s  (%s) ",  src.tagName(),  src.attr( "abs:src "),  src.attr( "width "),  src.attr( "height "),  trim(src.attr( "alt "),  20));  else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
Document  doc  =  Jsoup.parse  (  url,  3*1000  )  ;	[BUGGY]  Document  doc  =  Jsoup.parse(  url,  3*1002);  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    [BUGGY]  Document  doc  =  Jsoup.parse  (  url,  3*1002  )  ;  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  print( "  *  %s:  <%s>  %sx%s  (%s) ",  src.tagName(),  src.attr( "abs:src "),  src.attr( "width "),  src.attr( "height "),  trim(src.attr( "alt "),  20));  else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
Document  doc  =  Jsoup.parse  (  url,  3*1000  )  ;	[BUGGY]  Document  doc  =  Jsoup.parse(  url,  8*1000);  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    [BUGGY]  Document  doc  =  Jsoup.parse  (  url,  8*1000  )  ;  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  print( "  *  %s:  <%s>  %sx%s  (%s) ",  src.tagName(),  src.attr( "abs:src "),  src.attr( "width "),  src.attr( "height "),  trim(src.attr( "alt "),  20));  else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
Document  doc  =  Jsoup.parse  (  url,  3*1000  )  ;	[BUGGY]  Document  doc  =  Jsoup.parse(  url,  3*1001);  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    [BUGGY]  Document  doc  =  Jsoup.parse  (  url,  3*1001  )  ;  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  print( "  *  %s:  <%s>  %sx%s  (%s) ",  src.tagName(),  src.attr( "abs:src "),  src.attr( "width "),  src.attr( "height "),  trim(src.attr( "alt "),  20));  else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
Document  doc  =  Jsoup.parse  (  url,  3*1000  )  ;	[BUGGY]    [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    [BUGGY]  Document  doc  =  Jsoup.parse(url,  3*1000);    Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  print( "  *  %s:  <%s>  %sx%s  (%s) ",  src.tagName(),  src.attr( "abs:src "),  src.attr( "width "),  src.attr( "height "),  trim(src.attr( "alt "),  20));  else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
Elements  links  =  doc.select  (   "a[href] "  )  ;	[BUGGY]  Elements  links  =  doc.select(   "f[href] ");  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  [BUGGY]  Elements  links  =  doc.select  (   "f[href] "  )  ;  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  print( "  *  %s:  <%s>  %sx%s  (%s) ",  src.tagName(),  src.attr( "abs:src "),  src.attr( "width "),  src.attr( "height "),  trim(src.attr( "alt "),  20));  else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
Elements  links  =  doc.select  (   "a[href] "  )  ;	[BUGGY]  Elements  media  =  doc.select(   "[src] ");Elements  links  =  doc.select(   "a[href] ");  [CONTEXT]        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
Elements  links  =  doc.select  (   "a[href] "  )  ;	[BUGGY]  Elements  imports  =  doc.select(   "link[href] ");Elements  links  =  doc.select(   "a[href] ");  [CONTEXT]        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
Elements  links  =  doc.select  (   "a[href] "  )  ;  Elements  media  =  doc.select  (   "[src] "  )  ;	[BUGGY]    [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  [BUGGY]  Elements  links  =  doc.select( "a[href] ");      Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  print( "  *  %s:  <%s>  %sx%s  (%s) ",  src.tagName(),  src.attr( "abs:src "),  src.attr( "width "),  src.attr( "height "),  trim(src.attr( "alt "),  20));  else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
Elements  media  =  doc.select  (   "[src] "  )  ;	[BUGGY]  Elements  links  =  doc.select(   "a[href] ");Elements  media  =  doc.select(   "[src] ");  [CONTEXT]        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
Elements  media  =  doc.select  (   "[src] "  )  ;	[BUGGY]  Elements  imports  =  doc.select(   "link[href] ");Elements  media  =  doc.select(   "[src] ");  [CONTEXT]        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
Elements  media  =  doc.select  (   "[src] "  )  ;	[BUGGY]  Elements  media  =  doc.select(   "[src][s ");  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  [BUGGY]  Elements  media  =  doc.select  (   "[src][s "  )  ;  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  print( "  *  %s:  <%s>  %sx%s  (%s) ",  src.tagName(),  src.attr( "abs:src "),  src.attr( "width "),  src.attr( "height "),  trim(src.attr( "alt "),  20));  else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
Elements  media  =  doc.select  (   "[src] "  )  ;  Elements  imports  =  doc.select  (   "link[href] "  )  ;	[BUGGY]    [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  [BUGGY]  Elements  media  =  doc.select( "[src] ");        print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  print( "  *  %s:  <%s>  %sx%s  (%s) ",  src.tagName(),  src.attr( "abs:src "),  src.attr( "width "),  src.attr( "height "),  trim(src.attr( "alt "),  20));  else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
Elements  imports  =  doc.select  (   "link[href] "  )  ;	[BUGGY]  Elements  imports  =  doc.select(   "link[ink[href] ");  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  [BUGGY]  Elements  imports  =  doc.select  (   "link[ink[href] "  )  ;    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  print( "  *  %s:  <%s>  %sx%s  (%s) ",  src.tagName(),  src.attr( "abs:src "),  src.attr( "width "),  src.attr( "height "),  trim(src.attr( "alt "),  20));  else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
Elements  imports  =  doc.select  (   "link[href] "  )  ;	[BUGGY]  Elements  imports  =  doc.select(   "link[hreink[href] ");  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  [BUGGY]  Elements  imports  =  doc.select  (   "link[hreink[href] "  )  ;    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  print( "  *  %s:  <%s>  %sx%s  (%s) ",  src.tagName(),  src.attr( "abs:src "),  src.attr( "width "),  src.attr( "height "),  trim(src.attr( "alt "),  20));  else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
Elements  imports  =  doc.select  (   "link[href] "  )  ;	[BUGGY]    [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  [BUGGY]  Elements  imports  =  doc.select( "link[href] ");      print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  print( "  *  %s:  <%s>  %sx%s  (%s) ",  src.tagName(),  src.attr( "abs:src "),  src.attr( "width "),  src.attr( "height "),  trim(src.attr( "alt "),  20));  else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
print  (   "\nMedia:  (  %d  )   ",  media.size  (  )  )  ;	[BUGGY]  print(   "\nMedia:  (  %d) ",  media.size()  +  6  );  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    [BUGGY]  print  (   "\nMedia:(  %d  )   ",  media.size()  +  6)  ;  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  print( "  *  %s:  <%s>  %sx%s  (%s) ",  src.tagName(),  src.attr( "abs:src "),  src.attr( "width "),  src.attr( "height "),  trim(src.attr( "alt "),  20));  else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
print  (   "\nMedia:  (  %d  )   ",  media.size  (  )  )  ;	[BUGGY]  print(   "\nMedia:  (  %d) ",  links.size(  ));  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    [BUGGY]  print  (   "\nMedia:(  %d  )   ",  links.size  ())  ;  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  print( "  *  %s:  <%s>  %sx%s  (%s) ",  src.tagName(),  src.attr( "abs:src "),  src.attr( "width "),  src.attr( "height "),  trim(src.attr( "alt "),  20));  else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
print  (   "\nMedia:  (  %d  )   ",  media.size  (  )  )  ;	[BUGGY]  trim(   "\nMedia:  (  %d) ",  media.size(  ));  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    [BUGGY]  trim  (   "\nMedia:(  %d  )   ",  media.size  ())  ;  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  print( "  *  %s:  <%s>  %sx%s  (%s) ",  src.tagName(),  src.attr( "abs:src "),  src.attr( "width "),  src.attr( "height "),  trim(src.attr( "alt "),  20));  else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
print  (   "\nMedia:  (  %d  )   ",  media.size  (  )  )  ;	[BUGGY]    [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    [BUGGY]  print( "\nMedia:  (%d) ",  media.size());    for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  print( "  *  %s:  <%s>  %sx%s  (%s) ",  src.tagName(),  src.attr( "abs:src "),  src.attr( "width "),  src.attr( "height "),  trim(src.attr( "alt "),  20));  else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
print  (   "\nMedia:  (  %d  )   ",  media.size  (  )  )  ;	[BUGGY]  print(   "\nMedia:  (  %d) ",  media.size()  +  5  );  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    [BUGGY]  print  (   "\nMedia:(  %d  )   ",  media.size()  +  5)  ;  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  print( "  *  %s:  <%s>  %sx%s  (%s) ",  src.tagName(),  src.attr( "abs:src "),  src.attr( "width "),  src.attr( "height "),  trim(src.attr( "alt "),  20));  else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
if  (  src.tagName  (  )  .equals  (   "img "  )  )  print  (   "  *  %s:  <%s>  %sx%s  (  %s  )   ",  src.tagName  (  )  ,  src.attr  (   "abs:src "  )  ,  src.attr  (   "width "  )  ,  src.attr  (   "height "  )  ,  trim  (  src.attr  (   "alt "  )  ,  20  )  )  ;	[BUGGY]  if  (  src.tagName(  ).equals(   " "))print(   "  *  %s:  <%s>  %sx%s  (  %s) ",  src.tagName(  ),  src.attr(   "abs:src "),  src.attr(   "width "),  src.attr(   "height "),  trim(  src.attr(   "alt "),  20));  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  [BUGGY]  if(  src.tagName  ()  .equals  (   " "  ))  print  (   "  *  %s:  <%s>  %sx%s(  %s  )   ",  src.tagName  ()  ,  src.attr  (   "abs:src "  )  ,  src.attr  (   "width "  )  ,  src.attr  (   "height "  )  ,  trim  (  src.attr  (   "alt "  )  ,  20  ))  ;        else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
if  (  src.tagName  (  )  .equals  (   "img "  )  )  print  (   "  *  %s:  <%s>  %sx%s  (  %s  )   ",  src.tagName  (  )  ,  src.attr  (   "abs:src "  )  ,  src.attr  (   "width "  )  ,  src.attr  (   "height "  )  ,  trim  (  src.attr  (   "alt "  )  ,  20  )  )  ;	[BUGGY]  if  (  src.tagName(  ).equals(   "img "))print(   "  *  %s:  <%s>  %sx%s  (  %s) ",  src.tagName(  ),  src.attr(   "abs "),  src.attr(   "width "),  src.attr(   "height "),  trim(  src.attr(   "alt "),  20));  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  [BUGGY]  if(  src.tagName  ()  .equals  (   "img "  ))  print  (   "  *  %s:  <%s>  %sx%s(  %s  )   ",  src.tagName  ()  ,  src.attr  (   "abs "  )  ,  src.attr  (   "width "  )  ,  src.attr  (   "height "  )  ,  trim  (  src.attr  (   "alt "  )  ,  20  ))  ;        else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
if  (  src.tagName  (  )  .equals  (   "img "  )  )  print  (   "  *  %s:  <%s>  %sx%s  (  %s  )   ",  src.tagName  (  )  ,  src.attr  (   "abs:src "  )  ,  src.attr  (   "width "  )  ,  src.attr  (   "height "  )  ,  trim  (  src.attr  (   "alt "  )  ,  20  )  )  ;	[BUGGY]  if  (  src.tagName(  ).equals(   "img "))print(   "  *  %s:  <%s>  %sx%s  (  %s) ",  src.tagName(  ),  src.attr(   "abs:src "),  src.attr(   "wiidth "),  src.attr(   "height "),  trim(  src.attr(   "alt "),  20));  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  [BUGGY]  if(  src.tagName  ()  .equals  (   "img "  ))  print  (   "  *  %s:  <%s>  %sx%s(  %s  )   ",  src.tagName  ()  ,  src.attr  (   "abs:src "  )  ,  src.attr  (   "wiidth "  )  ,  src.attr  (   "height "  )  ,  trim  (  src.attr  (   "alt "  )  ,  20  ))  ;        else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
if  (  src.tagName  (  )  .equals  (   "img "  )  )  print  (   "  *  %s:  <%s>  %sx%s  (  %s  )   ",  src.tagName  (  )  ,  src.attr  (   "abs:src "  )  ,  src.attr  (   "width "  )  ,  src.attr  (   "height "  )  ,  trim  (  src.attr  (   "alt "  )  ,  20  )  )  ;	[BUGGY]  if  (  src.tagName(  ).equals(   "img "))print(   "  *  %s:  <%s>  %sx%s  (  %s) ",  src.tagName(  ),  src.attr(   "abs:src "),  src.attr(   "width "),  src.attr(   "h "),  trim(  src.attr(   "alt "),  20));  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  [BUGGY]  if(  src.tagName  ()  .equals  (   "img "  ))  print  (   "  *  %s:  <%s>  %sx%s(  %s  )   ",  src.tagName  ()  ,  src.attr  (   "abs:src "  )  ,  src.attr  (   "width "  )  ,  src.attr  (   "h "  )  ,  trim  (  src.attr  (   "alt "  )  ,  20  ))  ;        else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
if  (  src.tagName  (  )  .equals  (   "img "  )  )  print  (   "  *  %s:  <%s>  %sx%s  (  %s  )   ",  src.tagName  (  )  ,  src.attr  (   "abs:src "  )  ,  src.attr  (   "width "  )  ,  src.attr  (   "height "  )  ,  trim  (  src.attr  (   "alt "  )  ,  20  )  )  ;	[BUGGY]  if  (  src.tagName(  ).equals(   "img "))print(   "  *  %s:  <%s>  %sx%s  (  %s) ",  src.tagName(  ),  src.attr(   "abs:src "),  src.attr(   "width "),  src.attr(   "height "),  trim(  src.attr(   "allt "),  20));  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  [BUGGY]  if(  src.tagName  ()  .equals  (   "img "  ))  print  (   "  *  %s:  <%s>  %sx%s(  %s  )   ",  src.tagName  ()  ,  src.attr  (   "abs:src "  )  ,  src.attr  (   "width "  )  ,  src.attr  (   "height "  )  ,  trim  (  src.attr  (   "allt "  )  ,  20  ))  ;        else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
if  (  src.tagName  (  )  .equals  (   "img "  )  )  print  (   "  *  %s:  <%s>  %sx%s  (  %s  )   ",  src.tagName  (  )  ,  src.attr  (   "abs:src "  )  ,  src.attr  (   "width "  )  ,  src.attr  (   "height "  )  ,  trim  (  src.attr  (   "alt "  )  ,  20  )  )  ;	[BUGGY]  if  (  src.tagName(  ).equals(   "img "))print(   "  *  %s:  <%s>  %sx%s  (  %s) ",  src.tagName(  ),  src.attr(   "abs:src "),  src.attr(   "width "),  src.attr(   "height "),  trim(  src.attr(   "alt "),  28));  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  [BUGGY]  if(  src.tagName  ()  .equals  (   "img "  ))  print  (   "  *  %s:  <%s>  %sx%s(  %s  )   ",  src.tagName  ()  ,  src.attr  (   "abs:src "  )  ,  src.attr  (   "width "  )  ,  src.attr  (   "height "  )  ,  trim  (  src.attr  (   "alt "  )  ,  28  ))  ;        else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
if  (  src.tagName  (  )  .equals  (   "img "  )  )  print  (   "  *  %s:  <%s>  %sx%s  (  %s  )   ",  src.tagName  (  )  ,  src.attr  (   "abs:src "  )  ,  src.attr  (   "width "  )  ,  src.attr  (   "height "  )  ,  trim  (  src.attr  (   "alt "  )  ,  20  )  )  ;	[BUGGY]  if  (  src.tagName(  ).equals(   "img "))print(   "  *  %s:  <%s>  %sx%s  (  %s) ",  src.tagName(  ),  src.attr(   "abs:src:sr "),  src.attr(   "width "),  src.attr(   "height "),  trim(  src.attr(   "alt "),  20));  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  [BUGGY]  if(  src.tagName  ()  .equals  (   "img "  ))  print  (   "  *  %s:  <%s>  %sx%s(  %s  )   ",  src.tagName  ()  ,  src.attr  (   "abs:src:sr "  )  ,  src.attr  (   "width "  )  ,  src.attr  (   "height "  )  ,  trim  (  src.attr  (   "alt "  )  ,  20  ))  ;        else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
if  (  src.tagName  (  )  .equals  (   "img "  )  )  print  (   "  *  %s:  <%s>  %sx%s  (  %s  )   ",  src.tagName  (  )  ,  src.attr  (   "abs:src "  )  ,  src.attr  (   "width "  )  ,  src.attr  (   "height "  )  ,  trim  (  src.attr  (   "alt "  )  ,  20  )  )  ;	[BUGGY]  if  (  link.tagName(  ).equals(   "img "))print(   "  *  %s:  <%s>  %sx%s  (  %s) ",  src.tagName(  ),  src.attr(   "abs:src "),  src.attr(   "width "),  src.attr(   "height "),  trim(  src.attr(   "alt "),  20));  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  [BUGGY]  if(  link.tagName  ()  .equals  (   "img "  ))  print  (   "  *  %s:  <%s>  %sx%s(  %s  )   ",  src.tagName  ()  ,  src.attr  (   "abs:src "  )  ,  src.attr  (   "width "  )  ,  src.attr  (   "height "  )  ,  trim  (  src.attr  (   "alt "  )  ,  20  ))  ;        else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
if  (  src.tagName  (  )  .equals  (   "img "  )  )  print  (   "  *  %s:  <%s>  %sx%s  (  %s  )   ",  src.tagName  (  )  ,  src.attr  (   "abs:src "  )  ,  src.attr  (   "width "  )  ,  src.attr  (   "height "  )  ,  trim  (  src.attr  (   "alt "  )  ,  20  )  )  ;	[BUGGY]  if  (  src.attr(  ).equals(   "img "))print(   "  *  %s:  <%s>  %sx%s  (  %s) ",  src.tagName(  ),  src.attr(   "abs:src "),  src.attr(   "width "),  src.attr(   "height "),  trim(  src.attr(   "alt "),  20));  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  [BUGGY]  if(  src.attr  ()  .equals  (   "img "  ))  print  (   "  *  %s:  <%s>  %sx%s(  %s  )   ",  src.tagName  ()  ,  src.attr  (   "abs:src "  )  ,  src.attr  (   "width "  )  ,  src.attr  (   "height "  )  ,  trim  (  src.attr  (   "alt "  )  ,  20  ))  ;        else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
if  (  src.tagName  (  )  .equals  (   "img "  )  )  print  (   "  *  %s:  <%s>  %sx%s  (  %s  )   ",  src.tagName  (  )  ,  src.attr  (   "abs:src "  )  ,  src.attr  (   "width "  )  ,  src.attr  (   "height "  )  ,  trim  (  src.attr  (   "alt "  )  ,  20  )  )  ;	[BUGGY]  if  (  src.tagName(  ).equals(   "img "))print(   "  *  %s:  <%s>  %sx%s  (  %s) ",  src.tagName(  ),  src  .tagName(  )  ,  src  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  [BUGGY]  if(  src.tagName  ()  .equals  (   "img "  ))  print  (   "  *  %s:  <%s>  %sx%s(  %s  )   ",  src.tagName  ()  ,  src  .tagName  (),  src        else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
print  (   "  *  %s:  <%s> ",  src.tagName  (  )  ,  src.attr  (   "abs:src "  )  )  ;	[BUGGY]  print(   "  *  %s:  <%s> ",  src.tagName(  ),  src.attr(   "abs:s "));  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  print( "  *  %s:  <%s>  %sx%s  (%s) ",  src.tagName(),  src.attr( "abs:src "),  src.attr( "width "),  src.attr( "height "),  trim(src.attr( "alt "),  20));  else  [BUGGY]  print  (   "  *  %s:  <%s> ",  src.tagName  ()  ,  src.attr  (   "abs:s "  ))  ;  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
print  (   "  *  %s:  <%s> ",  src.tagName  (  )  ,  src.attr  (   "abs:src "  )  )  ;	[BUGGY]  print(   "  *  %s:  <%s> ",  link.tagName(  ),  src.attr(   "abs:src "));  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  print( "  *  %s:  <%s>  %sx%s  (%s) ",  src.tagName(),  src.attr( "abs:src "),  src.attr( "width "),  src.attr( "height "),  trim(src.attr( "alt "),  20));  else  [BUGGY]  print  (   "  *  %s:  <%s> ",  link.tagName  ()  ,  src.attr  (   "abs:src "  ))  ;  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
print  (   "  *  %s:  <%s> ",  src.tagName  (  )  ,  src.attr  (   "abs:src "  )  )  ;	[BUGGY]  print(   "  *  %s:  <%s> ",  src.attr(  ),  src.attr(   "abs:src "));  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  print( "  *  %s:  <%s>  %sx%s  (%s) ",  src.tagName(),  src.attr( "abs:src "),  src.attr( "width "),  src.attr( "height "),  trim(src.attr( "alt "),  20));  else  [BUGGY]  print  (   "  *  %s:  <%s> ",  src.attr  ()  ,  src.attr  (   "abs:src "  ))  ;  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
print  (   "  *  %s:  <%s> ",  src.tagName  (  )  ,  src.attr  (   "abs:src "  )  )  ;	[BUGGY]    [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  print( "  *  %s:  <%s>  %sx%s  (%s) ",  src.tagName(),  src.attr( "abs:src "),  src.attr( "width "),  src.attr( "height "),  trim(src.attr( "alt "),  20));  else  [BUGGY]  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));    }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
print  (   "  *  %s:  <%s> ",  src.tagName  (  )  ,  src.attr  (   "abs:src "  )  )  ;	[BUGGY]  print(   "  *  %s:  <%s> ",  src.tagName(  ),  src.attr(   "bs "));  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  print( "  *  %s:  <%s>  %sx%s  (%s) ",  src.tagName(),  src.attr( "abs:src "),  src.attr( "width "),  src.attr( "height "),  trim(src.attr( "alt "),  20));  else  [BUGGY]  print  (   "  *  %s:  <%s> ",  src.tagName  ()  ,  src.attr  (   "bs "  ))  ;  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
print  (   "  *  %s:  <%s> ",  src.tagName  (  )  ,  src.attr  (   "abs:src "  )  )  ;	[BUGGY]  print(   "  *  %s:  <%s> ",  src.tagName(  ),  src  .tagName(  )  );  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  print( "  *  %s:  <%s>  %sx%s  (%s) ",  src.tagName(),  src.attr( "abs:src "),  src.attr( "width "),  src.attr( "height "),  trim(src.attr( "alt "),  20));  else  [BUGGY]  print  (   "  *  %s:  <%s> ",  src.tagName  ()  ,  src  .tagName  ()  )  ;  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
print  (   "  *  %s:  <%s>  %sx%s  (  %s  )   ",  src.tagName  (  )  ,  src.attr  (   "abs:src "  )  ,  src.attr  (   "width "  )  ,  src.attr  (   "height "  )  ,  trim  (  src.attr  (   "alt "  )  ,  20  )  )  ;	[BUGGY]  print(   "  *  %s:  <%s>  %sx%s  (  %s) ",  src.tagName(  ),  src.attr(   "abs:src "),  src.attr(   "wiidth "),  src.attr(   "height "),  trim(  src.attr(   "alt "),  20));  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  [BUGGY]  print  (   "  *  %s:  <%s>  %sx%s(  %s  )   ",  src.tagName  ()  ,  src.attr  (   "abs:src "  )  ,  src.attr  (   "wiidth "  )  ,  src.attr  (   "height "  )  ,  trim  (  src.attr  (   "alt "  )  ,  20  ))  ;      else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
print  (   "  *  %s:  <%s>  %sx%s  (  %s  )   ",  src.tagName  (  )  ,  src.attr  (   "abs:src "  )  ,  src.attr  (   "width "  )  ,  src.attr  (   "height "  )  ,  trim  (  src.attr  (   "alt "  )  ,  20  )  )  ;	[BUGGY]  print(   "  *  %s:  <%s>  %sx%s  (  %s) ",  src.tagName(  ),  src.attr(   "abs:src "),  src.attr(   "width "),  src.attr(   "gh "),  trim(  src.attr(   "alt "),  20));  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  [BUGGY]  print  (   "  *  %s:  <%s>  %sx%s(  %s  )   ",  src.tagName  ()  ,  src.attr  (   "abs:src "  )  ,  src.attr  (   "width "  )  ,  src.attr  (   "gh "  )  ,  trim  (  src.attr  (   "alt "  )  ,  20  ))  ;      else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
print  (   "  *  %s:  <%s>  %sx%s  (  %s  )   ",  src.tagName  (  )  ,  src.attr  (   "abs:src "  )  ,  src.attr  (   "width "  )  ,  src.attr  (   "height "  )  ,  trim  (  src.attr  (   "alt "  )  ,  20  )  )  ;	[BUGGY]  print(   "  *  %s:  <%s>  %sx%s  (  %s) ",  src.tagName(  ),  src.attr(   "abs:src "),  src.attr(   "width "),  src.attr(   "height "),  trim(  src.attr(   "lt "),  20));  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  [BUGGY]  print  (   "  *  %s:  <%s>  %sx%s(  %s  )   ",  src.tagName  ()  ,  src.attr  (   "abs:src "  )  ,  src.attr  (   "width "  )  ,  src.attr  (   "height "  )  ,  trim  (  src.attr  (   "lt "  )  ,  20  ))  ;      else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
print  (   "  *  %s:  <%s>  %sx%s  (  %s  )   ",  src.tagName  (  )  ,  src.attr  (   "abs:src "  )  ,  src.attr  (   "width "  )  ,  src.attr  (   "height "  )  ,  trim  (  src.attr  (   "alt "  )  ,  20  )  )  ;	[BUGGY]  print(   "  *  %s:  <%s>  %sx%s  (  %s) ",  src.tagName(  ),  src.attr(   "abs:src "),  src.attr(   "width "),  src.attr(   "height "),  trim(  src.attr(   "alt "),  22));  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  [BUGGY]  print  (   "  *  %s:  <%s>  %sx%s(  %s  )   ",  src.tagName  ()  ,  src.attr  (   "abs:src "  )  ,  src.attr  (   "width "  )  ,  src.attr  (   "height "  )  ,  trim  (  src.attr  (   "alt "  )  ,  22  ))  ;      else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
print  (   "  *  %s:  <%s>  %sx%s  (  %s  )   ",  src.tagName  (  )  ,  src.attr  (   "abs:src "  )  ,  src.attr  (   "width "  )  ,  src.attr  (   "height "  )  ,  trim  (  src.attr  (   "alt "  )  ,  20  )  )  ;	[BUGGY]  print(   "  *  %s:  <%s>  %sx%s  (  %s) ",  link.tagName(  ),  src.attr(   "abs:src "),  src.attr(   "width "),  src.attr(   "height "),  trim(  src.attr(   "alt "),  20));  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  [BUGGY]  print  (   "  *  %s:  <%s>  %sx%s(  %s  )   ",  link.tagName  ()  ,  src.attr  (   "abs:src "  )  ,  src.attr  (   "width "  )  ,  src.attr  (   "height "  )  ,  trim  (  src.attr  (   "alt "  )  ,  20  ))  ;      else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
print  (   "  *  %s:  <%s>  %sx%s  (  %s  )   ",  src.tagName  (  )  ,  src.attr  (   "abs:src "  )  ,  src.attr  (   "width "  )  ,  src.attr  (   "height "  )  ,  trim  (  src.attr  (   "alt "  )  ,  20  )  )  ;	[BUGGY]  print(   "  *  %s:  <%s>  %sx%s  (  %s) ",  src.attr(  ),  src.attr(   "abs:src "),  src.attr(   "width "),  src.attr(   "height "),  trim(  src.attr(   "alt "),  20));  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  [BUGGY]  print  (   "  *  %s:  <%s>  %sx%s(  %s  )   ",  src.attr  ()  ,  src.attr  (   "abs:src "  )  ,  src.attr  (   "width "  )  ,  src.attr  (   "height "  )  ,  trim  (  src.attr  (   "alt "  )  ,  20  ))  ;      else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
print  (   "  *  %s:  <%s>  %sx%s  (  %s  )   ",  src.tagName  (  )  ,  src.attr  (   "abs:src "  )  ,  src.attr  (   "width "  )  ,  src.attr  (   "height "  )  ,  trim  (  src.attr  (   "alt "  )  ,  20  )  )  ;	[BUGGY]  print(   "  *  %s:  <%s>  %sx%s  (  %s) ",  src  .attr(  1)  ,  src.attr(   "abs:src "),  src.attr(   "width "),  src.attr(   "height "),  trim(  src.attr(   "alt "),  20));  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  [BUGGY]  print  (   "  *  %s:  <%s>  %sx%s(  %s  )   ",  src  .attr  (  1  ),  src.attr  (   "abs:src "  )  ,  src.attr  (   "width "  )  ,  src.attr  (   "height "  )  ,  trim  (  src.attr  (   "alt "  )  ,  20  ))  ;      else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
print  (   "  *  %s:  <%s>  %sx%s  (  %s  )   ",  src.tagName  (  )  ,  src.attr  (   "abs:src "  )  ,  src.attr  (   "width "  )  ,  src.attr  (   "height "  )  ,  trim  (  src.attr  (   "alt "  )  ,  20  )  )  ;	[BUGGY]    [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  [BUGGY]  print( "  *  %s:  <%s>  %sx%s  (%s) ",        else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
src.tagName  (  )  ,  src.attr  (   "abs:src "  )  ,  src.attr  (   "width "  )  ,  src.attr  (   "height "  )  ,  trim  (  src.attr  (   "alt "  )  ,  20  )  )  ;	[BUGGY]  src.tagName(  ),  link.attr(   "abs:src "),  src.attr(   "width "),  src.attr(   "height "),  trim(  src.attr(   "alt "),  20));  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  print( "  *  %s:  <%s>  %sx%s  (%s) ",  [BUGGY]  src.tagName  ()  ,  link.attr  (   "abs:src "  )  ,  src.attr  (   "width "  )  ,  src.attr  (   "height "  )  ,  trim  (  src.attr  (   "alt "  )  ,  20  ))  ;    else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
src.tagName  (  )  ,  src.attr  (   "abs:src "  )  ,  src.attr  (   "width "  )  ,  src.attr  (   "height "  )  ,  trim  (  src.attr  (   "alt "  )  ,  20  )  )  ;	[BUGGY]  src.attr(  ),  src.attr(   "abs:src "),  src.attr(   "width "),  src.attr(   "height "),  trim(  src.attr(   "alt "),  20));  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  print( "  *  %s:  <%s>  %sx%s  (%s) ",  [BUGGY]  src.attr  ()  ,  src.attr  (   "abs:src "  )  ,  src.attr  (   "width "  )  ,  src.attr  (   "height "  )  ,  trim  (  src.attr  (   "alt "  )  ,  20  ))  ;    else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
src.tagName  (  )  ,  src.attr  (   "abs:src "  )  ,  src.attr  (   "width "  )  ,  src.attr  (   "height "  )  ,  trim  (  src.attr  (   "alt "  )  ,  20  )  )  ;	[BUGGY]    [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  print( "  *  %s:  <%s>  %sx%s  (%s) ",  [BUGGY]  src.tagName(),  src.attr( "abs:src "),  src.attr( "width "),  src.attr( "height "),      else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
src.tagName  (  )  ,  src.attr  (   "abs:src "  )  ,  src.attr  (   "width "  )  ,  src.attr  (   "height "  )  ,  trim  (  src.attr  (   "alt "  )  ,  20  )  )  ;	[BUGGY]  src.tagName(  ),  src.attr(   "abs:srcabs:sr "),  src.attr(   "width "),  src.attr(   "height "),  trim(  src.attr(   "alt "),  20));  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  print( "  *  %s:  <%s>  %sx%s  (%s) ",  [BUGGY]  src.tagName  ()  ,  src.attr  (   "abs:srcabs:sr "  )  ,  src.attr  (   "width "  )  ,  src.attr  (   "height "  )  ,  trim  (  src.attr  (   "alt "  )  ,  20  ))  ;    else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
src.tagName  (  )  ,  src.attr  (   "abs:src "  )  ,  src.attr  (   "width "  )  ,  src.attr  (   "height "  )  ,  trim  (  src.attr  (   "alt "  )  ,  20  )  )  ;	[BUGGY]  src.tagName(  ),  src.attr(   "abs:src "),  src.attr(   "tidth "),  src.attr(   "height "),  trim(  src.attr(   "alt "),  20));  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  print( "  *  %s:  <%s>  %sx%s  (%s) ",  [BUGGY]  src.tagName  ()  ,  src.attr  (   "abs:src "  )  ,  src.attr  (   "tidth "  )  ,  src.attr  (   "height "  )  ,  trim  (  src.attr  (   "alt "  )  ,  20  ))  ;    else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
src.tagName  (  )  ,  src.attr  (   "abs:src "  )  ,  src.attr  (   "width "  )  ,  src.attr  (   "height "  )  ,  trim  (  src.attr  (   "alt "  )  ,  20  )  )  ;	[BUGGY]  src.tagName(  ),  src  .tagName(  )  ,  src  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  print( "  *  %s:  <%s>  %sx%s  (%s) ",  [BUGGY]  src.tagName  ()  ,  src  .tagName  (),  src    else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
trim  (  src.attr  (   "alt "  )  ,  20  )  )  ;	[BUGGY]  trim(  src.attr(   "lt "),  20));  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  print( "  *  %s:  <%s>  %sx%s  (%s) ",  src.tagName(),  src.attr( "abs:src "),  src.attr( "width "),  src.attr( "height "),  [BUGGY]  trim  (  src.attr  (   "lt "  )  ,  20  ))  ;  else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
trim  (  src.attr  (   "alt "  )  ,  20  )  )  ;	[BUGGY]  trim(  src.attr(   "alt "),  ));  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  print( "  *  %s:  <%s>  %sx%s  (%s) ",  src.tagName(),  src.attr( "abs:src "),  src.attr( "width "),  src.attr( "height "),  [BUGGY]  trim  (  src.attr  (   "alt "  )  ,))  ;  else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
trim  (  src.attr  (   "alt "  )  ,  20  )  )  ;	[BUGGY]  trim(  link.attr(   "alt "),  20));  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  print( "  *  %s:  <%s>  %sx%s  (%s) ",  src.tagName(),  src.attr( "abs:src "),  src.attr( "width "),  src.attr( "height "),  [BUGGY]  trim  (  link.attr  (   "alt "  )  ,  20  ))  ;  else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
trim  (  src.attr  (   "alt "  )  ,  20  )  )  ;	[BUGGY]  trim(  src  .tagName(  )  ,  20));  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  print( "  *  %s:  <%s>  %sx%s  (%s) ",  src.tagName(),  src.attr( "abs:src "),  src.attr( "width "),  src.attr( "height "),  [BUGGY]  trim  (  src  .tagName  (),  20  ))  ;  else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
trim  (  src.attr  (   "alt "  )  ,  20  )  )  ;	[BUGGY]    [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  print( "  *  %s:  <%s>  %sx%s  (%s) ",  src.tagName(),  src.attr( "abs:src "),  src.attr( "width "),  src.attr( "height "),  [BUGGY]  trim(src.attr( "alt "),  20));    else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
trim  (  src.attr  (   "alt "  )  ,  20  )  )  ;	[BUGGY]  trim(  src.attr(   "l "),  20));  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  print( "  *  %s:  <%s>  %sx%s  (%s) ",  src.tagName(),  src.attr( "abs:src "),  src.attr( "width "),  src.attr( "height "),  [BUGGY]  trim  (  src.attr  (   "l "  )  ,  20  ))  ;  else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
if  (  src.tagName  (  )  .equals  (   "img "  )  )  print  (   "  *  %s:  <%s>  %sx%s  (  %s  )   ",  src.tagName  (  )  ,  src.attr  (   "abs:src "  )  ,  src.attr  (   "width "  )  ,  src.attr  (   "height "  )  ,  trim  (  src.attr  (   "alt "  )  ,  20  )  )  ;	[BUGGY]  if  (  src.tagName(  ).equals(   "mg "))print(   "  *  %s:  <%s>  %sx%s  (  %s) ",  src.tagName(  ),  src.attr(   "abs:src "),  src.attr(   "width "),  src.attr(   "height "),  trim(  src.attr(   "alt "),  20));  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  [BUGGY]  if(  src.tagName  ()  .equals  (   "mg "  ))  print  (   "  *  %s:  <%s>  %sx%s(  %s  )   ",  src.tagName  ()  ,  src.attr  (   "abs:src "  )  ,  src.attr  (   "width "  )  ,  src.attr  (   "height "  )  ,  trim  (  src.attr  (   "alt "  )  ,  20  ))  ;        else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
print  (   "  *  %s:  <%s>  %sx%s  (  %s  )   ",  src.tagName  (  )  ,  src.attr  (   "abs:src "  )  ,  src.attr  (   "width "  )  ,  src.attr  (   "height "  )  ,  trim  (  src.attr  (   "alt "  )  ,  20  )  )  ;	[BUGGY]  print(   "  *  %s:  <%s>  %sx%s  (  %s) ",  src.tagName(  ),  src.attr(   "a "),  src.attr(   "width "),  src.attr(   "height "),  trim(  src.attr(   "alt "),  20));  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  [BUGGY]  print  (   "  *  %s:  <%s>  %sx%s(  %s  )   ",  src.tagName  ()  ,  src.attr  (   "a "  )  ,  src.attr  (   "width "  )  ,  src.attr  (   "height "  )  ,  trim  (  src.attr  (   "alt "  )  ,  20  ))  ;      else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
print  (   "  *  %s:  <%s>  %sx%s  (  %s  )   ",  src.tagName  (  )  ,  src.attr  (   "abs:src "  )  ,  src.attr  (   "width "  )  ,  src.attr  (   "height "  )  ,  trim  (  src.attr  (   "alt "  )  ,  20  )  )  ;	[BUGGY]  print(   "  *  %s:  <%s>  %sx%s  (  %s) ",  src.tagName(  ),  src.attr(   "abs:src "),  src.attr(   "idth "),  src.attr(   "height "),  trim(  src.attr(   "alt "),  20));  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  [BUGGY]  print  (   "  *  %s:  <%s>  %sx%s(  %s  )   ",  src.tagName  ()  ,  src.attr  (   "abs:src "  )  ,  src.attr  (   "idth "  )  ,  src.attr  (   "height "  )  ,  trim  (  src.attr  (   "alt "  )  ,  20  ))  ;      else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
print  (   "  *  %s:  <%s>  %sx%s  (  %s  )   ",  src.tagName  (  )  ,  src.attr  (   "abs:src "  )  ,  src.attr  (   "width "  )  ,  src.attr  (   "height "  )  ,  trim  (  src.attr  (   "alt "  )  ,  20  )  )  ;	[BUGGY]  print(   "  *  %s:  <%s>  %sx%s  (  %s) ",  src.tagName(  ),  src.attr(   "abs:src "),  src.attr(   "width "),  src.attr(   "heig "),  trim(  src.attr(   "alt "),  20));  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  [BUGGY]  print  (   "  *  %s:  <%s>  %sx%s(  %s  )   ",  src.tagName  ()  ,  src.attr  (   "abs:src "  )  ,  src.attr  (   "width "  )  ,  src.attr  (   "heig "  )  ,  trim  (  src.attr  (   "alt "  )  ,  20  ))  ;      else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
print  (   "  *  %s:  <%s>  %sx%s  (  %s  )   ",  src.tagName  (  )  ,  src.attr  (   "abs:src "  )  ,  src.attr  (   "width "  )  ,  src.attr  (   "height "  )  ,  trim  (  src.attr  (   "alt "  )  ,  20  )  )  ;	[BUGGY]  print(   "  *  %s:  <%s>  %sx%s  (  %s) ",  src.tagName(  ),  src.attr(   "abs:src "),  src.attr(   "width "),  src.attr(   "height "),  trim(  src.attr(   "alt "),  28));  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  [BUGGY]  print  (   "  *  %s:  <%s>  %sx%s(  %s  )   ",  src.tagName  ()  ,  src.attr  (   "abs:src "  )  ,  src.attr  (   "width "  )  ,  src.attr  (   "height "  )  ,  trim  (  src.attr  (   "alt "  )  ,  28  ))  ;      else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
print  (   "  *  %s:  <%s>  %sx%s  (  %s  )   ",  src.tagName  (  )  ,  src.attr  (   "abs:src "  )  ,  src.attr  (   "width "  )  ,  src.attr  (   "height "  )  ,  trim  (  src.attr  (   "alt "  )  ,  20  )  )  ;	[BUGGY]  print(   "  *  %s:  <%s>  %sx%s  (  %s) ",  link.tagName(  ),  src  .tagName(  )  ,  src  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  [BUGGY]  print  (   "  *  %s:  <%s>  %sx%s(  %s  )   ",  link.tagName  ()  ,  src  .tagName  (),  src      else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
src.tagName  (  )  ,  src.attr  (   "abs:src "  )  ,  src.attr  (   "width "  )  ,  src.attr  (   "height "  )  ,  trim  (  src.attr  (   "alt "  )  ,  20  )  )  ;	[BUGGY]  src.tagName(  ),  src.attr(   ":bs:src "),  src.attr(   "width "),  src.attr(   "height "),  trim(  src.attr(   "alt "),  20));  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  print( "  *  %s:  <%s>  %sx%s  (%s) ",  [BUGGY]  src.tagName  ()  ,  src.attr  (   ":bs:src "  )  ,  src.attr  (   "width "  )  ,  src.attr  (   "height "  )  ,  trim  (  src.attr  (   "alt "  )  ,  20  ))  ;    else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
src.tagName  (  )  ,  src.attr  (   "abs:src "  )  ,  src.attr  (   "width "  )  ,  src.attr  (   "height "  )  ,  trim  (  src.attr  (   "alt "  )  ,  20  )  )  ;	[BUGGY]  src.tagName(  ),  src.attr(   "abs:src "),  src.attr(   "w "),  src.attr(   "height "),  trim(  src.attr(   "alt "),  20));  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  print( "  *  %s:  <%s>  %sx%s  (%s) ",  [BUGGY]  src.tagName  ()  ,  src.attr  (   "abs:src "  )  ,  src.attr  (   "w "  )  ,  src.attr  (   "height "  )  ,  trim  (  src.attr  (   "alt "  )  ,  20  ))  ;    else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
src.tagName  (  )  ,  src.attr  (   "abs:src "  )  ,  src.attr  (   "width "  )  ,  src.attr  (   "height "  )  ,  trim  (  src.attr  (   "alt "  )  ,  20  )  )  ;	[BUGGY]  src.tagName(  ),  src.attr(   "abs:src "),  src.attr(   "width "),  src.attr(   "heeight "),  trim(  src.attr(   "alt "),  20));  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  print( "  *  %s:  <%s>  %sx%s  (%s) ",  [BUGGY]  src.tagName  ()  ,  src.attr  (   "abs:src "  )  ,  src.attr  (   "width "  )  ,  src.attr  (   "heeight "  )  ,  trim  (  src.attr  (   "alt "  )  ,  20  ))  ;    else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
trim  (  src.attr  (   "alt "  )  ,  20  )  )  ;	[BUGGY]  trim(  src.attr(   "alt "),  21));  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  print( "  *  %s:  <%s>  %sx%s  (%s) ",  src.tagName(),  src.attr( "abs:src "),  src.attr( "width "),  src.attr( "height "),  [BUGGY]  trim  (  src.attr  (   "alt "  )  ,  21  ))  ;  else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
trim  (  src.attr  (   "alt "  )  ,  20  )  )  ;	[BUGGY]  trim(  src.attr(   "al "),  20));  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  print( "  *  %s:  <%s>  %sx%s  (%s) ",  src.tagName(),  src.attr( "abs:src "),  src.attr( "width "),  src.attr( "height "),  [BUGGY]  trim  (  src.attr  (   "al "  )  ,  20  ))  ;  else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
trim  (  src.attr  (   "alt "  )  ,  20  )  )  ;	[BUGGY]  trim(  link  .tagName(  )  ,  20));  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  print( "  *  %s:  <%s>  %sx%s  (%s) ",  src.tagName(),  src.attr( "abs:src "),  src.attr( "width "),  src.attr( "height "),  [BUGGY]  trim  (  link  .tagName  (),  20  ))  ;  else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
print  (   "  *  %s:  <%s> ",  src.tagName  (  )  ,  src.attr  (   "abs:src "  )  )  ;	[BUGGY]  print(   "  *  %s:  <%s> ",  src.tagName(  ),  src.attr(   "a "));  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  print( "  *  %s:  <%s>  %sx%s  (%s) ",  src.tagName(),  src.attr( "abs:src "),  src.attr( "width "),  src.attr( "height "),  trim(src.attr( "alt "),  20));  else  [BUGGY]  print  (   "  *  %s:  <%s> ",  src.tagName  ()  ,  src.attr  (   "a "  ))  ;  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
print  (   "  *  %s:  <%s> ",  src.tagName  (  )  ,  src.attr  (   "abs:src "  )  )  ;	[BUGGY]  print(   "  *  %s:  <%s> ",  link.tagName(  ),  src  .tagName(  )  );  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  print( "  *  %s:  <%s>  %sx%s  (%s) ",  src.tagName(),  src.attr( "abs:src "),  src.attr( "width "),  src.attr( "height "),  trim(src.attr( "alt "),  20));  else  [BUGGY]  print  (   "  *  %s:  <%s> ",  link.tagName  ()  ,  src  .tagName  ()  )  ;  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
print  (   "  *  %s:  <%s> ",  src.tagName  (  )  ,  src.attr  (   "abs:src "  )  )  ;	[BUGGY]  print(   "  *  %s:  <%s> ",  link.attr(  ),  src.attr(   "abs:src "));  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  print( "  *  %s:  <%s>  %sx%s  (%s) ",  src.tagName(),  src.attr( "abs:src "),  src.attr( "width "),  src.attr( "height "),  trim(src.attr( "alt "),  20));  else  [BUGGY]  print  (   "  *  %s:  <%s> ",  link.attr  ()  ,  src.attr  (   "abs:src "  ))  ;  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
print  (   "  *  %s:  <%s> ",  src.tagName  (  )  ,  src.attr  (   "abs:src "  )  )  ;	[BUGGY]  print(   "  *  %s:  <%s> ",  src.tagName(  ),  src.attr(   "abs:srca "));  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  print( "  *  %s:  <%s>  %sx%s  (%s) ",  src.tagName(),  src.attr( "abs:src "),  src.attr( "width "),  src.attr( "height "),  trim(src.attr( "alt "),  20));  else  [BUGGY]  print  (   "  *  %s:  <%s> ",  src.tagName  ()  ,  src.attr  (   "abs:srca "  ))  ;  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
print  (   "\nImports:  (  %d  )   ",  imports.size  (  )  )  ;	[BUGGY]  print(   "\nImports:  (  %d) ",  imports.size()  -  2  );  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  print( "  *  %s:  <%s>  %sx%s  (%s) ",  src.tagName(),  src.attr( "abs:src "),  src.attr( "width "),  src.attr( "height "),  trim(src.attr( "alt "),  20));  else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    [BUGGY]  print  (   "\nImports:(  %d  )   ",  imports.size()  -  2)  ;  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
print  (   "\nImports:  (  %d  )   ",  imports.size  (  )  )  ;	[BUGGY]  print(   "\nImports:  (  %d) ",  media.size(  ));  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  print( "  *  %s:  <%s>  %sx%s  (%s) ",  src.tagName(),  src.attr( "abs:src "),  src.attr( "width "),  src.attr( "height "),  trim(src.attr( "alt "),  20));  else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    [BUGGY]  print  (   "\nImports:(  %d  )   ",  media.size  ())  ;  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
print  (   "\nImports:  (  %d  )   ",  imports.size  (  )  )  ;	[BUGGY]  trim(   "\nImports:  (  %d) ",  imports.size(  ));  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  print( "  *  %s:  <%s>  %sx%s  (%s) ",  src.tagName(),  src.attr( "abs:src "),  src.attr( "width "),  src.attr( "height "),  trim(src.attr( "alt "),  20));  else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    [BUGGY]  trim  (   "\nImports:(  %d  )   ",  imports.size  ())  ;  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
print  (   "\nImports:  (  %d  )   ",  imports.size  (  )  )  ;	[BUGGY]    [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  print( "  *  %s:  <%s>  %sx%s  (%s) ",  src.tagName(),  src.attr( "abs:src "),  src.attr( "width "),  src.attr( "height "),  trim(src.attr( "alt "),  20));  else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    [BUGGY]  print( "\nImports:  (%d) ",  imports.size());    for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
print  (   "\nImports:  (  %d  )   ",  imports.size  (  )  )  ;	[BUGGY]  print(   "\nImports:  (  %d) ",  imports.size()  -  1  );  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  print( "  *  %s:  <%s>  %sx%s  (%s) ",  src.tagName(),  src.attr( "abs:src "),  src.attr( "width "),  src.attr( "height "),  trim(src.attr( "alt "),  20));  else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    [BUGGY]  print  (   "\nImports:(  %d  )   ",  imports.size()  -  1)  ;  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
print  (   "  *  %s  <%s>  (  %s  )   ",  link.tagName  (  )  ,link.attr  (   "abs:href "  )  ,  link.attr  (   "rel "  )  )  ;	[BUGGY]  print(   "  *  %s  <%s>  (  %s) ",  link.tagName(  ),link.attr(   ":hr "),  link.attr(   "rel "));  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  print( "  *  %s:  <%s>  %sx%s  (%s) ",  src.tagName(),  src.attr( "abs:src "),  src.attr( "width "),  src.attr( "height "),  trim(src.attr( "alt "),  20));  else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  [BUGGY]  print  (   "  *  %s  <%s>(  %s  )   ",  link.tagName  ()  ,link.attr  (   ":hr "  )  ,  link.attr  (   "rel "  ))  ;  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
print  (   "  *  %s  <%s>  (  %s  )   ",  link.tagName  (  )  ,link.attr  (   "abs:href "  )  ,  link.attr  (   "rel "  )  )  ;	[BUGGY]  print(   "  *  %s  <%s>  (  %s) ",  link.tagName(  ),link.attr(   "abs:href "),  link.attr(   "el "));  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  print( "  *  %s:  <%s>  %sx%s  (%s) ",  src.tagName(),  src.attr( "abs:src "),  src.attr( "width "),  src.attr( "height "),  trim(src.attr( "alt "),  20));  else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  [BUGGY]  print  (   "  *  %s  <%s>(  %s  )   ",  link.tagName  ()  ,link.attr  (   "abs:href "  )  ,  link.attr  (   "el "  ))  ;  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
print  (   "  *  %s  <%s>  (  %s  )   ",  link.tagName  (  )  ,link.attr  (   "abs:href "  )  ,  link.attr  (   "rel "  )  )  ;	[BUGGY]  print(   "  *  %s  <%s>  (  %s) ",  src.tagName(  ),link.attr(   "abs:href "),  link.attr(   "rel "));  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  print( "  *  %s:  <%s>  %sx%s  (%s) ",  src.tagName(),  src.attr( "abs:src "),  src.attr( "width "),  src.attr( "height "),  trim(src.attr( "alt "),  20));  else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  [BUGGY]  print  (   "  *  %s  <%s>(  %s  )   ",  src.tagName  ()  ,link.attr  (   "abs:href "  )  ,  link.attr  (   "rel "  ))  ;  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
print  (   "  *  %s  <%s>  (  %s  )   ",  link.tagName  (  )  ,link.attr  (   "abs:href "  )  ,  link.attr  (   "rel "  )  )  ;	[BUGGY]  print(   "  *  %s  <%s>  (  %s) ",  link.attr(  ),link.attr(   "abs:href "),  link.attr(   "rel "));  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  print( "  *  %s:  <%s>  %sx%s  (%s) ",  src.tagName(),  src.attr( "abs:src "),  src.attr( "width "),  src.attr( "height "),  trim(src.attr( "alt "),  20));  else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  [BUGGY]  print  (   "  *  %s  <%s>(  %s  )   ",  link.attr  ()  ,link.attr  (   "abs:href "  )  ,  link.attr  (   "rel "  ))  ;  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
print  (   "  *  %s  <%s>  (  %s  )   ",  link.tagName  (  )  ,link.attr  (   "abs:href "  )  ,  link.attr  (   "rel "  )  )  ;	[BUGGY]  print(   "  *  %s  <%s>  (  %s) ",  src.attr(  ),link.attr(   "abs:href "),  link.attr(   "rel "));  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  print( "  *  %s:  <%s>  %sx%s  (%s) ",  src.tagName(),  src.attr( "abs:src "),  src.attr( "width "),  src.attr( "height "),  trim(src.attr( "alt "),  20));  else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  [BUGGY]  print  (   "  *  %s  <%s>(  %s  )   ",  src.attr  ()  ,link.attr  (   "abs:href "  )  ,  link.attr  (   "rel "  ))  ;  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
print  (   "  *  %s  <%s>  (  %s  )   ",  link.tagName  (  )  ,link.attr  (   "abs:href "  )  ,  link.attr  (   "rel "  )  )  ;	[BUGGY]    [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  print( "  *  %s:  <%s>  %sx%s  (%s) ",  src.tagName(),  src.attr( "abs:src "),  src.attr( "width "),  src.attr( "height "),  trim(src.attr( "alt "),  20));  else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  [BUGGY]  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));    }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
print  (   "  *  %s  <%s>  (  %s  )   ",  link.tagName  (  )  ,link.attr  (   "abs:href "  )  ,  link.attr  (   "rel "  )  )  ;	[BUGGY]  print(   "  *  %s  <%s>  (  %s) ",  link.tagName(  ),link.attr(   "s "),  link.attr(   "rel "));  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  print( "  *  %s:  <%s>  %sx%s  (%s) ",  src.tagName(),  src.attr( "abs:src "),  src.attr( "width "),  src.attr( "height "),  trim(src.attr( "alt "),  20));  else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  [BUGGY]  print  (   "  *  %s  <%s>(  %s  )   ",  link.tagName  ()  ,link.attr  (   "s "  )  ,  link.attr  (   "rel "  ))  ;  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
print  (   "  *  %s  <%s>  (  %s  )   ",  link.tagName  (  )  ,link.attr  (   "abs:href "  )  ,  link.attr  (   "rel "  )  )  ;	[BUGGY]  print(   "  *  %s  <%s>  (  %s) ",  link.tagName(  ),link.attr(   "abs:href "),  link.attr(   "relre "));  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  print( "  *  %s:  <%s>  %sx%s  (%s) ",  src.tagName(),  src.attr( "abs:src "),  src.attr( "width "),  src.attr( "height "),  trim(src.attr( "alt "),  20));  else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  [BUGGY]  print  (   "  *  %s  <%s>(  %s  )   ",  link.tagName  ()  ,link.attr  (   "abs:href "  )  ,  link.attr  (   "relre "  ))  ;  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
print  (   "  *  %s  <%s>  (  %s  )   ",  link.tagName  (  )  ,link.attr  (   "abs:href "  )  ,  link.attr  (   "rel "  )  )  ;	[BUGGY]  print(   "  *  %s  <%s>  (  %s) ",  link.tagName(  ),link  .tagName(  )  ,  link  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  print( "  *  %s:  <%s>  %sx%s  (%s) ",  src.tagName(),  src.attr( "abs:src "),  src.attr( "width "),  src.attr( "height "),  trim(src.attr( "alt "),  20));  else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  [BUGGY]  print  (   "  *  %s  <%s>(  %s  )   ",  link.tagName  ()  ,link  .tagName  (),  link  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
print  (   "\nLinks:  (  %d  )   ",  links.size  (  )  )  ;	[BUGGY]  print(   "\nLinks:  (  %d) ",  links.size()  -  8  );  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  print( "  *  %s:  <%s>  %sx%s  (%s) ",  src.tagName(),  src.attr( "abs:src "),  src.attr( "width "),  src.attr( "height "),  trim(src.attr( "alt "),  20));  else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    [BUGGY]  print  (   "\nLinks:(  %d  )   ",  links.size()  -  8)  ;  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
print  (   "\nLinks:  (  %d  )   ",  links.size  (  )  )  ;	[BUGGY]  print(   "\nLinks:  (  %d) ",  media.size(  ));  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  print( "  *  %s:  <%s>  %sx%s  (%s) ",  src.tagName(),  src.attr( "abs:src "),  src.attr( "width "),  src.attr( "height "),  trim(src.attr( "alt "),  20));  else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    [BUGGY]  print  (   "\nLinks:(  %d  )   ",  media.size  ())  ;  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
print  (   "\nLinks:  (  %d  )   ",  links.size  (  )  )  ;	[BUGGY]  trim(   "\nLinks:  (  %d) ",  links.size(  ));  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  print( "  *  %s:  <%s>  %sx%s  (%s) ",  src.tagName(),  src.attr( "abs:src "),  src.attr( "width "),  src.attr( "height "),  trim(src.attr( "alt "),  20));  else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    [BUGGY]  trim  (   "\nLinks:(  %d  )   ",  links.size  ())  ;  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
print  (   "\nLinks:  (  %d  )   ",  links.size  (  )  )  ;	[BUGGY]  trim(   "\nLinks:  (  %d) ",  media.size(  ));  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  print( "  *  %s:  <%s>  %sx%s  (%s) ",  src.tagName(),  src.attr( "abs:src "),  src.attr( "width "),  src.attr( "height "),  trim(src.attr( "alt "),  20));  else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    [BUGGY]  trim  (   "\nLinks:(  %d  )   ",  media.size  ())  ;  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
print  (   "\nLinks:  (  %d  )   ",  links.size  (  )  )  ;	[BUGGY]    [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  print( "  *  %s:  <%s>  %sx%s  (%s) ",  src.tagName(),  src.attr( "abs:src "),  src.attr( "width "),  src.attr( "height "),  trim(src.attr( "alt "),  20));  else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    [BUGGY]  print( "\nLinks:  (%d) ",  links.size());    for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
print  (   "\nLinks:  (  %d  )   ",  links.size  (  )  )  ;	[BUGGY]  print(   "\nLinks:  (  %d) ",  links.size()  +  3  );  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  print( "  *  %s:  <%s>  %sx%s  (%s) ",  src.tagName(),  src.attr( "abs:src "),  src.attr( "width "),  src.attr( "height "),  trim(src.attr( "alt "),  20));  else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    [BUGGY]  print  (   "\nLinks:(  %d  )   ",  links.size()  +  3)  ;  for  (Element  link  :  links)  {  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
print  (   "  *  a:  <%s>    (  %s  )   ",  link.attr  (   "abs:href "  )  ,  trim  (  link.text  (  )  ,  35  )  )  ;	[BUGGY]  print(   "  *  a:  <%s>    (  %s) ",  link.attr(   "bs:href "),  trim(  link.text(  ),  35));  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  print( "  *  %s:  <%s>  %sx%s  (%s) ",  src.tagName(),  src.attr( "abs:src "),  src.attr( "width "),  src.attr( "height "),  trim(src.attr( "alt "),  20));  else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  [BUGGY]  print  (   "  *  a:  <%s>  (  %s  )   ",  link.attr  (   "bs:href "  )  ,  trim  (  link.text  ()  ,  35  ))  ;  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
print  (   "  *  a:  <%s>    (  %s  )   ",  link.attr  (   "abs:href "  )  ,  trim  (  link.text  (  )  ,  35  )  )  ;	[BUGGY]  print(   "  *  a:  <%s>    (  %s) ",  link.attr(   "abs:href "),  trim(  link.text(  ),  ));  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  print( "  *  %s:  <%s>  %sx%s  (%s) ",  src.tagName(),  src.attr( "abs:src "),  src.attr( "width "),  src.attr( "height "),  trim(src.attr( "alt "),  20));  else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  [BUGGY]  print  (   "  *  a:  <%s>  (  %s  )   ",  link.attr  (   "abs:href "  )  ,  trim  (  link.text  ()  ,))  ;  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
print  (   "  *  a:  <%s>    (  %s  )   ",  link.attr  (   "abs:href "  )  ,  trim  (  link.text  (  )  ,  35  )  )  ;	[BUGGY]  print(   "  *  a:  <%s>    (  %s) ",  src.attr(   "abs:href "),  trim(  link.text(  ),  35));  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  print( "  *  %s:  <%s>  %sx%s  (%s) ",  src.tagName(),  src.attr( "abs:src "),  src.attr( "width "),  src.attr( "height "),  trim(src.attr( "alt "),  20));  else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  [BUGGY]  print  (   "  *  a:  <%s>  (  %s  )   ",  src.attr  (   "abs:href "  )  ,  trim  (  link.text  ()  ,  35  ))  ;  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
print  (   "  *  a:  <%s>    (  %s  )   ",  link.attr  (   "abs:href "  )  ,  trim  (  link.text  (  )  ,  35  )  )  ;	[BUGGY]  print(   "  *  a:  <%s>    (  %s) ",  link.attr(   "abs:href "),  print(  link.text(  ),  35));  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  print( "  *  %s:  <%s>  %sx%s  (%s) ",  src.tagName(),  src.attr( "abs:src "),  src.attr( "width "),  src.attr( "height "),  trim(src.attr( "alt "),  20));  else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  [BUGGY]  print  (   "  *  a:  <%s>  (  %s  )   ",  link.attr  (   "abs:href "  )  ,  print  (  link.text  ()  ,  35  ))  ;  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
print  (   "  *  a:  <%s>    (  %s  )   ",  link.attr  (   "abs:href "  )  ,  trim  (  link.text  (  )  ,  35  )  )  ;	[BUGGY]  print(   "  *  a:  <%s>    (  %s) ",  link.attr(   "abs:href "),  trim(  link.attr(  ),  35));  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  print( "  *  %s:  <%s>  %sx%s  (%s) ",  src.tagName(),  src.attr( "abs:src "),  src.attr( "width "),  src.attr( "height "),  trim(src.attr( "alt "),  20));  else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  [BUGGY]  print  (   "  *  a:  <%s>  (  %s  )   ",  link.attr  (   "abs:href "  )  ,  trim  (  link.attr  ()  ,  35  ))  ;  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
print  (   "  *  a:  <%s>    (  %s  )   ",  link.attr  (   "abs:href "  )  ,  trim  (  link.text  (  )  ,  35  )  )  ;	[BUGGY]    [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  print( "  *  %s:  <%s>  %sx%s  (%s) ",  src.tagName(),  src.attr( "abs:src "),  src.attr( "width "),  src.attr( "height "),  trim(src.attr( "alt "),  20));  else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  [BUGGY]  print( "  *  a:  <%s>(%s) ",  link.attr( "abs:href "),  trim(link.text(),  35));    }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
print  (   "  *  a:  <%s>    (  %s  )   ",  link.attr  (   "abs:href "  )  ,  trim  (  link.text  (  )  ,  35  )  )  ;	[BUGGY]  print(   "  *  a:  <%s>    (  %s) ",  link.attr(   "abs:hrefab "),  trim(  link.text(  ),  35));  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  print( "  *  %s:  <%s>  %sx%s  (%s) ",  src.tagName(),  src.attr( "abs:src "),  src.attr( "width "),  src.attr( "height "),  trim(src.attr( "alt "),  20));  else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  [BUGGY]  print  (   "  *  a:  <%s>  (  %s  )   ",  link.attr  (   "abs:hrefab "  )  ,  trim  (  link.text  ()  ,  35  ))  ;  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
print  (   "  *  a:  <%s>    (  %s  )   ",  link.attr  (   "abs:href "  )  ,  trim  (  link.text  (  )  ,  35  )  )  ;	[BUGGY]  print(   "  *  a:  <%s>    (  %s) ",  link.attr(   "abs:href "),  trim(  link.text(  ),  27));  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  print( "  *  %s:  <%s>  %sx%s  (%s) ",  src.tagName(),  src.attr( "abs:src "),  src.attr( "width "),  src.attr( "height "),  trim(src.attr( "alt "),  20));  else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  [BUGGY]  print  (   "  *  a:  <%s>  (  %s  )   ",  link.attr  (   "abs:href "  )  ,  trim  (  link.text  ()  ,  27  ))  ;  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
print  (   "  *  a:  <%s>    (  %s  )   ",  link.attr  (   "abs:href "  )  ,  trim  (  link.text  (  )  ,  35  )  )  ;	[BUGGY]  print(   "  *  a:  <%s>    (  %s) ",  link.attr(   "abs:href "),  trim(  link  .tagName(  )  ,  35));  [CONTEXT]  public  static  void  main(String[]  args)  throws  IOException  {  Validate.isTrue(args.length  ==  1,   "usage:  supply  url  to  fetch ");  URL  url  =  new  URL(args[0]);  print( "Fetching  %s... ",  url.toExternalForm());    Document  doc  =  Jsoup.parse(url,  3*1000);  Elements  links  =  doc.select( "a[href] ");  Elements  media  =  doc.select( "[src] ");  Elements  imports  =  doc.select( "link[href] ");    print( "\nMedia:  (%d) ",  media.size());  for  (Element  src  :  media)  {  if  (src.tagName().equals( "img "))  print( "  *  %s:  <%s>  %sx%s  (%s) ",  src.tagName(),  src.attr( "abs:src "),  src.attr( "width "),  src.attr( "height "),  trim(src.attr( "alt "),  20));  else  print( "  *  %s:  <%s> ",  src.tagName(),  src.attr( "abs:src "));  }    print( "\nImports:  (%d) ",  imports.size());  for  (Element  link  :  imports)  {  print( "  *  %s  <%s>  (%s) ",  link.tagName(),link.attr( "abs:href "),  link.attr( "rel "));  }    print( "\nLinks:  (%d) ",  links.size());  for  (Element  link  :  links)  {  [BUGGY]  print  (   "  *  a:  <%s>  (  %s  )   ",  link.attr  (   "abs:href "  )  ,  trim  (  link  .tagName  (),  35  ))  ;  }  }        [CLASS]  ListLinks    [METHOD]  main  [RETURN_TYPE]  void      String[]  args  [VARIABLES]  boolean    Element    link    src    String[]    args    Document    doc    Elements    imports    links    media    URL    url    
System.out.println  (  String.format  (  msg,  args  )  )  ;	[BUGGY]  System.out.println(  String.format(  args,  msg));  [CONTEXT]  private  static  void  print(String  msg,  Object...  args)  {  [BUGGY]  System.out.println  (  String.format  (  args,  msg  ))  ;  }        [CLASS]  ListLinks    [METHOD]  print  [RETURN_TYPE]  void      String  msg    args  [VARIABLES]  boolean    String    msg    Object[]    args    
System.out.println  (  String.format  (  msg,  args  )  )  ;	[BUGGY]  System.out.println(  String.format(    args));  [CONTEXT]  private  static  void  print(String  msg,  Object...  args)  {  [BUGGY]  System.out.println  (  String.format  (args  ))  ;  }        [CLASS]  ListLinks    [METHOD]  print  [RETURN_TYPE]  void      String  msg    args  [VARIABLES]  boolean    String    msg    Object[]    args    
System.out.println  (  String.format  (  msg,  args  )  )  ;	[BUGGY]  System.out.println(  String.format(  msg));  [CONTEXT]  private  static  void  print(String  msg,  Object...  args)  {  [BUGGY]  System.out.println  (  String.format  (  msg  ))  ;  }        [CLASS]  ListLinks    [METHOD]  print  [RETURN_TYPE]  void      String  msg    args  [VARIABLES]  boolean    String    msg    Object[]    args    
System.out.println  (  String.format  (  msg,  args  )  )  ;  }	[BUGGY]    [CONTEXT]  private  static  void  print(String  msg,  Object...  args)  {  [BUGGY]  System.out.println(String.format(msg,  args));          [CLASS]  ListLinks    [METHOD]  print  [RETURN_TYPE]  void      String  msg    args  [VARIABLES]  boolean    String    msg    Object[]    args    
if  (  s.length  (  )  >  width  )  return  s.substring  (  0,  width-1  )  +   ". ";	[BUGGY]  if  (  s.length(  )  >=  width)return  s.substring(  0,  width-1)  +   ". ";  [CONTEXT]  private  static  String  trim(String  s,  int  width)  {  [BUGGY]  if(  s.length  ()>=  width  )  return  s.substring  (  0,  width-1  )+   ". ";    else  return  s;  }        [CLASS]  ListLinks    [METHOD]  trim  [RETURN_TYPE]  String      String  s  int  width  [VARIABLES]  boolean    String    s    int    width    
if  (  s.length  (  )  >  width  )  return  s.substring  (  0,  width-1  )  +   ". ";	[BUGGY]  if    |  (  s.length(  )  >  width)return  s.substring(  0,  width-1)  +   ". ";  [CONTEXT]  private  static  String  trim(String  s,  int  width)  {  [BUGGY]  if|(  s.length  ()>  width  )  return  s.substring  (  0,  width-1  )+   ". ";    else  return  s;  }        [CLASS]  ListLinks    [METHOD]  trim  [RETURN_TYPE]  String      String  s  int  width  [VARIABLES]  boolean    String    s    int    width    
if  (  s.length  (  )  >  width  )  return  s.substring  (  0,  width-1  )  +   ". ";	[BUGGY]  if  (  s.length(  )  >  width)return  s.substring(  -8,  width-1)  +   ". ";  [CONTEXT]  private  static  String  trim(String  s,  int  width)  {  [BUGGY]  if(  s.length  ()>  width  )  return  s.substring  (  -8,  width-1  )+   ". ";    else  return  s;  }        [CLASS]  ListLinks    [METHOD]  trim  [RETURN_TYPE]  String      String  s  int  width  [VARIABLES]  boolean    String    s    int    width    
if  (  s.length  (  )  >  width  )  return  s.substring  (  0,  width-1  )  +   ". ";	[BUGGY]  if  (  s.length(  )  >  width)return  s.substring(  0,  width-width)  +   ". ";  [CONTEXT]  private  static  String  trim(String  s,  int  width)  {  [BUGGY]  if(  s.length  ()>  width  )  return  s.substring  (  0,  width-width  )+   ". ";    else  return  s;  }        [CLASS]  ListLinks    [METHOD]  trim  [RETURN_TYPE]  String      String  s  int  width  [VARIABLES]  boolean    String    s    int    width    
if  (  s.length  (  )  >  width  )  return  s.substring  (  0,  width-1  )  +   ". ";	[BUGGY]  if  (  s.length()  +  5    >  width)return  s.substring(  0,  width-1)  +   ". ";  [CONTEXT]  private  static  String  trim(String  s,  int  width)  {  [BUGGY]  if(  s.length()  +  5>  width  )  return  s.substring  (  0,  width-1  )+   ". ";    else  return  s;  }        [CLASS]  ListLinks    [METHOD]  trim  [RETURN_TYPE]  String      String  s  int  width  [VARIABLES]  boolean    String    s    int    width    
if  (  s.length  (  )  >  width  )  return  s.substring  (  0,  width-1  )  +   ". ";	[BUGGY]  if  (  width.length(  )  >  s)return  s.substring(  0,  width-1)  +   ". ";  [CONTEXT]  private  static  String  trim(String  s,  int  width)  {  [BUGGY]  if(  width.length  ()>  s  )  return  s.substring  (  0,  width-1  )+   ". ";    else  return  s;  }        [CLASS]  ListLinks    [METHOD]  trim  [RETURN_TYPE]  String      String  s  int  width  [VARIABLES]  boolean    String    s    int    width    
if  (  s.length  (  )  >  width  )  return  s.substring  (  0,  width-1  )  +   ". ";	[BUGGY]  if  (  s.length(  )  >  width)return  s.substring(  0-1)  +   ". ";  [CONTEXT]  private  static  String  trim(String  s,  int  width)  {  [BUGGY]  if(  s.length  ()>  width  )  return  s.substring  (  0-1  )+   ". ";    else  return  s;  }        [CLASS]  ListLinks    [METHOD]  trim  [RETURN_TYPE]  String      String  s  int  width  [VARIABLES]  boolean    String    s    int    width    
if  (  s.length  (  )  >  width  )  return  s.substring  (  0,  width-1  )  +   ". ";	[BUGGY]  if  (  s.substring(0,(width  -  1))  +   ". ")  +   ". ";  [CONTEXT]  private  static  String  trim(String  s,  int  width)  {  [BUGGY]  if(  s.substring(0,  (width  -  1))  +   ". "  )+   ". ";    else  return  s;  }        [CLASS]  ListLinks    [METHOD]  trim  [RETURN_TYPE]  String      String  s  int  width  [VARIABLES]  boolean    String    s    int    width    
if  (  s.length  (  )  >  width  )  return  s.substring  (  0,  width-1  )  +   ". ";	[BUGGY]  if  (  width  -  1)  +   ". ";  [CONTEXT]  private  static  String  trim(String  s,  int  width)  {  [BUGGY]  if(  width  -  1  )+   ". ";    else  return  s;  }        [CLASS]  ListLinks    [METHOD]  trim  [RETURN_TYPE]  String      String  s  int  width  [VARIABLES]  boolean    String    s    int    width    
if  (  s.length  (  )  >  width  )  return  s.substring  (  0,  width-1  )  +   ". ";	[BUGGY]  if  (  s.length(  )  >  width)return  s  .length(  )    +   ". ";  [CONTEXT]  private  static  String  trim(String  s,  int  width)  {  [BUGGY]  if(  s.length  ()>  width  )  return  s  .length  ()  +   ". ";    else  return  s;  }        [CLASS]  ListLinks    [METHOD]  trim  [RETURN_TYPE]  String      String  s  int  width  [VARIABLES]  boolean    String    s    int    width    
if  (  s.length  (  )  >  width  )  return  s.substring  (  0,  width-1  )  +   ". ";	[BUGGY]  if  (  s.length(  )  >  width)return  s.substring(  0  ,  width-1)  +   ". ";  [CONTEXT]  private  static  String  trim(String  s,  int  width)  {  [BUGGY]  if(  s.length  ()>  width  )  return  s.substring  (  0  ,  width-1  )+   ". ";    else  return  s;  }        [CLASS]  ListLinks    [METHOD]  trim  [RETURN_TYPE]  String      String  s  int  width  [VARIABLES]  boolean    String    s    int    width    
if  (  s.length  (  )  >  width  )  return  s.substring  (  0,  width-1  )  +   ". ";  else  return  s;  }	[BUGGY]  return(s.substring(0,(width  -  1)))  +   ". ";  [CONTEXT]  private  static  String  trim(String  s,  int  width)  {  [BUGGY]  if  (s.length()  >  width)    return  (s.substring(0,  (width  -  1)))  +   ". ";            [CLASS]  ListLinks    [METHOD]  trim  [RETURN_TYPE]  String      String  s  int  width  [VARIABLES]  boolean    String    s    int    width    
if  (  s.length  (  )  >  width  )  return  s.substring  (  0,  width-1  )  +   ". ";  else  return  s;  }	[BUGGY]    [CONTEXT]  private  static  String  trim(String  s,  int  width)  {  [BUGGY]  if  (s.length()  >  width)                [CLASS]  ListLinks    [METHOD]  trim  [RETURN_TYPE]  String      String  s  int  width  [VARIABLES]  boolean    String    s    int    width    
return  s.substring  (  0,  width-1  )  +   ". ";	[BUGGY]  return  s.substring(  0,  width-1)  &    +   ". ";  [CONTEXT]  private  static  String  trim(String  s,  int  width)  {  if  (s.length()  >  width)  [BUGGY]  return  s.substring  (  0,  width-1  )&+   ". ";  else  return  s;  }        [CLASS]  ListLinks    [METHOD]  trim  [RETURN_TYPE]  String      String  s  int  width  [VARIABLES]  boolean    String    s    int    width    
return  s.substring  (  0,  width-1  )  +   ". ";	[BUGGY]  return  s.substring(  ,  width-1)  +   ". ";  [CONTEXT]  private  static  String  trim(String  s,  int  width)  {  if  (s.length()  >  width)  [BUGGY]  return  s.substring  (  ,  width-1  )+   ". ";  else  return  s;  }        [CLASS]  ListLinks    [METHOD]  trim  [RETURN_TYPE]  String      String  s  int  width  [VARIABLES]  boolean    String    s    int    width    
return  s.substring  (  0,  width-1  )  +   ". ";	[BUGGY]  return  s.substring(  0,  width--4)  +   ". ";  [CONTEXT]  private  static  String  trim(String  s,  int  width)  {  if  (s.length()  >  width)  [BUGGY]  return  s.substring  (  0,  width--4  )+   ". ";  else  return  s;  }        [CLASS]  ListLinks    [METHOD]  trim  [RETURN_TYPE]  String      String  s  int  width  [VARIABLES]  boolean    String    s    int    width    
return  s.substring  (  0,  width-1  )  +   ". ";	[BUGGY]  return  s.substring(  0,  width-1)  +   " ";  [CONTEXT]  private  static  String  trim(String  s,  int  width)  {  if  (s.length()  >  width)  [BUGGY]  return  s.substring  (  0,  width-1  )+   " ";  else  return  s;  }        [CLASS]  ListLinks    [METHOD]  trim  [RETURN_TYPE]  String      String  s  int  width  [VARIABLES]  boolean    String    s    int    width    
return  s.substring  (  0,  width-1  )  +   ". ";	[BUGGY]  return  width.substring(  0,  s-1)  +   ". ";  [CONTEXT]  private  static  String  trim(String  s,  int  width)  {  if  (s.length()  >  width)  [BUGGY]  return  width.substring  (  0,  s-1  )+   ". ";  else  return  s;  }        [CLASS]  ListLinks    [METHOD]  trim  [RETURN_TYPE]  String      String  s  int  width  [VARIABLES]  boolean    String    s    int    width    
return  s.substring  (  0,  width-1  )  +   ". ";	[BUGGY]  return  s.substring(  0-1)  +   ". ";  [CONTEXT]  private  static  String  trim(String  s,  int  width)  {  if  (s.length()  >  width)  [BUGGY]  return  s.substring  (  0-1  )+   ". ";  else  return  s;  }        [CLASS]  ListLinks    [METHOD]  trim  [RETURN_TYPE]  String      String  s  int  width  [VARIABLES]  boolean    String    s    int    width    
return  s.substring  (  0,  width-1  )  +   ". ";	[BUGGY]  return  s  .length(  )    +   ". ";  [CONTEXT]  private  static  String  trim(String  s,  int  width)  {  if  (s.length()  >  width)  [BUGGY]  return  s  .length  ()  +   ". ";  else  return  s;  }        [CLASS]  ListLinks    [METHOD]  trim  [RETURN_TYPE]  String      String  s  int  width  [VARIABLES]  boolean    String    s    int    width    
return  s.substring  (  0,  width-1  )  +   ". ";	[BUGGY]  return  s.substring(  width,  width-1)  +   ". ";  [CONTEXT]  private  static  String  trim(String  s,  int  width)  {  if  (s.length()  >  width)  [BUGGY]  return  s.substring  (  width,  width-1  )+   ". ";  else  return  s;  }        [CLASS]  ListLinks    [METHOD]  trim  [RETURN_TYPE]  String      String  s  int  width  [VARIABLES]  boolean    String    s    int    width    
return  s.substring  (  0,  width-1  )  +   ". ";	[BUGGY]  return  s.substring(  0,  width-0)  +   ". ";  [CONTEXT]  private  static  String  trim(String  s,  int  width)  {  if  (s.length()  >  width)  [BUGGY]  return  s.substring  (  0,  width-0  )+   ". ";  else  return  s;  }        [CLASS]  ListLinks    [METHOD]  trim  [RETURN_TYPE]  String      String  s  int  width  [VARIABLES]  boolean    String    s    int    width    
return  s.substring  (  0,  width-1  )  +   ". ";	[BUGGY]    [CONTEXT]  private  static  String  trim(String  s,  int  width)  {  if  (s.length()  >  width)  [BUGGY]  return  s.substring(0,  width-1)  +   ". ";    else  return  s;        [CLASS]  ListLinks    [METHOD]  trim  [RETURN_TYPE]  String      String  s  int  width  [VARIABLES]  boolean    String    s    int    width    
return  s.substring  (  0,  width-1  )  +   ". ";	[BUGGY]  return  s.substring(  0,  width-1)  ||    +   ". ";  [CONTEXT]  private  static  String  trim(String  s,  int  width)  {  if  (s.length()  >  width)  [BUGGY]  return  s.substring  (  0,  width-1  )||+   ". ";  else  return  s;  }        [CLASS]  ListLinks    [METHOD]  trim  [RETURN_TYPE]  String      String  s  int  width  [VARIABLES]  boolean    String    s    int    width    
return  s.substring  (  0,  width-1  )  +   ". ";	[BUGGY]  return  s.substring(  4,  width-1)  +   ". ";  [CONTEXT]  private  static  String  trim(String  s,  int  width)  {  if  (s.length()  >  width)  [BUGGY]  return  s.substring  (  4,  width-1  )+   ". ";  else  return  s;  }        [CLASS]  ListLinks    [METHOD]  trim  [RETURN_TYPE]  String      String  s  int  width  [VARIABLES]  boolean    String    s    int    width    
return  s.substring  (  0,  width-1  )  +   ". ";	[BUGGY]  return  s.substring(  0,  width-width)  +   ". ";  [CONTEXT]  private  static  String  trim(String  s,  int  width)  {  if  (s.length()  >  width)  [BUGGY]  return  s.substring  (  0,  width-width  )+   ". ";  else  return  s;  }        [CLASS]  ListLinks    [METHOD]  trim  [RETURN_TYPE]  String      String  s  int  width  [VARIABLES]  boolean    String    s    int    width    
return  s.substring  (  0,  width-1  )  +   ". ";	[BUGGY]  return  s.substring(  0,  width-1)    ;  [CONTEXT]  private  static  String  trim(String  s,  int  width)  {  if  (s.length()  >  width)  [BUGGY]  return  s.substring  (  0,  width-1  )  ;  else  return  s;  }        [CLASS]  ListLinks    [METHOD]  trim  [RETURN_TYPE]  String      String  s  int  width  [VARIABLES]  boolean    String    s    int    width    
if  (  s.length  (  )  >  width  )  return  s.substring  (  0,  width-1  )  +   ". ";	[BUGGY]  if  (  s.length()  -  7    >  width)return  s.substring(  0,  width-1)  +   ". ";  [CONTEXT]  private  static  String  trim(String  s,  int  width)  {  [BUGGY]  if(  s.length()  -  7>  width  )  return  s.substring  (  0,  width-1  )+   ". ";    else  return  s;  }        [CLASS]  ListLinks    [METHOD]  trim  [RETURN_TYPE]  String      String  s  int  width  [VARIABLES]  boolean    String    s    int    width    
return  s.substring  (  0,  width-1  )  +   ". ";	[BUGGY]  return  s.substring(  6,  width-1)  +   ". ";  [CONTEXT]  private  static  String  trim(String  s,  int  width)  {  if  (s.length()  >  width)  [BUGGY]  return  s.substring  (  6,  width-1  )+   ". ";  else  return  s;  }        [CLASS]  ListLinks    [METHOD]  trim  [RETURN_TYPE]  String      String  s  int  width  [VARIABLES]  boolean    String    s    int    width    
private  static  final  String  SQ  =   "' ";	[BUGGY]  private  static  final  char  SQ  =   "' ";  [CONTEXT]      Parses  HTML  into  a  {@link  Document}.  Generally  best  to  use  one  of  themore  convenient  parse  methods  in  {@link  org.jsoup.Jsoup}.    @author  Jonathan  Hedley,  jonathan@hedley.net  */  public  class  Parser  {  [BUGGY]  private  static  final  char  SQ  =   "' ";  private  static  final  String  DQ  =   "\ " ";    private  static  final  Tag  htmlTag  =  Tag.valueOf( "html ");  private  static  final  Tag  headTag  =  Tag.valueOf( "head ");  private  static  final  Tag  bodyTag  =  Tag.valueOf( "body ");        [CLASS]  Parser      [VARIABLES]  
private  static  final  String  DQ  =   "\ " ";	[BUGGY]  private  static  final  char  DQ  =   "\ " ";  [CONTEXT]  Parses  HTML  into  a  {@link  Document}.  Generally  best  to  use  one  of  themore  convenient  parse  methods  in  {@link  org.jsoup.Jsoup}.    @author  Jonathan  Hedley,  jonathan@hedley.net  */  public  class  Parser  {  private  static  final  String  SQ  =   "' ";  [BUGGY]  private  static  final  char  DQ  =   "\ " ";    private  static  final  Tag  htmlTag  =  Tag.valueOf( "html ");  private  static  final  Tag  headTag  =  Tag.valueOf( "head ");  private  static  final  Tag  bodyTag  =  Tag.valueOf( "body ");  private  static  final  Tag  titleTag  =  Tag.valueOf( "title ");        [CLASS]  Parser      [VARIABLES]  
private  static  final  String  DQ  =   "\ " ";	[BUGGY]  private  static  final  String  DQ  =   "\ "\ ";  [CONTEXT]  Parses  HTML  into  a  {@link  Document}.  Generally  best  to  use  one  of  themore  convenient  parse  methods  in  {@link  org.jsoup.Jsoup}.    @author  Jonathan  Hedley,  jonathan@hedley.net  */  public  class  Parser  {  private  static  final  String  SQ  =   "' ";  [BUGGY]  private  static  final  String  DQ  =   "\ "\ ";    private  static  final  Tag  htmlTag  =  Tag.valueOf( "html ");  private  static  final  Tag  headTag  =  Tag.valueOf( "head ");  private  static  final  Tag  bodyTag  =  Tag.valueOf( "body ");  private  static  final  Tag  titleTag  =  Tag.valueOf( "title ");        [CLASS]  Parser      [VARIABLES]  
private  static  final  String  DQ  =   "\ " ";	[BUGGY]  private  static  final  String  DQ    =  null  ;  [CONTEXT]  Parses  HTML  into  a  {@link  Document}.  Generally  best  to  use  one  of  themore  convenient  parse  methods  in  {@link  org.jsoup.Jsoup}.    @author  Jonathan  Hedley,  jonathan@hedley.net  */  public  class  Parser  {  private  static  final  String  SQ  =   "' ";  [BUGGY]  private  static  final  String  DQ=  null  ;    private  static  final  Tag  htmlTag  =  Tag.valueOf( "html ");  private  static  final  Tag  headTag  =  Tag.valueOf( "head ");  private  static  final  Tag  bodyTag  =  Tag.valueOf( "body ");  private  static  final  Tag  titleTag  =  Tag.valueOf( "title ");        [CLASS]  Parser      [VARIABLES]  
private  static  final  Tag  htmlTag  =  Tag.valueOf  (   "html "  )  ;	[BUGGY]  private  static  final  Tag  htmlTag  =  Tag.valueOf(   "h ");  [CONTEXT]  @author  Jonathan  Hedley,  jonathan@hedley.net  */  public  class  Parser  {  private  static  final  String  SQ  =   "' ";  private  static  final  String  DQ  =   "\ " ";    [BUGGY]  private  static  final  Tag  htmlTag  =  Tag.valueOf  (   "h "  )  ;  private  static  final  Tag  headTag  =  Tag.valueOf( "head ");  private  static  final  Tag  bodyTag  =  Tag.valueOf( "body ");  private  static  final  Tag  titleTag  =  Tag.valueOf( "title ");  private  static  final  Tag  textareaTag  =  Tag.valueOf( "textarea ");          [CLASS]  Parser      [VARIABLES]  
private  static  final  Tag  htmlTag  =  Tag.valueOf  (   "html "  )  ;	[BUGGY]  private  static  final  Tag  htmlTag  =  Tag.equals(   "html ");  [CONTEXT]  @author  Jonathan  Hedley,  jonathan@hedley.net  */  public  class  Parser  {  private  static  final  String  SQ  =   "' ";  private  static  final  String  DQ  =   "\ " ";    [BUGGY]  private  static  final  Tag  htmlTag  =  Tag.equals  (   "html "  )  ;  private  static  final  Tag  headTag  =  Tag.valueOf( "head ");  private  static  final  Tag  bodyTag  =  Tag.valueOf( "body ");  private  static  final  Tag  titleTag  =  Tag.valueOf( "title ");  private  static  final  Tag  textareaTag  =  Tag.valueOf( "textarea ");          [CLASS]  Parser      [VARIABLES]  
private  static  final  Tag  htmlTag  =  Tag.valueOf  (   "html "  )  ;	[BUGGY]  private  static    Tag  htmlTag  =  Tag.valueOf(   "html ");  [CONTEXT]  @author  Jonathan  Hedley,  jonathan@hedley.net  */  public  class  Parser  {  private  static  final  String  SQ  =   "' ";  private  static  final  String  DQ  =   "\ " ";    [BUGGY]  private  staticTag  htmlTag  =  Tag.valueOf  (   "html "  )  ;  private  static  final  Tag  headTag  =  Tag.valueOf( "head ");  private  static  final  Tag  bodyTag  =  Tag.valueOf( "body ");  private  static  final  Tag  titleTag  =  Tag.valueOf( "title ");  private  static  final  Tag  textareaTag  =  Tag.valueOf( "textarea ");          [CLASS]  Parser      [VARIABLES]  
private  static  final  Tag  headTag  =  Tag.valueOf  (   "head "  )  ;	[BUGGY]  private  static  final  Tag  headTag  =  Tag.equals(   "head ");  [CONTEXT]  public  class  Parser  {  private  static  final  String  SQ  =   "' ";  private  static  final  String  DQ  =   "\ " ";    private  static  final  Tag  htmlTag  =  Tag.valueOf( "html ");  [BUGGY]  private  static  final  Tag  headTag  =  Tag.equals  (   "head "  )  ;  private  static  final  Tag  bodyTag  =  Tag.valueOf( "body ");  private  static  final  Tag  titleTag  =  Tag.valueOf( "title ");  private  static  final  Tag  textareaTag  =  Tag.valueOf( "textarea ");    private  final  LinkedList<Element>  stack;        [CLASS]  Parser      [VARIABLES]  
private  static  final  Tag  headTag  =  Tag.valueOf  (   "head "  )  ;	[BUGGY]  private  static    Tag  headTag  =  Tag.valueOf(   "head ");  [CONTEXT]  public  class  Parser  {  private  static  final  String  SQ  =   "' ";  private  static  final  String  DQ  =   "\ " ";    private  static  final  Tag  htmlTag  =  Tag.valueOf( "html ");  [BUGGY]  private  staticTag  headTag  =  Tag.valueOf  (   "head "  )  ;  private  static  final  Tag  bodyTag  =  Tag.valueOf( "body ");  private  static  final  Tag  titleTag  =  Tag.valueOf( "title ");  private  static  final  Tag  textareaTag  =  Tag.valueOf( "textarea ");    private  final  LinkedList<Element>  stack;        [CLASS]  Parser      [VARIABLES]  
private  static  final  Tag  bodyTag  =  Tag.valueOf  (   "body "  )  ;	[BUGGY]  private  static  final  Tag  bodyTag  =  Tag.valueOf(   "bodody ");  [CONTEXT]  private  static  final  String  SQ  =   "' ";  private  static  final  String  DQ  =   "\ " ";    private  static  final  Tag  htmlTag  =  Tag.valueOf( "html ");  private  static  final  Tag  headTag  =  Tag.valueOf( "head ");  [BUGGY]  private  static  final  Tag  bodyTag  =  Tag.valueOf  (   "bodody "  )  ;  private  static  final  Tag  titleTag  =  Tag.valueOf( "title ");  private  static  final  Tag  textareaTag  =  Tag.valueOf( "textarea ");    private  final  LinkedList<Element>  stack;  private  final  TokenQueue  tq;        [CLASS]  Parser      [VARIABLES]  
private  static  final  Tag  bodyTag  =  Tag.valueOf  (   "body "  )  ;	[BUGGY]  private  static  final  Tag  bodyTag  =  Tag.equals(   "body ");  [CONTEXT]  private  static  final  String  SQ  =   "' ";  private  static  final  String  DQ  =   "\ " ";    private  static  final  Tag  htmlTag  =  Tag.valueOf( "html ");  private  static  final  Tag  headTag  =  Tag.valueOf( "head ");  [BUGGY]  private  static  final  Tag  bodyTag  =  Tag.equals  (   "body "  )  ;  private  static  final  Tag  titleTag  =  Tag.valueOf( "title ");  private  static  final  Tag  textareaTag  =  Tag.valueOf( "textarea ");    private  final  LinkedList<Element>  stack;  private  final  TokenQueue  tq;        [CLASS]  Parser      [VARIABLES]  
private  static  final  Tag  bodyTag  =  Tag.valueOf  (   "body "  )  ;	[BUGGY]  private  static  final  Tag  bodyTag    =  null  ;  [CONTEXT]  private  static  final  String  SQ  =   "' ";  private  static  final  String  DQ  =   "\ " ";    private  static  final  Tag  htmlTag  =  Tag.valueOf( "html ");  private  static  final  Tag  headTag  =  Tag.valueOf( "head ");  [BUGGY]  private  static  final  Tag  bodyTag=  null  ;  private  static  final  Tag  titleTag  =  Tag.valueOf( "title ");  private  static  final  Tag  textareaTag  =  Tag.valueOf( "textarea ");    private  final  LinkedList<Element>  stack;  private  final  TokenQueue  tq;        [CLASS]  Parser      [VARIABLES]  
private  static  final  Tag  titleTag  =  Tag.valueOf  (   "title "  )  ;	[BUGGY]  private  static  final  Tag  titleTag  =  Tag.valueOf(   "titleit ");  [CONTEXT]  private  static  final  String  DQ  =   "\ " ";    private  static  final  Tag  htmlTag  =  Tag.valueOf( "html ");  private  static  final  Tag  headTag  =  Tag.valueOf( "head ");  private  static  final  Tag  bodyTag  =  Tag.valueOf( "body ");  [BUGGY]  private  static  final  Tag  titleTag  =  Tag.valueOf  (   "titleit "  )  ;  private  static  final  Tag  textareaTag  =  Tag.valueOf( "textarea ");    private  final  LinkedList<Element>  stack;  private  final  TokenQueue  tq;  private  final  Document  doc;        [CLASS]  Parser      [VARIABLES]  
private  static  final  Tag  titleTag  =  Tag.valueOf  (   "title "  )  ;	[BUGGY]  private  static  final  Tag  titleTag  =  Tag.equals(   "title ");  [CONTEXT]  private  static  final  String  DQ  =   "\ " ";    private  static  final  Tag  htmlTag  =  Tag.valueOf( "html ");  private  static  final  Tag  headTag  =  Tag.valueOf( "head ");  private  static  final  Tag  bodyTag  =  Tag.valueOf( "body ");  [BUGGY]  private  static  final  Tag  titleTag  =  Tag.equals  (   "title "  )  ;  private  static  final  Tag  textareaTag  =  Tag.valueOf( "textarea ");    private  final  LinkedList<Element>  stack;  private  final  TokenQueue  tq;  private  final  Document  doc;        [CLASS]  Parser      [VARIABLES]  
private  static  final  Tag  titleTag  =  Tag.valueOf  (   "title "  )  ;	[BUGGY]  private  static  final  Tag  titleTag  ;  [CONTEXT]  private  static  final  String  DQ  =   "\ " ";    private  static  final  Tag  htmlTag  =  Tag.valueOf( "html ");  private  static  final  Tag  headTag  =  Tag.valueOf( "head ");  private  static  final  Tag  bodyTag  =  Tag.valueOf( "body ");  [BUGGY]  private  static  final  Tag  titleTag  ;  private  static  final  Tag  textareaTag  =  Tag.valueOf( "textarea ");    private  final  LinkedList<Element>  stack;  private  final  TokenQueue  tq;  private  final  Document  doc;        [CLASS]  Parser      [VARIABLES]  
private  static  final  Tag  textareaTag  =  Tag.valueOf  (   "textarea "  )  ;	[BUGGY]  private  static  final  Tag  textareaTag  =  Tag.valueOf(   "extarextarea ");  [CONTEXT]    private  static  final  Tag  htmlTag  =  Tag.valueOf( "html ");  private  static  final  Tag  headTag  =  Tag.valueOf( "head ");  private  static  final  Tag  bodyTag  =  Tag.valueOf( "body ");  private  static  final  Tag  titleTag  =  Tag.valueOf( "title ");  [BUGGY]  private  static  final  Tag  textareaTag  =  Tag.valueOf  (   "extarextarea "  )  ;    private  final  LinkedList<Element>  stack;  private  final  TokenQueue  tq;  private  final  Document  doc;  private  String  baseUri;        [CLASS]  Parser      [VARIABLES]  
private  static  final  Tag  textareaTag  =  Tag.valueOf  (   "textarea "  )  ;	[BUGGY]  private  static  final  Tag  textareaTag  =  Tag.equals(   "textarea ");  [CONTEXT]    private  static  final  Tag  htmlTag  =  Tag.valueOf( "html ");  private  static  final  Tag  headTag  =  Tag.valueOf( "head ");  private  static  final  Tag  bodyTag  =  Tag.valueOf( "body ");  private  static  final  Tag  titleTag  =  Tag.valueOf( "title ");  [BUGGY]  private  static  final  Tag  textareaTag  =  Tag.equals  (   "textarea "  )  ;    private  final  LinkedList<Element>  stack;  private  final  TokenQueue  tq;  private  final  Document  doc;  private  String  baseUri;        [CLASS]  Parser      [VARIABLES]  
private  static  final  Tag  textareaTag  =  Tag.valueOf  (   "textarea "  )  ;	[BUGGY]  private  static  final  Tag  textareaTag  ;  [CONTEXT]    private  static  final  Tag  htmlTag  =  Tag.valueOf( "html ");  private  static  final  Tag  headTag  =  Tag.valueOf( "head ");  private  static  final  Tag  bodyTag  =  Tag.valueOf( "body ");  private  static  final  Tag  titleTag  =  Tag.valueOf( "title ");  [BUGGY]  private  static  final  Tag  textareaTag  ;    private  final  LinkedList<Element>  stack;  private  final  TokenQueue  tq;  private  final  Document  doc;  private  String  baseUri;        [CLASS]  Parser      [VARIABLES]  
private  String  baseUri;	[BUGGY]  private  char  baseUri;  [CONTEXT]  private  static  final  Tag  textareaTag  =  Tag.valueOf( "textarea ");    private  final  LinkedList<Element>  stack;  private  final  TokenQueue  tq;  private  final  Document  doc;  [BUGGY]  private  char  baseUri;    private  Parser(String  html,  String  baseUri,  boolean  isBodyFragment)  {  Validate.notNull(html);  Validate.notNull(baseUri);          [CLASS]  Parser      [VARIABLES]  
Validate.notNull  (  html  )  ;	[BUGGY]  Validate.notNull(  baseUri);  [CONTEXT]  private  Parser(String  html,  String  baseUri,  boolean  isBodyFragment)  {  [BUGGY]  Validate.notNull  (  baseUri  )  ;  Validate.notNull(baseUri);    stack  =  new  LinkedList<Element>();  tq  =  new  TokenQueue(html);  this.baseUri  =  baseUri;    if  (isBodyFragment)  {  doc  =  Document.createShell(baseUri);  stack.add(doc.body());  }  else  {  doc  =  new  Document(baseUri);  stack.add(doc);  }  }        [CLASS]  Parser    [METHOD]  <init>  [RETURN_TYPE]  String,boolean)      String  html  String  baseUri  boolean  isBodyFragment  [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    isBodyFragment    Document    doc    LinkedList    stack    
Validate.notNull  (  html  )  ;	[BUGGY]    [CONTEXT]  private  Parser(String  html,  String  baseUri,  boolean  isBodyFragment)  {  [BUGGY]  Validate.notNull(html);    Validate.notNull(baseUri);    stack  =  new  LinkedList<Element>();  tq  =  new  TokenQueue(html);  this.baseUri  =  baseUri;    if  (isBodyFragment)  {  doc  =  Document.createShell(baseUri);  stack.add(doc.body());  }  else  {  doc  =  new  Document(baseUri);  stack.add(doc);  }        [CLASS]  Parser    [METHOD]  <init>  [RETURN_TYPE]  String,boolean)      String  html  String  baseUri  boolean  isBodyFragment  [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    isBodyFragment    Document    doc    LinkedList    stack    
Validate.notNull  (  html  )  ;	[BUGGY]  Validate.notNull(  baseUri);  Validate.notNull(  html);  [CONTEXT]        [CLASS]  Parser    [METHOD]  <init>  [RETURN_TYPE]  String,boolean)      String  html  String  baseUri  boolean  isBodyFragment  [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    isBodyFragment    Document    doc    LinkedList    stack    
Validate.notNull  (  baseUri  )  ;	[BUGGY]  Validate.notNull(  html);  [CONTEXT]  private  Parser(String  html,  String  baseUri,  boolean  isBodyFragment)  {  Validate.notNull(html);  [BUGGY]  Validate.notNull  (  html  )  ;    stack  =  new  LinkedList<Element>();  tq  =  new  TokenQueue(html);  this.baseUri  =  baseUri;    if  (isBodyFragment)  {  doc  =  Document.createShell(baseUri);  stack.add(doc.body());  }  else  {  doc  =  new  Document(baseUri);  stack.add(doc);  }  }        [CLASS]  Parser    [METHOD]  <init>  [RETURN_TYPE]  String,boolean)      String  html  String  baseUri  boolean  isBodyFragment  [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    isBodyFragment    Document    doc    LinkedList    stack    
Validate.notNull  (  baseUri  )  ;	[BUGGY]    [CONTEXT]  private  Parser(String  html,  String  baseUri,  boolean  isBodyFragment)  {  Validate.notNull(html);  [BUGGY]  Validate.notNull(baseUri);      stack  =  new  LinkedList<Element>();  tq  =  new  TokenQueue(html);  this.baseUri  =  baseUri;    if  (isBodyFragment)  {  doc  =  Document.createShell(baseUri);  stack.add(doc.body());  }  else  {  doc  =  new  Document(baseUri);  stack.add(doc);  }        [CLASS]  Parser    [METHOD]  <init>  [RETURN_TYPE]  String,boolean)      String  html  String  baseUri  boolean  isBodyFragment  [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    isBodyFragment    Document    doc    LinkedList    stack    
stack  =  new  LinkedList<Element>  (  )  ;	[BUGGY]  stack    =    stack  ;  [CONTEXT]  private  Parser(String  html,  String  baseUri,  boolean  isBodyFragment)  {  Validate.notNull(html);  Validate.notNull(baseUri);    [BUGGY]  stack=stack  ;  tq  =  new  TokenQueue(html);  this.baseUri  =  baseUri;    if  (isBodyFragment)  {  doc  =  Document.createShell(baseUri);  stack.add(doc.body());  }  else  {  doc  =  new  Document(baseUri);  stack.add(doc);  }  }        [CLASS]  Parser    [METHOD]  <init>  [RETURN_TYPE]  String,boolean)      String  html  String  baseUri  boolean  isBodyFragment  [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    isBodyFragment    Document    doc    LinkedList    stack    
tq  =  new  TokenQueue  (  html  )  ;	[BUGGY]  tq  =  new  TokenQueue(  baseUri);  [CONTEXT]  private  Parser(String  html,  String  baseUri,  boolean  isBodyFragment)  {  Validate.notNull(html);  Validate.notNull(baseUri);    stack  =  new  LinkedList<Element>();  [BUGGY]  tq  =  new  TokenQueue  (  baseUri  )  ;  this.baseUri  =  baseUri;    if  (isBodyFragment)  {  doc  =  Document.createShell(baseUri);  stack.add(doc.body());  }  else  {  doc  =  new  Document(baseUri);  stack.add(doc);  }  }        [CLASS]  Parser    [METHOD]  <init>  [RETURN_TYPE]  String,boolean)      String  html  String  baseUri  boolean  isBodyFragment  [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    isBodyFragment    Document    doc    LinkedList    stack    
this.baseUri  =  baseUri;	[BUGGY]  this.baseUri  =  html;  [CONTEXT]  private  Parser(String  html,  String  baseUri,  boolean  isBodyFragment)  {  Validate.notNull(html);  Validate.notNull(baseUri);    stack  =  new  LinkedList<Element>();  tq  =  new  TokenQueue(html);  [BUGGY]  this.baseUri  =  html;    if  (isBodyFragment)  {  doc  =  Document.createShell(baseUri);  stack.add(doc.body());  }  else  {  doc  =  new  Document(baseUri);  stack.add(doc);  }  }        [CLASS]  Parser    [METHOD]  <init>  [RETURN_TYPE]  String,boolean)      String  html  String  baseUri  boolean  isBodyFragment  [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    isBodyFragment    Document    doc    LinkedList    stack    
doc  =  new  Document  (  baseUri  )  ;	[BUGGY]  doc  =  doc  =    new  DataNode(  data,  baseUri)  ;  [CONTEXT]  private  Parser(String  html,  String  baseUri,  boolean  isBodyFragment)  {  Validate.notNull(html);  Validate.notNull(baseUri);    stack  =  new  LinkedList<Element>();  tq  =  new  TokenQueue(html);  this.baseUri  =  baseUri;    if  (isBodyFragment)  {  doc  =  Document.createShell(baseUri);  stack.add(doc.body());  }  else  {  [BUGGY]  doc  =  doc  =new  DataNode  (  data,  baseUri  );  stack.add(doc);  }  }        [CLASS]  Parser    [METHOD]  <init>  [RETURN_TYPE]  String,boolean)      String  html  String  baseUri  boolean  isBodyFragment  [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    isBodyFragment    Document    doc    LinkedList    stack    
doc  =  new  Document  (  baseUri  )  ;	[BUGGY]  doc  =  new  Document(  html);  [CONTEXT]  private  Parser(String  html,  String  baseUri,  boolean  isBodyFragment)  {  Validate.notNull(html);  Validate.notNull(baseUri);    stack  =  new  LinkedList<Element>();  tq  =  new  TokenQueue(html);  this.baseUri  =  baseUri;    if  (isBodyFragment)  {  doc  =  Document.createShell(baseUri);  stack.add(doc.body());  }  else  {  [BUGGY]  doc  =  new  Document  (  html  )  ;  stack.add(doc);  }  }        [CLASS]  Parser    [METHOD]  <init>  [RETURN_TYPE]  String,boolean)      String  html  String  baseUri  boolean  isBodyFragment  [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    isBodyFragment    Document    doc    LinkedList    stack    
doc  =  new  Document  (  baseUri  )  ;	[BUGGY]    doc  =  new  Document(  baseUri);  [CONTEXT]        [CLASS]  Parser    [METHOD]  <init>  [RETURN_TYPE]  String,boolean)      String  html  String  baseUri  boolean  isBodyFragment  [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    isBodyFragment    Document    doc    LinkedList    stack    
doc  =  new  Document  (  baseUri  )  ;	[BUGGY]  doc  =  Document.createShell(  baseUri);doc  =  new  Document(  baseUri);  [CONTEXT]        [CLASS]  Parser    [METHOD]  <init>  [RETURN_TYPE]  String,boolean)      String  html  String  baseUri  boolean  isBodyFragment  [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    isBodyFragment    Document    doc    LinkedList    stack    
doc  =  new  Document  (  baseUri  )  ;	[BUGGY]  dataNode  =  new  DataNode(  data,  baseUri);doc  =  new  Document(  baseUri);  [CONTEXT]        [CLASS]  Parser    [METHOD]  <init>  [RETURN_TYPE]  String,boolean)      String  html  String  baseUri  boolean  isBodyFragment  [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    isBodyFragment    Document    doc    LinkedList    stack    
stack.add  (  doc  )  ;	[BUGGY]    [CONTEXT]  private  Parser(String  html,  String  baseUri,  boolean  isBodyFragment)  {  Validate.notNull(html);  Validate.notNull(baseUri);    stack  =  new  LinkedList<Element>();  tq  =  new  TokenQueue(html);  this.baseUri  =  baseUri;    if  (isBodyFragment)  {  doc  =  Document.createShell(baseUri);  stack.add(doc.body());  }  else  {  doc  =  new  Document(baseUri);  [BUGGY]  stack.add(doc);    }        [CLASS]  Parser    [METHOD]  <init>  [RETURN_TYPE]  String,boolean)      String  html  String  baseUri  boolean  isBodyFragment  [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    isBodyFragment    Document    doc    LinkedList    stack    
doc  =  Document.createShell  (  baseUri  )  ;	[BUGGY]  doc  =  Document.createShell(  html);  [CONTEXT]  private  Parser(String  html,  String  baseUri,  boolean  isBodyFragment)  {  Validate.notNull(html);  Validate.notNull(baseUri);    stack  =  new  LinkedList<Element>();  tq  =  new  TokenQueue(html);  this.baseUri  =  baseUri;    if  (isBodyFragment)  {  [BUGGY]  doc  =  Document.createShell  (  html  )  ;  stack.add(doc.body());  }  else  {  doc  =  new  Document(baseUri);  stack.add(doc);  }  }        [CLASS]  Parser    [METHOD]  <init>  [RETURN_TYPE]  String,boolean)      String  html  String  baseUri  boolean  isBodyFragment  [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    isBodyFragment    Document    doc    LinkedList    stack    
doc  =  Document.createShell  (  baseUri  )  ;	[BUGGY]  doc  =  Document.setBaseUri(  baseUri);  [CONTEXT]  private  Parser(String  html,  String  baseUri,  boolean  isBodyFragment)  {  Validate.notNull(html);  Validate.notNull(baseUri);    stack  =  new  LinkedList<Element>();  tq  =  new  TokenQueue(html);  this.baseUri  =  baseUri;    if  (isBodyFragment)  {  [BUGGY]  doc  =  Document.setBaseUri  (  baseUri  )  ;  stack.add(doc.body());  }  else  {  doc  =  new  Document(baseUri);  stack.add(doc);  }  }        [CLASS]  Parser    [METHOD]  <init>  [RETURN_TYPE]  String,boolean)      String  html  String  baseUri  boolean  isBodyFragment  [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    isBodyFragment    Document    doc    LinkedList    stack    
doc  =  Document.createShell  (  baseUri  )  ;	[BUGGY]  doc  =  Document  .normalise(  )  ;  [CONTEXT]  private  Parser(String  html,  String  baseUri,  boolean  isBodyFragment)  {  Validate.notNull(html);  Validate.notNull(baseUri);    stack  =  new  LinkedList<Element>();  tq  =  new  TokenQueue(html);  this.baseUri  =  baseUri;    if  (isBodyFragment)  {  [BUGGY]  doc  =  Document  .normalise  ();  stack.add(doc.body());  }  else  {  doc  =  new  Document(baseUri);  stack.add(doc);  }  }        [CLASS]  Parser    [METHOD]  <init>  [RETURN_TYPE]  String,boolean)      String  html  String  baseUri  boolean  isBodyFragment  [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    isBodyFragment    Document    doc    LinkedList    stack    
doc  =  Document.createShell  (  baseUri  )  ;  stack.add  (  doc.body  (  )  )  ;	[BUGGY]  stack.add(  doc.body(  ));  doc  =  Document.createShell(  baseUri);  [CONTEXT]        [CLASS]  Parser    [METHOD]  <init>  [RETURN_TYPE]  String,boolean)      String  html  String  baseUri  boolean  isBodyFragment  [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    isBodyFragment    Document    doc    LinkedList    stack    
doc  =  Document.createShell  (  baseUri  )  ;  stack.add  (  doc.body  (  )  )  ;	[BUGGY]  doc  =  Document.createShell(  baseUri);doc  =  Document.createShell(  baseUri);  stack.add(  doc.body(  ));  [CONTEXT]        [CLASS]  Parser    [METHOD]  <init>  [RETURN_TYPE]  String,boolean)      String  html  String  baseUri  boolean  isBodyFragment  [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    isBodyFragment    Document    doc    LinkedList    stack    
doc  =  Document.createShell  (  baseUri  )  ;	[BUGGY]    [CONTEXT]  private  Parser(String  html,  String  baseUri,  boolean  isBodyFragment)  {  Validate.notNull(html);  Validate.notNull(baseUri);    stack  =  new  LinkedList<Element>();  tq  =  new  TokenQueue(html);  this.baseUri  =  baseUri;    if  (isBodyFragment)  {  [BUGGY]  doc  =  Document.createShell(baseUri);    stack.add(doc.body());  }  else  {  doc  =  new  Document(baseUri);  stack.add(doc);  }        [CLASS]  Parser    [METHOD]  <init>  [RETURN_TYPE]  String,boolean)      String  html  String  baseUri  boolean  isBodyFragment  [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    isBodyFragment    Document    doc    LinkedList    stack    
stack.add  (  doc.body  (  )  )  ;	[BUGGY]  stack.size(  doc.body(  ));  [CONTEXT]  private  Parser(String  html,  String  baseUri,  boolean  isBodyFragment)  {  Validate.notNull(html);  Validate.notNull(baseUri);    stack  =  new  LinkedList<Element>();  tq  =  new  TokenQueue(html);  this.baseUri  =  baseUri;    if  (isBodyFragment)  {  doc  =  Document.createShell(baseUri);  [BUGGY]  stack.size  (  doc.body  ())  ;  }  else  {  doc  =  new  Document(baseUri);  stack.add(doc);  }  }        [CLASS]  Parser    [METHOD]  <init>  [RETURN_TYPE]  String,boolean)      String  html  String  baseUri  boolean  isBodyFragment  [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    isBodyFragment    Document    doc    LinkedList    stack    
stack.add  (  doc.body  (  )  )  ;	[BUGGY]  stack.add(  doc.Document(  ));  [CONTEXT]  private  Parser(String  html,  String  baseUri,  boolean  isBodyFragment)  {  Validate.notNull(html);  Validate.notNull(baseUri);    stack  =  new  LinkedList<Element>();  tq  =  new  TokenQueue(html);  this.baseUri  =  baseUri;    if  (isBodyFragment)  {  doc  =  Document.createShell(baseUri);  [BUGGY]  stack.add  (  doc.Document  ())  ;  }  else  {  doc  =  new  Document(baseUri);  stack.add(doc);  }  }        [CLASS]  Parser    [METHOD]  <init>  [RETURN_TYPE]  String,boolean)      String  html  String  baseUri  boolean  isBodyFragment  [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    isBodyFragment    Document    doc    LinkedList    stack    
stack.add  (  doc.body  (  )  )  ;	[BUGGY]    [CONTEXT]  private  Parser(String  html,  String  baseUri,  boolean  isBodyFragment)  {  Validate.notNull(html);  Validate.notNull(baseUri);    stack  =  new  LinkedList<Element>();  tq  =  new  TokenQueue(html);  this.baseUri  =  baseUri;    if  (isBodyFragment)  {  doc  =  Document.createShell(baseUri);  [BUGGY]  stack.add(doc.body());    }  else  {  doc  =  new  Document(baseUri);  stack.add(doc);  }        [CLASS]  Parser    [METHOD]  <init>  [RETURN_TYPE]  String,boolean)      String  html  String  baseUri  boolean  isBodyFragment  [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    isBodyFragment    Document    doc    LinkedList    stack    
doc  =  Document.createShell  (  baseUri  )  ;	[BUGGY]  stack.add(  doc.body(  ));  doc  =  Document.createShell(  baseUri);  [CONTEXT]        [CLASS]  Parser    [METHOD]  <init>  [RETURN_TYPE]  String,boolean)      String  html  String  baseUri  boolean  isBodyFragment  [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    isBodyFragment    Document    doc    LinkedList    stack    
doc  =  Document.createShell  (  baseUri  )  ;	[BUGGY]  doc  =  new  Document(  baseUri);doc  =  Document.createShell(  baseUri);  [CONTEXT]        [CLASS]  Parser    [METHOD]  <init>  [RETURN_TYPE]  String,boolean)      String  html  String  baseUri  boolean  isBodyFragment  [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    isBodyFragment    Document    doc    LinkedList    stack    
doc  =  new  Document  (  baseUri  )  ;	[BUGGY]  stack.add(  doc);  doc  =  new  Document(  baseUri);  [CONTEXT]        [CLASS]  Parser    [METHOD]  <init>  [RETURN_TYPE]  String,boolean)      String  html  String  baseUri  boolean  isBodyFragment  [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    isBodyFragment    Document    doc    LinkedList    stack    
doc  =  Document.createShell  (  baseUri  )  ;  stack.add  (  doc.body  (  )  )  ;	[BUGGY]    [CONTEXT]  private  Parser(String  html,  String  baseUri,  boolean  isBodyFragment)  {  Validate.notNull(html);  Validate.notNull(baseUri);    stack  =  new  LinkedList<Element>();  tq  =  new  TokenQueue(html);  this.baseUri  =  baseUri;    if  (isBodyFragment)  {  [BUGGY]  doc  =  Document.createShell(baseUri);      }  else  {  doc  =  new  Document(baseUri);  stack.add(doc);  }        [CLASS]  Parser    [METHOD]  <init>  [RETURN_TYPE]  String,boolean)      String  html  String  baseUri  boolean  isBodyFragment  [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    isBodyFragment    Document    doc    LinkedList    stack    
stack.add  (  doc.body  (  )  )  ;	[BUGGY]  stack  .add(  )  ;  [CONTEXT]  private  Parser(String  html,  String  baseUri,  boolean  isBodyFragment)  {  Validate.notNull(html);  Validate.notNull(baseUri);    stack  =  new  LinkedList<Element>();  tq  =  new  TokenQueue(html);  this.baseUri  =  baseUri;    if  (isBodyFragment)  {  doc  =  Document.createShell(baseUri);  [BUGGY]  stack  .add  ();  }  else  {  doc  =  new  Document(baseUri);  stack.add(doc);  }  }        [CLASS]  Parser    [METHOD]  <init>  [RETURN_TYPE]  String,boolean)      String  html  String  baseUri  boolean  isBodyFragment  [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    isBodyFragment    Document    doc    LinkedList    stack    
Parser  parser  =  new  Parser  (  html,  baseUri,  false  )  ;	[BUGGY]  Parser  parser  =  new  Parser(  html,  baseUri,  true);  [CONTEXT]  public  static  Document  parse(String  html,  String  baseUri)  {  [BUGGY]  Parser  parser  =  new  Parser  (  html,  baseUri,  true  )  ;  return  parser.parse();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      String  html  String  baseUri  [VARIABLES]  TokenQueue    tq    boolean    String    DQ    SQ    baseUri    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    Parser    parser    
Parser  parser  =  new  Parser  (  html,  baseUri,  false  )  ;	[BUGGY]  Parser  parser  =  new  Parser(  bodyHtml,  baseUri,  true)  ;  [CONTEXT]  public  static  Document  parse(String  html,  String  baseUri)  {  [BUGGY]  Parser  parser  =  new  Parser  (  bodyHtml,  baseUri,  true  );  return  parser.parse();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      String  html  String  baseUri  [VARIABLES]  TokenQueue    tq    boolean    String    DQ    SQ    baseUri    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    Parser    parser    
Parser  parser  =  new  Parser  (  html,  baseUri,  false  )  ;	[BUGGY]  Parser  parser  =  new  Parser(    baseUri,  false);  [CONTEXT]  public  static  Document  parse(String  html,  String  baseUri)  {  [BUGGY]  Parser  parser  =  new  Parser  (baseUri,  false  )  ;  return  parser.parse();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      String  html  String  baseUri  [VARIABLES]  TokenQueue    tq    boolean    String    DQ    SQ    baseUri    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    Parser    parser    
Parser  parser  =  new  Parser  (  html,  baseUri,  false  )  ;	[BUGGY]  Parser  parser  =  new  Parser(  html,    false);  [CONTEXT]  public  static  Document  parse(String  html,  String  baseUri)  {  [BUGGY]  Parser  parser  =  new  Parser  (  html,false  )  ;  return  parser.parse();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      String  html  String  baseUri  [VARIABLES]  TokenQueue    tq    boolean    String    DQ    SQ    baseUri    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    Parser    parser    
Parser  parser  =  new  Parser  (  html,  baseUri,  false  )  ;	[BUGGY]  Parser  parser  =  new  Parser(  SQ,  baseUri,  false);  [CONTEXT]  public  static  Document  parse(String  html,  String  baseUri)  {  [BUGGY]  Parser  parser  =  new  Parser  (  SQ,  baseUri,  false  )  ;  return  parser.parse();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      String  html  String  baseUri  [VARIABLES]  TokenQueue    tq    boolean    String    DQ    SQ    baseUri    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    Parser    parser    
Parser  parser  =  new  Parser  (  html,  baseUri,  false  )  ;	[BUGGY]  Parser  parser  =  new  Parser(  html,  SQ,  false);  [CONTEXT]  public  static  Document  parse(String  html,  String  baseUri)  {  [BUGGY]  Parser  parser  =  new  Parser  (  html,  SQ,  false  )  ;  return  parser.parse();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      String  html  String  baseUri  [VARIABLES]  TokenQueue    tq    boolean    String    DQ    SQ    baseUri    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    Parser    parser    
Parser  parser  =  new  Parser  (  html,  baseUri,  false  )  ;	[BUGGY]  Parser  parser  =  new  Parser(  baseUri,  html,  false);  [CONTEXT]  public  static  Document  parse(String  html,  String  baseUri)  {  [BUGGY]  Parser  parser  =  new  Parser  (  baseUri,  html,  false  )  ;  return  parser.parse();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      String  html  String  baseUri  [VARIABLES]  TokenQueue    tq    boolean    String    DQ    SQ    baseUri    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    Parser    parser    
Parser  parser  =  new  Parser  (  html,  baseUri,  false  )  ;	[BUGGY]  Parser  parser  =  new  Parser(  baseUri,  baseUri,  false);  [CONTEXT]  public  static  Document  parse(String  html,  String  baseUri)  {  [BUGGY]  Parser  parser  =  new  Parser  (  baseUri,  baseUri,  false  )  ;  return  parser.parse();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      String  html  String  baseUri  [VARIABLES]  TokenQueue    tq    boolean    String    DQ    SQ    baseUri    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    Parser    parser    
Parser  parser  =  new  Parser  (  html,  baseUri,  false  )  ;	[BUGGY]  Parser  parser  =  new  Parser(  html,  html,  false);  [CONTEXT]  public  static  Document  parse(String  html,  String  baseUri)  {  [BUGGY]  Parser  parser  =  new  Parser  (  html,  html,  false  )  ;  return  parser.parse();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      String  html  String  baseUri  [VARIABLES]  TokenQueue    tq    boolean    String    DQ    SQ    baseUri    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    Parser    parser    
Parser  parser  =  new  Parser  (  html,  baseUri,  false  )  ;  return  parser.parse  (  )  ;	[BUGGY]  return  parser.parse(  );  Parser  parser  =  new  Parser(  html,  baseUri,  false);  [CONTEXT]        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      String  html  String  baseUri  [VARIABLES]  TokenQueue    tq    boolean    String    DQ    SQ    baseUri    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    Parser    parser    
Parser  parser  =  new  Parser  (  html,  baseUri,  false  )  ;  return  parser.parse  (  )  ;	[BUGGY]  Parser  parser  =  new  Parser(  html,  baseUri,  false);Parser  parser  =  new  Parser(  html,  baseUri,  false);  return  parser.parse(  );  [CONTEXT]        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      String  html  String  baseUri  [VARIABLES]  TokenQueue    tq    boolean    String    DQ    SQ    baseUri    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    Parser    parser    
Parser  parser  =  new  Parser  (  html,  baseUri,  false  )  ;  return  parser.parse  (  )  ;	[BUGGY]  Parser  parser  =  new  Parser(  bodyHtml,  baseUri,  true);Parser  parser  =  new  Parser(  html,  baseUri,  false);  return  parser.parse(  );  [CONTEXT]        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      String  html  String  baseUri  [VARIABLES]  TokenQueue    tq    boolean    String    DQ    SQ    baseUri    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    Parser    parser    
return  parser.parse  (  )  ;	[BUGGY]  return  parser.popStackToClose(  );  [CONTEXT]  public  static  Document  parse(String  html,  String  baseUri)  {  Parser  parser  =  new  Parser(html,  baseUri,  false);  [BUGGY]  return  parser.popStackToClose  ()  ;  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      String  html  String  baseUri  [VARIABLES]  TokenQueue    tq    boolean    String    DQ    SQ    baseUri    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    Parser    parser    
return  parser.parse  (  )  ;	[BUGGY]  return  parser  .parse(  baseUri  ,  DQ)  ;  [CONTEXT]  public  static  Document  parse(String  html,  String  baseUri)  {  Parser  parser  =  new  Parser(html,  baseUri,  false);  [BUGGY]  return  parser  .parse  (  baseUri  ,  DQ  );  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      String  html  String  baseUri  [VARIABLES]  TokenQueue    tq    boolean    String    DQ    SQ    baseUri    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    Parser    parser    
return  parser.parse  (  )  ;	[BUGGY]  return  parser  .parse(  DQ  ,  baseUri)  ;  [CONTEXT]  public  static  Document  parse(String  html,  String  baseUri)  {  Parser  parser  =  new  Parser(html,  baseUri,  false);  [BUGGY]  return  parser  .parse  (  DQ  ,  baseUri  );  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      String  html  String  baseUri  [VARIABLES]  TokenQueue    tq    boolean    String    DQ    SQ    baseUri    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    Parser    parser    
return  parser.parse  (  )  ;	[BUGGY]    [CONTEXT]  public  static  Document  parse(String  html,  String  baseUri)  {  Parser  parser  =  new  Parser(html,  baseUri,  false);  [BUGGY]  return  parser.parse();          [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      String  html  String  baseUri  [VARIABLES]  TokenQueue    tq    boolean    String    DQ    SQ    baseUri    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    Parser    parser    
Parser  parser  =  new  Parser  (  bodyHtml,  baseUri,  true  )  ;	[BUGGY]  Parser  parser  =  new  Parser(  bodyHtml,  baseUri,  false);  [CONTEXT]  public  static  Document  parseBodyFragment(String  bodyHtml,  String  baseUri)  {  [BUGGY]  Parser  parser  =  new  Parser  (  bodyHtml,  baseUri,  false  )  ;  return  parser.parse();  }        [CLASS]  Parser    [METHOD]  parseBodyFragment  [RETURN_TYPE]  Document      String  bodyHtml  String  baseUri  [VARIABLES]  TokenQueue    tq    boolean    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    Parser    parser    
Parser  parser  =  new  Parser  (  bodyHtml,  baseUri,  true  )  ;	[BUGGY]  Parser  parser  =  new  Parser(  html,  baseUri,  false)  ;  [CONTEXT]  public  static  Document  parseBodyFragment(String  bodyHtml,  String  baseUri)  {  [BUGGY]  Parser  parser  =  new  Parser  (  html,  baseUri,  false  );  return  parser.parse();  }        [CLASS]  Parser    [METHOD]  parseBodyFragment  [RETURN_TYPE]  Document      String  bodyHtml  String  baseUri  [VARIABLES]  TokenQueue    tq    boolean    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    Parser    parser    
Parser  parser  =  new  Parser  (  bodyHtml,  baseUri,  true  )  ;	[BUGGY]  Parser  parser  =  new  Parser(    baseUri,  true);  [CONTEXT]  public  static  Document  parseBodyFragment(String  bodyHtml,  String  baseUri)  {  [BUGGY]  Parser  parser  =  new  Parser  (baseUri,  true  )  ;  return  parser.parse();  }        [CLASS]  Parser    [METHOD]  parseBodyFragment  [RETURN_TYPE]  Document      String  bodyHtml  String  baseUri  [VARIABLES]  TokenQueue    tq    boolean    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    Parser    parser    
Parser  parser  =  new  Parser  (  bodyHtml,  baseUri,  true  )  ;	[BUGGY]  Parser  parser  =  new  Parser(  bodyHtml,    true);  [CONTEXT]  public  static  Document  parseBodyFragment(String  bodyHtml,  String  baseUri)  {  [BUGGY]  Parser  parser  =  new  Parser  (  bodyHtml,true  )  ;  return  parser.parse();  }        [CLASS]  Parser    [METHOD]  parseBodyFragment  [RETURN_TYPE]  Document      String  bodyHtml  String  baseUri  [VARIABLES]  TokenQueue    tq    boolean    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    Parser    parser    
Parser  parser  =  new  Parser  (  bodyHtml,  baseUri,  true  )  ;	[BUGGY]  Parser  parser  =  new  Parser(  html,  baseUri,  true);  [CONTEXT]  public  static  Document  parseBodyFragment(String  bodyHtml,  String  baseUri)  {  [BUGGY]  Parser  parser  =  new  Parser  (  html,  baseUri,  true  )  ;  return  parser.parse();  }        [CLASS]  Parser    [METHOD]  parseBodyFragment  [RETURN_TYPE]  Document      String  bodyHtml  String  baseUri  [VARIABLES]  TokenQueue    tq    boolean    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    Parser    parser    
Parser  parser  =  new  Parser  (  bodyHtml,  baseUri,  true  )  ;	[BUGGY]  Parser  parser  =  new  Parser(  bodyHtml,  html,  true);  [CONTEXT]  public  static  Document  parseBodyFragment(String  bodyHtml,  String  baseUri)  {  [BUGGY]  Parser  parser  =  new  Parser  (  bodyHtml,  html,  true  )  ;  return  parser.parse();  }        [CLASS]  Parser    [METHOD]  parseBodyFragment  [RETURN_TYPE]  Document      String  bodyHtml  String  baseUri  [VARIABLES]  TokenQueue    tq    boolean    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    Parser    parser    
Parser  parser  =  new  Parser  (  bodyHtml,  baseUri,  true  )  ;	[BUGGY]  Parser  parser  =  new  Parser(  baseUri,  bodyHtml,  true);  [CONTEXT]  public  static  Document  parseBodyFragment(String  bodyHtml,  String  baseUri)  {  [BUGGY]  Parser  parser  =  new  Parser  (  baseUri,  bodyHtml,  true  )  ;  return  parser.parse();  }        [CLASS]  Parser    [METHOD]  parseBodyFragment  [RETURN_TYPE]  Document      String  bodyHtml  String  baseUri  [VARIABLES]  TokenQueue    tq    boolean    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    Parser    parser    
Parser  parser  =  new  Parser  (  bodyHtml,  baseUri,  true  )  ;	[BUGGY]    Parser  parser  =  new  Parser(  bodyHtml,  baseUri,  true);  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseBodyFragment  [RETURN_TYPE]  Document      String  bodyHtml  String  baseUri  [VARIABLES]  TokenQueue    tq    boolean    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    Parser    parser    
Parser  parser  =  new  Parser  (  bodyHtml,  baseUri,  true  )  ;	[BUGGY]  Parser  parser  =  new  Parser(  html,  baseUri,  false);Parser  parser  =  new  Parser(  bodyHtml,  baseUri,  true);  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseBodyFragment  [RETURN_TYPE]  Document      String  bodyHtml  String  baseUri  [VARIABLES]  TokenQueue    tq    boolean    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    Parser    parser    
return  parser.parse  (  )  ;	[BUGGY]  return  parser.popStackToClose(  );  [CONTEXT]  public  static  Document  parseBodyFragment(String  bodyHtml,  String  baseUri)  {  Parser  parser  =  new  Parser(bodyHtml,  baseUri,  true);  [BUGGY]  return  parser.popStackToClose  ()  ;  }        [CLASS]  Parser    [METHOD]  parseBodyFragment  [RETURN_TYPE]  Document      String  bodyHtml  String  baseUri  [VARIABLES]  TokenQueue    tq    boolean    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    Parser    parser    
return  parser.parse  (  )  ;	[BUGGY]  return  parser  .parse(  baseUri  ,  html)  ;  [CONTEXT]  public  static  Document  parseBodyFragment(String  bodyHtml,  String  baseUri)  {  Parser  parser  =  new  Parser(bodyHtml,  baseUri,  true);  [BUGGY]  return  parser  .parse  (  baseUri  ,  html  );  }        [CLASS]  Parser    [METHOD]  parseBodyFragment  [RETURN_TYPE]  Document      String  bodyHtml  String  baseUri  [VARIABLES]  TokenQueue    tq    boolean    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    Parser    parser    
return  parser.parse  (  )  ;	[BUGGY]    [CONTEXT]  public  static  Document  parseBodyFragment(String  bodyHtml,  String  baseUri)  {  Parser  parser  =  new  Parser(bodyHtml,  baseUri,  true);  [BUGGY]  return  parser.parse();          [CLASS]  Parser    [METHOD]  parseBodyFragment  [RETURN_TYPE]  Document      String  bodyHtml  String  baseUri  [VARIABLES]  TokenQueue    tq    boolean    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    Parser    parser    
while  (  !tq.isEmpty  (  )  )  {	[BUGGY]  while  (  !tq.chompTo(  ))  {  [CONTEXT]  private  Document  parse()  {  [BUGGY]  while(  !tq.chompTo  ()){  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
if  (  tq.matches  (   "<!-- "  )  )  {	[BUGGY]  if  (  tq.matchChomp(   "<!-- "))  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  [BUGGY]  if(  tq.matchChomp  (   "<!-- "  )){  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
if  (  tq.matches  (   "<!-- "  )  )  {	[BUGGY]  if  (  tq  .matchesAny(  bodyHtml  ,  bodyHtml  ,  DQ)  )  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  [BUGGY]  if(  tq  .matchesAny  (  bodyHtml  ,  bodyHtml  ,  DQ  )  ){  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
if  (  tq.matches  (   "<!-- "  )  )  {	[BUGGY]  if  (  tq  .matchesAny(  html  ,  bodyHtml  ,  DQ)  )  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  [BUGGY]  if(  tq  .matchesAny  (  html  ,  bodyHtml  ,  DQ  )  ){  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "<![CDATA[ "  )  )  {	[BUGGY]    else  if  (  tq.matches(   "<![CDATA![CDATA[ "))  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  [BUGGY]  }  else  if(  tq.matches  (   "<![CDATA![CDATA[ "  )){  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "<![CDATA[ "  )  )  {	[BUGGY]    else  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  [BUGGY]  }  else  {  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "<![CDATA[ "  )  )  {	[BUGGY]    else  if  (  tq.matchChomp(   "<![CDATA[ "))  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  [BUGGY]  }  else  if(  tq.matchChomp  (   "<![CDATA[ "  )){  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "<![CDATA[ "  )  )  {	[BUGGY]    else  if  (  tq  .matchesAny(  bodyHtml  ,  DQ  ,  html)  )  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  [BUGGY]  }  else  if(  tq  .matchesAny  (  bodyHtml  ,  DQ  ,  html  )  ){  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "<![CDATA[ "  )  )  {	[BUGGY]    else  if  (  tq  .matchesAny(  bodyHtml  ,  bodyHtml  ,  bodyHtml)  )  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  [BUGGY]  }  else  if(  tq  .matchesAny  (  bodyHtml  ,  bodyHtml  ,  bodyHtml  )  ){  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "<![CDATA[ "  )  )  {	[BUGGY]    else  if  (  tq.matches(   "< "))  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  [BUGGY]  }  else  if(  tq.matches  (   "< "  )){  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "<![CDATA[ "  )  )  {	[BUGGY]    else  if  (  tq.matches(   "</ "))  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  [BUGGY]  }  else  if(  tq.matches  (   "</ "  )){  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "<![CDATA[ "  )  )  {	[BUGGY]    else  if  (  tq.matchChomp(  DQ))  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  [BUGGY]  }  else  if(  tq.matchChomp  (  DQ  )){  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "<? "  )  ||  tq.matches  (   "<! "  )  )  {	[BUGGY]    else  if  (  tq.matches(   "<? ")  &&  tq.matches(   "<! "))  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  [BUGGY]  }  else  if(  tq.matches  (   "<? "  )&&  tq.matches  (   "<! "  )){  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "<? "  )  ||  tq.matches  (   "<! "  )  )  {	[BUGGY]    else  if  (  tq.matches(   "<? ")  ||  tq.matches(   "! "))  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  [BUGGY]  }  else  if(  tq.matches  (   "<? "  )||  tq.matches  (   "! "  )){  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "<? "  )  ||  tq.matches  (   "<! "  )  )  {	[BUGGY]    else  if  (  tq.matches(   "<? ")){  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  [BUGGY]  }  else  if(  tq.matches  (   "<? "  ))  {  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "<? "  )  ||  tq.matches  (   "<! "  )  )  {	[BUGGY]    else  if  (    tq.matches(   "<! "))  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  [BUGGY]  }  else  if(tq.matches  (   "<! "  )){  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "<? "  )  ||  tq.matches  (   "<! "  )  )  {	[BUGGY]    else  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  [BUGGY]  }  else  {  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "<? "  )  ||  tq.matches  (   "<! "  )  )  {	[BUGGY]    else  if  (  tq.matchChomp(   "<? ")  ||  tq.matches(   "<! "))  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  [BUGGY]  }  else  if(  tq.matchChomp  (   "<? "  )||  tq.matches  (   "<! "  )){  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "<? "  )  ||  tq.matches  (   "<! "  )  )  {	[BUGGY]      if  (  tq  .matchesAny(  baseUri  ,  SQ  ,  DQ)    ||  tq  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  [BUGGY]  }if(  tq  .matchesAny  (  baseUri  ,  SQ  ,  DQ  )  ||  tq  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "</ "  )  )  {	[BUGGY]    else  if  (  tq.matches(   "< "))  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  [BUGGY]  }  else  if(  tq.matches  (   "< "  )){  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "</ "  )  )  {	[BUGGY]    else  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  [BUGGY]  }  else  {  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "</ "  )  )  {	[BUGGY]    else  if  (  tq.matchChomp(   "</ "))  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  [BUGGY]  }  else  if(  tq.matchChomp  (   "</ "  )){  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "</ "  )  )  {	[BUGGY]    else  if  (  tq.matches(   "<![CDATA[ "))  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  [BUGGY]  }  else  if(  tq.matches  (   "<![CDATA[ "  )){  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "</ "  )  )  {	[BUGGY]    else  if  (  tq.matchChomp(  DQ))  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  [BUGGY]  }  else  if(  tq.matchChomp  (  DQ  )){  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "< "  )  )  {	[BUGGY]    else  if  (  tq.matches(   " "))  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  [BUGGY]  }  else  if(  tq.matches  (   " "  )){  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "< "  )  )  {	[BUGGY]    else  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  [BUGGY]  }  else  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "< "  )  )  {	[BUGGY]    else  if  (  tq.matchChomp(   "< "))  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  [BUGGY]  }  else  if(  tq.matchChomp  (   "< "  )){  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "< "  )  )  {	[BUGGY]    else  if  (  tq.matches(   "<![CDATA[ "))  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  [BUGGY]  }  else  if(  tq.matches  (   "<![CDATA[ "  )){  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "< "  )  )  {	[BUGGY]    else  if  (  tq.matches(   "</ "))  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  [BUGGY]  }  else  if(  tq.matches  (   "</ "  )){  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "< "  )  )  {	[BUGGY]    else  if  (  elTag.equals(  tag))  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  [BUGGY]  }  else  if(  elTag.equals  (  tag  )){  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "< "  )  )  {	[BUGGY]    else  if  (  tq.matchChomp(  DQ))  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  [BUGGY]  }  else  if(  tq.matchChomp  (  DQ  )){  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "< "  )  )  {  parseStartTag  (  )  ;  }  else  {  parseTextNode  (  )  ;  }	[BUGGY]  parseStartTag();  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  [BUGGY]  }  else  if  (tq.matches( "< "))  {    parseStartTag();        }  return  doc.normalise();        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "< "  )  )  {  parseStartTag  (  )  ;  }  else  {  parseTextNode  (  )  ;  }	[BUGGY]    [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  [BUGGY]  }  else  if  (tq.matches( "< "))  {            }  return  doc.normalise();        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
[Delete]	[BUGGY]  if  (  tq.matches(   "</ "))  {          parseEndTag(  );  }else          if  (  tq.matches(   "< "))  {                  parseStartTag(  );          }else  {                  parseTextNode(  );          }  [CONTEXT]        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
[Delete]	[BUGGY]  if  (  tq.matchChomp(   "/> "))  {          isEmptyElement  =  true;  }else  {          tq.matchChomp(   "> ");  }  [CONTEXT]        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
parseTextNode  (  )  ;	[BUGGY]  parseAttribute(  );  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  [BUGGY]  parseAttribute  ()  ;  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
parseTextNode  (  )  ;	[BUGGY]    [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  [BUGGY]  parseTextNode();    }  }  return  doc.normalise();        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
parseStartTag  (  )  ;	[BUGGY]  parseCdata(  );  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  }  else  if  (tq.matches( "< "))  {  [BUGGY]  parseCdata  ()  ;  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
parseStartTag  (  )  ;	[BUGGY]    [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  }  else  if  (tq.matches( "< "))  {  [BUGGY]  parseStartTag();    }  else  {  parseTextNode();  }  }  return  doc.normalise();        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
parseEndTag  (  )  ;	[BUGGY]  parseCdata(  );  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  [BUGGY]  parseCdata  ()  ;  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
parseEndTag  (  )  ;	[BUGGY]    [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  [BUGGY]  parseEndTag();    }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "< "  )  )  {	[BUGGY]      if  (  tq.matchChomp(   "< "))  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  [BUGGY]  }if(  tq.matchChomp  (   "< "  )){  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
parseXmlDecl  (  )  ;	[BUGGY]  parseComment(  );  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  [BUGGY]  parseComment  ()  ;  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
parseXmlDecl  (  )  ;	[BUGGY]    [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  [BUGGY]  parseXmlDecl();    }  else  if  (tq.matches( "</ "))  {  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "</ "  )  )  {	[BUGGY]    else  if  (  tq  .matchesAny(  DQ  ,  html  ,  html)  )  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  [BUGGY]  }  else  if(  tq  .matchesAny  (  DQ  ,  html  ,  html  )  ){  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "</ "  )  )  {	[BUGGY]      if  (  tq.matchChomp(   "</ "))  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  [BUGGY]  }if(  tq.matchChomp  (   "</ "  )){  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "< "  )  )  {	[BUGGY]      if  (  tq  .matchesAny(  DQ  ,  bodyHtml  ,  baseUri)  )  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  [BUGGY]  }if(  tq  .matchesAny  (  DQ  ,  bodyHtml  ,  baseUri  )  ){  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "<? "  )  ||  tq.matches  (   "<! "  )  )  {	[BUGGY]    else  if  (  tq  .matchesAny(  baseUri  ,  bodyHtml  ,  SQ)    ||  tq  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  [BUGGY]  }  else  if(  tq  .matchesAny  (  baseUri  ,  bodyHtml  ,  SQ  )  ||  tq  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "</ "  )  )  {	[BUGGY]    else  if  (  tq.matches(   "/ "))  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  [BUGGY]  }  else  if(  tq.matches  (   "/ "  )){  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
parseCdata  (  )  ;	[BUGGY]  parseEndTag(  );  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  [BUGGY]  parseEndTag  ()  ;  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
parseCdata  (  )  ;	[BUGGY]    [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  [BUGGY]  parseCdata();    }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "<? "  )  ||  tq.matches  (   "<! "  )  )  {	[BUGGY]    else  if  (  tq.matches(   "<?< ")  ||  tq.matches(   "<! "))  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  [BUGGY]  }  else  if(  tq.matches  (   "<?< "  )||  tq.matches  (   "<! "  )){  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "<? "  )  ||  tq.matches  (   "<! "  )  )  {	[BUGGY]    else  if  (  tq  .matchesAny(  html  ,  html  ,  SQ)    ||  tq  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  [BUGGY]  }  else  if(  tq  .matchesAny  (  html  ,  html  ,  SQ  )  ||  tq  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "<? "  )  ||  tq.matches  (   "<! "  )  )  {	[BUGGY]    else  if  (  tq  .matchesAny(  baseUri  ,  bodyHtml  ,  DQ)    ||  tq  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  [BUGGY]  }  else  if(  tq  .matchesAny  (  baseUri  ,  bodyHtml  ,  DQ  )  ||  tq  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "< "  )  )  {	[BUGGY]    else  if  (  tq  .matchesAny(  html  ,  bodyHtml  ,  SQ)  )  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  [BUGGY]  }  else  if(  tq  .matchesAny  (  html  ,  bodyHtml  ,  SQ  )  ){  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "</ "  )  )  {	[BUGGY]    else  if  (  tq.matches(   " "))  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  [BUGGY]  }  else  if(  tq.matches  (   " "  )){  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "</ "  )  )  {	[BUGGY]    else  if  (  tq  .matchesAny(  html  ,  SQ  ,  SQ)  )  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  [BUGGY]  }  else  if(  tq  .matchesAny  (  html  ,  SQ  ,  SQ  )  ){  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "< "  )  )  {	[BUGGY]    else  if  (  tq  .matchesAny(  baseUri  ,  html  ,  html)  )  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  [BUGGY]  }  else  if(  tq  .matchesAny  (  baseUri  ,  html  ,  html  )  ){  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "<![CDATA[ "  )  )  {	[BUGGY]    else  if  (  tq.matches(   "A "))  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  [BUGGY]  }  else  if(  tq.matches  (   "A "  )){  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "<![CDATA[ "  )  )  {	[BUGGY]    else  if  (  tq  .matchesAny(  SQ  ,  bodyHtml  ,  html)  )  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  [BUGGY]  }  else  if(  tq  .matchesAny  (  SQ  ,  bodyHtml  ,  html  )  ){  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "<? "  )  ||  tq.matches  (   "<! "  )  )  {	[BUGGY]    else  if  (  tq.matches(   "< ")  ||  tq.matches(   "<! "))  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  [BUGGY]  }  else  if(  tq.matches  (   "< "  )||  tq.matches  (   "<! "  )){  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "<? "  )  ||  tq.matches  (   "<! "  )  )  {	[BUGGY]    else  if  (  tq  .matchesAny(  SQ  ,  baseUri  ,  bodyHtml)    ||  tq  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  [BUGGY]  }  else  if(  tq  .matchesAny  (  SQ  ,  baseUri  ,  bodyHtml  )  ||  tq  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "< "  )  )  {	[BUGGY]    else  if  (  tq  .matchesAny(  DQ  ,  html  ,  baseUri)  )  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  [BUGGY]  }  else  if(  tq  .matchesAny  (  DQ  ,  html  ,  baseUri  )  ){  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "< "  )  )  {	[BUGGY]    else  if  (  tq  .matchesAny(  SQ  ,  baseUri  ,  baseUri)  )  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  [BUGGY]  }  else  if(  tq  .matchesAny  (  SQ  ,  baseUri  ,  baseUri  )  ){  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
parseComment  (  )  ;	[BUGGY]  parseCdata(  );  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  [BUGGY]  parseCdata  ()  ;  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
parseComment  (  )  ;	[BUGGY]    [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  [BUGGY]  parseComment();    }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "<![CDATA[ "  )  )  {	[BUGGY]    else  if  (  tq  .matchesAny(  DQ  ,  DQ  ,  DQ)  )  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  [BUGGY]  }  else  if(  tq  .matchesAny  (  DQ  ,  DQ  ,  DQ  )  ){  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "<![CDATA[ "  )  )  {	[BUGGY]    else  if  (  tq  .matchesAny(  html  ,  bodyHtml  ,  SQ)  )  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  [BUGGY]  }  else  if(  tq  .matchesAny  (  html  ,  bodyHtml  ,  SQ  )  ){  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "<![CDATA[ "  )  )  {	[BUGGY]    else  if  (  tq  .matchesAny(  DQ  ,  DQ  ,  bodyHtml)  )  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  [BUGGY]  }  else  if(  tq  .matchesAny  (  DQ  ,  DQ  ,  bodyHtml  )  ){  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "<? "  )  ||  tq.matches  (   "<! "  )  )  {	[BUGGY]    else  if  (  tq.matches(   "<? ")  ||  tq.matches(   "< "))  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  [BUGGY]  }  else  if(  tq.matches  (   "<? "  )||  tq.matches  (   "< "  )){  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "<? "  )  ||  tq.matches  (   "<! "  )  )  {	[BUGGY]    else  if  (  tq  .matchesAny(  baseUri  ,  bodyHtml  ,  bodyHtml)    ||  tq  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  [BUGGY]  }  else  if(  tq  .matchesAny  (  baseUri  ,  bodyHtml  ,  bodyHtml  )  ||  tq  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "<? "  )  ||  tq.matches  (   "<! "  )  )  {	[BUGGY]    else  if  (  tq  .matchesAny(  bodyHtml  ,  SQ  ,  html)    ||  tq  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  [BUGGY]  }  else  if(  tq  .matchesAny  (  bodyHtml  ,  SQ  ,  html  )  ||  tq  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "<? "  )  ||  tq.matches  (   "<! "  )  )  {	[BUGGY]      if  (  tq.matchChomp(   "<? ")){  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  [BUGGY]  }if(  tq.matchChomp  (   "<? "  ))  {  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "< "  )  )  {	[BUGGY]    else  if  (  tq  .matchesAny(  DQ  ,  html  ,  bodyHtml)  )  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  [BUGGY]  }  else  if(  tq  .matchesAny  (  DQ  ,  html  ,  bodyHtml  )  ){  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "< "  )  )  {	[BUGGY]    else  if  (  tq  .matchesAny(  baseUri  ,  html  ,  SQ)  )  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  [BUGGY]  }  else  if(  tq  .matchesAny  (  baseUri  ,  html  ,  SQ  )  ){  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "</ "  )  )  {	[BUGGY]    else  if  (  tq.matches(   "</< "))  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  [BUGGY]  }  else  if(  tq.matches  (   "</< "  )){  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "< "  )  )  {	[BUGGY]    else  if  (  tq  .matchesAny(  DQ  ,  baseUri  ,  html)  )  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  [BUGGY]  }  else  if(  tq  .matchesAny  (  DQ  ,  baseUri  ,  html  )  ){  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "< "  )  )  {	[BUGGY]    else  if  (  tq  .matchesAny(  baseUri  ,  SQ  ,  baseUri)  )  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  [BUGGY]  }  else  if(  tq  .matchesAny  (  baseUri  ,  SQ  ,  baseUri  )  ){  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "<? "  )  ||  tq.matches  (   "<! "  )  )  {	[BUGGY]    else  if  (  tq.matches(   "<? ")  ||  tq.matches(   "<!< "))  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  [BUGGY]  }  else  if(  tq.matches  (   "<? "  )||  tq.matches  (   "<!< "  )){  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "</ "  )  )  {	[BUGGY]    else  if  (  tq  .matchesAny(  baseUri  ,  DQ  ,  DQ)  )  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  [BUGGY]  }  else  if(  tq  .matchesAny  (  baseUri  ,  DQ  ,  DQ  )  ){  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "< "  )  )  {	[BUGGY]    else  if  (  tq  .matchesAny(  DQ  ,  DQ  ,  html)  )  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  [BUGGY]  }  else  if(  tq  .matchesAny  (  DQ  ,  DQ  ,  html  )  ){  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "< "  )  )  {	[BUGGY]    else  if  (  tq  .matchesAny(  baseUri  ,  baseUri  ,  SQ)  )  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  [BUGGY]  }  else  if(  tq  .matchesAny  (  baseUri  ,  baseUri  ,  SQ  )  ){  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "< "  )  )  {	[BUGGY]      if  (  tq  .matchesAny(  DQ  ,  DQ  ,  html)  )  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  [BUGGY]  }if(  tq  .matchesAny  (  DQ  ,  DQ  ,  html  )  ){  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "</ "  )  )  {	[BUGGY]    else  if  (  tq  .matchesAny(  SQ  ,  bodyHtml  ,  SQ)  )  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  [BUGGY]  }  else  if(  tq  .matchesAny  (  SQ  ,  bodyHtml  ,  SQ  )  ){  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "< "  )  )  {	[BUGGY]    else  if  (  tq  .matchesAny(  DQ  ,  DQ  ,  DQ)  )  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  [BUGGY]  }  else  if(  tq  .matchesAny  (  DQ  ,  DQ  ,  DQ  )  ){  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "<![CDATA[ "  )  )  {	[BUGGY]    else  if  (  tq.matches(   "<![![CDATA[ "))  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  [BUGGY]  }  else  if(  tq.matches  (   "<![![CDATA[ "  )){  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "<![CDATA[ "  )  )  {	[BUGGY]    else  if  (  tq  .matchesAny(  bodyHtml  ,  baseUri  ,  SQ)  )  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  [BUGGY]  }  else  if(  tq  .matchesAny  (  bodyHtml  ,  baseUri  ,  SQ  )  ){  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "<? "  )  ||  tq.matches  (   "<! "  )  )  {	[BUGGY]    else  if  (  tq.matches(   " ")  ||  tq.matches(   "<! "))  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  [BUGGY]  }  else  if(  tq.matches  (   " "  )||  tq.matches  (   "<! "  )){  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "<? "  )  ||  tq.matches  (   "<! "  )  )  {	[BUGGY]    else  if  (  tq  .matchesAny(  html  ,  bodyHtml  ,  DQ)    ||  tq  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  [BUGGY]  }  else  if(  tq  .matchesAny  (  html  ,  bodyHtml  ,  DQ  )  ||  tq  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "<? "  )  ||  tq.matches  (   "<! "  )  )  {	[BUGGY]    else  if  (  tq.matches(   "<? ")  ||  tq.matches(   " "))  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  [BUGGY]  }  else  if(  tq.matches  (   "<? "  )||  tq.matches  (   " "  )){  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "< "  )  )  {	[BUGGY]    else  if  (  tq  .matchesAny(  baseUri  ,  bodyHtml  ,  DQ)  )  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  [BUGGY]  }  else  if(  tq  .matchesAny  (  baseUri  ,  bodyHtml  ,  DQ  )  ){  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
if  (  tq.matches  (   "<!-- "  )  )  {	[BUGGY]  if  (  tq.matches(   "<! "))  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  [BUGGY]  if(  tq.matches  (   "<! "  )){  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
if  (  tq.matches  (   "<!-- "  )  )  {	[BUGGY]  if  (  tq  .matchesAny(  html  ,  bodyHtml  ,  html)  )  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  [BUGGY]  if(  tq  .matchesAny  (  html  ,  bodyHtml  ,  html  )  ){  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "<![CDATA[ "  )  )  {	[BUGGY]    else  if  (  tq.matches(   "CDATA![CDATA[ "))  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  [BUGGY]  }  else  if(  tq.matches  (   "CDATA![CDATA[ "  )){  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "<![CDATA[ "  )  )  {	[BUGGY]    else  if  (  tq  .matchesAny(  bodyHtml  ,  html  ,  DQ)  )  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  [BUGGY]  }  else  if(  tq  .matchesAny  (  bodyHtml  ,  html  ,  DQ  )  ){  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "<![CDATA[ "  )  )  {	[BUGGY]    else  if  (  tq  .matchesAny(  html  ,  bodyHtml  ,  baseUri)  )  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  [BUGGY]  }  else  if(  tq  .matchesAny  (  html  ,  bodyHtml  ,  baseUri  )  ){  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "<? "  )  ||  tq.matches  (   "<! "  )  )  {	[BUGGY]    else  if  (  tq  .matchesAny(  SQ  ,  html  ,  SQ)    ||  tq  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  [BUGGY]  }  else  if(  tq  .matchesAny  (  SQ  ,  html  ,  SQ  )  ||  tq  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "< "  )  )  {	[BUGGY]    else  if  (  tq  .matchesAny(  SQ  ,  bodyHtml  ,  baseUri)  )  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  [BUGGY]  }  else  if(  tq  .matchesAny  (  SQ  ,  bodyHtml  ,  baseUri  )  ){  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "</ "  )  )  {	[BUGGY]    else  if  (  tq  .matchesAny(  baseUri  ,  baseUri  ,  DQ)  )  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  [BUGGY]  }  else  if(  tq  .matchesAny  (  baseUri  ,  baseUri  ,  DQ  )  ){  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "</ "  )  )  {	[BUGGY]    else  if  (  tq  .matchesAny(  SQ  ,  SQ  ,  SQ)  )  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  [BUGGY]  }  else  if(  tq  .matchesAny  (  SQ  ,  SQ  ,  SQ  )  ){  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "<? "  )  ||  tq.matches  (   "<! "  )  )  {	[BUGGY]    else  if  (  tq  .matchesAny(  baseUri  ,  SQ  ,  bodyHtml)    ||  tq  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  [BUGGY]  }  else  if(  tq  .matchesAny  (  baseUri  ,  SQ  ,  bodyHtml  )  ||  tq  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "<? "  )  ||  tq.matches  (   "<! "  )  )  {	[BUGGY]    else  if  (  tq  .matchesAny(  html  ,  baseUri  ,  html)    ||  tq  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  [BUGGY]  }  else  if(  tq  .matchesAny  (  html  ,  baseUri  ,  html  )  ||  tq  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "<? "  )  ||  tq.matches  (   "<! "  )  )  {	[BUGGY]    else  if  (  tq  .matchesAny(  DQ  ,  bodyHtml  ,  baseUri)    ||  tq  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  [BUGGY]  }  else  if(  tq  .matchesAny  (  DQ  ,  bodyHtml  ,  baseUri  )  ||  tq  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "</ "  )  )  {	[BUGGY]    else  if  (  tq  .matchesAny(  SQ  ,  baseUri  ,  html)  )  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  [BUGGY]  }  else  if(  tq  .matchesAny  (  SQ  ,  baseUri  ,  html  )  ){  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "< "  )  )  {	[BUGGY]    else  if  (  tq  .matchesAny(  SQ  ,  baseUri  ,  DQ)  )  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  [BUGGY]  }  else  if(  tq  .matchesAny  (  SQ  ,  baseUri  ,  DQ  )  ){  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "< "  )  )  {	[BUGGY]    else  if  (  tq  .matchesAny(  DQ  ,  baseUri  ,  baseUri)  )  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  [BUGGY]  }  else  if(  tq  .matchesAny  (  DQ  ,  baseUri  ,  baseUri  )  ){  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "< "  )  )  {	[BUGGY]    else  if  (  tq  .matchesAny(  html  ,  baseUri  ,  SQ)  )  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  [BUGGY]  }  else  if(  tq  .matchesAny  (  html  ,  baseUri  ,  SQ  )  ){  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "<![CDATA[ "  )  )  {	[BUGGY]    else  if  (  tq  .matchesAny(  SQ  ,  bodyHtml  ,  bodyHtml)  )  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  [BUGGY]  }  else  if(  tq  .matchesAny  (  SQ  ,  bodyHtml  ,  bodyHtml  )  ){  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "<![CDATA[ "  )  )  {	[BUGGY]    else  if  (  tq  .matchesAny(  baseUri  ,  baseUri  ,  DQ)  )  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  [BUGGY]  }  else  if(  tq  .matchesAny  (  baseUri  ,  baseUri  ,  DQ  )  ){  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "<![CDATA[ "  )  )  {	[BUGGY]      if  (  tq.matchChomp(   "<![CDATA[ "))  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  [BUGGY]  }if(  tq.matchChomp  (   "<![CDATA[ "  )){  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "<? "  )  ||  tq.matches  (   "<! "  )  )  {	[BUGGY]    else  if  (  tq  .matchesAny(  bodyHtml  ,  SQ  ,  SQ)    ||  tq  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  [BUGGY]  }  else  if(  tq  .matchesAny  (  bodyHtml  ,  SQ  ,  SQ  )  ||  tq  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "<? "  )  ||  tq.matches  (   "<! "  )  )  {	[BUGGY]    else  if  (  tq  .matchesAny(  DQ  ,  DQ  ,  SQ)    ||  tq  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  [BUGGY]  }  else  if(  tq  .matchesAny  (  DQ  ,  DQ  ,  SQ  )  ||  tq  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "</ "  )  )  {	[BUGGY]      if  (  tq  .matchesAny(  SQ  ,  baseUri  ,  SQ)  )  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  [BUGGY]  }if(  tq  .matchesAny  (  SQ  ,  baseUri  ,  SQ  )  ){  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "< "  )  )  {	[BUGGY]    else  if  (  tq  .matchesAny(  SQ  ,  SQ  ,  SQ)  )  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  [BUGGY]  }  else  if(  tq  .matchesAny  (  SQ  ,  SQ  ,  SQ  )  ){  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "</ "  )  )  {	[BUGGY]    else  if  (  tq  .matchesAny(  baseUri  ,  bodyHtml  ,  bodyHtml)  )  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  [BUGGY]  }  else  if(  tq  .matchesAny  (  baseUri  ,  bodyHtml  ,  bodyHtml  )  ){  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "<? "  )  ||  tq.matches  (   "<! "  )  )  {	[BUGGY]    else  if  (  tq  .matchesAny(  baseUri  ,  baseUri  ,  DQ)    ||  tq  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  [BUGGY]  }  else  if(  tq  .matchesAny  (  baseUri  ,  baseUri  ,  DQ  )  ||  tq  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "< "  )  )  {	[BUGGY]    else  if  (  tq  .matchesAny(  baseUri  ,  html  ,  DQ)  )  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  [BUGGY]  }  else  if(  tq  .matchesAny  (  baseUri  ,  html  ,  DQ  )  ){  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "< "  )  )  {	[BUGGY]    else  if  (  tq  .matchesAny(  baseUri  ,  bodyHtml  ,  baseUri)  )  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  [BUGGY]  }  else  if(  tq  .matchesAny  (  baseUri  ,  bodyHtml  ,  baseUri  )  ){  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "<? "  )  ||  tq.matches  (   "<! "  )  )  {	[BUGGY]    else  if  (  tq  .matchesAny(  html  ,  baseUri  ,  SQ)    ||  tq  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  [BUGGY]  }  else  if(  tq  .matchesAny  (  html  ,  baseUri  ,  SQ  )  ||  tq  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "<? "  )  ||  tq.matches  (   "<! "  )  )  {	[BUGGY]      if  (  tq  .matchesAny(  html  ,  html  ,  html)    ||  tq  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  [BUGGY]  }if(  tq  .matchesAny  (  html  ,  html  ,  html  )  ||  tq  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "</ "  )  )  {	[BUGGY]    else  if  (  tq  .matchesAny(  baseUri  ,  html  ,  bodyHtml)  )  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  [BUGGY]  }  else  if(  tq  .matchesAny  (  baseUri  ,  html  ,  bodyHtml  )  ){  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "</ "  )  )  {	[BUGGY]    else  if  (  tq  .matchesAny(  html  ,  html  ,  SQ)  )  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  [BUGGY]  }  else  if(  tq  .matchesAny  (  html  ,  html  ,  SQ  )  ){  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "< "  )  )  {	[BUGGY]    else  if  (  tq  .matchesAny(  bodyHtml  ,  baseUri  ,  SQ)  )  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  [BUGGY]  }  else  if(  tq  .matchesAny  (  bodyHtml  ,  baseUri  ,  SQ  )  ){  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "</ "  )  )  {	[BUGGY]    else  if  (  tq  .matchesAny(  SQ  ,  baseUri  ,  bodyHtml)  )  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  [BUGGY]  }  else  if(  tq  .matchesAny  (  SQ  ,  baseUri  ,  bodyHtml  )  ){  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "< "  )  )  {	[BUGGY]    else  if  (  tq  .matchesAny(  baseUri  ,  baseUri  ,  baseUri)  )  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  [BUGGY]  }  else  if(  tq  .matchesAny  (  baseUri  ,  baseUri  ,  baseUri  )  ){  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
while  (  !tq.isEmpty  (  )  )  {  if  (  tq.matches  (   "<!-- "  )  )  {  parseComment  (  )  ;	[BUGGY]    [CONTEXT]  private  Document  parse()  {  [BUGGY]  while  (!tq.isEmpty())  {        }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
if  (  tq.matches  (   "<!-- "  )  )  {	[BUGGY]  if  (  tq.matches(   "<!--! "))  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  [BUGGY]  if(  tq.matches  (   "<!--! "  )){  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "<![CDATA[ "  )  )  {	[BUGGY]    else  if  (  tq  .matchesAny(  DQ  ,  DQ  ,  baseUri)  )  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  [BUGGY]  }  else  if(  tq  .matchesAny  (  DQ  ,  DQ  ,  baseUri  )  ){  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "<? "  )  ||  tq.matches  (   "<! "  )  )  {	[BUGGY]    else  if  (  tq.matches(   "? ")  ||  tq.matches(   "<! "))  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  [BUGGY]  }  else  if(  tq.matches  (   "? "  )||  tq.matches  (   "<! "  )){  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
}  else  if  (  tq.matches  (   "</ "  )  )  {	[BUGGY]    else  if  (  tq  .matchesAny(  SQ  ,  DQ  ,  SQ)  )  {  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  [BUGGY]  }  else  if(  tq  .matchesAny  (  SQ  ,  DQ  ,  SQ  )  ){  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  return  doc.normalise();  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
return  doc.normalise  (  )  ;	[BUGGY]  return  doc.body(  );  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  [BUGGY]  return  doc.body  ()  ;  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
return  doc.normalise  (  )  ;	[BUGGY]  return  doc  .createShell(  html)  ;  [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  [BUGGY]  return  doc  .createShell  (  html  );  }        [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
return  doc.normalise  (  )  ;	[BUGGY]    [CONTEXT]  private  Document  parse()  {  while  (!tq.isEmpty())  {  if  (tq.matches( "<!-- "))  {  parseComment();  }  else  if  (tq.matches( "<![CDATA[ "))  {  parseCdata();  }  else  if  (tq.matches( "<? ")  ||  tq.matches( "<! "))  {  parseXmlDecl();  }  else  if  (tq.matches( "</ "))  {  parseEndTag();  }  else  if  (tq.matches( "< "))  {  parseStartTag();  }  else  {  parseTextNode();  }  }  [BUGGY]  return  doc.normalise();          [CLASS]  Parser    [METHOD]  parse  [RETURN_TYPE]  Document      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
tq.consume  (   "<!-- "  )  ;	[BUGGY]  tq.consume(   "!- ");  [CONTEXT]  private  void  parseComment()  {  [BUGGY]  tq.consume  (   "!- "  )  ;  String  data  =  tq.chompTo( "-> ");    if  (data.endsWith( "- "))  //  i.e.  was  -->  data  =  data.substring(0,  data.length()-1);  Comment  comment  =  new  Comment(data,  baseUri);  last().appendChild(comment);  }        [CLASS]  Parser    [METHOD]  parseComment  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    Comment    comment    boolean    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.consume  (   "<!-- "  )  ;	[BUGGY]  tq.consumeTo(   "<!-- ");  [CONTEXT]  private  void  parseComment()  {  [BUGGY]  tq.consumeTo  (   "<!-- "  )  ;  String  data  =  tq.chompTo( "-> ");    if  (data.endsWith( "- "))  //  i.e.  was  -->  data  =  data.substring(0,  data.length()-1);  Comment  comment  =  new  Comment(data,  baseUri);  last().appendChild(comment);  }        [CLASS]  Parser    [METHOD]  parseComment  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    Comment    comment    boolean    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.consume  (   "<!-- "  )  ;	[BUGGY]  tq  .consumeTo(  data)  ;  [CONTEXT]  private  void  parseComment()  {  [BUGGY]  tq  .consumeTo  (  data  );  String  data  =  tq.chompTo( "-> ");    if  (data.endsWith( "- "))  //  i.e.  was  -->  data  =  data.substring(0,  data.length()-1);  Comment  comment  =  new  Comment(data,  baseUri);  last().appendChild(comment);  }        [CLASS]  Parser    [METHOD]  parseComment  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    Comment    comment    boolean    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.consume  (   "<!-- "  )  ;	[BUGGY]    [CONTEXT]  private  void  parseComment()  {  [BUGGY]  tq.consume( "<!-- ");    String  data  =  tq.chompTo( "-> ");    if  (data.endsWith( "- "))  //  i.e.  was  -->  data  =  data.substring(0,  data.length()-1);  Comment  comment  =  new  Comment(data,  baseUri);  last().appendChild(comment);        [CLASS]  Parser    [METHOD]  parseComment  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    Comment    comment    boolean    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.consume  (   "<!-- "  )  ;	[BUGGY]  tq.consumeWhitespace(  );tq.consume(   "<!-- ");  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseComment  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    Comment    comment    boolean    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.consume  (   "<!-- "  )  ;	[BUGGY]  tq.consume(  );tq.consume(   "<!-- ");  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseComment  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    Comment    comment    boolean    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.consume  (   "<!-- "  )  ;	[BUGGY]  tq.consume(   "</ ");tq.consume(   "<!-- ");  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseComment  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    Comment    comment    boolean    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.consume  (   "<!-- "  )  ;	[BUGGY]  tq.chompTo(   "> ");tq.consume(   "<!-- ");  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseComment  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    Comment    comment    boolean    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.consume  (   "<!-- "  )  ;	[BUGGY]  tq.consume(   "< ");tq.consume(   "<!-- ");  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseComment  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    Comment    comment    boolean    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.consume  (   "<!-- "  )  ;	[BUGGY]  tq.consume(   "<![CDATA[ ");tq.consume(   "<!-- ");  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseComment  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    Comment    comment    boolean    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
String  data  =  tq.chompTo  (   "-> "  )  ;	[BUGGY]  char  data  =  tq.chompTo(   "-> ");  [CONTEXT]  private  void  parseComment()  {  tq.consume( "<!-- ");  [BUGGY]  char  data  =  tq.chompTo  (   "-> "  )  ;    if  (data.endsWith( "- "))  //  i.e.  was  -->  data  =  data.substring(0,  data.length()-1);  Comment  comment  =  new  Comment(data,  baseUri);  last().appendChild(comment);  }        [CLASS]  Parser    [METHOD]  parseComment  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    Comment    comment    boolean    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
String  data  =  tq.chompTo  (   "-> "  )  ;	[BUGGY]  String  data  =  tq.chompTo(   "- ");  [CONTEXT]  private  void  parseComment()  {  tq.consume( "<!-- ");  [BUGGY]  String  data  =  tq.chompTo  (   "- "  )  ;    if  (data.endsWith( "- "))  //  i.e.  was  -->  data  =  data.substring(0,  data.length()-1);  Comment  comment  =  new  Comment(data,  baseUri);  last().appendChild(comment);  }        [CLASS]  Parser    [METHOD]  parseComment  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    Comment    comment    boolean    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
String  data  =  tq.chompTo  (   "-> "  )  ;	[BUGGY]  String  data  =  tq.consumeTo(   "-> ");  [CONTEXT]  private  void  parseComment()  {  tq.consume( "<!-- ");  [BUGGY]  String  data  =  tq.consumeTo  (   "-> "  )  ;    if  (data.endsWith( "- "))  //  i.e.  was  -->  data  =  data.substring(0,  data.length()-1);  Comment  comment  =  new  Comment(data,  baseUri);  last().appendChild(comment);  }        [CLASS]  Parser    [METHOD]  parseComment  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    Comment    comment    boolean    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
String  data  =  tq.chompTo  (   "-> "  )  ;	[BUGGY]  String  data  =  tq.chompTo(   "> ");  [CONTEXT]  private  void  parseComment()  {  tq.consume( "<!-- ");  [BUGGY]  String  data  =  tq.chompTo  (   "> "  )  ;    if  (data.endsWith( "- "))  //  i.e.  was  -->  data  =  data.substring(0,  data.length()-1);  Comment  comment  =  new  Comment(data,  baseUri);  last().appendChild(comment);  }        [CLASS]  Parser    [METHOD]  parseComment  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    Comment    comment    boolean    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
String  data  =  tq.chompTo  (   "-> "  )  ;	[BUGGY]    [CONTEXT]  private  void  parseComment()  {  tq.consume( "<!-- ");  [BUGGY]  String  data  =  tq.chompTo( "-> ");      if  (data.endsWith( "- "))  //  i.e.  was  -->  data  =  data.substring(0,  data.length()-1);  Comment  comment  =  new  Comment(data,  baseUri);  last().appendChild(comment);        [CLASS]  Parser    [METHOD]  parseComment  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    Comment    comment    boolean    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  data.endsWith  (   "- "  )  )  data  =  data.substring  (  0,  data.length  (  )  -1  )  ;	[BUGGY]  if  (  data.endsWith(   " "))data  =  data.substring(  0,  data.length(  )-1);  [CONTEXT]  private  void  parseComment()  {  tq.consume( "<!-- ");  String  data  =  tq.chompTo( "-> ");    [BUGGY]  if(  data.endsWith  (   " "  ))  data  =  data.substring  (  0,  data.length  ()  -1  )  ;    Comment  comment  =  new  Comment(data,  baseUri);  last().appendChild(comment);  }        [CLASS]  Parser    [METHOD]  parseComment  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    Comment    comment    boolean    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  data.endsWith  (   "- "  )  )  data  =  data.substring  (  0,  data.length  (  )  -1  )  ;	[BUGGY]  if  (  data.endsWith(   "- "))data  =  data.substring(  -8,  data.length(  )-1);  [CONTEXT]  private  void  parseComment()  {  tq.consume( "<!-- ");  String  data  =  tq.chompTo( "-> ");    [BUGGY]  if(  data.endsWith  (   "- "  ))  data  =  data.substring  (  -8,  data.length  ()  -1  )  ;    Comment  comment  =  new  Comment(data,  baseUri);  last().appendChild(comment);  }        [CLASS]  Parser    [METHOD]  parseComment  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    Comment    comment    boolean    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  data.endsWith  (   "- "  )  )  data  =  data.substring  (  0,  data.length  (  )  -1  )  ;	[BUGGY]  if  (  data.endsWith(   "- "))data  =  data.substring(  0,  data.length(  )-7);  [CONTEXT]  private  void  parseComment()  {  tq.consume( "<!-- ");  String  data  =  tq.chompTo( "-> ");    [BUGGY]  if(  data.endsWith  (   "- "  ))  data  =  data.substring  (  0,  data.length  ()  -7  )  ;    Comment  comment  =  new  Comment(data,  baseUri);  last().appendChild(comment);  }        [CLASS]  Parser    [METHOD]  parseComment  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    Comment    comment    boolean    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  data.endsWith  (   "- "  )  )  data  =  data.substring  (  0,  data.length  (  )  -1  )  ;	[BUGGY]  if  (  data.endsWith(   "- "))data  =  data.substring(  0,  data.length()  -  2  -1);  [CONTEXT]  private  void  parseComment()  {  tq.consume( "<!-- ");  String  data  =  tq.chompTo( "-> ");    [BUGGY]  if(  data.endsWith  (   "- "  ))  data  =  data.substring  (  0,  data.length()  -  2  -1  )  ;    Comment  comment  =  new  Comment(data,  baseUri);  last().appendChild(comment);  }        [CLASS]  Parser    [METHOD]  parseComment  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    Comment    comment    boolean    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  data.endsWith  (   "- "  )  )  data  =  data.substring  (  0,  data.length  (  )  -1  )  ;	[BUGGY]  if  (  html.endsWith(   "- "))data  =  data.substring(  0,  data.length(  )-1);  [CONTEXT]  private  void  parseComment()  {  tq.consume( "<!-- ");  String  data  =  tq.chompTo( "-> ");    [BUGGY]  if(  html.endsWith  (   "- "  ))  data  =  data.substring  (  0,  data.length  ()  -1  )  ;    Comment  comment  =  new  Comment(data,  baseUri);  last().appendChild(comment);  }        [CLASS]  Parser    [METHOD]  parseComment  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    Comment    comment    boolean    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  data.endsWith  (   "- "  )  )  data  =  data.substring  (  0,  data.length  (  )  -1  )  ;	[BUGGY]  if  (  data.endsWith(   "- "))data  =  data.substring(  0,  data.substring(  )-1);  [CONTEXT]  private  void  parseComment()  {  tq.consume( "<!-- ");  String  data  =  tq.chompTo( "-> ");    [BUGGY]  if(  data.endsWith  (   "- "  ))  data  =  data.substring  (  0,  data.substring  ()  -1  )  ;    Comment  comment  =  new  Comment(data,  baseUri);  last().appendChild(comment);  }        [CLASS]  Parser    [METHOD]  parseComment  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    Comment    comment    boolean    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  data.endsWith  (   "- "  )  )  data  =  data.substring  (  0,  data.length  (  )  -1  )  ;  Comment  comment  =  new  Comment  (  data,  baseUri  )  ;  last  (  )  .appendChild  (  comment  )  ;  }	[BUGGY]  data  =  data.substring(0,((data.length())  -  1));  [CONTEXT]  private  void  parseComment()  {  tq.consume( "<!-- ");  String  data  =  tq.chompTo( "-> ");    [BUGGY]  if  (data.endsWith( "- "))  //  i.e.  was  -->    data  =  data.substring(0,  ((data.length())  -  1));            [CLASS]  Parser    [METHOD]  parseComment  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    Comment    comment    boolean    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  data.endsWith  (   "- "  )  )  data  =  data.substring  (  0,  data.length  (  )  -1  )  ;  Comment  comment  =  new  Comment  (  data,  baseUri  )  ;  last  (  )  .appendChild  (  comment  )  ;  }	[BUGGY]    [CONTEXT]  private  void  parseComment()  {  tq.consume( "<!-- ");  String  data  =  tq.chompTo( "-> ");    [BUGGY]  if  (data.endsWith( "- "))  //  i.e.  was  -->                [CLASS]  Parser    [METHOD]  parseComment  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    Comment    comment    boolean    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
data  =  data.substring  (  0,  data.length  (  )  -1  )  ;	[BUGGY]  data  =  data.substring(  0,  data.length(  )-);  [CONTEXT]  private  void  parseComment()  {  tq.consume( "<!-- ");  String  data  =  tq.chompTo( "-> ");    if  (data.endsWith( "- "))  //  i.e.  was  -->  [BUGGY]  data  =  data.substring  (  0,  data.length  ()  -  )  ;  Comment  comment  =  new  Comment(data,  baseUri);  last().appendChild(comment);  }        [CLASS]  Parser    [METHOD]  parseComment  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    Comment    comment    boolean    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
data  =  data.substring  (  0,  data.length  (  )  -1  )  ;	[BUGGY]  data  =  data.substring(  0,  data.length()  -  6  -1);  [CONTEXT]  private  void  parseComment()  {  tq.consume( "<!-- ");  String  data  =  tq.chompTo( "-> ");    if  (data.endsWith( "- "))  //  i.e.  was  -->  [BUGGY]  data  =  data.substring  (  0,  data.length()  -  6  -1  )  ;  Comment  comment  =  new  Comment(data,  baseUri);  last().appendChild(comment);  }        [CLASS]  Parser    [METHOD]  parseComment  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    Comment    comment    boolean    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
data  =  data.substring  (  0,  data.length  (  )  -1  )  ;	[BUGGY]  data  =  html.substring(  0,  data.length(  )-1);  [CONTEXT]  private  void  parseComment()  {  tq.consume( "<!-- ");  String  data  =  tq.chompTo( "-> ");    if  (data.endsWith( "- "))  //  i.e.  was  -->  [BUGGY]  data  =  html.substring  (  0,  data.length  ()  -1  )  ;  Comment  comment  =  new  Comment(data,  baseUri);  last().appendChild(comment);  }        [CLASS]  Parser    [METHOD]  parseComment  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    Comment    comment    boolean    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
data  =  data.substring  (  0,  data.length  (  )  -1  )  ;	[BUGGY]  data  =  data.substring(  0,  data.substring(  )-1);  [CONTEXT]  private  void  parseComment()  {  tq.consume( "<!-- ");  String  data  =  tq.chompTo( "-> ");    if  (data.endsWith( "- "))  //  i.e.  was  -->  [BUGGY]  data  =  data.substring  (  0,  data.substring  ()  -1  )  ;  Comment  comment  =  new  Comment(data,  baseUri);  last().appendChild(comment);  }        [CLASS]  Parser    [METHOD]  parseComment  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    Comment    comment    boolean    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
data  =  data.substring  (  0,  data.length  (  )  -1  )  ;	[BUGGY]  data  =  data.substring(  0,  data  .endsWith(  SQ)  -1);  [CONTEXT]  private  void  parseComment()  {  tq.consume( "<!-- ");  String  data  =  tq.chompTo( "-> ");    if  (data.endsWith( "- "))  //  i.e.  was  -->  [BUGGY]  data  =  data.substring  (  0,  data  .endsWith  (  SQ  )-1  )  ;  Comment  comment  =  new  Comment(data,  baseUri);  last().appendChild(comment);  }        [CLASS]  Parser    [METHOD]  parseComment  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    Comment    comment    boolean    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
data  =  data.substring  (  0,  data.length  (  )  -1  )  ;	[BUGGY]  data  =  data.substring(  0  ,  data.length(  )-1);  [CONTEXT]  private  void  parseComment()  {  tq.consume( "<!-- ");  String  data  =  tq.chompTo( "-> ");    if  (data.endsWith( "- "))  //  i.e.  was  -->  [BUGGY]  data  =  data.substring  (  0  ,  data.length  ()  -1  )  ;  Comment  comment  =  new  Comment(data,  baseUri);  last().appendChild(comment);  }        [CLASS]  Parser    [METHOD]  parseComment  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    Comment    comment    boolean    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
data  =  data.substring  (  0,  data.length  (  )  -1  )  ;	[BUGGY]  data  =  data.substring(  0,  data.length()  +  8  -1);  [CONTEXT]  private  void  parseComment()  {  tq.consume( "<!-- ");  String  data  =  tq.chompTo( "-> ");    if  (data.endsWith( "- "))  //  i.e.  was  -->  [BUGGY]  data  =  data.substring  (  0,  data.length()  +  8  -1  )  ;  Comment  comment  =  new  Comment(data,  baseUri);  last().appendChild(comment);  }        [CLASS]  Parser    [METHOD]  parseComment  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    Comment    comment    boolean    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
data  =  data.substring  (  0,  data.length  (  )  -1  )  ;	[BUGGY]    [CONTEXT]  private  void  parseComment()  {  tq.consume( "<!-- ");  String  data  =  tq.chompTo( "-> ");    if  (data.endsWith( "- "))  //  i.e.  was  -->  [BUGGY]  data  =  data.substring(0,  data.length()-1);    Comment  comment  =  new  Comment(data,  baseUri);  last().appendChild(comment);        [CLASS]  Parser    [METHOD]  parseComment  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    Comment    comment    boolean    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
data  =  data.substring  (  0,  data.length  (  )  -1  )  ;	[BUGGY]  data  =  bodyHtml.substring(  0,  data.length(  )-1);  [CONTEXT]  private  void  parseComment()  {  tq.consume( "<!-- ");  String  data  =  tq.chompTo( "-> ");    if  (data.endsWith( "- "))  //  i.e.  was  -->  [BUGGY]  data  =  bodyHtml.substring  (  0,  data.length  ()  -1  )  ;  Comment  comment  =  new  Comment(data,  baseUri);  last().appendChild(comment);  }        [CLASS]  Parser    [METHOD]  parseComment  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    Comment    comment    boolean    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
data  =  data.substring  (  0,  data.length  (  )  -1  )  ;	[BUGGY]  data  =  data.substring(  1,  data.length(  )-1);  [CONTEXT]  private  void  parseComment()  {  tq.consume( "<!-- ");  String  data  =  tq.chompTo( "-> ");    if  (data.endsWith( "- "))  //  i.e.  was  -->  [BUGGY]  data  =  data.substring  (  1,  data.length  ()  -1  )  ;  Comment  comment  =  new  Comment(data,  baseUri);  last().appendChild(comment);  }        [CLASS]  Parser    [METHOD]  parseComment  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    Comment    comment    boolean    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
data  =  data.substring  (  0,  data.length  (  )  -1  )  ;	[BUGGY]  data  =  data.substring(  0,  data.length(  )--5);  [CONTEXT]  private  void  parseComment()  {  tq.consume( "<!-- ");  String  data  =  tq.chompTo( "-> ");    if  (data.endsWith( "- "))  //  i.e.  was  -->  [BUGGY]  data  =  data.substring  (  0,  data.length  ()  --5  )  ;  Comment  comment  =  new  Comment(data,  baseUri);  last().appendChild(comment);  }        [CLASS]  Parser    [METHOD]  parseComment  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    Comment    comment    boolean    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
data  =  data.substring  (  0,  data.length  (  )  -1  )  ;	[BUGGY]  data  =  data.substring(  0,  data.length()  -  3  -1);  [CONTEXT]  private  void  parseComment()  {  tq.consume( "<!-- ");  String  data  =  tq.chompTo( "-> ");    if  (data.endsWith( "- "))  //  i.e.  was  -->  [BUGGY]  data  =  data.substring  (  0,  data.length()  -  3  -1  )  ;  Comment  comment  =  new  Comment(data,  baseUri);  last().appendChild(comment);  }        [CLASS]  Parser    [METHOD]  parseComment  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    Comment    comment    boolean    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
data  =  data.substring  (  0,  data.length  (  )  -1  )  ;	[BUGGY]  data  =  data  .endsWith(  baseUri)  ;  [CONTEXT]  private  void  parseComment()  {  tq.consume( "<!-- ");  String  data  =  tq.chompTo( "-> ");    if  (data.endsWith( "- "))  //  i.e.  was  -->  [BUGGY]  data  =  data  .endsWith  (  baseUri  );  Comment  comment  =  new  Comment(data,  baseUri);  last().appendChild(comment);  }        [CLASS]  Parser    [METHOD]  parseComment  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    Comment    comment    boolean    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  data.endsWith  (   "- "  )  )  data  =  data.substring  (  0,  data.length  (  )  -1  )  ;	[BUGGY]  if  (  data.endsWith(   "- "))data  =  data.substring(  0,  data.length()  +  6  -1);  [CONTEXT]  private  void  parseComment()  {  tq.consume( "<!-- ");  String  data  =  tq.chompTo( "-> ");    [BUGGY]  if(  data.endsWith  (   "- "  ))  data  =  data.substring  (  0,  data.length()  +  6  -1  )  ;    Comment  comment  =  new  Comment(data,  baseUri);  last().appendChild(comment);  }        [CLASS]  Parser    [METHOD]  parseComment  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    Comment    comment    boolean    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  data.endsWith  (   "- "  )  )  data  =  data.substring  (  0,  data.length  (  )  -1  )  ;	[BUGGY]  if  (  bodyHtml.endsWith(   "- "))data  =  data.substring(  0,  data.length(  )-1);  [CONTEXT]  private  void  parseComment()  {  tq.consume( "<!-- ");  String  data  =  tq.chompTo( "-> ");    [BUGGY]  if(  bodyHtml.endsWith  (   "- "  ))  data  =  data.substring  (  0,  data.length  ()  -1  )  ;    Comment  comment  =  new  Comment(data,  baseUri);  last().appendChild(comment);  }        [CLASS]  Parser    [METHOD]  parseComment  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    Comment    comment    boolean    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
data  =  data.substring  (  0,  data.length  (  )  -1  )  ;	[BUGGY]  data  =  data.substring(  -4,  data.length(  )-1);  [CONTEXT]  private  void  parseComment()  {  tq.consume( "<!-- ");  String  data  =  tq.chompTo( "-> ");    if  (data.endsWith( "- "))  //  i.e.  was  -->  [BUGGY]  data  =  data.substring  (  -4,  data.length  ()  -1  )  ;  Comment  comment  =  new  Comment(data,  baseUri);  last().appendChild(comment);  }        [CLASS]  Parser    [METHOD]  parseComment  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    Comment    comment    boolean    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
data  =  data.substring  (  0,  data.length  (  )  -1  )  ;	[BUGGY]  data  =  data.substring(  0,  data.length()  -  9  -1);  [CONTEXT]  private  void  parseComment()  {  tq.consume( "<!-- ");  String  data  =  tq.chompTo( "-> ");    if  (data.endsWith( "- "))  //  i.e.  was  -->  [BUGGY]  data  =  data.substring  (  0,  data.length()  -  9  -1  )  ;  Comment  comment  =  new  Comment(data,  baseUri);  last().appendChild(comment);  }        [CLASS]  Parser    [METHOD]  parseComment  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    Comment    comment    boolean    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
data  =  data.substring  (  0,  data.length  (  )  -1  )  ;	[BUGGY]  data  =  data  .endsWith(  data)  ;  [CONTEXT]  private  void  parseComment()  {  tq.consume( "<!-- ");  String  data  =  tq.chompTo( "-> ");    if  (data.endsWith( "- "))  //  i.e.  was  -->  [BUGGY]  data  =  data  .endsWith  (  data  );  Comment  comment  =  new  Comment(data,  baseUri);  last().appendChild(comment);  }        [CLASS]  Parser    [METHOD]  parseComment  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    Comment    comment    boolean    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
data  =  data.substring  (  0,  data.length  (  )  -1  )  ;	[BUGGY]  data  =  data.substring(  0,  data  .endsWith(  bodyHtml)  -1);  [CONTEXT]  private  void  parseComment()  {  tq.consume( "<!-- ");  String  data  =  tq.chompTo( "-> ");    if  (data.endsWith( "- "))  //  i.e.  was  -->  [BUGGY]  data  =  data.substring  (  0,  data  .endsWith  (  bodyHtml  )-1  )  ;  Comment  comment  =  new  Comment(data,  baseUri);  last().appendChild(comment);  }        [CLASS]  Parser    [METHOD]  parseComment  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    Comment    comment    boolean    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
data  =  data.substring  (  0,  data.length  (  )  -1  )  ;  Comment  comment  =  new  Comment  (  data,  baseUri  )  ;	[BUGGY]    [CONTEXT]  private  void  parseComment()  {  tq.consume( "<!-- ");  String  data  =  tq.chompTo( "-> ");    if  (data.endsWith( "- "))  //  i.e.  was  -->  [BUGGY]  data  =  data.substring(0,  data.length()-1);      last().appendChild(comment);        [CLASS]  Parser    [METHOD]  parseComment  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    Comment    comment    boolean    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
data  =  data.substring  (  0,  data.length  (  )  -1  )  ;	[BUGGY]  data  =  data.substring(  0,  data.length()  +  4  -1);  [CONTEXT]  private  void  parseComment()  {  tq.consume( "<!-- ");  String  data  =  tq.chompTo( "-> ");    if  (data.endsWith( "- "))  //  i.e.  was  -->  [BUGGY]  data  =  data.substring  (  0,  data.length()  +  4  -1  )  ;  Comment  comment  =  new  Comment(data,  baseUri);  last().appendChild(comment);  }        [CLASS]  Parser    [METHOD]  parseComment  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    Comment    comment    boolean    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
data  =  data.substring  (  0,  data.length  (  )  -1  )  ;	[BUGGY]  data  =  data.substring(  0,  data  .endsWith(  DQ)  -1);  [CONTEXT]  private  void  parseComment()  {  tq.consume( "<!-- ");  String  data  =  tq.chompTo( "-> ");    if  (data.endsWith( "- "))  //  i.e.  was  -->  [BUGGY]  data  =  data.substring  (  0,  data  .endsWith  (  DQ  )-1  )  ;  Comment  comment  =  new  Comment(data,  baseUri);  last().appendChild(comment);  }        [CLASS]  Parser    [METHOD]  parseComment  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    Comment    comment    boolean    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Comment  comment  =  new  Comment  (  data,  baseUri  )  ;	[BUGGY]  Comment  comment  =  new  DataNode(  data,  baseUri)  ;  [CONTEXT]  private  void  parseComment()  {  tq.consume( "<!-- ");  String  data  =  tq.chompTo( "-> ");    if  (data.endsWith( "- "))  //  i.e.  was  -->  data  =  data.substring(0,  data.length()-1);  [BUGGY]  Comment  comment  =  new  DataNode  (  data,  baseUri  );  last().appendChild(comment);  }        [CLASS]  Parser    [METHOD]  parseComment  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    Comment    comment    boolean    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Comment  comment  =  new  Comment  (  data,  baseUri  )  ;	[BUGGY]  Comment  comment  =  new  Comment(  data,  html);  [CONTEXT]  private  void  parseComment()  {  tq.consume( "<!-- ");  String  data  =  tq.chompTo( "-> ");    if  (data.endsWith( "- "))  //  i.e.  was  -->  data  =  data.substring(0,  data.length()-1);  [BUGGY]  Comment  comment  =  new  Comment  (  data,  html  )  ;  last().appendChild(comment);  }        [CLASS]  Parser    [METHOD]  parseComment  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    Comment    comment    boolean    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Comment  comment  =  new  Comment  (  data,  baseUri  )  ;	[BUGGY]  Comment  comment  =  new  Comment(  baseUri,  data);  [CONTEXT]  private  void  parseComment()  {  tq.consume( "<!-- ");  String  data  =  tq.chompTo( "-> ");    if  (data.endsWith( "- "))  //  i.e.  was  -->  data  =  data.substring(0,  data.length()-1);  [BUGGY]  Comment  comment  =  new  Comment  (  baseUri,  data  )  ;  last().appendChild(comment);  }        [CLASS]  Parser    [METHOD]  parseComment  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    Comment    comment    boolean    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Comment  comment  =  new  Comment  (  data,  baseUri  )  ;	[BUGGY]  Comment  comment  =  new  Comment(    baseUri);  [CONTEXT]  private  void  parseComment()  {  tq.consume( "<!-- ");  String  data  =  tq.chompTo( "-> ");    if  (data.endsWith( "- "))  //  i.e.  was  -->  data  =  data.substring(0,  data.length()-1);  [BUGGY]  Comment  comment  =  new  Comment  (baseUri  )  ;  last().appendChild(comment);  }        [CLASS]  Parser    [METHOD]  parseComment  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    Comment    comment    boolean    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Comment  comment  =  new  Comment  (  data,  baseUri  )  ;	[BUGGY]  Comment  comment  =  new  Comment(  data);  [CONTEXT]  private  void  parseComment()  {  tq.consume( "<!-- ");  String  data  =  tq.chompTo( "-> ");    if  (data.endsWith( "- "))  //  i.e.  was  -->  data  =  data.substring(0,  data.length()-1);  [BUGGY]  Comment  comment  =  new  Comment  (  data  )  ;  last().appendChild(comment);  }        [CLASS]  Parser    [METHOD]  parseComment  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    Comment    comment    boolean    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Comment  comment  =  new  Comment  (  data,  baseUri  )  ;	[BUGGY]  Comment  comment  =  new  Comment(  html,  baseUri);  [CONTEXT]  private  void  parseComment()  {  tq.consume( "<!-- ");  String  data  =  tq.chompTo( "-> ");    if  (data.endsWith( "- "))  //  i.e.  was  -->  data  =  data.substring(0,  data.length()-1);  [BUGGY]  Comment  comment  =  new  Comment  (  html,  baseUri  )  ;  last().appendChild(comment);  }        [CLASS]  Parser    [METHOD]  parseComment  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    Comment    comment    boolean    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Comment  comment  =  new  Comment  (  data,  baseUri  )  ;	[BUGGY]    Comment  comment  =  new  Comment(  data,  baseUri);  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseComment  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    Comment    comment    boolean    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Comment  comment  =  new  Comment  (  data,  baseUri  )  ;	[BUGGY]  Element  child  =  new  Element(  tag,  baseUri,  attributes);Comment  comment  =  new  Comment(  data,  baseUri);  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseComment  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    Comment    comment    boolean    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Comment  comment  =  new  Comment  (  data,  baseUri  )  ;	[BUGGY]  Element  head  =  new  Element(  headTag,  baseUri);Comment  comment  =  new  Comment(  data,  baseUri);  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseComment  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    Comment    comment    boolean    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Comment  comment  =  new  Comment  (  data,  baseUri  )  ;	[BUGGY]  Element  implicit  =  new  Element(  parentTag,  baseUri);Comment  comment  =  new  Comment(  data,  baseUri);  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseComment  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    Comment    comment    boolean    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
last  (  )  .appendChild  (  comment  )  ;	[BUGGY]  parse(  ).appendChild(  comment);  [CONTEXT]  private  void  parseComment()  {  tq.consume( "<!-- ");  String  data  =  tq.chompTo( "-> ");    if  (data.endsWith( "- "))  //  i.e.  was  -->  data  =  data.substring(0,  data.length()-1);  Comment  comment  =  new  Comment(data,  baseUri);  [BUGGY]  parse  ()  .appendChild  (  comment  )  ;  }        [CLASS]  Parser    [METHOD]  parseComment  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    Comment    comment    boolean    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
last  (  )  .appendChild  (  comment  )  ;	[BUGGY]    [CONTEXT]  private  void  parseComment()  {  tq.consume( "<!-- ");  String  data  =  tq.chompTo( "-> ");    if  (data.endsWith( "- "))  //  i.e.  was  -->  data  =  data.substring(0,  data.length()-1);  Comment  comment  =  new  Comment(data,  baseUri);  [BUGGY]  last().appendChild(comment);          [CLASS]  Parser    [METHOD]  parseComment  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    Comment    comment    boolean    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.consume  (   "< "  )  ;	[BUGGY]  tq.consume(   " ");  [CONTEXT]  private  void  parseXmlDecl()  {  [BUGGY]  tq.consume  (   " "  )  ;  Character  firstChar  =  tq.consume();  //  <?  or  <!,  from  initial  match.  boolean  procInstr  =  firstChar.toString().equals( "! ");  String  data  =  tq.chompTo( "> ");    XmlDeclaration  decl  =  new  XmlDeclaration(data,  baseUri,  procInstr);  last().appendChild(decl);  }        [CLASS]  Parser    [METHOD]  parseXmlDecl  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    procInstr    Character    firstChar    XmlDeclaration    decl    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.consume  (   "< "  )  ;	[BUGGY]  tq.consumeTo(   "< ");  [CONTEXT]  private  void  parseXmlDecl()  {  [BUGGY]  tq.consumeTo  (   "< "  )  ;  Character  firstChar  =  tq.consume();  //  <?  or  <!,  from  initial  match.  boolean  procInstr  =  firstChar.toString().equals( "! ");  String  data  =  tq.chompTo( "> ");    XmlDeclaration  decl  =  new  XmlDeclaration(data,  baseUri,  procInstr);  last().appendChild(decl);  }        [CLASS]  Parser    [METHOD]  parseXmlDecl  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    procInstr    Character    firstChar    XmlDeclaration    decl    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.consume  (   "< "  )  ;	[BUGGY]  tq  .consumeTo(  DQ)  ;  [CONTEXT]  private  void  parseXmlDecl()  {  [BUGGY]  tq  .consumeTo  (  DQ  );  Character  firstChar  =  tq.consume();  //  <?  or  <!,  from  initial  match.  boolean  procInstr  =  firstChar.toString().equals( "! ");  String  data  =  tq.chompTo( "> ");    XmlDeclaration  decl  =  new  XmlDeclaration(data,  baseUri,  procInstr);  last().appendChild(decl);  }        [CLASS]  Parser    [METHOD]  parseXmlDecl  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    procInstr    Character    firstChar    XmlDeclaration    decl    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.consume  (   "< "  )  ;  Character  firstChar  =  tq.consume  (  )  ;	[BUGGY]    [CONTEXT]  private  void  parseXmlDecl()  {  [BUGGY]  tq.consume( "< ");      boolean  procInstr  =  firstChar.toString().equals( "! ");  String  data  =  tq.chompTo( "> ");    XmlDeclaration  decl  =  new  XmlDeclaration(data,  baseUri,  procInstr);  last().appendChild(decl);        [CLASS]  Parser    [METHOD]  parseXmlDecl  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    procInstr    Character    firstChar    XmlDeclaration    decl    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.consume  (   "< "  )  ;	[BUGGY]  tq.consumeWhitespace(  );tq.consume(   "< ");  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseXmlDecl  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    procInstr    Character    firstChar    XmlDeclaration    decl    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.consume  (   "< "  )  ;	[BUGGY]  String  text  =  tq.consumeTo(   "< ");tq.consume(   "< ");  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseXmlDecl  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    procInstr    Character    firstChar    XmlDeclaration    decl    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.consume  (   "< "  )  ;	[BUGGY]  tq.consume(  );tq.consume(   "< ");  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseXmlDecl  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    procInstr    Character    firstChar    XmlDeclaration    decl    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.consume  (   "< "  )  ;	[BUGGY]  tq.matchChomp(   "> ");tq.consume(   "< ");  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseXmlDecl  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    procInstr    Character    firstChar    XmlDeclaration    decl    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.consume  (   "< "  )  ;	[BUGGY]  tq.consume(   "</ ");tq.consume(   "< ");  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseXmlDecl  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    procInstr    Character    firstChar    XmlDeclaration    decl    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.consume  (   "< "  )  ;	[BUGGY]  tq.chompTo(   "> ");tq.consume(   "< ");  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseXmlDecl  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    procInstr    Character    firstChar    XmlDeclaration    decl    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.consume  (   "< "  )  ;	[BUGGY]  tq.consume(   "<![CDATA[ ");tq.consume(   "< ");  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseXmlDecl  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    procInstr    Character    firstChar    XmlDeclaration    decl    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.consume  (   "< "  )  ;	[BUGGY]  tq.consume(   "<!-- ");tq.consume(   "< ");  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseXmlDecl  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    procInstr    Character    firstChar    XmlDeclaration    decl    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Character  firstChar  =  tq.consume  (  )  ;	[BUGGY]  Character  firstChar  =  tq.consumeWord(  );  [CONTEXT]  private  void  parseXmlDecl()  {  tq.consume( "< ");  [BUGGY]  Character  firstChar  =  tq.consumeWord  ()  ;  boolean  procInstr  =  firstChar.toString().equals( "! ");  String  data  =  tq.chompTo( "> ");    XmlDeclaration  decl  =  new  XmlDeclaration(data,  baseUri,  procInstr);  last().appendChild(decl);  }        [CLASS]  Parser    [METHOD]  parseXmlDecl  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    procInstr    Character    firstChar    XmlDeclaration    decl    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Character  firstChar  =  tq.consume  (  )  ;  boolean  procInstr  =  firstChar.toString  (  )  .equals  (   "! "  )  ;	[BUGGY]  boolean  procInstr  =  firstChar.toString(  ).equals(   "! ");  Character  firstChar  =  tq.consume(  );  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseXmlDecl  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    procInstr    Character    firstChar    XmlDeclaration    decl    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Character  firstChar  =  tq.consume  (  )  ;  boolean  procInstr  =  firstChar.toString  (  )  .equals  (   "! "  )  ;	[BUGGY]  boolean  procInstr  =  firstChar.toString(  ).equals(   "! ");Character  firstChar  =  tq.consume(  );  boolean  procInstr  =  firstChar.toString(  ).equals(   "! ");  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseXmlDecl  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    procInstr    Character    firstChar    XmlDeclaration    decl    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Character  firstChar  =  tq.consume  (  )  ;	[BUGGY]  Character  firstChar  =  tq  .consume(  DQ)  ;  [CONTEXT]  private  void  parseXmlDecl()  {  tq.consume( "< ");  [BUGGY]  Character  firstChar  =  tq  .consume  (  DQ  );  boolean  procInstr  =  firstChar.toString().equals( "! ");  String  data  =  tq.chompTo( "> ");    XmlDeclaration  decl  =  new  XmlDeclaration(data,  baseUri,  procInstr);  last().appendChild(decl);  }        [CLASS]  Parser    [METHOD]  parseXmlDecl  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    procInstr    Character    firstChar    XmlDeclaration    decl    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Character  firstChar  =  tq.consume  (  )  ;  boolean  procInstr  =  firstChar.toString  (  )  .equals  (   "! "  )  ;	[BUGGY]    [CONTEXT]  private  void  parseXmlDecl()  {  tq.consume( "< ");  [BUGGY]  Character  firstChar  =  tq.consume();  //  <?  or  <!,  from  initial  match.      String  data  =  tq.chompTo( "> ");    XmlDeclaration  decl  =  new  XmlDeclaration(data,  baseUri,  procInstr);  last().appendChild(decl);        [CLASS]  Parser    [METHOD]  parseXmlDecl  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    procInstr    Character    firstChar    XmlDeclaration    decl    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
boolean  procInstr  =  firstChar.toString  (  )  .equals  (   "! "  )  ;	[BUGGY]  boolean  procInstr  =  firstChar.toString(  ).equals(   " ");  [CONTEXT]  private  void  parseXmlDecl()  {  tq.consume( "< ");  Character  firstChar  =  tq.consume();  //  <?  or  <!,  from  initial  match.  [BUGGY]  boolean  procInstr  =  firstChar.toString  ()  .equals  (   " "  )  ;  String  data  =  tq.chompTo( "> ");    XmlDeclaration  decl  =  new  XmlDeclaration(data,  baseUri,  procInstr);  last().appendChild(decl);  }        [CLASS]  Parser    [METHOD]  parseXmlDecl  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    procInstr    Character    firstChar    XmlDeclaration    decl    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
boolean  procInstr  =  firstChar.toString  (  )  .equals  (   "! "  )  ;	[BUGGY]  boolean  procInstr  =  firstChar.toString(  )  .equals(  bodyHtml)  ;  [CONTEXT]  private  void  parseXmlDecl()  {  tq.consume( "< ");  Character  firstChar  =  tq.consume();  //  <?  or  <!,  from  initial  match.  [BUGGY]  boolean  procInstr  =  firstChar.toString  ().equals  (  bodyHtml  );  String  data  =  tq.chompTo( "> ");    XmlDeclaration  decl  =  new  XmlDeclaration(data,  baseUri,  procInstr);  last().appendChild(decl);  }        [CLASS]  Parser    [METHOD]  parseXmlDecl  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    procInstr    Character    firstChar    XmlDeclaration    decl    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
boolean  procInstr  =  firstChar.toString  (  )  .equals  (   "! "  )  ;  String  data  =  tq.chompTo  (   "> "  )  ;	[BUGGY]  String  data  =  tq.chompTo(   "> ");  boolean  procInstr  =  firstChar.toString(  ).equals(   "! ");  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseXmlDecl  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    procInstr    Character    firstChar    XmlDeclaration    decl    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
boolean  procInstr  =  firstChar.toString  (  )  .equals  (   "! "  )  ;  String  data  =  tq.chompTo  (   "> "  )  ;	[BUGGY]  boolean  procInstr  =  firstChar.toString(  ).equals(   "! ");boolean  procInstr  =  firstChar.toString(  ).equals(   "! ");  String  data  =  tq.chompTo(   "> ");  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseXmlDecl  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    procInstr    Character    firstChar    XmlDeclaration    decl    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
boolean  procInstr  =  firstChar.toString  (  )  .equals  (   "! "  )  ;	[BUGGY]  boolean  procInstr  =  firstChar.toString(  )  .equals(  DQ)  ;  [CONTEXT]  private  void  parseXmlDecl()  {  tq.consume( "< ");  Character  firstChar  =  tq.consume();  //  <?  or  <!,  from  initial  match.  [BUGGY]  boolean  procInstr  =  firstChar.toString  ().equals  (  DQ  );  String  data  =  tq.chompTo( "> ");    XmlDeclaration  decl  =  new  XmlDeclaration(data,  baseUri,  procInstr);  last().appendChild(decl);  }        [CLASS]  Parser    [METHOD]  parseXmlDecl  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    procInstr    Character    firstChar    XmlDeclaration    decl    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
boolean  procInstr  =  firstChar.toString  (  )  .equals  (   "! "  )  ;	[BUGGY]    [CONTEXT]  private  void  parseXmlDecl()  {  tq.consume( "< ");  Character  firstChar  =  tq.consume();  //  <?  or  <!,  from  initial  match.  [BUGGY]  boolean  procInstr  =  firstChar.toString().equals( "! ");    String  data  =  tq.chompTo( "> ");    XmlDeclaration  decl  =  new  XmlDeclaration(data,  baseUri,  procInstr);  last().appendChild(decl);        [CLASS]  Parser    [METHOD]  parseXmlDecl  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    procInstr    Character    firstChar    XmlDeclaration    decl    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
boolean  procInstr  =  firstChar.toString  (  )  .equals  (   "! "  )  ;  String  data  =  tq.chompTo  (   "> "  )  ;	[BUGGY]    [CONTEXT]  private  void  parseXmlDecl()  {  tq.consume( "< ");  Character  firstChar  =  tq.consume();  //  <?  or  <!,  from  initial  match.  [BUGGY]  boolean  procInstr  =  firstChar.toString().equals( "! ");        XmlDeclaration  decl  =  new  XmlDeclaration(data,  baseUri,  procInstr);  last().appendChild(decl);        [CLASS]  Parser    [METHOD]  parseXmlDecl  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    procInstr    Character    firstChar    XmlDeclaration    decl    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
String  data  =  tq.chompTo  (   "> "  )  ;	[BUGGY]  char  data  =  tq.chompTo(   "> ");  [CONTEXT]  private  void  parseXmlDecl()  {  tq.consume( "< ");  Character  firstChar  =  tq.consume();  //  <?  or  <!,  from  initial  match.  boolean  procInstr  =  firstChar.toString().equals( "! ");  [BUGGY]  char  data  =  tq.chompTo  (   "> "  )  ;    XmlDeclaration  decl  =  new  XmlDeclaration(data,  baseUri,  procInstr);  last().appendChild(decl);  }        [CLASS]  Parser    [METHOD]  parseXmlDecl  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    procInstr    Character    firstChar    XmlDeclaration    decl    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
String  data  =  tq.chompTo  (   "> "  )  ;	[BUGGY]  String  data  =  tq.chompTo(   " ");  [CONTEXT]  private  void  parseXmlDecl()  {  tq.consume( "< ");  Character  firstChar  =  tq.consume();  //  <?  or  <!,  from  initial  match.  boolean  procInstr  =  firstChar.toString().equals( "! ");  [BUGGY]  String  data  =  tq.chompTo  (   " "  )  ;    XmlDeclaration  decl  =  new  XmlDeclaration(data,  baseUri,  procInstr);  last().appendChild(decl);  }        [CLASS]  Parser    [METHOD]  parseXmlDecl  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    procInstr    Character    firstChar    XmlDeclaration    decl    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
String  data  =  tq.chompTo  (   "> "  )  ;	[BUGGY]  String  data  =  tq.consumeTo(   "> ");  [CONTEXT]  private  void  parseXmlDecl()  {  tq.consume( "< ");  Character  firstChar  =  tq.consume();  //  <?  or  <!,  from  initial  match.  boolean  procInstr  =  firstChar.toString().equals( "! ");  [BUGGY]  String  data  =  tq.consumeTo  (   "> "  )  ;    XmlDeclaration  decl  =  new  XmlDeclaration(data,  baseUri,  procInstr);  last().appendChild(decl);  }        [CLASS]  Parser    [METHOD]  parseXmlDecl  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    procInstr    Character    firstChar    XmlDeclaration    decl    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
String  data  =  tq.chompTo  (   "> "  )  ;	[BUGGY]    [CONTEXT]  private  void  parseXmlDecl()  {  tq.consume( "< ");  Character  firstChar  =  tq.consume();  //  <?  or  <!,  from  initial  match.  boolean  procInstr  =  firstChar.toString().equals( "! ");  [BUGGY]  String  data  =  tq.chompTo( "> ");      XmlDeclaration  decl  =  new  XmlDeclaration(data,  baseUri,  procInstr);  last().appendChild(decl);        [CLASS]  Parser    [METHOD]  parseXmlDecl  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    procInstr    Character    firstChar    XmlDeclaration    decl    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
XmlDeclaration  decl  =  new  XmlDeclaration  (  data,  baseUri,  procInstr  )  ;	[BUGGY]  XmlDeclaration  decl  =  new  XmlDeclaration(    baseUri,  procInstr);  [CONTEXT]  private  void  parseXmlDecl()  {  tq.consume( "< ");  Character  firstChar  =  tq.consume();  //  <?  or  <!,  from  initial  match.  boolean  procInstr  =  firstChar.toString().equals( "! ");  String  data  =  tq.chompTo( "> ");    [BUGGY]  XmlDeclaration  decl  =  new  XmlDeclaration  (baseUri,  procInstr  )  ;  last().appendChild(decl);  }        [CLASS]  Parser    [METHOD]  parseXmlDecl  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    procInstr    Character    firstChar    XmlDeclaration    decl    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
XmlDeclaration  decl  =  new  XmlDeclaration  (  data,  baseUri,  procInstr  )  ;	[BUGGY]  XmlDeclaration  decl  =  new  XmlDeclaration(  data,  baseUri);  [CONTEXT]  private  void  parseXmlDecl()  {  tq.consume( "< ");  Character  firstChar  =  tq.consume();  //  <?  or  <!,  from  initial  match.  boolean  procInstr  =  firstChar.toString().equals( "! ");  String  data  =  tq.chompTo( "> ");    [BUGGY]  XmlDeclaration  decl  =  new  XmlDeclaration  (  data,  baseUri  )  ;  last().appendChild(decl);  }        [CLASS]  Parser    [METHOD]  parseXmlDecl  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    procInstr    Character    firstChar    XmlDeclaration    decl    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
XmlDeclaration  decl  =  new  XmlDeclaration  (  data,  baseUri,  procInstr  )  ;	[BUGGY]  XmlDeclaration  decl  =  new  XmlDeclaration(  html,  baseUri,  procInstr);  [CONTEXT]  private  void  parseXmlDecl()  {  tq.consume( "< ");  Character  firstChar  =  tq.consume();  //  <?  or  <!,  from  initial  match.  boolean  procInstr  =  firstChar.toString().equals( "! ");  String  data  =  tq.chompTo( "> ");    [BUGGY]  XmlDeclaration  decl  =  new  XmlDeclaration  (  html,  baseUri,  procInstr  )  ;  last().appendChild(decl);  }        [CLASS]  Parser    [METHOD]  parseXmlDecl  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    procInstr    Character    firstChar    XmlDeclaration    decl    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
XmlDeclaration  decl  =  new  XmlDeclaration  (  data,  baseUri,  procInstr  )  ;	[BUGGY]  XmlDeclaration  decl  =  new  XmlDeclaration(  data,  html,  procInstr);  [CONTEXT]  private  void  parseXmlDecl()  {  tq.consume( "< ");  Character  firstChar  =  tq.consume();  //  <?  or  <!,  from  initial  match.  boolean  procInstr  =  firstChar.toString().equals( "! ");  String  data  =  tq.chompTo( "> ");    [BUGGY]  XmlDeclaration  decl  =  new  XmlDeclaration  (  data,  html,  procInstr  )  ;  last().appendChild(decl);  }        [CLASS]  Parser    [METHOD]  parseXmlDecl  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    procInstr    Character    firstChar    XmlDeclaration    decl    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
XmlDeclaration  decl  =  new  XmlDeclaration  (  data,  baseUri,  procInstr  )  ;	[BUGGY]  XmlDeclaration  decl  =  new  XmlDeclaration(  procInstr,  baseUri,  data);  [CONTEXT]  private  void  parseXmlDecl()  {  tq.consume( "< ");  Character  firstChar  =  tq.consume();  //  <?  or  <!,  from  initial  match.  boolean  procInstr  =  firstChar.toString().equals( "! ");  String  data  =  tq.chompTo( "> ");    [BUGGY]  XmlDeclaration  decl  =  new  XmlDeclaration  (  procInstr,  baseUri,  data  )  ;  last().appendChild(decl);  }        [CLASS]  Parser    [METHOD]  parseXmlDecl  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    procInstr    Character    firstChar    XmlDeclaration    decl    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
XmlDeclaration  decl  =  new  XmlDeclaration  (  data,  baseUri,  procInstr  )  ;	[BUGGY]  XmlDeclaration  decl  =  new  XmlDeclaration(  data,  procInstr,  baseUri);  [CONTEXT]  private  void  parseXmlDecl()  {  tq.consume( "< ");  Character  firstChar  =  tq.consume();  //  <?  or  <!,  from  initial  match.  boolean  procInstr  =  firstChar.toString().equals( "! ");  String  data  =  tq.chompTo( "> ");    [BUGGY]  XmlDeclaration  decl  =  new  XmlDeclaration  (  data,  procInstr,  baseUri  )  ;  last().appendChild(decl);  }        [CLASS]  Parser    [METHOD]  parseXmlDecl  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    procInstr    Character    firstChar    XmlDeclaration    decl    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
XmlDeclaration  decl  =  new  XmlDeclaration  (  data,  baseUri,  procInstr  )  ;	[BUGGY]  XmlDeclaration  decl  =  new  XmlDeclaration(  baseUri,  data,  procInstr);  [CONTEXT]  private  void  parseXmlDecl()  {  tq.consume( "< ");  Character  firstChar  =  tq.consume();  //  <?  or  <!,  from  initial  match.  boolean  procInstr  =  firstChar.toString().equals( "! ");  String  data  =  tq.chompTo( "> ");    [BUGGY]  XmlDeclaration  decl  =  new  XmlDeclaration  (  baseUri,  data,  procInstr  )  ;  last().appendChild(decl);  }        [CLASS]  Parser    [METHOD]  parseXmlDecl  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    procInstr    Character    firstChar    XmlDeclaration    decl    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
XmlDeclaration  decl  =  new  XmlDeclaration  (  data,  baseUri,  procInstr  )  ;	[BUGGY]  XmlDeclaration  decl  =  new  XmlDeclaration(  data,    procInstr);  [CONTEXT]  private  void  parseXmlDecl()  {  tq.consume( "< ");  Character  firstChar  =  tq.consume();  //  <?  or  <!,  from  initial  match.  boolean  procInstr  =  firstChar.toString().equals( "! ");  String  data  =  tq.chompTo( "> ");    [BUGGY]  XmlDeclaration  decl  =  new  XmlDeclaration  (  data,procInstr  )  ;  last().appendChild(decl);  }        [CLASS]  Parser    [METHOD]  parseXmlDecl  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    procInstr    Character    firstChar    XmlDeclaration    decl    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
last  (  )  .appendChild  (  decl  )  ;	[BUGGY]  parse(  ).appendChild(  decl);  [CONTEXT]  private  void  parseXmlDecl()  {  tq.consume( "< ");  Character  firstChar  =  tq.consume();  //  <?  or  <!,  from  initial  match.  boolean  procInstr  =  firstChar.toString().equals( "! ");  String  data  =  tq.chompTo( "> ");    XmlDeclaration  decl  =  new  XmlDeclaration(data,  baseUri,  procInstr);  [BUGGY]  parse  ()  .appendChild  (  decl  )  ;  }        [CLASS]  Parser    [METHOD]  parseXmlDecl  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    procInstr    Character    firstChar    XmlDeclaration    decl    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
last  (  )  .appendChild  (  decl  )  ;	[BUGGY]    [CONTEXT]  private  void  parseXmlDecl()  {  tq.consume( "< ");  Character  firstChar  =  tq.consume();  //  <?  or  <!,  from  initial  match.  boolean  procInstr  =  firstChar.toString().equals( "! ");  String  data  =  tq.chompTo( "> ");    XmlDeclaration  decl  =  new  XmlDeclaration(data,  baseUri,  procInstr);  [BUGGY]  last().appendChild(decl);          [CLASS]  Parser    [METHOD]  parseXmlDecl  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    procInstr    Character    firstChar    XmlDeclaration    decl    String    DQ    SQ    baseUri    bodyHtml    data    html    Tag    bodyTag    headTag    htmlTag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.consume  (   "</ "  )  ;	[BUGGY]  tq.consume(   " ");  [CONTEXT]  private  void  parseEndTag()  {  [BUGGY]  tq.consume  (   " "  )  ;  String  tagName  =  tq.consumeWord();  tq.chompTo( "> ");    if  (tagName.length()  !=  0)  {  Tag  tag  =  Tag.valueOf(tagName);  popStackToClose(tag);  }  }        [CLASS]  Parser    [METHOD]  parseEndTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    data    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
tq.consume  (   "</ "  )  ;	[BUGGY]  tq.consumeTo(   "</ ");  [CONTEXT]  private  void  parseEndTag()  {  [BUGGY]  tq.consumeTo  (   "</ "  )  ;  String  tagName  =  tq.consumeWord();  tq.chompTo( "> ");    if  (tagName.length()  !=  0)  {  Tag  tag  =  Tag.valueOf(tagName);  popStackToClose(tag);  }  }        [CLASS]  Parser    [METHOD]  parseEndTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    data    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
tq.consume  (   "</ "  )  ;  String  tagName  =  tq.consumeWord  (  )  ;	[BUGGY]    [CONTEXT]  private  void  parseEndTag()  {  [BUGGY]  tq.consume( "</ ");      tq.chompTo( "> ");    if  (tagName.length()  !=  0)  {  Tag  tag  =  Tag.valueOf(tagName);  popStackToClose(tag);  }        [CLASS]  Parser    [METHOD]  parseEndTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    data    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
tq.consume  (   "</ "  )  ;  String  tagName  =  tq.consumeWord  (  )  ;	[BUGGY]  String  tagName  =  tq.consumeWord(  );  tq.consume(   "</ ");  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseEndTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    data    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
tq.consume  (   "</ "  )  ;  String  tagName  =  tq.consumeWord  (  )  ;	[BUGGY]  String  tagName  =  tq.consumeWord(  );tq.consume(   "</ ");  String  tagName  =  tq.consumeWord(  );  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseEndTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    data    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
String  tagName  =  tq.consumeWord  (  )  ;	[BUGGY]  char  tagName  =  tq.consumeWord(  );  [CONTEXT]  private  void  parseEndTag()  {  tq.consume( "</ ");  [BUGGY]  char  tagName  =  tq.consumeWord  ()  ;  tq.chompTo( "> ");    if  (tagName.length()  !=  0)  {  Tag  tag  =  Tag.valueOf(tagName);  popStackToClose(tag);  }  }        [CLASS]  Parser    [METHOD]  parseEndTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    data    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
String  tagName  =  tq.consumeWord  (  )  ;	[BUGGY]  String  tagName  =  tq.consume(  );  [CONTEXT]  private  void  parseEndTag()  {  tq.consume( "</ ");  [BUGGY]  String  tagName  =  tq.consume  ()  ;  tq.chompTo( "> ");    if  (tagName.length()  !=  0)  {  Tag  tag  =  Tag.valueOf(tagName);  popStackToClose(tag);  }  }        [CLASS]  Parser    [METHOD]  parseEndTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    data    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
String  tagName  =  tq.consumeWord  (  )  ;	[BUGGY]  String  text  =  tq.consumeTo(   "< ");String  tagName  =  tq.consumeWord(  );  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseEndTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    data    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
String  tagName  =  tq.consumeWord  (  )  ;	[BUGGY]  String  rawText  =  tq.chompTo(   "]]> ");String  tagName  =  tq.consumeWord(  );  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseEndTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    data    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
String  tagName  =  tq.consumeWord  (  )  ;	[BUGGY]  String  data  =  tq.chompTo(   "-> ");String  tagName  =  tq.consumeWord(  );  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseEndTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    data    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
String  tagName  =  tq.consumeWord  (  )  ;	[BUGGY]  String  key  =  tq.consumeAttributeKey(  );String  tagName  =  tq.consumeWord(  );  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseEndTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    data    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
String  tagName  =  tq.consumeWord  (  )  ;	[BUGGY]  String  data  =  tq.chompTo(   "> ");String  tagName  =  tq.consumeWord(  );  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseEndTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    data    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
String  tagName  =  tq.consumeWord  (  )  ;	[BUGGY]  String  tagName  =  tq  .consumeTo(  tagName)  ;  [CONTEXT]  private  void  parseEndTag()  {  tq.consume( "</ ");  [BUGGY]  String  tagName  =  tq  .consumeTo  (  tagName  );  tq.chompTo( "> ");    if  (tagName.length()  !=  0)  {  Tag  tag  =  Tag.valueOf(tagName);  popStackToClose(tag);  }  }        [CLASS]  Parser    [METHOD]  parseEndTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    data    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
String  tagName  =  tq.consumeWord  (  )  ;  tq.chompTo  (   "> "  )  ;	[BUGGY]    [CONTEXT]  private  void  parseEndTag()  {  tq.consume( "</ ");  [BUGGY]  String  tagName  =  tq.consumeWord();        if  (tagName.length()  !=  0)  {  Tag  tag  =  Tag.valueOf(tagName);  popStackToClose(tag);  }        [CLASS]  Parser    [METHOD]  parseEndTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    data    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
tq.chompTo  (   "> "  )  ;	[BUGGY]  tq.chompTo(   " ");  [CONTEXT]  private  void  parseEndTag()  {  tq.consume( "</ ");  String  tagName  =  tq.consumeWord();  [BUGGY]  tq.chompTo  (   " "  )  ;    if  (tagName.length()  !=  0)  {  Tag  tag  =  Tag.valueOf(tagName);  popStackToClose(tag);  }  }        [CLASS]  Parser    [METHOD]  parseEndTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    data    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
tq.chompTo  (   "> "  )  ;	[BUGGY]  tq.consumeTo(   "> ");  [CONTEXT]  private  void  parseEndTag()  {  tq.consume( "</ ");  String  tagName  =  tq.consumeWord();  [BUGGY]  tq.consumeTo  (   "> "  )  ;    if  (tagName.length()  !=  0)  {  Tag  tag  =  Tag.valueOf(tagName);  popStackToClose(tag);  }  }        [CLASS]  Parser    [METHOD]  parseEndTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    data    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
tq.chompTo  (   "> "  )  ;	[BUGGY]    [CONTEXT]  private  void  parseEndTag()  {  tq.consume( "</ ");  String  tagName  =  tq.consumeWord();  [BUGGY]  tq.chompTo( "> ");      if  (tagName.length()  !=  0)  {  Tag  tag  =  Tag.valueOf(tagName);  popStackToClose(tag);  }        [CLASS]  Parser    [METHOD]  parseEndTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    data    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
if  (  tagName.length  (  )  !=  0  )  {	[BUGGY]  if  (  tagName.length(  )  >=  0)  {  [CONTEXT]  private  void  parseEndTag()  {  tq.consume( "</ ");  String  tagName  =  tq.consumeWord();  tq.chompTo( "> ");    [BUGGY]  if(  tagName.length  ()>=  0  ){  Tag  tag  =  Tag.valueOf(tagName);  popStackToClose(tag);  }  }        [CLASS]  Parser    [METHOD]  parseEndTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    data    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
if  (  tagName.length  (  )  !=  0  )  {	[BUGGY]  if  (  tagName.length(  )  !=  -8)  {  [CONTEXT]  private  void  parseEndTag()  {  tq.consume( "</ ");  String  tagName  =  tq.consumeWord();  tq.chompTo( "> ");    [BUGGY]  if(  tagName.length  ()!=  -8  ){  Tag  tag  =  Tag.valueOf(tagName);  popStackToClose(tag);  }  }        [CLASS]  Parser    [METHOD]  parseEndTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    data    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
if  (  tagName.length  (  )  !=  0  )  {	[BUGGY]  if  (  tagName.length()  +  9    !=  0)  {  [CONTEXT]  private  void  parseEndTag()  {  tq.consume( "</ ");  String  tagName  =  tq.consumeWord();  tq.chompTo( "> ");    [BUGGY]  if(  tagName.length()  +  9!=  0  ){  Tag  tag  =  Tag.valueOf(tagName);  popStackToClose(tag);  }  }        [CLASS]  Parser    [METHOD]  parseEndTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    data    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
if  (  tagName.length  (  )  !=  0  )  {	[BUGGY]  if  (  bodyHtml.length(  )  !=  0)  {  [CONTEXT]  private  void  parseEndTag()  {  tq.consume( "</ ");  String  tagName  =  tq.consumeWord();  tq.chompTo( "> ");    [BUGGY]  if(  bodyHtml.length  ()!=  0  ){  Tag  tag  =  Tag.valueOf(tagName);  popStackToClose(tag);  }  }        [CLASS]  Parser    [METHOD]  parseEndTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    data    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
if  (  tagName.length  (  )  !=  0  )  {	[BUGGY]  if  (  titleTagName.length(  )  !=  0)  {  [CONTEXT]  private  void  parseEndTag()  {  tq.consume( "</ ");  String  tagName  =  tq.consumeWord();  tq.chompTo( "> ");    [BUGGY]  if(  titleTagName.length  ()!=  0  ){  Tag  tag  =  Tag.valueOf(tagName);  popStackToClose(tag);  }  }        [CLASS]  Parser    [METHOD]  parseEndTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    data    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
if  (  tagName.length  (  )  !=  0  )  {	[BUGGY]  if  (  tag.length(  )  !=  0)  {  [CONTEXT]  private  void  parseEndTag()  {  tq.consume( "</ ");  String  tagName  =  tq.consumeWord();  tq.chompTo( "> ");    [BUGGY]  if(  tag.length  ()!=  0  ){  Tag  tag  =  Tag.valueOf(tagName);  popStackToClose(tag);  }  }        [CLASS]  Parser    [METHOD]  parseEndTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    data    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
if  (  tagName.length  (  )  !=  0  )  {	[BUGGY]  if  (  tagNameName.length(  )  !=  0)  {  [CONTEXT]  private  void  parseEndTag()  {  tq.consume( "</ ");  String  tagName  =  tq.consumeWord();  tq.chompTo( "> ");    [BUGGY]  if(  tagNameName.length  ()!=  0  ){  Tag  tag  =  Tag.valueOf(tagName);  popStackToClose(tag);  }  }        [CLASS]  Parser    [METHOD]  parseEndTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    data    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
if  (  tagName.length  (  )  !=  0  )  {	[BUGGY]  if  (  tagName.substring(  )  !=  0)  {  [CONTEXT]  private  void  parseEndTag()  {  tq.consume( "</ ");  String  tagName  =  tq.consumeWord();  tq.chompTo( "> ");    [BUGGY]  if(  tagName.substring  ()!=  0  ){  Tag  tag  =  Tag.valueOf(tagName);  popStackToClose(tag);  }  }        [CLASS]  Parser    [METHOD]  parseEndTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    data    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
if  (  tagName.length  (  )  !=  0  )  {	[BUGGY]  if  (  tagName.length(  )  !=  0  )  {  [CONTEXT]  private  void  parseEndTag()  {  tq.consume( "</ ");  String  tagName  =  tq.consumeWord();  tq.chompTo( "> ");    [BUGGY]  if(  tagName.length  ()!=  0){  Tag  tag  =  Tag.valueOf(tagName);  popStackToClose(tag);  }  }        [CLASS]  Parser    [METHOD]  parseEndTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    data    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
if  (  tagName.length  (  )  !=  0  )  {	[BUGGY]  if  (  href.length(  )  !=  0)  {  [CONTEXT]  private  void  parseEndTag()  {  tq.consume( "</ ");  String  tagName  =  tq.consumeWord();  tq.chompTo( "> ");    [BUGGY]  if(  href.length  ()!=  0  ){  Tag  tag  =  Tag.valueOf(tagName);  popStackToClose(tag);  }  }        [CLASS]  Parser    [METHOD]  parseEndTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    data    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
if  (  tagName.length  (  )  !=  0  )  {	[BUGGY]  if  (  tagName.length(  )  ==  0)  {  [CONTEXT]  private  void  parseEndTag()  {  tq.consume( "</ ");  String  tagName  =  tq.consumeWord();  tq.chompTo( "> ");    [BUGGY]  if(  tagName.length  ()==  0  ){  Tag  tag  =  Tag.valueOf(tagName);  popStackToClose(tag);  }  }        [CLASS]  Parser    [METHOD]  parseEndTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    data    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
if  (  tagName.length  (  )  !=  0  )  {  Tag  tag  =  Tag.valueOf  (  tagName  )  ;  popStackToClose  (  tag  )  ;  }	[BUGGY]  org.jsoup.parser.Tag  tag  =  org.jsoup.parser.Tag.valueOf(tagName);  popStackToClose(tag);  [CONTEXT]  private  void  parseEndTag()  {  tq.consume( "</ ");  String  tagName  =  tq.consumeWord();  tq.chompTo( "> ");    [BUGGY]  if  (tagName.length()  !=  0)  {    org.jsoup.parser.Tag  tag  =  org.jsoup.parser.Tag.valueOf(tagName);  popStackToClose(tag);            [CLASS]  Parser    [METHOD]  parseEndTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    data    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
if  (  tagName.length  (  )  !=  0  )  {  Tag  tag  =  Tag.valueOf  (  tagName  )  ;  popStackToClose  (  tag  )  ;  }	[BUGGY]    [CONTEXT]  private  void  parseEndTag()  {  tq.consume( "</ ");  String  tagName  =  tq.consumeWord();  tq.chompTo( "> ");    [BUGGY]  if  (tagName.length()  !=  0)  {                [CLASS]  Parser    [METHOD]  parseEndTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    data    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
Tag  tag  =  Tag.valueOf  (  tagName  )  ;	[BUGGY]  Tag  tag  =  Tag.valueOf(  bodyHtml);  [CONTEXT]  private  void  parseEndTag()  {  tq.consume( "</ ");  String  tagName  =  tq.consumeWord();  tq.chompTo( "> ");    if  (tagName.length()  !=  0)  {  [BUGGY]  Tag  tag  =  Tag.valueOf  (  bodyHtml  )  ;  popStackToClose(tag);  }  }        [CLASS]  Parser    [METHOD]  parseEndTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    data    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
Tag  tag  =  Tag.valueOf  (  tagName  )  ;	[BUGGY]  Tag  tag  =  Tag.equals(  tagName);  [CONTEXT]  private  void  parseEndTag()  {  tq.consume( "</ ");  String  tagName  =  tq.consumeWord();  tq.chompTo( "> ");    if  (tagName.length()  !=  0)  {  [BUGGY]  Tag  tag  =  Tag.equals  (  tagName  )  ;  popStackToClose(tag);  }  }        [CLASS]  Parser    [METHOD]  parseEndTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    data    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
Tag  tag  =  Tag.valueOf  (  tagName  )  ;	[BUGGY]  Tag  tag  =  Tag.valueOf(  html);  [CONTEXT]  private  void  parseEndTag()  {  tq.consume( "</ ");  String  tagName  =  tq.consumeWord();  tq.chompTo( "> ");    if  (tagName.length()  !=  0)  {  [BUGGY]  Tag  tag  =  Tag.valueOf  (  html  )  ;  popStackToClose(tag);  }  }        [CLASS]  Parser    [METHOD]  parseEndTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    data    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
Tag  tag  =  Tag.valueOf  (  tagName  )  ;	[BUGGY]  Tag  tag  =  Tag.valueOf(  data);  [CONTEXT]  private  void  parseEndTag()  {  tq.consume( "</ ");  String  tagName  =  tq.consumeWord();  tq.chompTo( "> ");    if  (tagName.length()  !=  0)  {  [BUGGY]  Tag  tag  =  Tag.valueOf  (  data  )  ;  popStackToClose(tag);  }  }        [CLASS]  Parser    [METHOD]  parseEndTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    data    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
Tag  tag  =  Tag.valueOf  (  tagName  )  ;	[BUGGY]    [CONTEXT]  private  void  parseEndTag()  {  tq.consume( "</ ");  String  tagName  =  tq.consumeWord();  tq.chompTo( "> ");    if  (tagName.length()  !=  0)  {  [BUGGY]  Tag  tag  =  Tag.valueOf(tagName);    popStackToClose(tag);  }        [CLASS]  Parser    [METHOD]  parseEndTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    data    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
popStackToClose  (  tag  )  ;	[BUGGY]  popStackToSuitableContainer(  tag);  [CONTEXT]  private  void  parseEndTag()  {  tq.consume( "</ ");  String  tagName  =  tq.consumeWord();  tq.chompTo( "> ");    if  (tagName.length()  !=  0)  {  Tag  tag  =  Tag.valueOf(tagName);  [BUGGY]  popStackToSuitableContainer  (  tag  )  ;  }  }        [CLASS]  Parser    [METHOD]  parseEndTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    data    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
popStackToClose  (  tag  )  ;	[BUGGY]  popStackToSuitableContainer(  titleTag);  [CONTEXT]  private  void  parseEndTag()  {  tq.consume( "</ ");  String  tagName  =  tq.consumeWord();  tq.chompTo( "> ");    if  (tagName.length()  !=  0)  {  Tag  tag  =  Tag.valueOf(tagName);  [BUGGY]  popStackToSuitableContainer  (  titleTag  )  ;  }  }        [CLASS]  Parser    [METHOD]  parseEndTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    data    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
popStackToClose  (  tag  )  ;	[BUGGY]    [CONTEXT]  private  void  parseEndTag()  {  tq.consume( "</ ");  String  tagName  =  tq.consumeWord();  tq.chompTo( "> ");    if  (tagName.length()  !=  0)  {  Tag  tag  =  Tag.valueOf(tagName);  [BUGGY]  popStackToClose(tag);    }        [CLASS]  Parser    [METHOD]  parseEndTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    data    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
Tag  tag  =  Tag.valueOf  (  tagName  )  ;	[BUGGY]  Tag  tag  =  Tag  .isValidParent(  headTag)  ;  [CONTEXT]  private  void  parseEndTag()  {  tq.consume( "</ ");  String  tagName  =  tq.consumeWord();  tq.chompTo( "> ");    if  (tagName.length()  !=  0)  {  [BUGGY]  Tag  tag  =  Tag  .isValidParent  (  headTag  );  popStackToClose(tag);  }  }        [CLASS]  Parser    [METHOD]  parseEndTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    data    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
Tag  tag  =  Tag.valueOf  (  tagName  )  ;  popStackToClose  (  tag  )  ;	[BUGGY]  popStackToClose(  tag);  Tag  tag  =  Tag.valueOf(  tagName);  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseEndTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    data    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
Tag  tag  =  Tag.valueOf  (  tagName  )  ;  popStackToClose  (  tag  )  ;	[BUGGY]  Tag  tag  =  Tag.valueOf(  tagName);Tag  tag  =  Tag.valueOf(  tagName);  popStackToClose(  tag);  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseEndTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    data    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
if  (  tagName.length  (  )  !=  0  )  {	[BUGGY]  if  (  tagName.length()  +  0    !=  0)  {  [CONTEXT]  private  void  parseEndTag()  {  tq.consume( "</ ");  String  tagName  =  tq.consumeWord();  tq.chompTo( "> ");    [BUGGY]  if(  tagName.length()  +  0!=  0  ){  Tag  tag  =  Tag.valueOf(tagName);  popStackToClose(tag);  }  }        [CLASS]  Parser    [METHOD]  parseEndTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    data    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
if  (  tagName.length  (  )  !=  0  )  {	[BUGGY]  if  (  html.length(  )  !=  0)  {  [CONTEXT]  private  void  parseEndTag()  {  tq.consume( "</ ");  String  tagName  =  tq.consumeWord();  tq.chompTo( "> ");    [BUGGY]  if(  html.length  ()!=  0  ){  Tag  tag  =  Tag.valueOf(tagName);  popStackToClose(tag);  }  }        [CLASS]  Parser    [METHOD]  parseEndTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    data    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
Tag  tag  =  Tag.valueOf  (  tagName  )  ;  popStackToClose  (  tag  )  ;	[BUGGY]    [CONTEXT]  private  void  parseEndTag()  {  tq.consume( "</ ");  String  tagName  =  tq.consumeWord();  tq.chompTo( "> ");    if  (tagName.length()  !=  0)  {  [BUGGY]  Tag  tag  =  Tag.valueOf(tagName);      }        [CLASS]  Parser    [METHOD]  parseEndTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    data    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
popStackToClose  (  tag  )  ;	[BUGGY]  popStackToClose(  titleTag);  [CONTEXT]  private  void  parseEndTag()  {  tq.consume( "</ ");  String  tagName  =  tq.consumeWord();  tq.chompTo( "> ");    if  (tagName.length()  !=  0)  {  Tag  tag  =  Tag.valueOf(tagName);  [BUGGY]  popStackToClose  (  titleTag  )  ;  }  }        [CLASS]  Parser    [METHOD]  parseEndTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    data    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
tq.consume  (   "< "  )  ;	[BUGGY]  tq.consume(   " ");  [CONTEXT]  last().appendChild(decl);  }    private  void  parseEndTag()  {  tq.consume( "</ ");  String  tagName  =  tq.consumeWord();  tq.chompTo( "> ");    if  (tagName.length()  !=  0)  {  Tag  tag  =  Tag.valueOf(tagName);  popStackToClose(tag);  }  }    private  void  parseStartTag()  {  [BUGGY]  tq.consume  (   " "  )  ;  String  tagName  =  tq.consumeWord();    if  (tagName.length()  ==  0)  {  //  doesn't  look  like  a  start  tag  after  all;  put  <  back  on  stack  and  handle  as  text  tq.addFirst( "&lt; ");  parseTextNode();  return;  }    Attributes  attributes  =  new  Attributes();  while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.isEmpty())  {  Attribute  attribute  =  parseAttribute();  if  (attribute  !=  null)  attributes.put(attribute);  }          [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.consume  (   "< "  )  ;	[BUGGY]  tq.consumeTo(   "< ");  [CONTEXT]  last().appendChild(decl);  }    private  void  parseEndTag()  {  tq.consume( "</ ");  String  tagName  =  tq.consumeWord();  tq.chompTo( "> ");    if  (tagName.length()  !=  0)  {  Tag  tag  =  Tag.valueOf(tagName);  popStackToClose(tag);  }  }    private  void  parseStartTag()  {  [BUGGY]  tq.consumeTo  (   "< "  )  ;  String  tagName  =  tq.consumeWord();    if  (tagName.length()  ==  0)  {  //  doesn't  look  like  a  start  tag  after  all;  put  <  back  on  stack  and  handle  as  text  tq.addFirst( "&lt; ");  parseTextNode();  return;  }    Attributes  attributes  =  new  Attributes();  while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.isEmpty())  {  Attribute  attribute  =  parseAttribute();  if  (attribute  !=  null)  attributes.put(attribute);  }          [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.consume  (   "< "  )  ;	[BUGGY]    [CONTEXT]  last().appendChild(decl);  }    private  void  parseEndTag()  {  tq.consume( "</ ");  String  tagName  =  tq.consumeWord();  tq.chompTo( "> ");    if  (tagName.length()  !=  0)  {  Tag  tag  =  Tag.valueOf(tagName);  popStackToClose(tag);  }  }    private  void  parseStartTag()  {  [BUGGY]  tq.consume( "< ");    String  tagName  =  tq.consumeWord();    if  (tagName.length()  ==  0)  {  //  doesn't  look  like  a  start  tag  after  all;  put  <  back  on  stack  and  handle  as  text  tq.addFirst( "&lt; ");  parseTextNode();  return;  }    Attributes  attributes  =  new  Attributes();  while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.isEmpty())  {  Attribute  attribute  =  parseAttribute();  if  (attribute  !=  null)  attributes.put(attribute);  }        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.consume  (   "< "  )  ;  String  tagName  =  tq.consumeWord  (  )  ;	[BUGGY]  String  tagName  =  tq.consumeWord(  );  tq.consume(   "< ");  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.consume  (   "< "  )  ;  String  tagName  =  tq.consumeWord  (  )  ;	[BUGGY]  String  tagName  =  tq.consumeWord(  );tq.consume(   "< ");  String  tagName  =  tq.consumeWord(  );  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
String  tagName  =  tq.consumeWord  (  )  ;	[BUGGY]  char  tagName  =  tq.consumeWord(  );  [CONTEXT]  }    private  void  parseEndTag()  {  tq.consume( "</ ");  String  tagName  =  tq.consumeWord();  tq.chompTo( "> ");    if  (tagName.length()  !=  0)  {  Tag  tag  =  Tag.valueOf(tagName);  popStackToClose(tag);  }  }    private  void  parseStartTag()  {  tq.consume( "< ");  [BUGGY]  char  tagName  =  tq.consumeWord  ()  ;    if  (tagName.length()  ==  0)  {  //  doesn't  look  like  a  start  tag  after  all;  put  <  back  on  stack  and  handle  as  text  tq.addFirst( "&lt; ");  parseTextNode();  return;  }    Attributes  attributes  =  new  Attributes();  while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.isEmpty())  {  Attribute  attribute  =  parseAttribute();  if  (attribute  !=  null)  attributes.put(attribute);  }    Tag  tag  =  Tag.valueOf(tagName);        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
String  tagName  =  tq.consumeWord  (  )  ;	[BUGGY]  String  tagName  =  tq.consume(  );  [CONTEXT]  }    private  void  parseEndTag()  {  tq.consume( "</ ");  String  tagName  =  tq.consumeWord();  tq.chompTo( "> ");    if  (tagName.length()  !=  0)  {  Tag  tag  =  Tag.valueOf(tagName);  popStackToClose(tag);  }  }    private  void  parseStartTag()  {  tq.consume( "< ");  [BUGGY]  String  tagName  =  tq.consume  ()  ;    if  (tagName.length()  ==  0)  {  //  doesn't  look  like  a  start  tag  after  all;  put  <  back  on  stack  and  handle  as  text  tq.addFirst( "&lt; ");  parseTextNode();  return;  }    Attributes  attributes  =  new  Attributes();  while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.isEmpty())  {  Attribute  attribute  =  parseAttribute();  if  (attribute  !=  null)  attributes.put(attribute);  }    Tag  tag  =  Tag.valueOf(tagName);        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
String  tagName  =  tq.consumeWord  (  )  ;	[BUGGY]  String  tagName  =  tq  .consumeTo(  baseUri)  ;  [CONTEXT]  }    private  void  parseEndTag()  {  tq.consume( "</ ");  String  tagName  =  tq.consumeWord();  tq.chompTo( "> ");    if  (tagName.length()  !=  0)  {  Tag  tag  =  Tag.valueOf(tagName);  popStackToClose(tag);  }  }    private  void  parseStartTag()  {  tq.consume( "< ");  [BUGGY]  String  tagName  =  tq  .consumeTo  (  baseUri  );    if  (tagName.length()  ==  0)  {  //  doesn't  look  like  a  start  tag  after  all;  put  <  back  on  stack  and  handle  as  text  tq.addFirst( "&lt; ");  parseTextNode();  return;  }    Attributes  attributes  =  new  Attributes();  while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.isEmpty())  {  Attribute  attribute  =  parseAttribute();  if  (attribute  !=  null)  attributes.put(attribute);  }    Tag  tag  =  Tag.valueOf(tagName);        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
String  tagName  =  tq.consumeWord  (  )  ;	[BUGGY]    [CONTEXT]  }    private  void  parseEndTag()  {  tq.consume( "</ ");  String  tagName  =  tq.consumeWord();  tq.chompTo( "> ");    if  (tagName.length()  !=  0)  {  Tag  tag  =  Tag.valueOf(tagName);  popStackToClose(tag);  }  }    private  void  parseStartTag()  {  tq.consume( "< ");  [BUGGY]  String  tagName  =  tq.consumeWord();      if  (tagName.length()  ==  0)  {  //  doesn't  look  like  a  start  tag  after  all;  put  <  back  on  stack  and  handle  as  text  tq.addFirst( "&lt; ");  parseTextNode();  return;  }    Attributes  attributes  =  new  Attributes();  while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.isEmpty())  {  Attribute  attribute  =  parseAttribute();  if  (attribute  !=  null)  attributes.put(attribute);  }          [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  tagName.length  (  )  ==  0  )  {	[BUGGY]  if  (  tagName.length(  )  !=  0)  {  [CONTEXT]  private  void  parseEndTag()  {  tq.consume( "</ ");  String  tagName  =  tq.consumeWord();  tq.chompTo( "> ");    if  (tagName.length()  !=  0)  {  Tag  tag  =  Tag.valueOf(tagName);  popStackToClose(tag);  }  }    private  void  parseStartTag()  {  tq.consume( "< ");  String  tagName  =  tq.consumeWord();    [BUGGY]  if(  tagName.length  ()!=  0  ){  tq.addFirst( "&lt; ");  parseTextNode();  return;  }    Attributes  attributes  =  new  Attributes();  while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.isEmpty())  {  Attribute  attribute  =  parseAttribute();  if  (attribute  !=  null)  attributes.put(attribute);  }    Tag  tag  =  Tag.valueOf(tagName);  Element  child  =  new  Element(tag,  baseUri,  attributes);          [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  tagName.length  (  )  ==  0  )  {	[BUGGY]  if  (  tagName.length(  )  ==  2)  {  [CONTEXT]  private  void  parseEndTag()  {  tq.consume( "</ ");  String  tagName  =  tq.consumeWord();  tq.chompTo( "> ");    if  (tagName.length()  !=  0)  {  Tag  tag  =  Tag.valueOf(tagName);  popStackToClose(tag);  }  }    private  void  parseStartTag()  {  tq.consume( "< ");  String  tagName  =  tq.consumeWord();    [BUGGY]  if(  tagName.length  ()==  2  ){  tq.addFirst( "&lt; ");  parseTextNode();  return;  }    Attributes  attributes  =  new  Attributes();  while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.isEmpty())  {  Attribute  attribute  =  parseAttribute();  if  (attribute  !=  null)  attributes.put(attribute);  }    Tag  tag  =  Tag.valueOf(tagName);  Element  child  =  new  Element(tag,  baseUri,  attributes);          [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  tagName.length  (  )  ==  0  )  {	[BUGGY]  if  (  tagName.length()  +  4    ==  0)  {  [CONTEXT]  private  void  parseEndTag()  {  tq.consume( "</ ");  String  tagName  =  tq.consumeWord();  tq.chompTo( "> ");    if  (tagName.length()  !=  0)  {  Tag  tag  =  Tag.valueOf(tagName);  popStackToClose(tag);  }  }    private  void  parseStartTag()  {  tq.consume( "< ");  String  tagName  =  tq.consumeWord();    [BUGGY]  if(  tagName.length()  +  4==  0  ){  tq.addFirst( "&lt; ");  parseTextNode();  return;  }    Attributes  attributes  =  new  Attributes();  while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.isEmpty())  {  Attribute  attribute  =  parseAttribute();  if  (attribute  !=  null)  attributes.put(attribute);  }    Tag  tag  =  Tag.valueOf(tagName);  Element  child  =  new  Element(tag,  baseUri,  attributes);          [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  tagName.length  (  )  ==  0  )  {	[BUGGY]  if  (  href.length(  )  ==  0)  {  [CONTEXT]  private  void  parseEndTag()  {  tq.consume( "</ ");  String  tagName  =  tq.consumeWord();  tq.chompTo( "> ");    if  (tagName.length()  !=  0)  {  Tag  tag  =  Tag.valueOf(tagName);  popStackToClose(tag);  }  }    private  void  parseStartTag()  {  tq.consume( "< ");  String  tagName  =  tq.consumeWord();    [BUGGY]  if(  href.length  ()==  0  ){  tq.addFirst( "&lt; ");  parseTextNode();  return;  }    Attributes  attributes  =  new  Attributes();  while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.isEmpty())  {  Attribute  attribute  =  parseAttribute();  if  (attribute  !=  null)  attributes.put(attribute);  }    Tag  tag  =  Tag.valueOf(tagName);  Element  child  =  new  Element(tag,  baseUri,  attributes);          [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  tagName.length  (  )  ==  0  )  {	[BUGGY]  if  (  tagName.substring(  )  ==  0)  {  [CONTEXT]  private  void  parseEndTag()  {  tq.consume( "</ ");  String  tagName  =  tq.consumeWord();  tq.chompTo( "> ");    if  (tagName.length()  !=  0)  {  Tag  tag  =  Tag.valueOf(tagName);  popStackToClose(tag);  }  }    private  void  parseStartTag()  {  tq.consume( "< ");  String  tagName  =  tq.consumeWord();    [BUGGY]  if(  tagName.substring  ()==  0  ){  tq.addFirst( "&lt; ");  parseTextNode();  return;  }    Attributes  attributes  =  new  Attributes();  while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.isEmpty())  {  Attribute  attribute  =  parseAttribute();  if  (attribute  !=  null)  attributes.put(attribute);  }    Tag  tag  =  Tag.valueOf(tagName);  Element  child  =  new  Element(tag,  baseUri,  attributes);          [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  tagName.length  (  )  ==  0  )  {	[BUGGY]  if  (  tagName  .endsWith(  DQ)    ==  0)  {  [CONTEXT]  private  void  parseEndTag()  {  tq.consume( "</ ");  String  tagName  =  tq.consumeWord();  tq.chompTo( "> ");    if  (tagName.length()  !=  0)  {  Tag  tag  =  Tag.valueOf(tagName);  popStackToClose(tag);  }  }    private  void  parseStartTag()  {  tq.consume( "< ");  String  tagName  =  tq.consumeWord();    [BUGGY]  if(  tagName  .endsWith  (  DQ  )  ==  0  ){  tq.addFirst( "&lt; ");  parseTextNode();  return;  }    Attributes  attributes  =  new  Attributes();  while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.isEmpty())  {  Attribute  attribute  =  parseAttribute();  if  (attribute  !=  null)  attributes.put(attribute);  }    Tag  tag  =  Tag.valueOf(tagName);  Element  child  =  new  Element(tag,  baseUri,  attributes);          [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  tagName.length  (  )  ==  0  )  {	[BUGGY]  if  (  tagName.length(  )  ==  0  )  {  [CONTEXT]  private  void  parseEndTag()  {  tq.consume( "</ ");  String  tagName  =  tq.consumeWord();  tq.chompTo( "> ");    if  (tagName.length()  !=  0)  {  Tag  tag  =  Tag.valueOf(tagName);  popStackToClose(tag);  }  }    private  void  parseStartTag()  {  tq.consume( "< ");  String  tagName  =  tq.consumeWord();    [BUGGY]  if(  tagName.length  ()==  0){  tq.addFirst( "&lt; ");  parseTextNode();  return;  }    Attributes  attributes  =  new  Attributes();  while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.isEmpty())  {  Attribute  attribute  =  parseAttribute();  if  (attribute  !=  null)  attributes.put(attribute);  }    Tag  tag  =  Tag.valueOf(tagName);  Element  child  =  new  Element(tag,  baseUri,  attributes);          [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  tagName.length  (  )  ==  0  )  {	[BUGGY]  if  (  href.length(  )  !=  0)  {  [CONTEXT]  private  void  parseEndTag()  {  tq.consume( "</ ");  String  tagName  =  tq.consumeWord();  tq.chompTo( "> ");    if  (tagName.length()  !=  0)  {  Tag  tag  =  Tag.valueOf(tagName);  popStackToClose(tag);  }  }    private  void  parseStartTag()  {  tq.consume( "< ");  String  tagName  =  tq.consumeWord();    [BUGGY]  if(  href.length  ()!=  0  ){  tq.addFirst( "&lt; ");  parseTextNode();  return;  }    Attributes  attributes  =  new  Attributes();  while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.isEmpty())  {  Attribute  attribute  =  parseAttribute();  if  (attribute  !=  null)  attributes.put(attribute);  }    Tag  tag  =  Tag.valueOf(tagName);  Element  child  =  new  Element(tag,  baseUri,  attributes);          [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  tagName.length  (  )  ==  0  )  {  tq.addFirst  (   "&lt; "  )  ;  parseTextNode  (  )  ;  return;  }	[BUGGY]  tq.addFirst( "&lt; ");  parseTextNode();  return  ;  [CONTEXT]  private  void  parseEndTag()  {  tq.consume( "</ ");  String  tagName  =  tq.consumeWord();  tq.chompTo( "> ");    if  (tagName.length()  !=  0)  {  Tag  tag  =  Tag.valueOf(tagName);  popStackToClose(tag);  }  }    private  void  parseStartTag()  {  tq.consume( "< ");  String  tagName  =  tq.consumeWord();    [BUGGY]  if  (tagName.length()  ==  0)  {  //  doesn't  look  like  a  start  tag  after  all;  put  <  back  on  stack  and  handle  as  text    tq.addFirst( "&lt; ");  parseTextNode();  return  ;          Attributes  attributes  =  new  Attributes();  while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.isEmpty())  {  Attribute  attribute  =  parseAttribute();  if  (attribute  !=  null)  attributes.put(attribute);  }    Tag  tag  =  Tag.valueOf(tagName);  Element  child  =  new  Element(tag,  baseUri,  attributes);        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  tagName.length  (  )  ==  0  )  {  tq.addFirst  (   "&lt; "  )  ;  parseTextNode  (  )  ;  return;  }	[BUGGY]    [CONTEXT]  private  void  parseEndTag()  {  tq.consume( "</ ");  String  tagName  =  tq.consumeWord();  tq.chompTo( "> ");    if  (tagName.length()  !=  0)  {  Tag  tag  =  Tag.valueOf(tagName);  popStackToClose(tag);  }  }    private  void  parseStartTag()  {  tq.consume( "< ");  String  tagName  =  tq.consumeWord();    [BUGGY]  if  (tagName.length()  ==  0)  {  //  doesn't  look  like  a  start  tag  after  all;  put  <  back  on  stack  and  handle  as  text              Attributes  attributes  =  new  Attributes();  while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.isEmpty())  {  Attribute  attribute  =  parseAttribute();  if  (attribute  !=  null)  attributes.put(attribute);  }    Tag  tag  =  Tag.valueOf(tagName);  Element  child  =  new  Element(tag,  baseUri,  attributes);        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.addFirst  (   "&lt; "  )  ;	[BUGGY]  tq.addFirst(   "&lt;lt ");  [CONTEXT]  tq.consume( "</ ");  String  tagName  =  tq.consumeWord();  tq.chompTo( "> ");    if  (tagName.length()  !=  0)  {  Tag  tag  =  Tag.valueOf(tagName);  popStackToClose(tag);  }  }    private  void  parseStartTag()  {  tq.consume( "< ");  String  tagName  =  tq.consumeWord();    if  (tagName.length()  ==  0)  {  //  doesn't  look  like  a  start  tag  after  all;  put  <  back  on  stack  and  handle  as  text  [BUGGY]  tq.addFirst  (   "&lt;lt "  )  ;  parseTextNode();  return;  }    Attributes  attributes  =  new  Attributes();  while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.isEmpty())  {  Attribute  attribute  =  parseAttribute();  if  (attribute  !=  null)  attributes.put(attribute);  }    Tag  tag  =  Tag.valueOf(tagName);  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.addFirst  (   "&lt; "  )  ;	[BUGGY]  tq.matches(   "&lt; ");  [CONTEXT]  tq.consume( "</ ");  String  tagName  =  tq.consumeWord();  tq.chompTo( "> ");    if  (tagName.length()  !=  0)  {  Tag  tag  =  Tag.valueOf(tagName);  popStackToClose(tag);  }  }    private  void  parseStartTag()  {  tq.consume( "< ");  String  tagName  =  tq.consumeWord();    if  (tagName.length()  ==  0)  {  //  doesn't  look  like  a  start  tag  after  all;  put  <  back  on  stack  and  handle  as  text  [BUGGY]  tq.matches  (   "&lt; "  )  ;  parseTextNode();  return;  }    Attributes  attributes  =  new  Attributes();  while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.isEmpty())  {  Attribute  attribute  =  parseAttribute();  if  (attribute  !=  null)  attributes.put(attribute);  }    Tag  tag  =  Tag.valueOf(tagName);  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.addFirst  (   "&lt; "  )  ;	[BUGGY]  tq  .matchesWhitespace(  )  ;  [CONTEXT]  tq.consume( "</ ");  String  tagName  =  tq.consumeWord();  tq.chompTo( "> ");    if  (tagName.length()  !=  0)  {  Tag  tag  =  Tag.valueOf(tagName);  popStackToClose(tag);  }  }    private  void  parseStartTag()  {  tq.consume( "< ");  String  tagName  =  tq.consumeWord();    if  (tagName.length()  ==  0)  {  //  doesn't  look  like  a  start  tag  after  all;  put  <  back  on  stack  and  handle  as  text  [BUGGY]  tq  .matchesWhitespace  ();  parseTextNode();  return;  }    Attributes  attributes  =  new  Attributes();  while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.isEmpty())  {  Attribute  attribute  =  parseAttribute();  if  (attribute  !=  null)  attributes.put(attribute);  }    Tag  tag  =  Tag.valueOf(tagName);  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.addFirst  (   "&lt; "  )  ;  parseTextNode  (  )  ;	[BUGGY]    [CONTEXT]  tq.consume( "</ ");  String  tagName  =  tq.consumeWord();  tq.chompTo( "> ");    if  (tagName.length()  !=  0)  {  Tag  tag  =  Tag.valueOf(tagName);  popStackToClose(tag);  }  }    private  void  parseStartTag()  {  tq.consume( "< ");  String  tagName  =  tq.consumeWord();    if  (tagName.length()  ==  0)  {  //  doesn't  look  like  a  start  tag  after  all;  put  <  back  on  stack  and  handle  as  text  [BUGGY]  tq.addFirst( "&lt; ");      return;  }    Attributes  attributes  =  new  Attributes();  while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.isEmpty())  {  Attribute  attribute  =  parseAttribute();  if  (attribute  !=  null)  attributes.put(attribute);  }    Tag  tag  =  Tag.valueOf(tagName);  Element  child  =  new  Element(tag,  baseUri,  attributes);          [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
parseTextNode  (  )  ;	[BUGGY]  parseAttribute(  );  [CONTEXT]  String  tagName  =  tq.consumeWord();  tq.chompTo( "> ");    if  (tagName.length()  !=  0)  {  Tag  tag  =  Tag.valueOf(tagName);  popStackToClose(tag);  }  }    private  void  parseStartTag()  {  tq.consume( "< ");  String  tagName  =  tq.consumeWord();    if  (tagName.length()  ==  0)  {  //  doesn't  look  like  a  start  tag  after  all;  put  <  back  on  stack  and  handle  as  text  tq.addFirst( "&lt; ");  [BUGGY]  parseAttribute  ()  ;  return;  }    Attributes  attributes  =  new  Attributes();  while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.isEmpty())  {  Attribute  attribute  =  parseAttribute();  if  (attribute  !=  null)  attributes.put(attribute);  }    Tag  tag  =  Tag.valueOf(tagName);  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
parseTextNode  (  )  ;	[BUGGY]    [CONTEXT]  String  tagName  =  tq.consumeWord();  tq.chompTo( "> ");    if  (tagName.length()  !=  0)  {  Tag  tag  =  Tag.valueOf(tagName);  popStackToClose(tag);  }  }    private  void  parseStartTag()  {  tq.consume( "< ");  String  tagName  =  tq.consumeWord();    if  (tagName.length()  ==  0)  {  //  doesn't  look  like  a  start  tag  after  all;  put  <  back  on  stack  and  handle  as  text  tq.addFirst( "&lt; ");  [BUGGY]  parseTextNode();    return;  }    Attributes  attributes  =  new  Attributes();  while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.isEmpty())  {  Attribute  attribute  =  parseAttribute();  if  (attribute  !=  null)  attributes.put(attribute);  }    Tag  tag  =  Tag.valueOf(tagName);  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
parseTextNode  (  )  ;	[BUGGY]    parseTextNode(  );  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
parseTextNode  (  )  ;	[BUGGY]  parseComment(  );parseTextNode(  );  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
parseTextNode  (  )  ;	[BUGGY]  parseCdata(  );parseTextNode(  );  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
parseTextNode  (  )  ;	[BUGGY]  parseEndTag(  );parseTextNode(  );  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
parseTextNode  (  )  ;	[BUGGY]  parseStartTag(  );parseTextNode(  );  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
parseTextNode  (  )  ;	[BUGGY]  parseXmlDecl(  );parseTextNode(  );  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  tagName.length  (  )  ==  0  )  {	[BUGGY]  if  (  tagName.length()  -  0    ==  0)  {  [CONTEXT]  private  void  parseEndTag()  {  tq.consume( "</ ");  String  tagName  =  tq.consumeWord();  tq.chompTo( "> ");    if  (tagName.length()  !=  0)  {  Tag  tag  =  Tag.valueOf(tagName);  popStackToClose(tag);  }  }    private  void  parseStartTag()  {  tq.consume( "< ");  String  tagName  =  tq.consumeWord();    [BUGGY]  if(  tagName.length()  -  0==  0  ){  tq.addFirst( "&lt; ");  parseTextNode();  return;  }    Attributes  attributes  =  new  Attributes();  while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.isEmpty())  {  Attribute  attribute  =  parseAttribute();  if  (attribute  !=  null)  attributes.put(attribute);  }    Tag  tag  =  Tag.valueOf(tagName);  Element  child  =  new  Element(tag,  baseUri,  attributes);          [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  tagName.length  (  )  ==  0  )  {	[BUGGY]  if  (  tagName  .endsWith(  tagName)    ==  0)  {  [CONTEXT]  private  void  parseEndTag()  {  tq.consume( "</ ");  String  tagName  =  tq.consumeWord();  tq.chompTo( "> ");    if  (tagName.length()  !=  0)  {  Tag  tag  =  Tag.valueOf(tagName);  popStackToClose(tag);  }  }    private  void  parseStartTag()  {  tq.consume( "< ");  String  tagName  =  tq.consumeWord();    [BUGGY]  if(  tagName  .endsWith  (  tagName  )  ==  0  ){  tq.addFirst( "&lt; ");  parseTextNode();  return;  }    Attributes  attributes  =  new  Attributes();  while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.isEmpty())  {  Attribute  attribute  =  parseAttribute();  if  (attribute  !=  null)  attributes.put(attribute);  }    Tag  tag  =  Tag.valueOf(tagName);  Element  child  =  new  Element(tag,  baseUri,  attributes);          [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  tagName.length  (  )  ==  0  )  {	[BUGGY]  if  (  href.substring(  )  ==  0)  {  [CONTEXT]  private  void  parseEndTag()  {  tq.consume( "</ ");  String  tagName  =  tq.consumeWord();  tq.chompTo( "> ");    if  (tagName.length()  !=  0)  {  Tag  tag  =  Tag.valueOf(tagName);  popStackToClose(tag);  }  }    private  void  parseStartTag()  {  tq.consume( "< ");  String  tagName  =  tq.consumeWord();    [BUGGY]  if(  href.substring  ()==  0  ){  tq.addFirst( "&lt; ");  parseTextNode();  return;  }    Attributes  attributes  =  new  Attributes();  while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.isEmpty())  {  Attribute  attribute  =  parseAttribute();  if  (attribute  !=  null)  attributes.put(attribute);  }    Tag  tag  =  Tag.valueOf(tagName);  Element  child  =  new  Element(tag,  baseUri,  attributes);          [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.addFirst  (   "&lt; "  )  ;	[BUGGY]  tq.addFirst(   "t ");  [CONTEXT]  tq.consume( "</ ");  String  tagName  =  tq.consumeWord();  tq.chompTo( "> ");    if  (tagName.length()  !=  0)  {  Tag  tag  =  Tag.valueOf(tagName);  popStackToClose(tag);  }  }    private  void  parseStartTag()  {  tq.consume( "< ");  String  tagName  =  tq.consumeWord();    if  (tagName.length()  ==  0)  {  //  doesn't  look  like  a  start  tag  after  all;  put  <  back  on  stack  and  handle  as  text  [BUGGY]  tq.addFirst  (   "t "  )  ;  parseTextNode();  return;  }    Attributes  attributes  =  new  Attributes();  while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.isEmpty())  {  Attribute  attribute  =  parseAttribute();  if  (attribute  !=  null)  attributes.put(attribute);  }    Tag  tag  =  Tag.valueOf(tagName);  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.addFirst  (   "&lt; "  )  ;	[BUGGY]    [CONTEXT]  tq.consume( "</ ");  String  tagName  =  tq.consumeWord();  tq.chompTo( "> ");    if  (tagName.length()  !=  0)  {  Tag  tag  =  Tag.valueOf(tagName);  popStackToClose(tag);  }  }    private  void  parseStartTag()  {  tq.consume( "< ");  String  tagName  =  tq.consumeWord();    if  (tagName.length()  ==  0)  {  //  doesn't  look  like  a  start  tag  after  all;  put  <  back  on  stack  and  handle  as  text  [BUGGY]  tq.addFirst( "&lt; ");    parseTextNode();  return;  }    Attributes  attributes  =  new  Attributes();  while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.isEmpty())  {  Attribute  attribute  =  parseAttribute();  if  (attribute  !=  null)  attributes.put(attribute);  }    Tag  tag  =  Tag.valueOf(tagName);  Element  child  =  new  Element(tag,  baseUri,  attributes);          [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
parseTextNode  (  )  ;  return;	[BUGGY]    [CONTEXT]  String  tagName  =  tq.consumeWord();  tq.chompTo( "> ");    if  (tagName.length()  !=  0)  {  Tag  tag  =  Tag.valueOf(tagName);  popStackToClose(tag);  }  }    private  void  parseStartTag()  {  tq.consume( "< ");  String  tagName  =  tq.consumeWord();    if  (tagName.length()  ==  0)  {  //  doesn't  look  like  a  start  tag  after  all;  put  <  back  on  stack  and  handle  as  text  tq.addFirst( "&lt; ");  [BUGGY]  parseTextNode();      }    Attributes  attributes  =  new  Attributes();  while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.isEmpty())  {  Attribute  attribute  =  parseAttribute();  if  (attribute  !=  null)  attributes.put(attribute);  }    Tag  tag  =  Tag.valueOf(tagName);  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
parseTextNode  (  )  ;	[BUGGY]  return;  parseTextNode(  );  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
while  (  !tq.matchesAny  (   "< ",   "/> ",   "> "  )  &&  !tq.isEmpty  (  )  )  {	[BUGGY]  while  (  !tq.matchesAny(   "< ",   "/> ",   "> ")  ||  !tq.isEmpty(  ))  {  [CONTEXT]  popStackToClose(tag);  }  }    private  void  parseStartTag()  {  tq.consume( "< ");  String  tagName  =  tq.consumeWord();    if  (tagName.length()  ==  0)  {  //  doesn't  look  like  a  start  tag  after  all;  put  <  back  on  stack  and  handle  as  text  tq.addFirst( "&lt; ");  parseTextNode();  return;  }    Attributes  attributes  =  new  Attributes();  [BUGGY]  while(  !tq.matchesAny  (   "< ",   "/> ",   "> "  )||  !tq.isEmpty  ()){  Attribute  attribute  =  parseAttribute();  if  (attribute  !=  null)  attributes.put(attribute);  }    Tag  tag  =  Tag.valueOf(tagName);  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }          [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
while  (  !tq.matchesAny  (   "< ",   "/> ",   "> "  )  &&  !tq.isEmpty  (  )  )  {	[BUGGY]  while  (  !tq.matchesAny(   " ",   "/> ",   "> ")  &&  !tq.isEmpty(  ))  {  [CONTEXT]  popStackToClose(tag);  }  }    private  void  parseStartTag()  {  tq.consume( "< ");  String  tagName  =  tq.consumeWord();    if  (tagName.length()  ==  0)  {  //  doesn't  look  like  a  start  tag  after  all;  put  <  back  on  stack  and  handle  as  text  tq.addFirst( "&lt; ");  parseTextNode();  return;  }    Attributes  attributes  =  new  Attributes();  [BUGGY]  while(  !tq.matchesAny  (   " ",   "/> ",   "> "  )&&  !tq.isEmpty  ()){  Attribute  attribute  =  parseAttribute();  if  (attribute  !=  null)  attributes.put(attribute);  }    Tag  tag  =  Tag.valueOf(tagName);  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }          [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
while  (  !tq.matchesAny  (   "< ",   "/> ",   "> "  )  &&  !tq.isEmpty  (  )  )  {	[BUGGY]  while  (  !tq.matchesAny(   "< ",   " ",   "> ")  &&  !tq.isEmpty(  ))  {  [CONTEXT]  popStackToClose(tag);  }  }    private  void  parseStartTag()  {  tq.consume( "< ");  String  tagName  =  tq.consumeWord();    if  (tagName.length()  ==  0)  {  //  doesn't  look  like  a  start  tag  after  all;  put  <  back  on  stack  and  handle  as  text  tq.addFirst( "&lt; ");  parseTextNode();  return;  }    Attributes  attributes  =  new  Attributes();  [BUGGY]  while(  !tq.matchesAny  (   "< ",   " ",   "> "  )&&  !tq.isEmpty  ()){  Attribute  attribute  =  parseAttribute();  if  (attribute  !=  null)  attributes.put(attribute);  }    Tag  tag  =  Tag.valueOf(tagName);  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }          [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
while  (  !tq.matchesAny  (   "< ",   "/> ",   "> "  )  &&  !tq.isEmpty  (  )  )  {	[BUGGY]  while  (  !tq.matchesAny(   "< ",   "/> ",   " ")  &&  !tq.isEmpty(  ))  {  [CONTEXT]  popStackToClose(tag);  }  }    private  void  parseStartTag()  {  tq.consume( "< ");  String  tagName  =  tq.consumeWord();    if  (tagName.length()  ==  0)  {  //  doesn't  look  like  a  start  tag  after  all;  put  <  back  on  stack  and  handle  as  text  tq.addFirst( "&lt; ");  parseTextNode();  return;  }    Attributes  attributes  =  new  Attributes();  [BUGGY]  while(  !tq.matchesAny  (   "< ",   "/> ",   " "  )&&  !tq.isEmpty  ()){  Attribute  attribute  =  parseAttribute();  if  (attribute  !=  null)  attributes.put(attribute);  }    Tag  tag  =  Tag.valueOf(tagName);  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }          [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
while  (  !tq.matchesAny  (   "< ",   "/> ",   "> "  )  &&  !tq.isEmpty  (  )  )  {	[BUGGY]  while  (  !tq  .matches(  html)    &&  !tq.isEmpty(  ))  {  [CONTEXT]  popStackToClose(tag);  }  }    private  void  parseStartTag()  {  tq.consume( "< ");  String  tagName  =  tq.consumeWord();    if  (tagName.length()  ==  0)  {  //  doesn't  look  like  a  start  tag  after  all;  put  <  back  on  stack  and  handle  as  text  tq.addFirst( "&lt; ");  parseTextNode();  return;  }    Attributes  attributes  =  new  Attributes();  [BUGGY]  while(  !tq  .matches  (  html  )  &&  !tq.isEmpty  ()){  Attribute  attribute  =  parseAttribute();  if  (attribute  !=  null)  attributes.put(attribute);  }    Tag  tag  =  Tag.valueOf(tagName);  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }          [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
while  (  !tq.matchesAny  (   "< ",   "/> ",   "> "  )  &&  !tq.isEmpty  (  )  )  {	[BUGGY]  while  (  !tq.matchesAny(   "< ",   "/> ",   "> ")  &&  !tq.chompTo(  ))  {  [CONTEXT]  popStackToClose(tag);  }  }    private  void  parseStartTag()  {  tq.consume( "< ");  String  tagName  =  tq.consumeWord();    if  (tagName.length()  ==  0)  {  //  doesn't  look  like  a  start  tag  after  all;  put  <  back  on  stack  and  handle  as  text  tq.addFirst( "&lt; ");  parseTextNode();  return;  }    Attributes  attributes  =  new  Attributes();  [BUGGY]  while(  !tq.matchesAny  (   "< ",   "/> ",   "> "  )&&  !tq.chompTo  ()){  Attribute  attribute  =  parseAttribute();  if  (attribute  !=  null)  attributes.put(attribute);  }    Tag  tag  =  Tag.valueOf(tagName);  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }          [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
while  (  !tq.matchesAny  (   "< ",   "/> ",   "> "  )  &&  !tq.isEmpty  (  )  )  {	[BUGGY]  while  (  !tq.matchesAny(   "< ",   "/> ",   "> ")  &&  !tq  .chompTo(  SQ)  )  {  [CONTEXT]  popStackToClose(tag);  }  }    private  void  parseStartTag()  {  tq.consume( "< ");  String  tagName  =  tq.consumeWord();    if  (tagName.length()  ==  0)  {  //  doesn't  look  like  a  start  tag  after  all;  put  <  back  on  stack  and  handle  as  text  tq.addFirst( "&lt; ");  parseTextNode();  return;  }    Attributes  attributes  =  new  Attributes();  [BUGGY]  while(  !tq.matchesAny  (   "< ",   "/> ",   "> "  )&&  !tq  .chompTo  (  SQ  )  ){  Attribute  attribute  =  parseAttribute();  if  (attribute  !=  null)  attributes.put(attribute);  }    Tag  tag  =  Tag.valueOf(tagName);  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }          [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  attribute  !=  null  )  attributes.put  (  attribute  )  ;	[BUGGY]  if  (  attribute  ==  null)attributes.put(  attribute);  [CONTEXT]  }    private  void  parseStartTag()  {  tq.consume( "< ");  String  tagName  =  tq.consumeWord();    if  (tagName.length()  ==  0)  {  //  doesn't  look  like  a  start  tag  after  all;  put  <  back  on  stack  and  handle  as  text  tq.addFirst( "&lt; ");  parseTextNode();  return;  }    Attributes  attributes  =  new  Attributes();  while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.isEmpty())  {  Attribute  attribute  =  parseAttribute();  [BUGGY]  if(  attribute  ==  null  )  attributes.put  (  attribute  )  ;    }    Tag  tag  =  Tag.valueOf(tagName);  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  attribute  !=  null  )  attributes.put  (  attribute  )  ;	[BUGGY]  if  (  attributes  !=  null)attribute.put(  attribute);  [CONTEXT]  }    private  void  parseStartTag()  {  tq.consume( "< ");  String  tagName  =  tq.consumeWord();    if  (tagName.length()  ==  0)  {  //  doesn't  look  like  a  start  tag  after  all;  put  <  back  on  stack  and  handle  as  text  tq.addFirst( "&lt; ");  parseTextNode();  return;  }    Attributes  attributes  =  new  Attributes();  while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.isEmpty())  {  Attribute  attribute  =  parseAttribute();  [BUGGY]  if(  attributes  !=  null  )  attribute.put  (  attribute  )  ;    }    Tag  tag  =  Tag.valueOf(tagName);  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  attribute  !=  null  )  attributes.put  (  attribute  )  ;	[BUGGY]  if  (  attribute  !=  true)attributes.put(  attribute);  [CONTEXT]  }    private  void  parseStartTag()  {  tq.consume( "< ");  String  tagName  =  tq.consumeWord();    if  (tagName.length()  ==  0)  {  //  doesn't  look  like  a  start  tag  after  all;  put  <  back  on  stack  and  handle  as  text  tq.addFirst( "&lt; ");  parseTextNode();  return;  }    Attributes  attributes  =  new  Attributes();  while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.isEmpty())  {  Attribute  attribute  =  parseAttribute();  [BUGGY]  if(  attribute  !=  true  )  attributes.put  (  attribute  )  ;    }    Tag  tag  =  Tag.valueOf(tagName);  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  attribute  !=  null  )  attributes.put  (  attribute  )  ;  }	[BUGGY]  attributes.put(attribute);  [CONTEXT]  }    private  void  parseStartTag()  {  tq.consume( "< ");  String  tagName  =  tq.consumeWord();    if  (tagName.length()  ==  0)  {  //  doesn't  look  like  a  start  tag  after  all;  put  <  back  on  stack  and  handle  as  text  tq.addFirst( "&lt; ");  parseTextNode();  return;  }    Attributes  attributes  =  new  Attributes();  while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.isEmpty())  {  Attribute  attribute  =  parseAttribute();  [BUGGY]  if  (attribute  !=  null)    attributes.put(attribute);      Tag  tag  =  Tag.valueOf(tagName);  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }              [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  attribute  !=  null  )  attributes.put  (  attribute  )  ;  }	[BUGGY]    [CONTEXT]  }    private  void  parseStartTag()  {  tq.consume( "< ");  String  tagName  =  tq.consumeWord();    if  (tagName.length()  ==  0)  {  //  doesn't  look  like  a  start  tag  after  all;  put  <  back  on  stack  and  handle  as  text  tq.addFirst( "&lt; ");  parseTextNode();  return;  }    Attributes  attributes  =  new  Attributes();  while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.isEmpty())  {  Attribute  attribute  =  parseAttribute();  [BUGGY]  if  (attribute  !=  null)          Tag  tag  =  Tag.valueOf(tagName);  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }              [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
attributes.put  (  attribute  )  ;	[BUGGY]  attributes  .Attributes(  )  ;  [CONTEXT]    private  void  parseStartTag()  {  tq.consume( "< ");  String  tagName  =  tq.consumeWord();    if  (tagName.length()  ==  0)  {  //  doesn't  look  like  a  start  tag  after  all;  put  <  back  on  stack  and  handle  as  text  tq.addFirst( "&lt; ");  parseTextNode();  return;  }    Attributes  attributes  =  new  Attributes();  while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.isEmpty())  {  Attribute  attribute  =  parseAttribute();  if  (attribute  !=  null)  [BUGGY]  attributes  .Attributes  ();  }    Tag  tag  =  Tag.valueOf(tagName);  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
attributes.put  (  attribute  )  ;	[BUGGY]    [CONTEXT]    private  void  parseStartTag()  {  tq.consume( "< ");  String  tagName  =  tq.consumeWord();    if  (tagName.length()  ==  0)  {  //  doesn't  look  like  a  start  tag  after  all;  put  <  back  on  stack  and  handle  as  text  tq.addFirst( "&lt; ");  parseTextNode();  return;  }    Attributes  attributes  =  new  Attributes();  while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.isEmpty())  {  Attribute  attribute  =  parseAttribute();  if  (attribute  !=  null)  [BUGGY]  attributes.put(attribute);    }    Tag  tag  =  Tag.valueOf(tagName);  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Attribute  attribute  =  parseAttribute  (  )  ;	[BUGGY]  Attribute  attribute  =  parseStartTag(  );  [CONTEXT]  }  }    private  void  parseStartTag()  {  tq.consume( "< ");  String  tagName  =  tq.consumeWord();    if  (tagName.length()  ==  0)  {  //  doesn't  look  like  a  start  tag  after  all;  put  <  back  on  stack  and  handle  as  text  tq.addFirst( "&lt; ");  parseTextNode();  return;  }    Attributes  attributes  =  new  Attributes();  while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.isEmpty())  {  [BUGGY]  Attribute  attribute  =  parseStartTag  ()  ;  if  (attribute  !=  null)  attributes.put(attribute);  }    Tag  tag  =  Tag.valueOf(tagName);  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }              [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Attribute  attribute  =  parseAttribute  (  )  ;	[BUGGY]    [CONTEXT]  }  }    private  void  parseStartTag()  {  tq.consume( "< ");  String  tagName  =  tq.consumeWord();    if  (tagName.length()  ==  0)  {  //  doesn't  look  like  a  start  tag  after  all;  put  <  back  on  stack  and  handle  as  text  tq.addFirst( "&lt; ");  parseTextNode();  return;  }    Attributes  attributes  =  new  Attributes();  while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.isEmpty())  {  [BUGGY]  Attribute  attribute  =  parseAttribute();    if  (attribute  !=  null)  attributes.put(attribute);  }    Tag  tag  =  Tag.valueOf(tagName);  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }          [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  attribute  !=  null  )  attributes.put  (  attribute  )  ;	[BUGGY]  if  (  attribute  !=  null)attributes  .Attributes(  )  ;  [CONTEXT]  }    private  void  parseStartTag()  {  tq.consume( "< ");  String  tagName  =  tq.consumeWord();    if  (tagName.length()  ==  0)  {  //  doesn't  look  like  a  start  tag  after  all;  put  <  back  on  stack  and  handle  as  text  tq.addFirst( "&lt; ");  parseTextNode();  return;  }    Attributes  attributes  =  new  Attributes();  while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.isEmpty())  {  Attribute  attribute  =  parseAttribute();  [BUGGY]  if(  attribute  !=  null  )  attributes  .Attributes  ();    }    Tag  tag  =  Tag.valueOf(tagName);  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
while  (  !tq.matchesAny  (   "< ",   "/> ",   "> "  )  &&  !tq.isEmpty  (  )  )  {	[BUGGY]  while  (  !tq.matchesAny(   "< ",   "/ ",   "> ")  &&  !tq.isEmpty(  ))  {  [CONTEXT]  popStackToClose(tag);  }  }    private  void  parseStartTag()  {  tq.consume( "< ");  String  tagName  =  tq.consumeWord();    if  (tagName.length()  ==  0)  {  //  doesn't  look  like  a  start  tag  after  all;  put  <  back  on  stack  and  handle  as  text  tq.addFirst( "&lt; ");  parseTextNode();  return;  }    Attributes  attributes  =  new  Attributes();  [BUGGY]  while(  !tq.matchesAny  (   "< ",   "/ ",   "> "  )&&  !tq.isEmpty  ()){  Attribute  attribute  =  parseAttribute();  if  (attribute  !=  null)  attributes.put(attribute);  }    Tag  tag  =  Tag.valueOf(tagName);  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }          [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
while  (  !tq.matchesAny  (   "< ",   "/> ",   "> "  )  &&  !tq.isEmpty  (  )  )  {	[BUGGY]  while  (  !tq  .matches(  baseUri)    &&  !tq.isEmpty(  ))  {  [CONTEXT]  popStackToClose(tag);  }  }    private  void  parseStartTag()  {  tq.consume( "< ");  String  tagName  =  tq.consumeWord();    if  (tagName.length()  ==  0)  {  //  doesn't  look  like  a  start  tag  after  all;  put  <  back  on  stack  and  handle  as  text  tq.addFirst( "&lt; ");  parseTextNode();  return;  }    Attributes  attributes  =  new  Attributes();  [BUGGY]  while(  !tq  .matches  (  baseUri  )  &&  !tq.isEmpty  ()){  Attribute  attribute  =  parseAttribute();  if  (attribute  !=  null)  attributes.put(attribute);  }    Tag  tag  =  Tag.valueOf(tagName);  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }          [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
while  (  !tq.matchesAny  (   "< ",   "/> ",   "> "  )  &&  !tq.isEmpty  (  )  )  {  Attribute  attribute  =  parseAttribute  (  )  ;	[BUGGY]    [CONTEXT]  popStackToClose(tag);  }  }    private  void  parseStartTag()  {  tq.consume( "< ");  String  tagName  =  tq.consumeWord();    if  (tagName.length()  ==  0)  {  //  doesn't  look  like  a  start  tag  after  all;  put  <  back  on  stack  and  handle  as  text  tq.addFirst( "&lt; ");  parseTextNode();  return;  }    Attributes  attributes  =  new  Attributes();  [BUGGY]  while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.isEmpty())  {      if  (attribute  !=  null)  attributes.put(attribute);  }    Tag  tag  =  Tag.valueOf(tagName);  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
while  (  !tq.matchesAny  (   "< ",   "/> ",   "> "  )  &&  !tq.isEmpty  (  )  )  {	[BUGGY]  while  (  !tq.matchesAny(   "< ",   "/> ",   "> ")  &&  !tq.isEmpty(  ))  {  Attribute  attribute  =  parseAttribute(  );while  (  !tq.matchesAny(   "< ",   "/> ",   "> ")  &&  !tq.isEmpty(  ))  {  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Tag  tag  =  Tag.valueOf  (  tagName  )  ;	[BUGGY]  Tag  tag  =  Tag.valueOf(  data);  [CONTEXT]  String  tagName  =  tq.consumeWord();    if  (tagName.length()  ==  0)  {  //  doesn't  look  like  a  start  tag  after  all;  put  <  back  on  stack  and  handle  as  text  tq.addFirst( "&lt; ");  parseTextNode();  return;  }    Attributes  attributes  =  new  Attributes();  while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.isEmpty())  {  Attribute  attribute  =  parseAttribute();  if  (attribute  !=  null)  attributes.put(attribute);  }    [BUGGY]  Tag  tag  =  Tag.valueOf  (  data  )  ;  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Tag  tag  =  Tag.valueOf  (  tagName  )  ;	[BUGGY]  Tag  tag  =  Tag.equals(  tagName);  [CONTEXT]  String  tagName  =  tq.consumeWord();    if  (tagName.length()  ==  0)  {  //  doesn't  look  like  a  start  tag  after  all;  put  <  back  on  stack  and  handle  as  text  tq.addFirst( "&lt; ");  parseTextNode();  return;  }    Attributes  attributes  =  new  Attributes();  while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.isEmpty())  {  Attribute  attribute  =  parseAttribute();  if  (attribute  !=  null)  attributes.put(attribute);  }    [BUGGY]  Tag  tag  =  Tag.equals  (  tagName  )  ;  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Tag  tag  =  Tag.valueOf  (  tagName  )  ;	[BUGGY]  Tag  tag  =  Tag.valueOf(  html);  [CONTEXT]  String  tagName  =  tq.consumeWord();    if  (tagName.length()  ==  0)  {  //  doesn't  look  like  a  start  tag  after  all;  put  <  back  on  stack  and  handle  as  text  tq.addFirst( "&lt; ");  parseTextNode();  return;  }    Attributes  attributes  =  new  Attributes();  while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.isEmpty())  {  Attribute  attribute  =  parseAttribute();  if  (attribute  !=  null)  attributes.put(attribute);  }    [BUGGY]  Tag  tag  =  Tag.valueOf  (  html  )  ;  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Tag  tag  =  Tag.valueOf  (  tagName  )  ;	[BUGGY]  Tag  tag  =  Tag  .isValidParent(  bodyTag)  ;  [CONTEXT]  String  tagName  =  tq.consumeWord();    if  (tagName.length()  ==  0)  {  //  doesn't  look  like  a  start  tag  after  all;  put  <  back  on  stack  and  handle  as  text  tq.addFirst( "&lt; ");  parseTextNode();  return;  }    Attributes  attributes  =  new  Attributes();  while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.isEmpty())  {  Attribute  attribute  =  parseAttribute();  if  (attribute  !=  null)  attributes.put(attribute);  }    [BUGGY]  Tag  tag  =  Tag  .isValidParent  (  bodyTag  );  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Tag  tag  =  Tag.valueOf  (  tagName  )  ;	[BUGGY]  Tag  tag  =  Tag.equals(  data);  [CONTEXT]  String  tagName  =  tq.consumeWord();    if  (tagName.length()  ==  0)  {  //  doesn't  look  like  a  start  tag  after  all;  put  <  back  on  stack  and  handle  as  text  tq.addFirst( "&lt; ");  parseTextNode();  return;  }    Attributes  attributes  =  new  Attributes();  while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.isEmpty())  {  Attribute  attribute  =  parseAttribute();  if  (attribute  !=  null)  attributes.put(attribute);  }    [BUGGY]  Tag  tag  =  Tag.equals  (  data  )  ;  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Tag  tag  =  Tag.valueOf  (  tagName  )  ;  Element  child  =  new  Element  (  tag,  baseUri,  attributes  )  ;	[BUGGY]    [CONTEXT]  String  tagName  =  tq.consumeWord();    if  (tagName.length()  ==  0)  {  //  doesn't  look  like  a  start  tag  after  all;  put  <  back  on  stack  and  handle  as  text  tq.addFirst( "&lt; ");  parseTextNode();  return;  }    Attributes  attributes  =  new  Attributes();  while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.isEmpty())  {  Attribute  attribute  =  parseAttribute();  if  (attribute  !=  null)  attributes.put(attribute);  }    [BUGGY]  Tag  tag  =  Tag.valueOf(tagName);        boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");          [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Element  child  =  new  Element  (  tag,  baseUri,  attributes  )  ;	[BUGGY]  Element  child  =  new  Element(    baseUri,  attributes);  [CONTEXT]    if  (tagName.length()  ==  0)  {  //  doesn't  look  like  a  start  tag  after  all;  put  <  back  on  stack  and  handle  as  text  tq.addFirst( "&lt; ");  parseTextNode();  return;  }    Attributes  attributes  =  new  Attributes();  while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.isEmpty())  {  Attribute  attribute  =  parseAttribute();  if  (attribute  !=  null)  attributes.put(attribute);  }    Tag  tag  =  Tag.valueOf(tagName);  [BUGGY]  Element  child  =  new  Element  (baseUri,  attributes  )  ;    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Element  child  =  new  Element  (  tag,  baseUri,  attributes  )  ;	[BUGGY]  Element  child  =  new  Element(  tag,  baseUri);  [CONTEXT]    if  (tagName.length()  ==  0)  {  //  doesn't  look  like  a  start  tag  after  all;  put  <  back  on  stack  and  handle  as  text  tq.addFirst( "&lt; ");  parseTextNode();  return;  }    Attributes  attributes  =  new  Attributes();  while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.isEmpty())  {  Attribute  attribute  =  parseAttribute();  if  (attribute  !=  null)  attributes.put(attribute);  }    Tag  tag  =  Tag.valueOf(tagName);  [BUGGY]  Element  child  =  new  Element  (  tag,  baseUri  )  ;    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Element  child  =  new  Element  (  tag,  baseUri,  attributes  )  ;	[BUGGY]  Element  child  =  new  Element(  titleTag,  baseUri,  attributes);  [CONTEXT]    if  (tagName.length()  ==  0)  {  //  doesn't  look  like  a  start  tag  after  all;  put  <  back  on  stack  and  handle  as  text  tq.addFirst( "&lt; ");  parseTextNode();  return;  }    Attributes  attributes  =  new  Attributes();  while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.isEmpty())  {  Attribute  attribute  =  parseAttribute();  if  (attribute  !=  null)  attributes.put(attribute);  }    Tag  tag  =  Tag.valueOf(tagName);  [BUGGY]  Element  child  =  new  Element  (  titleTag,  baseUri,  attributes  )  ;    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Element  child  =  new  Element  (  tag,  baseUri,  attributes  )  ;	[BUGGY]  Element  child  =  new  Element(  baseUri,  tag,  attributes);  [CONTEXT]    if  (tagName.length()  ==  0)  {  //  doesn't  look  like  a  start  tag  after  all;  put  <  back  on  stack  and  handle  as  text  tq.addFirst( "&lt; ");  parseTextNode();  return;  }    Attributes  attributes  =  new  Attributes();  while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.isEmpty())  {  Attribute  attribute  =  parseAttribute();  if  (attribute  !=  null)  attributes.put(attribute);  }    Tag  tag  =  Tag.valueOf(tagName);  [BUGGY]  Element  child  =  new  Element  (  baseUri,  tag,  attributes  )  ;    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Element  child  =  new  Element  (  tag,  baseUri,  attributes  )  ;	[BUGGY]  Element  child  =  new  Element(  tag,  attributes,  baseUri);  [CONTEXT]    if  (tagName.length()  ==  0)  {  //  doesn't  look  like  a  start  tag  after  all;  put  <  back  on  stack  and  handle  as  text  tq.addFirst( "&lt; ");  parseTextNode();  return;  }    Attributes  attributes  =  new  Attributes();  while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.isEmpty())  {  Attribute  attribute  =  parseAttribute();  if  (attribute  !=  null)  attributes.put(attribute);  }    Tag  tag  =  Tag.valueOf(tagName);  [BUGGY]  Element  child  =  new  Element  (  tag,  attributes,  baseUri  )  ;    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Element  child  =  new  Element  (  tag,  baseUri,  attributes  )  ;	[BUGGY]  Element  child  =  new  Element(  tag,    attributes);  [CONTEXT]    if  (tagName.length()  ==  0)  {  //  doesn't  look  like  a  start  tag  after  all;  put  <  back  on  stack  and  handle  as  text  tq.addFirst( "&lt; ");  parseTextNode();  return;  }    Attributes  attributes  =  new  Attributes();  while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.isEmpty())  {  Attribute  attribute  =  parseAttribute();  if  (attribute  !=  null)  attributes.put(attribute);  }    Tag  tag  =  Tag.valueOf(tagName);  [BUGGY]  Element  child  =  new  Element  (  tag,attributes  )  ;    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Element  child  =  new  Element  (  tag,  baseUri,  attributes  )  ;	[BUGGY]  Element  child  =  new  Element(  tag,  tagName,  attributes);  [CONTEXT]    if  (tagName.length()  ==  0)  {  //  doesn't  look  like  a  start  tag  after  all;  put  <  back  on  stack  and  handle  as  text  tq.addFirst( "&lt; ");  parseTextNode();  return;  }    Attributes  attributes  =  new  Attributes();  while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.isEmpty())  {  Attribute  attribute  =  parseAttribute();  if  (attribute  !=  null)  attributes.put(attribute);  }    Tag  tag  =  Tag.valueOf(tagName);  [BUGGY]  Element  child  =  new  Element  (  tag,  tagName,  attributes  )  ;    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
boolean  isEmptyElement  =  tag.isEmpty  (  )  ;	[BUGGY]  boolean  isEmptyElement  =  titleTag.isEmpty(  );  [CONTEXT]  tq.addFirst( "&lt; ");  parseTextNode();  return;  }    Attributes  attributes  =  new  Attributes();  while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.isEmpty())  {  Attribute  attribute  =  parseAttribute();  if  (attribute  !=  null)  attributes.put(attribute);  }    Tag  tag  =  Tag.valueOf(tagName);  Element  child  =  new  Element(tag,  baseUri,  attributes);    [BUGGY]  boolean  isEmptyElement  =  titleTag.isEmpty  ()  ;  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
boolean  isEmptyElement  =  tag.isEmpty  (  )  ;	[BUGGY]  boolean  isEmptyElement  =  tag.valueOf(  );  [CONTEXT]  tq.addFirst( "&lt; ");  parseTextNode();  return;  }    Attributes  attributes  =  new  Attributes();  while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.isEmpty())  {  Attribute  attribute  =  parseAttribute();  if  (attribute  !=  null)  attributes.put(attribute);  }    Tag  tag  =  Tag.valueOf(tagName);  Element  child  =  new  Element(tag,  baseUri,  attributes);    [BUGGY]  boolean  isEmptyElement  =  tag.valueOf  ()  ;  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
boolean  isEmptyElement  =  tag.isEmpty  (  )  ;	[BUGGY]  boolean  isEmptyElement  =  tag  .chompTo(  bodyHtml)  ;  [CONTEXT]  tq.addFirst( "&lt; ");  parseTextNode();  return;  }    Attributes  attributes  =  new  Attributes();  while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.isEmpty())  {  Attribute  attribute  =  parseAttribute();  if  (attribute  !=  null)  attributes.put(attribute);  }    Tag  tag  =  Tag.valueOf(tagName);  Element  child  =  new  Element(tag,  baseUri,  attributes);    [BUGGY]  boolean  isEmptyElement  =  tag  .chompTo  (  bodyHtml  );  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
boolean  isEmptyElement  =  tag.isEmpty  (  )  ;	[BUGGY]  boolean  isEmptyElement  =  titleTag  .chompTo(  SQ)  ;  [CONTEXT]  tq.addFirst( "&lt; ");  parseTextNode();  return;  }    Attributes  attributes  =  new  Attributes();  while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.isEmpty())  {  Attribute  attribute  =  parseAttribute();  if  (attribute  !=  null)  attributes.put(attribute);  }    Tag  tag  =  Tag.valueOf(tagName);  Element  child  =  new  Element(tag,  baseUri,  attributes);    [BUGGY]  boolean  isEmptyElement  =  titleTag  .chompTo  (  SQ  );  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
boolean  isEmptyElement  =  tag.isEmpty  (  )  ;	[BUGGY]    [CONTEXT]  tq.addFirst( "&lt; ");  parseTextNode();  return;  }    Attributes  attributes  =  new  Attributes();  while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.isEmpty())  {  Attribute  attribute  =  parseAttribute();  if  (attribute  !=  null)  attributes.put(attribute);  }    Tag  tag  =  Tag.valueOf(tagName);  Element  child  =  new  Element(tag,  baseUri,  attributes);    [BUGGY]  boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>    if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  tq.matchChomp  (   "/> "  )  )  {	[BUGGY]  if  (  tq.matches(   "/> "))  {  [CONTEXT]  parseTextNode();  return;  }    Attributes  attributes  =  new  Attributes();  while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.isEmpty())  {  Attribute  attribute  =  parseAttribute();  if  (attribute  !=  null)  attributes.put(attribute);  }    Tag  tag  =  Tag.valueOf(tagName);  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  [BUGGY]  if(  tq.matches  (   "/> "  )){  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  tq.matchChomp  (   "/> "  )  )  {	[BUGGY]  if  (  tq  .matches(  html)  )  {  [CONTEXT]  parseTextNode();  return;  }    Attributes  attributes  =  new  Attributes();  while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.isEmpty())  {  Attribute  attribute  =  parseAttribute();  if  (attribute  !=  null)  attributes.put(attribute);  }    Tag  tag  =  Tag.valueOf(tagName);  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  [BUGGY]  if(  tq  .matches  (  html  )  ){  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  tq.matchChomp  (   "/> "  )  )  {	[BUGGY]  if  (  tq.matchChomp(   "= "))  {  [CONTEXT]  parseTextNode();  return;  }    Attributes  attributes  =  new  Attributes();  while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.isEmpty())  {  Attribute  attribute  =  parseAttribute();  if  (attribute  !=  null)  attributes.put(attribute);  }    Tag  tag  =  Tag.valueOf(tagName);  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  [BUGGY]  if(  tq.matchChomp  (   "= "  )){  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  tq.matchChomp  (   "/> "  )  )  {	[BUGGY]  if  (  tq.matchChomp(  SQ))  {  [CONTEXT]  parseTextNode();  return;  }    Attributes  attributes  =  new  Attributes();  while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.isEmpty())  {  Attribute  attribute  =  parseAttribute();  if  (attribute  !=  null)  attributes.put(attribute);  }    Tag  tag  =  Tag.valueOf(tagName);  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  [BUGGY]  if(  tq.matchChomp  (  SQ  )){  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  tq.matchChomp  (   "/> "  )  )  {  isEmptyElement  =  true;  }  else  {  tq.matchChomp  (   "> "  )  ;  }	[BUGGY]  isEmptyElement  =  true;  [CONTEXT]  parseTextNode();  return;  }    Attributes  attributes  =  new  Attributes();  while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.isEmpty())  {  Attribute  attribute  =  parseAttribute();  if  (attribute  !=  null)  attributes.put(attribute);  }    Tag  tag  =  Tag.valueOf(tagName);  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  [BUGGY]  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag    isEmptyElement  =  true;              if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  tq.matchChomp  (   "/> "  )  )  {  isEmptyElement  =  true;  }  else  {  tq.matchChomp  (   "> "  )  ;  }	[BUGGY]    [CONTEXT]  parseTextNode();  return;  }    Attributes  attributes  =  new  Attributes();  while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.isEmpty())  {  Attribute  attribute  =  parseAttribute();  if  (attribute  !=  null)  attributes.put(attribute);  }    Tag  tag  =  Tag.valueOf(tagName);  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  [BUGGY]  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag                  if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
[Delete]	[BUGGY]  if  (  tq.matches(   "< "))  {          parseStartTag(  );  }else  {          parseTextNode(  );  }  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.matchChomp  (   "> "  )  ;	[BUGGY]  tq.matchChomp(   " ");  [CONTEXT]  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  [BUGGY]  tq.matchChomp  (   " "  )  ;  }        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.matchChomp  (   "> "  )  ;	[BUGGY]  tq.matches(   "> ");  [CONTEXT]  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  [BUGGY]  tq.matches  (   "> "  )  ;  }        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.matchChomp  (   "> "  )  ;	[BUGGY]    [CONTEXT]  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  [BUGGY]  tq.matchChomp( "> ");          [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.matchChomp  (   "> "  )  ;	[BUGGY]  if  (  tq.matchChomp(   "= "))  {  tq.matchChomp(   "> ");  }  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.matchChomp  (   "> "  )  ;	[BUGGY]  if  (  tq.matchChomp(   "/> "))  {  tq.matchChomp(   "> ");  }  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.matchChomp  (   "> "  )  ;	[BUGGY]  if  (  tq.matchChomp(  SQ))  {  tq.matchChomp(   "> ");  }  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
isEmptyElement  =  true;	[BUGGY]  isEmptyElement  =  false;  [CONTEXT]  return;  }    Attributes  attributes  =  new  Attributes();  while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.isEmpty())  {  Attribute  attribute  =  parseAttribute();  if  (attribute  !=  null)  attributes.put(attribute);  }    Tag  tag  =  Tag.valueOf(tagName);  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  [BUGGY]  isEmptyElement  =  false;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  tq.matchChomp  (   "/> "  )  )  {	[BUGGY]  if  (  tq.matchChomp(   "> "))  {  [CONTEXT]  parseTextNode();  return;  }    Attributes  attributes  =  new  Attributes();  while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.isEmpty())  {  Attribute  attribute  =  parseAttribute();  if  (attribute  !=  null)  attributes.put(attribute);  }    Tag  tag  =  Tag.valueOf(tagName);  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  [BUGGY]  if(  tq.matchChomp  (   "> "  )){  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.matchChomp  (   "> "  )  ;	[BUGGY]  tq.matches(   "> ");  [CONTEXT]    Attributes  attributes  =  new  Attributes();  while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.isEmpty())  {  Attribute  attribute  =  parseAttribute();  if  (attribute  !=  null)  attributes.put(attribute);  }    Tag  tag  =  Tag.valueOf(tagName);  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  [BUGGY]  tq.matches  (   "> "  )  ;  }        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }          [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.matchChomp  (   "> "  )  ;	[BUGGY]  tq  .matches(  tagName)  ;  [CONTEXT]    Attributes  attributes  =  new  Attributes();  while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.isEmpty())  {  Attribute  attribute  =  parseAttribute();  if  (attribute  !=  null)  attributes.put(attribute);  }    Tag  tag  =  Tag.valueOf(tagName);  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  [BUGGY]  tq  .matches  (  tagName  );  }        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }          [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.matchChomp  (   "> "  )  ;	[BUGGY]    [CONTEXT]    Attributes  attributes  =  new  Attributes();  while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.isEmpty())  {  Attribute  attribute  =  parseAttribute();  if  (attribute  !=  null)  attributes.put(attribute);  }    Tag  tag  =  Tag.valueOf(tagName);  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  [BUGGY]  tq.matchChomp( "> ");    }        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.matchChomp  (   "> "  )  ;	[BUGGY]  if  (  tq.matchChomp(   "= "))  {  tq.matchChomp(   "> ");  }  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.matchChomp  (   "> "  )  ;	[BUGGY]  if  (  tq.matchChomp(   "/> "))  {  tq.matchChomp(   "> ");  }  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.matchChomp  (   "> "  )  ;	[BUGGY]  if  (  tq.matchChomp(  SQ))  {  tq.matchChomp(   "> ");  }  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  tag.isData  (  )  )  {	[BUGGY]  if  (  titleTag.isData(  ))  {  [CONTEXT]  if  (attribute  !=  null)  attributes.put(attribute);  }    Tag  tag  =  Tag.valueOf(tagName);  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        [BUGGY]  if(  titleTag.isData  ()){  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  tag.isData  (  )  )  {	[BUGGY]  if  (  titleTag)  ||  textareaTag))  {  [CONTEXT]  if  (attribute  !=  null)  attributes.put(attribute);  }    Tag  tag  =  Tag.valueOf(tagName);  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        [BUGGY]  if(  titleTag)  ||  textareaTag)  ){  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  tag.isData  (  )  )  {	[BUGGY]  if  (  tag.equals(  ))  {  [CONTEXT]  if  (attribute  !=  null)  attributes.put(attribute);  }    Tag  tag  =  Tag.valueOf(tagName);  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        [BUGGY]  if(  tag.equals  ()){  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  tag.isData  (  )  )  {	[BUGGY]  if  (  tag  .isEmpty(  )  )  {  [CONTEXT]  if  (attribute  !=  null)  attributes.put(attribute);  }    Tag  tag  =  Tag.valueOf(tagName);  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        [BUGGY]  if(  tag  .isEmpty  ()  ){  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  tag.equals  (  titleTag  )  ||  tag.equals  (  textareaTag  )  )  dataNode  =  TextNode.createFromEncoded  (  data,  baseUri  )  ;	[BUGGY]  if  (  tag.equals(  titleTag)  &&  tag.equals(  textareaTag))dataNode  =  TextNode.createFromEncoded(  data,  baseUri);  [CONTEXT]  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  [BUGGY]  if(  tag.equals  (  titleTag  )&&  tag.equals  (  textareaTag  ))  dataNode  =  TextNode.createFromEncoded  (  data,  baseUri  )  ;    else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;  doc.setBaseUri(href);  //  set  on  the  doc  so  doc.createElement(Tag)  will  get  updated  base  }  }          [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  tag.equals  (  titleTag  )  ||  tag.equals  (  textareaTag  )  )  dataNode  =  TextNode.createFromEncoded  (  data,  baseUri  )  ;	[BUGGY]  if  (  tag.equals(  titleTag)  ||  tag.equals(  textareaTag))dataNode  =  TextNode.createFromEncoded(    baseUri);  [CONTEXT]  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  [BUGGY]  if(  tag.equals  (  titleTag  )||  tag.equals  (  textareaTag  ))  dataNode  =  TextNode.createFromEncoded  (baseUri  )  ;    else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;  doc.setBaseUri(href);  //  set  on  the  doc  so  doc.createElement(Tag)  will  get  updated  base  }  }          [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  tag.equals  (  titleTag  )  ||  tag.equals  (  textareaTag  )  )  dataNode  =  TextNode.createFromEncoded  (  data,  baseUri  )  ;	[BUGGY]  if  (  titleTag.equals(  titleTag)  ||  tag.equals(  textareaTag))dataNode  =  TextNode.createFromEncoded(  data,  baseUri);  [CONTEXT]  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  [BUGGY]  if(  titleTag.equals  (  titleTag  )||  tag.equals  (  textareaTag  ))  dataNode  =  TextNode.createFromEncoded  (  data,  baseUri  )  ;    else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;  doc.setBaseUri(href);  //  set  on  the  doc  so  doc.createElement(Tag)  will  get  updated  base  }  }          [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  tag.equals  (  titleTag  )  ||  tag.equals  (  textareaTag  )  )  dataNode  =  TextNode.createFromEncoded  (  data,  baseUri  )  ;	[BUGGY]  if  (  tag.equals(  titleTag)  ||  tag.equals(  textareaTag))htmlNode  =  TextNode.createFromEncoded(  data,  baseUri);  [CONTEXT]  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  [BUGGY]  if(  tag.equals  (  titleTag  )||  tag.equals  (  textareaTag  ))  htmlNode  =  TextNode.createFromEncoded  (  data,  baseUri  )  ;    else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;  doc.setBaseUri(href);  //  set  on  the  doc  so  doc.createElement(Tag)  will  get  updated  base  }  }          [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  tag.equals  (  titleTag  )  ||  tag.equals  (  textareaTag  )  )  dataNode  =  TextNode.createFromEncoded  (  data,  baseUri  )  ;	[BUGGY]  if  (  tag.equals(  textareaTag)  ||  tag.equals(  textareaTag))dataNode  =  TextNode.createFromEncoded(  data,  baseUri);  [CONTEXT]  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  [BUGGY]  if(  tag.equals  (  textareaTag  )||  tag.equals  (  textareaTag  ))  dataNode  =  TextNode.createFromEncoded  (  data,  baseUri  )  ;    else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;  doc.setBaseUri(href);  //  set  on  the  doc  so  doc.createElement(Tag)  will  get  updated  base  }  }          [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  tag.equals  (  titleTag  )  ||  tag.equals  (  textareaTag  )  )  dataNode  =  TextNode.createFromEncoded  (  data,  baseUri  )  ;	[BUGGY]  if  (  tag.equals(  titleTag)  ||  tag.equals(  tag))dataNode  =  TextNode.createFromEncoded(  data,  baseUri);  [CONTEXT]  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  [BUGGY]  if(  tag.equals  (  titleTag  )||  tag.equals  (  tag  ))  dataNode  =  TextNode.createFromEncoded  (  data,  baseUri  )  ;    else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;  doc.setBaseUri(href);  //  set  on  the  doc  so  doc.createElement(Tag)  will  get  updated  base  }  }          [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  tag.equals  (  titleTag  )  ||  tag.equals  (  textareaTag  )  )  dataNode  =  TextNode.createFromEncoded  (  data,  baseUri  )  ;	[BUGGY]  if  (  tag.equals(  titleTag)  ||  tag.equals(  textareaTag))dataNode  =  TextNode.createFromEncoded(  data,  tagName);  [CONTEXT]  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  [BUGGY]  if(  tag.equals  (  titleTag  )||  tag.equals  (  textareaTag  ))  dataNode  =  TextNode.createFromEncoded  (  data,  tagName  )  ;    else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;  doc.setBaseUri(href);  //  set  on  the  doc  so  doc.createElement(Tag)  will  get  updated  base  }  }          [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  tag.equals  (  titleTag  )  ||  tag.equals  (  textareaTag  )  )  dataNode  =  TextNode.createFromEncoded  (  data,  baseUri  )  ;	[BUGGY]  if  (  titleTag.equals(  tag)  ||  tag.equals(  textareaTag))dataNode  =  TextNode.createFromEncoded(  data,  baseUri);  [CONTEXT]  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  [BUGGY]  if(  titleTag.equals  (  tag  )||  tag.equals  (  textareaTag  ))  dataNode  =  TextNode.createFromEncoded  (  data,  baseUri  )  ;    else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;  doc.setBaseUri(href);  //  set  on  the  doc  so  doc.createElement(Tag)  will  get  updated  base  }  }          [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  tag.equals  (  titleTag  )  ||  tag.equals  (  textareaTag  )  )  dataNode  =  TextNode.createFromEncoded  (  data,  baseUri  )  ;	[BUGGY]  if  (  data.equals(  titleTag)  ||  tag.equals(  textareaTag))tagNode  =  TextNode.createFromEncoded(  data,  baseUri);  [CONTEXT]  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  [BUGGY]  if(  data.equals  (  titleTag  )||  tag.equals  (  textareaTag  ))  tagNode  =  TextNode.createFromEncoded  (  data,  baseUri  )  ;    else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;  doc.setBaseUri(href);  //  set  on  the  doc  so  doc.createElement(Tag)  will  get  updated  base  }  }          [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  tag.equals  (  titleTag  )  ||  tag.equals  (  textareaTag  )  )  dataNode  =  TextNode.createFromEncoded  (  data,  baseUri  )  ;	[BUGGY]  if  (  tag.equals(  textareaTag)  ||  tag.equals(  titleTag))dataNode  =  TextNode.createFromEncoded(  data,  baseUri);  [CONTEXT]  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  [BUGGY]  if(  tag.equals  (  textareaTag  )||  tag.equals  (  titleTag  ))  dataNode  =  TextNode.createFromEncoded  (  data,  baseUri  )  ;    else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;  doc.setBaseUri(href);  //  set  on  the  doc  so  doc.createElement(Tag)  will  get  updated  base  }  }          [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  tag.equals  (  titleTag  )  ||  tag.equals  (  textareaTag  )  )  dataNode  =  TextNode.createFromEncoded  (  data,  baseUri  )  ;	[BUGGY]  if  (  textareaTag.equals(  titleTag)  ||  tag.equals(  tag))dataNode  =  TextNode.createFromEncoded(  data,  baseUri);  [CONTEXT]  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  [BUGGY]  if(  textareaTag.equals  (  titleTag  )||  tag.equals  (  tag  ))  dataNode  =  TextNode.createFromEncoded  (  data,  baseUri  )  ;    else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;  doc.setBaseUri(href);  //  set  on  the  doc  so  doc.createElement(Tag)  will  get  updated  base  }  }          [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  tag.equals  (  titleTag  )  ||  tag.equals  (  textareaTag  )  )  dataNode  =  TextNode.createFromEncoded  (  data,  baseUri  )  ;	[BUGGY]  if  (  tag.equals(  titleTag)  ||  tag.equals(  baseUri))dataNode  =  TextNode.createFromEncoded(  data,  textareaTag);  [CONTEXT]  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  [BUGGY]  if(  tag.equals  (  titleTag  )||  tag.equals  (  baseUri  ))  dataNode  =  TextNode.createFromEncoded  (  data,  textareaTag  )  ;    else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;  doc.setBaseUri(href);  //  set  on  the  doc  so  doc.createElement(Tag)  will  get  updated  base  }  }          [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  tag.equals  (  titleTag  )  ||  tag.equals  (  textareaTag  )  )  dataNode  =  TextNode.createFromEncoded  (  data,  baseUri  )  ;	[BUGGY]  if  (  tag.equals(  titleTag)  ||  tag.equals(  textareaTag))dataNode  =  TextNode.createFromEncoded(  data);  [CONTEXT]  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  [BUGGY]  if(  tag.equals  (  titleTag  )||  tag.equals  (  textareaTag  ))  dataNode  =  TextNode.createFromEncoded  (  data  )  ;    else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;  doc.setBaseUri(href);  //  set  on  the  doc  so  doc.createElement(Tag)  will  get  updated  base  }  }          [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  tag.equals  (  titleTag  )  ||  tag.equals  (  textareaTag  )  )  dataNode  =  TextNode.createFromEncoded  (  data,  baseUri  )  ;	[BUGGY]  if  (  tag.isValidParent(  titleTag)  ||  tag.equals(  textareaTag))dataNode  =  TextNode.createFromEncoded(  data,  baseUri);  [CONTEXT]  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  [BUGGY]  if(  tag.isValidParent  (  titleTag  )||  tag.equals  (  textareaTag  ))  dataNode  =  TextNode.createFromEncoded  (  data,  baseUri  )  ;    else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;  doc.setBaseUri(href);  //  set  on  the  doc  so  doc.createElement(Tag)  will  get  updated  base  }  }          [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  tag.equals  (  titleTag  )  ||  tag.equals  (  textareaTag  )  )  dataNode  =  TextNode.createFromEncoded  (  data,  baseUri  )  ;	[BUGGY]  if  (  tag  .canContain(  titleTag)    ||  tag  [CONTEXT]  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  [BUGGY]  if(  tag  .canContain  (  titleTag  )  ||  tag    else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;  doc.setBaseUri(href);  //  set  on  the  doc  so  doc.createElement(Tag)  will  get  updated  base  }  }          [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  tag.equals  (  titleTag  )  ||  tag.equals  (  textareaTag  )  )  dataNode  =  TextNode.createFromEncoded  (  data,  baseUri  )  ;	[BUGGY]  if  (  tag.equals(  titleTag)  ||  tag.equals(  textareaTag))dataNode  =  TextNode  .TextNode(  )  ;  [CONTEXT]  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  [BUGGY]  if(  tag.equals  (  titleTag  )||  tag.equals  (  textareaTag  ))  dataNode  =  TextNode  .TextNode  ();    else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;  doc.setBaseUri(href);  //  set  on  the  doc  so  doc.createElement(Tag)  will  get  updated  base  }  }          [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  tag.equals  (  titleTag  )  ||  tag.equals  (  textareaTag  )  )  dataNode  =  TextNode.createFromEncoded  (  data,  baseUri  )  ;	[BUGGY]  if  (  tag.isValidParent(  textareaTag)  ||  tag.equals(  textareaTag))dataNode  =  TextNode.createFromEncoded(  data,  baseUri);  [CONTEXT]  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  [BUGGY]  if(  tag.isValidParent  (  textareaTag  )||  tag.equals  (  textareaTag  ))  dataNode  =  TextNode.createFromEncoded  (  data,  baseUri  )  ;    else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;  doc.setBaseUri(href);  //  set  on  the  doc  so  doc.createElement(Tag)  will  get  updated  base  }  }          [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  tag.equals  (  titleTag  )  ||  tag.equals  (  textareaTag  )  )  dataNode  =  TextNode.createFromEncoded  (  data,  baseUri  )  ;  else  dataNode  =  new  DataNode  (  data,  baseUri  )  ;  child.appendChild  (  dataNode  )  ;  }	[BUGGY]  dataNode  =  org.jsoup.parser.TextNode.createFromEncoded(data,  baseUri);  [CONTEXT]  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  [BUGGY]  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)    dataNode  =  org.jsoup.parser.TextNode.createFromEncoded(data,  baseUri);        }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;  doc.setBaseUri(href);  //  set  on  the  doc  so  doc.createElement(Tag)  will  get  updated  base  }  }        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  tag.equals  (  titleTag  )  ||  tag.equals  (  textareaTag  )  )  dataNode  =  TextNode.createFromEncoded  (  data,  baseUri  )  ;  else  dataNode  =  new  DataNode  (  data,  baseUri  )  ;  child.appendChild  (  dataNode  )  ;  }	[BUGGY]    [CONTEXT]  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  [BUGGY]  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)            }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;  doc.setBaseUri(href);  //  set  on  the  doc  so  doc.createElement(Tag)  will  get  updated  base  }  }        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
[Delete]	[BUGGY]  if  (  tag.isData(  ))  {          String  data  =  tq.chompTo(  (   "</ "  +  tagName));          tq.chompTo(   "> ");          Node  dataNode;          if  (  (  tag.equals(  titleTag))  ||  (  tag.equals(  textareaTag)))                  dataNode  =  createFromEncoded(  data,  baseUri);          else                  dataNode  =  new  DataNode(  data,  baseUri);                    child.appendChild(  dataNode);  }  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
dataNode  =  new  DataNode  (  data,  baseUri  )  ;	[BUGGY]  dataNode  =  dataNode  =    new  Document(  baseUri)  ;  [CONTEXT]  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  [BUGGY]  dataNode  =  dataNode  =new  Document  (  baseUri  );  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;  doc.setBaseUri(href);  //  set  on  the  doc  so  doc.createElement(Tag)  will  get  updated  base  }  }    addChildToParent(child,  isEmptyElement);  }          [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
dataNode  =  new  DataNode  (  data,  baseUri  )  ;	[BUGGY]  dataNode  =  new  DataNode(  tagName,  baseUri);  [CONTEXT]  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  [BUGGY]  dataNode  =  new  DataNode  (  tagName,  baseUri  )  ;  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;  doc.setBaseUri(href);  //  set  on  the  doc  so  doc.createElement(Tag)  will  get  updated  base  }  }    addChildToParent(child,  isEmptyElement);  }          [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
dataNode  =  new  DataNode  (  data,  baseUri  )  ;	[BUGGY]  dataNode  =  new  DataNode(  data,  tagName);  [CONTEXT]  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  [BUGGY]  dataNode  =  new  DataNode  (  data,  tagName  )  ;  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;  doc.setBaseUri(href);  //  set  on  the  doc  so  doc.createElement(Tag)  will  get  updated  base  }  }    addChildToParent(child,  isEmptyElement);  }          [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
dataNode  =  new  DataNode  (  data,  baseUri  )  ;	[BUGGY]  dataNode  =  new  DataNode(  baseUri,  data);  [CONTEXT]  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  [BUGGY]  dataNode  =  new  DataNode  (  baseUri,  data  )  ;  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;  doc.setBaseUri(href);  //  set  on  the  doc  so  doc.createElement(Tag)  will  get  updated  base  }  }    addChildToParent(child,  isEmptyElement);  }          [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
dataNode  =  new  DataNode  (  data,  baseUri  )  ;	[BUGGY]  dataNode  =  new  DataNode(    baseUri);  [CONTEXT]  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  [BUGGY]  dataNode  =  new  DataNode  (baseUri  )  ;  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;  doc.setBaseUri(href);  //  set  on  the  doc  so  doc.createElement(Tag)  will  get  updated  base  }  }    addChildToParent(child,  isEmptyElement);  }          [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
dataNode  =  new  DataNode  (  data,  baseUri  )  ;	[BUGGY]  dataNode  =  new  DataNode(  data);  [CONTEXT]  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  [BUGGY]  dataNode  =  new  DataNode  (  data  )  ;  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;  doc.setBaseUri(href);  //  set  on  the  doc  so  doc.createElement(Tag)  will  get  updated  base  }  }    addChildToParent(child,  isEmptyElement);  }          [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
dataNode  =  new  DataNode  (  data,  baseUri  )  ;	[BUGGY]  dataNode  =    new  DataNode(  null,  baseUri);  [CONTEXT]  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  [BUGGY]  dataNode  =new  DataNode  (  null,  baseUri  )  ;  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;  doc.setBaseUri(href);  //  set  on  the  doc  so  doc.createElement(Tag)  will  get  updated  base  }  }    addChildToParent(child,  isEmptyElement);  }          [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
dataNode  =  new  DataNode  (  data,  baseUri  )  ;  child.appendChild  (  dataNode  )  ;	[BUGGY]  child.appendChild(  dataNode);  dataNode  =  new  DataNode(  data,  baseUri);  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
dataNode  =  new  DataNode  (  data,  baseUri  )  ;  child.appendChild  (  dataNode  )  ;	[BUGGY]  dataNode  =  new  DataNode(  data,  baseUri);dataNode  =  new  DataNode(  data,  baseUri);  child.appendChild(  dataNode);  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
dataNode  =  new  DataNode  (  data,  baseUri  )  ;	[BUGGY]  dataNode  =  new  DataNode(  html,  baseUri);  [CONTEXT]  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  [BUGGY]  dataNode  =  new  DataNode  (  html,  baseUri  )  ;  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;  doc.setBaseUri(href);  //  set  on  the  doc  so  doc.createElement(Tag)  will  get  updated  base  }  }    addChildToParent(child,  isEmptyElement);  }          [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
dataNode  =  TextNode.createFromEncoded  (  data,  baseUri  )  ;	[BUGGY]  dataNode  =  TextNode.createFromEncoded(  html,  baseUri);  [CONTEXT]    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  [BUGGY]  dataNode  =  TextNode.createFromEncoded  (  html,  baseUri  )  ;  else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;  doc.setBaseUri(href);  //  set  on  the  doc  so  doc.createElement(Tag)  will  get  updated  base  }  }    addChildToParent(child,  isEmptyElement);        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
dataNode  =  TextNode.createFromEncoded  (  data,  baseUri  )  ;	[BUGGY]  dataNode  =  TextNode.createFromEncoded(  baseUri,  data);  [CONTEXT]    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  [BUGGY]  dataNode  =  TextNode.createFromEncoded  (  baseUri,  data  )  ;  else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;  doc.setBaseUri(href);  //  set  on  the  doc  so  doc.createElement(Tag)  will  get  updated  base  }  }    addChildToParent(child,  isEmptyElement);        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
dataNode  =  TextNode.createFromEncoded  (  data,  baseUri  )  ;	[BUGGY]  dataNode  =  TextNode.createFromEncoded(    baseUri);  [CONTEXT]    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  [BUGGY]  dataNode  =  TextNode.createFromEncoded  (baseUri  )  ;  else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;  doc.setBaseUri(href);  //  set  on  the  doc  so  doc.createElement(Tag)  will  get  updated  base  }  }    addChildToParent(child,  isEmptyElement);        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
dataNode  =  TextNode.createFromEncoded  (  data,  baseUri  )  ;	[BUGGY]  dataNode  =  TextNode.createFromEncoded(  data);  [CONTEXT]    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  [BUGGY]  dataNode  =  TextNode.createFromEncoded  (  data  )  ;  else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;  doc.setBaseUri(href);  //  set  on  the  doc  so  doc.createElement(Tag)  will  get  updated  base  }  }    addChildToParent(child,  isEmptyElement);        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
dataNode  =  TextNode.createFromEncoded  (  data,  baseUri  )  ;	[BUGGY]  dataNode  =    TextNode.createFromEncoded(  tagName,  baseUri);  [CONTEXT]    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  [BUGGY]  dataNode  =TextNode.createFromEncoded  (  tagName,  baseUri  )  ;  else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;  doc.setBaseUri(href);  //  set  on  the  doc  so  doc.createElement(Tag)  will  get  updated  base  }  }    addChildToParent(child,  isEmptyElement);        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
dataNode  =  TextNode.createFromEncoded  (  data,  baseUri  )  ;	[BUGGY]  dataNode  =  TextNode.createFromEncoded(  data,  tagName);  [CONTEXT]    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  [BUGGY]  dataNode  =  TextNode.createFromEncoded  (  data,  tagName  )  ;  else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;  doc.setBaseUri(href);  //  set  on  the  doc  so  doc.createElement(Tag)  will  get  updated  base  }  }    addChildToParent(child,  isEmptyElement);        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
dataNode  =  TextNode.createFromEncoded  (  data,  baseUri  )  ;	[BUGGY]    [CONTEXT]    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  [BUGGY]  dataNode  =  TextNode.createFromEncoded(data,  baseUri);    else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;  doc.setBaseUri(href);  //  set  on  the  doc  so  doc.createElement(Tag)  will  get  updated  base  }  }          [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
dataNode  =  TextNode.createFromEncoded  (  data,  baseUri  )  ;	[BUGGY]  dataNode  =  TextNode  .TextNode(  )  ;  [CONTEXT]    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  [BUGGY]  dataNode  =  TextNode  .TextNode  ();  else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;  doc.setBaseUri(href);  //  set  on  the  doc  so  doc.createElement(Tag)  will  get  updated  base  }  }    addChildToParent(child,  isEmptyElement);        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
dataNode  =  new  DataNode  (  data,  baseUri  )  ;	[BUGGY]    dataNode  =  new  DataNode(  data,  baseUri);  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
dataNode  =  new  DataNode  (  data,  baseUri  )  ;	[BUGGY]  dataNode  =  TextNode.createFromEncoded(  data,  baseUri);dataNode  =  new  DataNode(  data,  baseUri);  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
dataNode  =  new  DataNode  (  data,  baseUri  )  ;	[BUGGY]  doc  =  new  Document(  baseUri);dataNode  =  new  DataNode(  data,  baseUri);  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
dataNode  =  new  DataNode  (  data,  baseUri  )  ;	[BUGGY]  dataNode  =  new  DataNode(  data,  html);  [CONTEXT]  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  [BUGGY]  dataNode  =  new  DataNode  (  data,  html  )  ;  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;  doc.setBaseUri(href);  //  set  on  the  doc  so  doc.createElement(Tag)  will  get  updated  base  }  }    addChildToParent(child,  isEmptyElement);  }          [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
String  data  =  tq.chompTo  (   "</ "  +  tagName  )  ;	[BUGGY]  char  data  =  tq.chompTo(   "</ "  +  tagName);  [CONTEXT]  attributes.put(attribute);  }    Tag  tag  =  Tag.valueOf(tagName);  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  [BUGGY]  char  data  =  tq.chompTo  (   "</ "  +  tagName  )  ;  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
String  data  =  tq.chompTo  (   "</ "  +  tagName  )  ;	[BUGGY]  String  data  =  tq.chompTo(   "</ "      instanceof      tagName);  [CONTEXT]  attributes.put(attribute);  }    Tag  tag  =  Tag.valueOf(tagName);  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  [BUGGY]  String  data  =  tq.chompTo  (   "</ "  instanceof  tagName  )  ;  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
String  data  =  tq.chompTo  (   "</ "  +  tagName  )  ;	[BUGGY]  String  data  =  tq.chompTo(   "</ "  +  html);  [CONTEXT]  attributes.put(attribute);  }    Tag  tag  =  Tag.valueOf(tagName);  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  [BUGGY]  String  data  =  tq.chompTo  (   "</ "  +  html  )  ;  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
String  data  =  tq.chompTo  (   "</ "  +  tagName  )  ;	[BUGGY]  String  data  =  tagName.chompTo(   "</ "  +  tq);  [CONTEXT]  attributes.put(attribute);  }    Tag  tag  =  Tag.valueOf(tagName);  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  [BUGGY]  String  data  =  tagName.chompTo  (   "</ "  +  tq  )  ;  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
String  data  =  tq.chompTo  (   "</ "  +  tagName  )  ;	[BUGGY]  String  text  =  tq.consumeTo(   "< ");String  data  =  tq.chompTo(   "</ "  +  tagName);  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
String  data  =  tq.chompTo  (   "</ "  +  tagName  )  ;	[BUGGY]  String  rawText  =  tq.chompTo(   "]]> ");String  data  =  tq.chompTo(   "</ "  +  tagName);  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
String  data  =  tq.chompTo  (   "</ "  +  tagName  )  ;	[BUGGY]  String  data  =  tq.chompTo(   "-> ");String  data  =  tq.chompTo(   "</ "  +  tagName);  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
String  data  =  tq.chompTo  (   "</ "  +  tagName  )  ;	[BUGGY]  String  data  =  tq.chompTo(   "> ");String  data  =  tq.chompTo(   "</ "  +  tagName);  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
String  data  =  tq.chompTo  (   "</ "  +  tagName  )  ;	[BUGGY]  String  data  =  tq.chompTo(   "</ "    <<    tagName);  [CONTEXT]  attributes.put(attribute);  }    Tag  tag  =  Tag.valueOf(tagName);  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  [BUGGY]  String  data  =  tq.chompTo  (   "</ "<<tagName  )  ;  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
String  data  =  tq.chompTo  (   "</ "  +  tagName  )  ;	[BUGGY]  String  data  =  tq.chompTo(   " "  +  tagName);  [CONTEXT]  attributes.put(attribute);  }    Tag  tag  =  Tag.valueOf(tagName);  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  [BUGGY]  String  data  =  tq.chompTo  (   " "  +  tagName  )  ;  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
String  data  =  tq.chompTo  (   "</ "  +  tagName  )  ;	[BUGGY]  String  data  =  tq.chompTo(   "</ "  +  data);  [CONTEXT]  attributes.put(attribute);  }    Tag  tag  =  Tag.valueOf(tagName);  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  [BUGGY]  String  data  =  tq.chompTo  (   "</ "  +  data  )  ;  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
String  data  =  tq.chompTo  (   "</ "  +  tagName  )  ;	[BUGGY]  String  data  =  tq  .chompTo(  html)  ;  [CONTEXT]  attributes.put(attribute);  }    Tag  tag  =  Tag.valueOf(tagName);  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  [BUGGY]  String  data  =  tq  .chompTo  (  html  );  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
String  data  =  tq.chompTo  (   "</ "  +  tagName  )  ;	[BUGGY]  String  data  =  tq.chompTo(   "</ "  +  href);  [CONTEXT]  attributes.put(attribute);  }    Tag  tag  =  Tag.valueOf(tagName);  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  [BUGGY]  String  data  =  tq.chompTo  (   "</ "  +  href  )  ;  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
String  data  =  tq.chompTo  (   "</ "  +  tagName  )  ;  tq.chompTo  (   "> "  )  ;	[BUGGY]    [CONTEXT]  attributes.put(attribute);  }    Tag  tag  =  Tag.valueOf(tagName);  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  [BUGGY]  String  data  =  tq.chompTo( "</ "  +  tagName);        Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.chompTo  (   "> "  )  ;	[BUGGY]  tq.consumeTo(   "> ");  [CONTEXT]  }    Tag  tag  =  Tag.valueOf(tagName);  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  [BUGGY]  tq.consumeTo  (   "> "  )  ;    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;  doc.setBaseUri(href);  //  set  on  the  doc  so  doc.createElement(Tag)  will  get  updated  base        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.chompTo  (   "> "  )  ;	[BUGGY]  tq  .consumeTo(  tagName)  ;  [CONTEXT]  }    Tag  tag  =  Tag.valueOf(tagName);  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  [BUGGY]  tq  .consumeTo  (  tagName  );    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;  doc.setBaseUri(href);  //  set  on  the  doc  so  doc.createElement(Tag)  will  get  updated  base        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.chompTo  (   "> "  )  ;	[BUGGY]    [CONTEXT]  }    Tag  tag  =  Tag.valueOf(tagName);  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  [BUGGY]  tq.chompTo( "> ");      Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  tag.equals  (  titleTag  )  ||  tag.equals  (  textareaTag  )  )  dataNode  =  TextNode.createFromEncoded  (  data,  baseUri  )  ;	[BUGGY]  if  (  textareaTag.equals(  titleTag)  ||  tag.equals(  textareaTag))dataNode  =  TextNode.createFromEncoded(  data,  baseUri);  [CONTEXT]  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  [BUGGY]  if(  textareaTag.equals  (  titleTag  )||  tag.equals  (  textareaTag  ))  dataNode  =  TextNode.createFromEncoded  (  data,  baseUri  )  ;    else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;  doc.setBaseUri(href);  //  set  on  the  doc  so  doc.createElement(Tag)  will  get  updated  base  }  }          [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  tag.equals  (  titleTag  )  ||  tag.equals  (  textareaTag  )  )  dataNode  =  TextNode.createFromEncoded  (  data,  baseUri  )  ;	[BUGGY]  if  (  tag.equals(  titleTag)  ||  tag.equals(  titleTag))dataNode  =  TextNode.createFromEncoded(  data,  baseUri);  [CONTEXT]  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  [BUGGY]  if(  tag.equals  (  titleTag  )||  tag.equals  (  titleTag  ))  dataNode  =  TextNode.createFromEncoded  (  data,  baseUri  )  ;    else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;  doc.setBaseUri(href);  //  set  on  the  doc  so  doc.createElement(Tag)  will  get  updated  base  }  }          [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  tag.equals  (  titleTag  )  ||  tag.equals  (  textareaTag  )  )  dataNode  =  TextNode.createFromEncoded  (  data,  baseUri  )  ;	[BUGGY]  if  (  tag  .canContain(  bodyTag)    ||  tag  [CONTEXT]  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  [BUGGY]  if(  tag  .canContain  (  bodyTag  )  ||  tag    else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;  doc.setBaseUri(href);  //  set  on  the  doc  so  doc.createElement(Tag)  will  get  updated  base  }  }          [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  tag.equals  (  titleTag  )  ||  tag.equals  (  textareaTag  )  )  dataNode  =  TextNode.createFromEncoded  (  data,  baseUri  )  ;	[BUGGY]  if  (  tag  .canContain(  textareaTag)    ||  tag  [CONTEXT]  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  [BUGGY]  if(  tag  .canContain  (  textareaTag  )  ||  tag    else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;  doc.setBaseUri(href);  //  set  on  the  doc  so  doc.createElement(Tag)  will  get  updated  base  }  }          [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
dataNode  =  TextNode.createFromEncoded  (  data,  baseUri  )  ;	[BUGGY]  dataNode  =  TextNode.createFromEncoded(  data,  html);  [CONTEXT]    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  [BUGGY]  dataNode  =  TextNode.createFromEncoded  (  data,  html  )  ;  else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;  doc.setBaseUri(href);  //  set  on  the  doc  so  doc.createElement(Tag)  will  get  updated  base  }  }    addChildToParent(child,  isEmptyElement);        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
child.appendChild  (  dataNode  )  ;	[BUGGY]  child  .appendChild(  this)  ;  [CONTEXT]  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  [BUGGY]  child  .appendChild  (  this  );  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;  doc.setBaseUri(href);  //  set  on  the  doc  so  doc.createElement(Tag)  will  get  updated  base  }  }    addChildToParent(child,  isEmptyElement);  }    private  Attribute  parseAttribute()  {        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
child.appendChild  (  dataNode  )  ;	[BUGGY]    [CONTEXT]  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  [BUGGY]  child.appendChild(dataNode);    }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;  doc.setBaseUri(href);  //  set  on  the  doc  so  doc.createElement(Tag)  will  get  updated  base  }  }    addChildToParent(child,  isEmptyElement);  }          [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  tag.equals  (  titleTag  )  ||  tag.equals  (  textareaTag  )  )  dataNode  =  TextNode.createFromEncoded  (  data,  baseUri  )  ;	[BUGGY]  if  (  tag.equals(  titleTag)  ||  tag.equals(  textareaTag))tagNameNode  =  TextNode.createFromEncoded(  data,  baseUri);  [CONTEXT]  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  [BUGGY]  if(  tag.equals  (  titleTag  )||  tag.equals  (  textareaTag  ))  tagNameNode  =  TextNode.createFromEncoded  (  data,  baseUri  )  ;    else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;  doc.setBaseUri(href);  //  set  on  the  doc  so  doc.createElement(Tag)  will  get  updated  base  }  }          [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  tag.equals  (  titleTag  )  ||  tag.equals  (  textareaTag  )  )  dataNode  =  TextNode.createFromEncoded  (  data,  baseUri  )  ;	[BUGGY]  if  (  tag.equals(  tag)  ||  tag.equals(  textareaTag))dataNode  =  TextNode.createFromEncoded(  data,  baseUri);  [CONTEXT]  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  [BUGGY]  if(  tag.equals  (  tag  )||  tag.equals  (  textareaTag  ))  dataNode  =  TextNode.createFromEncoded  (  data,  baseUri  )  ;    else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;  doc.setBaseUri(href);  //  set  on  the  doc  so  doc.createElement(Tag)  will  get  updated  base  }  }          [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  tag.equals  (  titleTag  )  ||  tag.equals  (  textareaTag  )  )  dataNode  =  TextNode.createFromEncoded  (  data,  baseUri  )  ;	[BUGGY]  if  (  tag.equals(  titleTag)  ||  tag.equals(  textareaTag))dataNode  =  TextNode.createFromEncoded(  data,  html);  [CONTEXT]  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  [BUGGY]  if(  tag.equals  (  titleTag  )||  tag.equals  (  textareaTag  ))  dataNode  =  TextNode.createFromEncoded  (  data,  html  )  ;    else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;  doc.setBaseUri(href);  //  set  on  the  doc  so  doc.createElement(Tag)  will  get  updated  base  }  }          [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  tag.equals  (  titleTag  )  ||  tag.equals  (  textareaTag  )  )  dataNode  =  TextNode.createFromEncoded  (  data,  baseUri  )  ;	[BUGGY]  if  (  tag.equals(  titleTag)  ||  tag.equals(  textareaTag))baseUriNode  =  TextNode.createFromEncoded(  data,  data);  [CONTEXT]  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  [BUGGY]  if(  tag.equals  (  titleTag  )||  tag.equals  (  textareaTag  ))  baseUriNode  =  TextNode.createFromEncoded  (  data,  data  )  ;    else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;  doc.setBaseUri(href);  //  set  on  the  doc  so  doc.createElement(Tag)  will  get  updated  base  }  }          [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
dataNode  =  new  DataNode  (  data,  baseUri  )  ;	[BUGGY]  dataNode  =      new  Document(  baseUri)  ;  [CONTEXT]  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  [BUGGY]  dataNode  =  new  Document  (  baseUri  );  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;  doc.setBaseUri(href);  //  set  on  the  doc  so  doc.createElement(Tag)  will  get  updated  base  }  }    addChildToParent(child,  isEmptyElement);  }          [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
String  data  =  tq.chompTo  (   "</ "  +  tagName  )  ;	[BUGGY]  String  data  =  tq.chompTo(   "</ "    ==    tagName);  [CONTEXT]  attributes.put(attribute);  }    Tag  tag  =  Tag.valueOf(tagName);  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  [BUGGY]  String  data  =  tq.chompTo  (   "</ "==tagName  )  ;  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
String  data  =  tq.chompTo  (   "</ "  +  tagName  )  ;	[BUGGY]  String  data  =  tq.chompTo(   "< "  +  tagName);  [CONTEXT]  attributes.put(attribute);  }    Tag  tag  =  Tag.valueOf(tagName);  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  [BUGGY]  String  data  =  tq.chompTo  (   "< "  +  tagName  )  ;  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
String  data  =  tq.chompTo  (   "</ "  +  tagName  )  ;	[BUGGY]  tq.chompTo(   "> ");  String  data  =  tq.chompTo(   "</ "  +  tagName);  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  tag.isData  (  )  )  {	[BUGGY]  if  (  textareaTag.isData(  ))  {  [CONTEXT]  if  (attribute  !=  null)  attributes.put(attribute);  }    Tag  tag  =  Tag.valueOf(tagName);  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        [BUGGY]  if(  textareaTag.isData  ()){  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
String  data  =  tq.chompTo  (   "</ "  +  tagName  )  ;	[BUGGY]  String  data  =  tq.chompTo(   "</ "    >=    tagName);  [CONTEXT]  attributes.put(attribute);  }    Tag  tag  =  Tag.valueOf(tagName);  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  [BUGGY]  String  data  =  tq.chompTo  (   "</ ">=tagName  )  ;  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.chompTo  (   "> "  )  ;	[BUGGY]  tq.chompTo(   " ");  [CONTEXT]  }    Tag  tag  =  Tag.valueOf(tagName);  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  [BUGGY]  tq.chompTo  (   " "  )  ;    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;  doc.setBaseUri(href);  //  set  on  the  doc  so  doc.createElement(Tag)  will  get  updated  base        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  tag.equals  (  titleTag  )  ||  tag.equals  (  textareaTag  )  )  dataNode  =  TextNode.createFromEncoded  (  data,  baseUri  )  ;	[BUGGY]  if  (  titleTag.isValidParent(  titleTag)  ||  tag.equals(  textareaTag))dataNode  =  TextNode.createFromEncoded(  data,  baseUri);  [CONTEXT]  Element  child  =  new  Element(tag,  baseUri,  attributes);    boolean  isEmptyElement  =  tag.isEmpty();  //  empty  element  if  empty  tag  (e.g.  img)  or  self-closed  el  (<div/>  if  (tq.matchChomp( "/> "))  {  //  close  empty  element  or  tag  isEmptyElement  =  true;  }  else  {  tq.matchChomp( "> ");  }        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  [BUGGY]  if(  titleTag.isValidParent  (  titleTag  )||  tag.equals  (  textareaTag  ))  dataNode  =  TextNode.createFromEncoded  (  data,  baseUri  )  ;    else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;  doc.setBaseUri(href);  //  set  on  the  doc  so  doc.createElement(Tag)  will  get  updated  base  }  }          [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  child.tagName  (  )  .equals  (   "base "  )  )  {	[BUGGY]  if  (  child.tagName(  ).equals(   "b "))  {  [CONTEXT]        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        [BUGGY]  if(  child.tagName  ()  .equals  (   "b "  )){  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;  doc.setBaseUri(href);  //  set  on  the  doc  so  doc.createElement(Tag)  will  get  updated  base  }  }    addChildToParent(child,  isEmptyElement);  }    private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  child.tagName  (  )  .equals  (   "base "  )  )  {	[BUGGY]  if  (  child.absUrl(  ).equals(   "base "))  {  [CONTEXT]        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        [BUGGY]  if(  child.absUrl  ()  .equals  (   "base "  )){  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;  doc.setBaseUri(href);  //  set  on  the  doc  so  doc.createElement(Tag)  will  get  updated  base  }  }    addChildToParent(child,  isEmptyElement);  }    private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  child.tagName  (  )  .equals  (   "base "  )  )  {	[BUGGY]  if  (  child  .tag(  )  .equals(   "base "))  {  [CONTEXT]        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        [BUGGY]  if(  child  .tag  ().equals  (   "base "  )){  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;  doc.setBaseUri(href);  //  set  on  the  doc  so  doc.createElement(Tag)  will  get  updated  base  }  }    addChildToParent(child,  isEmptyElement);  }    private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  child.tagName  (  )  .equals  (   "base "  )  )  {	[BUGGY]  if  (  child.tag(  ).equals(  bodyTag))  {  [CONTEXT]        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        [BUGGY]  if(  child.tag  ()  .equals  (  bodyTag  )){  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;  doc.setBaseUri(href);  //  set  on  the  doc  so  doc.createElement(Tag)  will  get  updated  base  }  }    addChildToParent(child,  isEmptyElement);  }    private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  child.tagName  (  )  .equals  (   "base "  )  )  {  String  href  =  child.absUrl  (   "href "  )  ;  if  (  href.length  (  )  !=  0  )  {  baseUri  =  href;  doc.setBaseUri  (  href  )  ;  }	[BUGGY]  java.lang.String  href  =  child.absUrl( "href ");  if((href.length())  !=  0)  {        baseUri  =  href;        doc.setBaseUri(href);};  [CONTEXT]        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        [BUGGY]  if  (child.tagName().equals( "base "))  {    java.lang.String  href  =  child.absUrl( "href ");  if  ((href.length())  !=  0)  {baseUri  =  href;doc.setBaseUri(href);};        }  }    addChildToParent(child,  isEmptyElement);  }    private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  child.tagName  (  )  .equals  (   "base "  )  )  {  String  href  =  child.absUrl  (   "href "  )  ;  if  (  href.length  (  )  !=  0  )  {  baseUri  =  href;  doc.setBaseUri  (  href  )  ;  }	[BUGGY]    [CONTEXT]        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        [BUGGY]  if  (child.tagName().equals( "base "))  {            }  }    addChildToParent(child,  isEmptyElement);  }    private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  href.length  (  )  !=  0  )  {	[BUGGY]  if  (  href.length(  )  >=  0)  {  [CONTEXT]  if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  [BUGGY]  if(  href.length  ()>=  0  ){  baseUri  =  href;  doc.setBaseUri(href);  //  set  on  the  doc  so  doc.createElement(Tag)  will  get  updated  base  }  }    addChildToParent(child,  isEmptyElement);  }    private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  href.length  (  )  !=  0  )  {	[BUGGY]  if  (  href.length(  )  !=  -9)  {  [CONTEXT]  if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  [BUGGY]  if(  href.length  ()!=  -9  ){  baseUri  =  href;  doc.setBaseUri(href);  //  set  on  the  doc  so  doc.createElement(Tag)  will  get  updated  base  }  }    addChildToParent(child,  isEmptyElement);  }    private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  href.length  (  )  !=  0  )  {	[BUGGY]  if  (  href.length()  -  2    !=  0)  {  [CONTEXT]  if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  [BUGGY]  if(  href.length()  -  2!=  0  ){  baseUri  =  href;  doc.setBaseUri(href);  //  set  on  the  doc  so  doc.createElement(Tag)  will  get  updated  base  }  }    addChildToParent(child,  isEmptyElement);  }    private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  href.length  (  )  !=  0  )  {	[BUGGY]  if  (  data.length(  )  !=  0)  {  [CONTEXT]  if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  [BUGGY]  if(  data.length  ()!=  0  ){  baseUri  =  href;  doc.setBaseUri(href);  //  set  on  the  doc  so  doc.createElement(Tag)  will  get  updated  base  }  }    addChildToParent(child,  isEmptyElement);  }    private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  href.length  (  )  !=  0  )  {	[BUGGY]  if  (  href.substring(  )  !=  0)  {  [CONTEXT]  if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  [BUGGY]  if(  href.substring  ()!=  0  ){  baseUri  =  href;  doc.setBaseUri(href);  //  set  on  the  doc  so  doc.createElement(Tag)  will  get  updated  base  }  }    addChildToParent(child,  isEmptyElement);  }    private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  href.length  (  )  !=  0  )  {	[BUGGY]  if  (  href  .endsWith(  html)    !=  0)  {  [CONTEXT]  if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  [BUGGY]  if(  href  .endsWith  (  html  )  !=  0  ){  baseUri  =  href;  doc.setBaseUri(href);  //  set  on  the  doc  so  doc.createElement(Tag)  will  get  updated  base  }  }    addChildToParent(child,  isEmptyElement);  }    private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  href.length  (  )  !=  0  )  {	[BUGGY]  if  (  href.length(  )  !=  0  )  {  [CONTEXT]  if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  [BUGGY]  if(  href.length  ()!=  0){  baseUri  =  href;  doc.setBaseUri(href);  //  set  on  the  doc  so  doc.createElement(Tag)  will  get  updated  base  }  }    addChildToParent(child,  isEmptyElement);  }    private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  href.length  (  )  !=  0  )  {	[BUGGY]  if  (  tagName.length(  )  !=  0)  {  [CONTEXT]  if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  [BUGGY]  if(  tagName.length  ()!=  0  ){  baseUri  =  href;  doc.setBaseUri(href);  //  set  on  the  doc  so  doc.createElement(Tag)  will  get  updated  base  }  }    addChildToParent(child,  isEmptyElement);  }    private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  href.length  (  )  !=  0  )  {	[BUGGY]  if  (  tagName.length(  )  ==  0)  {  [CONTEXT]  if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  [BUGGY]  if(  tagName.length  ()==  0  ){  baseUri  =  href;  doc.setBaseUri(href);  //  set  on  the  doc  so  doc.createElement(Tag)  will  get  updated  base  }  }    addChildToParent(child,  isEmptyElement);  }    private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  href.length  (  )  !=  0  )  {  baseUri  =  href;  doc.setBaseUri  (  href  )  ;  }	[BUGGY]  baseUri  =  href;  doc.setBaseUri(href);  [CONTEXT]  if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  [BUGGY]  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc    baseUri  =  href;  doc.setBaseUri(href);      }    addChildToParent(child,  isEmptyElement);  }    private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  href.length  (  )  !=  0  )  {  baseUri  =  href;  doc.setBaseUri  (  href  )  ;  }	[BUGGY]    [CONTEXT]  if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  [BUGGY]  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc          }    addChildToParent(child,  isEmptyElement);  }    private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
baseUri  =  href;	[BUGGY]  baseUri  =  tagName;  [CONTEXT]  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  [BUGGY]  baseUri  =  tagName;  doc.setBaseUri(href);  //  set  on  the  doc  so  doc.createElement(Tag)  will  get  updated  base  }  }    addChildToParent(child,  isEmptyElement);  }    private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();          [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
baseUri  =  href;	[BUGGY]  baseUri  =    html;  [CONTEXT]  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  [BUGGY]  baseUri  =html;  doc.setBaseUri(href);  //  set  on  the  doc  so  doc.createElement(Tag)  will  get  updated  base  }  }    addChildToParent(child,  isEmptyElement);  }    private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();          [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
baseUri  =  href;	[BUGGY]    baseUri  =  href;  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
baseUri  =  href;	[BUGGY]  this.baseUri  =  baseUri;baseUri  =  href;  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
doc.setBaseUri  (  href  )  ;	[BUGGY]  doc.setBaseUri(  data);  [CONTEXT]  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;  [BUGGY]  doc.setBaseUri  (  data  )  ;  }  }    addChildToParent(child,  isEmptyElement);  }    private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
doc.setBaseUri  (  href  )  ;	[BUGGY]  doc.createShell(  href);  [CONTEXT]  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;  [BUGGY]  doc.createShell  (  href  )  ;  }  }    addChildToParent(child,  isEmptyElement);  }    private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
doc.setBaseUri  (  href  )  ;	[BUGGY]  doc  .createShell(  data)  ;  [CONTEXT]  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;  [BUGGY]  doc  .createShell  (  data  );  }  }    addChildToParent(child,  isEmptyElement);  }    private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
doc.setBaseUri  (  href  )  ;	[BUGGY]    [CONTEXT]  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;  [BUGGY]  doc.setBaseUri(href);  //  set  on  the  doc  so  doc.createElement(Tag)  will  get  updated  base    }  }    addChildToParent(child,  isEmptyElement);  }    private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();          [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
baseUri  =  href;	[BUGGY]  doc.setBaseUri(  href);  baseUri  =  href;  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
String  href  =  child.absUrl  (   "href "  )  ;	[BUGGY]  char  href  =  child.absUrl(   "href ");  [CONTEXT]      if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  [BUGGY]  char  href  =  child.absUrl  (   "href "  )  ;  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;  doc.setBaseUri(href);  //  set  on  the  doc  so  doc.createElement(Tag)  will  get  updated  base  }  }    addChildToParent(child,  isEmptyElement);  }    private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
String  href  =  child.absUrl  (   "href "  )  ;	[BUGGY]  String  href  =  child.absUrl(   "hrefhr ");  [CONTEXT]      if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  [BUGGY]  String  href  =  child.absUrl  (   "hrefhr "  )  ;  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;  doc.setBaseUri(href);  //  set  on  the  doc  so  doc.createElement(Tag)  will  get  updated  base  }  }    addChildToParent(child,  isEmptyElement);  }    private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
String  href  =  child.absUrl  (   "href "  )  ;	[BUGGY]    [CONTEXT]      if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  [BUGGY]  String  href  =  child.absUrl( "href ");    if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;  doc.setBaseUri(href);  //  set  on  the  doc  so  doc.createElement(Tag)  will  get  updated  base  }  }    addChildToParent(child,  isEmptyElement);  }    private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  href.length  (  )  !=  0  )  {	[BUGGY]  if  (  href  .endsWith(  DQ)    !=  0)  {  [CONTEXT]  if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  [BUGGY]  if(  href  .endsWith  (  DQ  )  !=  0  ){  baseUri  =  href;  doc.setBaseUri(href);  //  set  on  the  doc  so  doc.createElement(Tag)  will  get  updated  base  }  }    addChildToParent(child,  isEmptyElement);  }    private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
doc.setBaseUri  (  href  )  ;	[BUGGY]  doc.setBaseUri(  tagName);  [CONTEXT]  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;  [BUGGY]  doc.setBaseUri  (  tagName  )  ;  }  }    addChildToParent(child,  isEmptyElement);  }    private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
doc.setBaseUri  (  href  )  ;	[BUGGY]  doc  .createShell(  html)  ;  [CONTEXT]  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;  [BUGGY]  doc  .createShell  (  html  );  }  }    addChildToParent(child,  isEmptyElement);  }    private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  href.length  (  )  !=  0  )  {	[BUGGY]  if  (  href.length(  )  <=  0)  {  [CONTEXT]  if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  [BUGGY]  if(  href.length  ()<=  0  ){  baseUri  =  href;  doc.setBaseUri(href);  //  set  on  the  doc  so  doc.createElement(Tag)  will  get  updated  base  }  }    addChildToParent(child,  isEmptyElement);  }    private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  href.length  (  )  !=  0  )  {	[BUGGY]  if  (  href.length(  )  !=  2)  {  [CONTEXT]  if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  [BUGGY]  if(  href.length  ()!=  2  ){  baseUri  =  href;  doc.setBaseUri(href);  //  set  on  the  doc  so  doc.createElement(Tag)  will  get  updated  base  }  }    addChildToParent(child,  isEmptyElement);  }    private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  href.length  (  )  !=  0  )  {	[BUGGY]  if  (  href.length()  +  4    !=  0)  {  [CONTEXT]  if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  [BUGGY]  if(  href.length()  +  4!=  0  ){  baseUri  =  href;  doc.setBaseUri(href);  //  set  on  the  doc  so  doc.createElement(Tag)  will  get  updated  base  }  }    addChildToParent(child,  isEmptyElement);  }    private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
baseUri  =  href;	[BUGGY]  baseUri  =  data;  [CONTEXT]  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  [BUGGY]  baseUri  =  data;  doc.setBaseUri(href);  //  set  on  the  doc  so  doc.createElement(Tag)  will  get  updated  base  }  }    addChildToParent(child,  isEmptyElement);  }    private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();          [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  child.tagName  (  )  .equals  (   "base "  )  )  {	[BUGGY]  if  (  child.tagName(  ).equals(   "bases "))  {  [CONTEXT]        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        [BUGGY]  if(  child.tagName  ()  .equals  (   "bases "  )){  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;  doc.setBaseUri(href);  //  set  on  the  doc  so  doc.createElement(Tag)  will  get  updated  base  }  }    addChildToParent(child,  isEmptyElement);  }    private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  child.tagName  (  )  .equals  (   "base "  )  )  {	[BUGGY]  if  (  child.tagName(  )  .equals(  DQ)  )  {  [CONTEXT]        if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        [BUGGY]  if(  child.tagName  ().equals  (  DQ  )  ){  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;  doc.setBaseUri(href);  //  set  on  the  doc  so  doc.createElement(Tag)  will  get  updated  base  }  }    addChildToParent(child,  isEmptyElement);  }    private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
String  href  =  child.absUrl  (   "href "  )  ;	[BUGGY]  String  href  =  child.absUrl(   "ref ");  [CONTEXT]      if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  [BUGGY]  String  href  =  child.absUrl  (   "ref "  )  ;  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;  doc.setBaseUri(href);  //  set  on  the  doc  so  doc.createElement(Tag)  will  get  updated  base  }  }    addChildToParent(child,  isEmptyElement);  }    private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  href.length  (  )  !=  0  )  {	[BUGGY]  if  (  href.length()  +  8    !=  0)  {  [CONTEXT]  if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  [BUGGY]  if(  href.length()  +  8!=  0  ){  baseUri  =  href;  doc.setBaseUri(href);  //  set  on  the  doc  so  doc.createElement(Tag)  will  get  updated  base  }  }    addChildToParent(child,  isEmptyElement);  }    private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  href.length  (  )  !=  0  )  {	[BUGGY]  if  (  html.length(  )  !=  0)  {  [CONTEXT]  if  (tag.isData())  {  String  data  =  tq.chompTo( "</ "  +  tagName);  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  [BUGGY]  if(  html.length  ()!=  0  ){  baseUri  =  href;  doc.setBaseUri(href);  //  set  on  the  doc  so  doc.createElement(Tag)  will  get  updated  base  }  }    addChildToParent(child,  isEmptyElement);  }    private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
doc.setBaseUri  (  href  )  ;	[BUGGY]  doc  .createShell(  baseUri)  ;  [CONTEXT]  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;  [BUGGY]  doc  .createShell  (  baseUri  );  }  }    addChildToParent(child,  isEmptyElement);  }    private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
doc.setBaseUri  (  href  )  ;	[BUGGY]  doc.createShell(  tagName);  [CONTEXT]  tq.chompTo( "> ");    Node  dataNode;  if  (tag.equals(titleTag)  ||  tag.equals(textareaTag))  //  want  to  show  as  text,  but  not  contain  inside  tags  (so  not  a  data  tag?)  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;  [BUGGY]  doc.createShell  (  tagName  )  ;  }  }    addChildToParent(child,  isEmptyElement);  }    private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
addChildToParent  (  child,  isEmptyElement  )  ;	[BUGGY]  addChildToParent(  isEmptyElement,  child);  [CONTEXT]  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;  doc.setBaseUri(href);  //  set  on  the  doc  so  doc.createElement(Tag)  will  get  updated  base  }  }    [BUGGY]  addChildToParent  (  isEmptyElement,  child  )  ;  }    private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
addChildToParent  (  child,  isEmptyElement  )  ;	[BUGGY]  addChildToParent(    isEmptyElement);  [CONTEXT]  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;  doc.setBaseUri(href);  //  set  on  the  doc  so  doc.createElement(Tag)  will  get  updated  base  }  }    [BUGGY]  addChildToParent  (isEmptyElement  )  ;  }    private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
addChildToParent  (  child,  isEmptyElement  )  ;	[BUGGY]  addChildToParent(  child);  [CONTEXT]  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;  doc.setBaseUri(href);  //  set  on  the  doc  so  doc.createElement(Tag)  will  get  updated  base  }  }    [BUGGY]  addChildToParent  (  child  )  ;  }    private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
addChildToParent  (  child,  isEmptyElement  )  ;	[BUGGY]  parseBodyFragment(  child,  isEmptyElement);  [CONTEXT]  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;  doc.setBaseUri(href);  //  set  on  the  doc  so  doc.createElement(Tag)  will  get  updated  base  }  }    [BUGGY]  parseBodyFragment  (  child,  isEmptyElement  )  ;  }    private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
addChildToParent  (  child,  isEmptyElement  )  ;	[BUGGY]    [CONTEXT]  dataNode  =  TextNode.createFromEncoded(data,  baseUri);  else  dataNode  =  new  DataNode(data,  baseUri);  //  data  not  encoded  but  raw  (for   "  in  script)  child.appendChild(dataNode);  }        if  (child.tagName().equals( "base "))  {  String  href  =  child.absUrl( "href ");  if  (href.length()  !=  0)  {  //  ignore  <base  target>  etc  baseUri  =  href;  doc.setBaseUri(href);  //  set  on  the  doc  so  doc.createElement(Tag)  will  get  updated  base  }  }    [BUGGY]  addChildToParent(child,  isEmptyElement);    }    private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);        [CLASS]  Parser    [METHOD]  parseStartTag  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    Attribute    attribute    Element    child    Node    dataNode    Attributes    attributes    String    DQ    SQ    baseUri    bodyHtml    data    href    html    tagName    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.consumeWhitespace  (  )  ;	[BUGGY]  tq.matchesWhitespace(  );  [CONTEXT]  private  Attribute  parseAttribute()  {  [BUGGY]  tq.matchesWhitespace  ()  ;  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.consumeWhitespace  (  )  ;	[BUGGY]    [CONTEXT]  private  Attribute  parseAttribute()  {  [BUGGY]  tq.consumeWhitespace();    String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.consumeWhitespace  (  )  ;	[BUGGY]  tq.consume(  );tq.consumeWhitespace(  );  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.consumeWhitespace  (  )  ;	[BUGGY]  tq.consume(   "</ ");tq.consumeWhitespace(  );  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.consumeWhitespace  (  )  ;	[BUGGY]  tq.consume(   "< ");tq.consumeWhitespace(  );  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.consumeWhitespace  (  )  ;	[BUGGY]  tq.consume(   "<!-- ");tq.consumeWhitespace(  );  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
String  key  =  tq.consumeAttributeKey  (  )  ;	[BUGGY]  char  key  =  tq.consumeAttributeKey(  );  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  [BUGGY]  char  key  =  tq.consumeAttributeKey  ()  ;  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
String  key  =  tq.consumeAttributeKey  (  )  ;	[BUGGY]  String  key  =  tq.consumeWord(  );  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  [BUGGY]  String  key  =  tq.consumeWord  ()  ;  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
String  key  =  tq.consumeAttributeKey  (  )  ;	[BUGGY]  String  text  =  tq.consumeTo(   "< ");String  key  =  tq.consumeAttributeKey(  );  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
String  key  =  tq.consumeAttributeKey  (  )  ;	[BUGGY]  String  tagName  =  tq.consumeWord(  );String  key  =  tq.consumeAttributeKey(  );  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
String  key  =  tq.consumeAttributeKey  (  )  ;  String  value  =   " ";	[BUGGY]    [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  [BUGGY]  String  key  =  tq.consumeAttributeKey();      tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
String  value  =   " ";	[BUGGY]  char  value  =   " ";  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  [BUGGY]  char  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.consumeWhitespace  (  )  ;	[BUGGY]  tq.matchesWhitespace(  );  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  [BUGGY]  tq.matchesWhitespace  ()  ;  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.consumeWhitespace  (  )  ;	[BUGGY]    [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  [BUGGY]  tq.consumeWhitespace();    if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
while  (  !tq.matchesAny  (   "< ",   "/> ",   "> "  )  &&  !tq.matchesWhitespace  (  )  &&  !tq.isEmpty  (  )  )  {	[BUGGY]  while  (  !tq.matchesAny(   "< ",   "/> ",   "> ")  ||  !tq.matchesWhitespace(  )  &&  !tq.isEmpty(  ))  {  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      [BUGGY]  while(  !tq.matchesAny  (   "< ",   "/> ",   "> "  )||  !tq.matchesWhitespace  ()&&  !tq.isEmpty  ()){  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
while  (  !tq.matchesAny  (   "< ",   "/> ",   "> "  )  &&  !tq.matchesWhitespace  (  )  &&  !tq.isEmpty  (  )  )  {	[BUGGY]  while  (  !tq.matchesAny(   " ",   "/> ",   "> ")  &&  !tq.matchesWhitespace(  )  &&  !tq.isEmpty(  ))  {  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      [BUGGY]  while(  !tq.matchesAny  (   " ",   "/> ",   "> "  )&&  !tq.matchesWhitespace  ()&&  !tq.isEmpty  ()){  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
while  (  !tq.matchesAny  (   "< ",   "/> ",   "> "  )  &&  !tq.matchesWhitespace  (  )  &&  !tq.isEmpty  (  )  )  {	[BUGGY]  while  (  !tq.matchesAny(   "< ",   "/> ",   " ")  &&  !tq.matchesWhitespace(  )  &&  !tq.isEmpty(  ))  {  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      [BUGGY]  while(  !tq.matchesAny  (   "< ",   "/> ",   " "  )&&  !tq.matchesWhitespace  ()&&  !tq.isEmpty  ()){  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
while  (  !tq.matchesAny  (   "< ",   "/> ",   "> "  )  &&  !tq.matchesWhitespace  (  )  &&  !tq.isEmpty  (  )  )  {	[BUGGY]  while  (  !tq.matchesAny(   "< ",   "/> ",   "> ")  &&  !tq.consumeWhitespace(  )  &&  !tq.isEmpty(  ))  {  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      [BUGGY]  while(  !tq.matchesAny  (   "< ",   "/> ",   "> "  )&&  !tq.consumeWhitespace  ()&&  !tq.isEmpty  ()){  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
while  (  !tq.matchesAny  (   "< ",   "/> ",   "> "  )  &&  !tq.matchesWhitespace  (  )  &&  !tq.isEmpty  (  )  )  {	[BUGGY]  while  (  !tq.matchesAny(   "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace(  )  &&  !tq.chompTo(  ))  {  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      [BUGGY]  while(  !tq.matchesAny  (   "< ",   "/> ",   "> "  )&&  !tq.matchesWhitespace  ()&&  !tq.chompTo  ()){  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
valueAccum.append  (  tq.consume  (  )  )  ;	[BUGGY]  valueAccum  .toString(  )  ;  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  [BUGGY]  valueAccum  .toString  ();  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
valueAccum.append  (  tq.consume  (  )  )  ;	[BUGGY]  valueAccum.append(  tq.consumeWord(  ));  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  [BUGGY]  valueAccum.append  (  tq.consumeWord  ())  ;  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
valueAccum.append  (  tq.consume  (  )  )  ;	[BUGGY]    [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  [BUGGY]  valueAccum.append(tq.consume());    }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  tq.matchChomp  (   "= "  )  )  {	[BUGGY]  if  (  tq.matchChomp(   " "))  {  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  [BUGGY]  if(  tq.matchChomp  (   " "  )){  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  tq.matchChomp  (   "= "  )  )  {	[BUGGY]  if  ((!(tq.matchesAny( "< ",   "/> ",   "> "))  &&  !(tq.matchesWhitespace())))  {  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  [BUGGY]  if(  (!(tq.matchesAny( "< ",   "/> ",   "> "))  &&  !(tq.matchesWhitespace()))  ){  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  tq.matchChomp  (   "= "  )  )  {	[BUGGY]  if  (  tq.matches(   "= "))  {  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  [BUGGY]  if(  tq.matches  (   "= "  )){  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  tq.matchChomp  (   "= "  )  )  {	[BUGGY]  if  (  tq.matchesWhitespace(   "= "))  {  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  [BUGGY]  if(  tq.matchesWhitespace  (   "= "  )){  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  tq.matchChomp  (   "= "  )  )  {	[BUGGY]  if  (  tq.matchChomp(   "/> "))  {  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  [BUGGY]  if(  tq.matchChomp  (   "/> "  )){  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  tq.matchChomp  (   "= "  )  )  {	[BUGGY]  if  (  tq.matchChomp(  SQ))  {  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  [BUGGY]  if(  tq.matchChomp  (  SQ  )){  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
while  (  !tq.matchesAny  (   "< ",   "/> ",   "> "  )  &&  !tq.matchesWhitespace  (  )  &&  !tq.isEmpty  (  )  )  {	[BUGGY]  while  (  !tq  .matches(  href)    &&  !tq.matchesWhitespace(  )  &&  !tq.isEmpty(  ))  {  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      [BUGGY]  while(  !tq  .matches  (  href  )  &&  !tq.matchesWhitespace  ()&&  !tq.isEmpty  ()){  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  tq.matchChomp  (  SQ  )  )  {	[BUGGY]  if  (  tq.matchChomp(  key))  {  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    [BUGGY]  if(  tq.matchChomp  (  key  )){  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  tq.matchChomp  (  SQ  )  )  {	[BUGGY]  if  (  SQ.matchChomp(  tq))  {  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    [BUGGY]  if(  SQ.matchChomp  (  tq  )){  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  tq.matchChomp  (  SQ  )  )  {	[BUGGY]  if  ((!(tq.matchesAny( "< ",   "/> ",   "> "))  &&  !(tq.matchesWhitespace())))  {  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    [BUGGY]  if(  (!(tq.matchesAny( "< ",   "/> ",   "> "))  &&  !(tq.matchesWhitespace()))  ){  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  tq.matchChomp  (  SQ  )  )  {	[BUGGY]  if  (  tq.matchesWhitespace(  SQ))  {  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    [BUGGY]  if(  tq.matchesWhitespace  (  SQ  )){  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  tq.matchChomp  (  SQ  )  )  {	[BUGGY]  if  (  tq  .matches(  bodyHtml)  )  {  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    [BUGGY]  if(  tq  .matches  (  bodyHtml  )  ){  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  tq.matchChomp  (  SQ  )  )  {	[BUGGY]  if  (  tq  .matches(  value)  )  {  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    [BUGGY]  if(  tq  .matches  (  value  )  ){  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  tq.matchChomp  (  SQ  )  )  {	[BUGGY]  if  (  tq.matchChomp(  value))  {  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    [BUGGY]  if(  tq.matchChomp  (  value  )){  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  tq.matchChomp  (  SQ  )  )  {	[BUGGY]  if  (  tq.matchChomp(   "= "))  {  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    [BUGGY]  if(  tq.matchChomp  (   "= "  )){  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  tq.matchChomp  (  SQ  )  )  {	[BUGGY]  if  (  tq.matchChomp(   "/> "))  {  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    [BUGGY]  if(  tq.matchChomp  (   "/> "  )){  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
while  (  !tq.matchesAny  (   "< ",   "/> ",   "> "  )  &&  !tq.matchesWhitespace  (  )  &&  !tq.isEmpty  (  )  )  {	[BUGGY]  while  (  !tq.matchesAny(   "< ",   " ",   "> ")  &&  !tq.matchesWhitespace(  )  &&  !tq.isEmpty(  ))  {  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      [BUGGY]  while(  !tq.matchesAny  (   "< ",   " ",   "> "  )&&  !tq.matchesWhitespace  ()&&  !tq.isEmpty  ()){  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
while  (  !tq.matchesAny  (   "< ",   "/> ",   "> "  )  &&  !tq.matchesWhitespace  (  )  &&  !tq.isEmpty  (  )  )  {	[BUGGY]  while  (  !tq.matchesAny(   "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace(  )  &&  !tq  .chompTo(  bodyHtml)  )  {  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      [BUGGY]  while(  !tq.matchesAny  (   "< ",   "/> ",   "> "  )&&  !tq.matchesWhitespace  ()&&  !tq  .chompTo  (  bodyHtml  )  ){  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
}  else  if  (  tq.matchChomp  (  DQ  )  )  {	[BUGGY]    else  if  (  tq.matchChomp(  html))  {  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  [BUGGY]  }  else  if(  tq.matchChomp  (  html  )){  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
}  else  if  (  tq.matchChomp  (  DQ  )  )  {	[BUGGY]    else  if  (  DQ.matchChomp(  tq))  {  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  [BUGGY]  }  else  if(  DQ.matchChomp  (  tq  )){  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
}  else  if  (  tq.matchChomp  (  DQ  )  )  {	[BUGGY]    else  if  ((!(tq.matchesAny( "< ",   "/> ",   "> "))  &&  !(tq.matchesWhitespace())))  {  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  [BUGGY]  }  else  if(  (!(tq.matchesAny( "< ",   "/> ",   "> "))  &&  !(tq.matchesWhitespace()))  ){  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
}  else  if  (  tq.matchChomp  (  DQ  )  )  {	[BUGGY]    else  {  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  [BUGGY]  }  else  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
}  else  if  (  tq.matchChomp  (  DQ  )  )  {	[BUGGY]    else  if  (  tq.matchesWhitespace(  DQ))  {  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  [BUGGY]  }  else  if(  tq.matchesWhitespace  (  DQ  )){  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
}  else  if  (  tq.matchChomp  (  DQ  )  )  {	[BUGGY]      if  (  tq.matchChomp(  key))  {  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  [BUGGY]  }if(  tq.matchChomp  (  key  )){  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
}  else  if  (  tq.matchChomp  (  DQ  )  )  {	[BUGGY]    else  if  (  tq.matches(   "<![CDATA[ "))  {  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  [BUGGY]  }  else  if(  tq.matches  (   "<![CDATA[ "  )){  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
}  else  if  (  tq.matchChomp  (  DQ  )  )  {	[BUGGY]    else  if  (  tq.matches(   "< "))  {  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  [BUGGY]  }  else  if(  tq.matches  (   "< "  )){  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
}  else  if  (  tq.matchChomp  (  DQ  )  )  {	[BUGGY]    else  if  (  tq.matches(   "</ "))  {  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  [BUGGY]  }  else  if(  tq.matches  (   "</ "  )){  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
while  (  !tq.matchesAny  (   "< ",   "/> ",   "> "  )  &&  !tq.matchesWhitespace  (  )  &&  !tq.isEmpty  (  )  )  {	[BUGGY]  while  (  !tq.matchesAny(   "< ",   "/> ",   "> ")  ||  !tq.matchesWhitespace(  )  &&  !tq.isEmpty(  ))  {  [CONTEXT]  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      [BUGGY]  while(  !tq.matchesAny  (   "< ",   "/> ",   "> "  )||  !tq.matchesWhitespace  ()&&  !tq.isEmpty  ()){  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
while  (  !tq.matchesAny  (   "< ",   "/> ",   "> "  )  &&  !tq.matchesWhitespace  (  )  &&  !tq.isEmpty  (  )  )  {	[BUGGY]  while  (  !tq.matchesAny(   " ",   "/> ",   "> ")  &&  !tq.matchesWhitespace(  )  &&  !tq.isEmpty(  ))  {  [CONTEXT]  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      [BUGGY]  while(  !tq.matchesAny  (   " ",   "/> ",   "> "  )&&  !tq.matchesWhitespace  ()&&  !tq.isEmpty  ()){  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
while  (  !tq.matchesAny  (   "< ",   "/> ",   "> "  )  &&  !tq.matchesWhitespace  (  )  &&  !tq.isEmpty  (  )  )  {	[BUGGY]  while  (  !tq.matchesAny(   "< ",   "/> ",   " ")  &&  !tq.matchesWhitespace(  )  &&  !tq.isEmpty(  ))  {  [CONTEXT]  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      [BUGGY]  while(  !tq.matchesAny  (   "< ",   "/> ",   " "  )&&  !tq.matchesWhitespace  ()&&  !tq.isEmpty  ()){  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
while  (  !tq.matchesAny  (   "< ",   "/> ",   "> "  )  &&  !tq.matchesWhitespace  (  )  &&  !tq.isEmpty  (  )  )  {	[BUGGY]  while  (  !tq  .matches(  baseUri)    &&  !tq.matchesWhitespace(  )  &&  !tq.isEmpty(  ))  {  [CONTEXT]  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      [BUGGY]  while(  !tq  .matches  (  baseUri  )  &&  !tq.matchesWhitespace  ()&&  !tq.isEmpty  ()){  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
while  (  !tq.matchesAny  (   "< ",   "/> ",   "> "  )  &&  !tq.matchesWhitespace  (  )  &&  !tq.isEmpty  (  )  )  {	[BUGGY]  while  (  !tq.matchesAny(   "< ",   "/> ",   "> ")  &&  !tq.consumeWhitespace(  )  &&  !tq.isEmpty(  ))  {  [CONTEXT]  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      [BUGGY]  while(  !tq.matchesAny  (   "< ",   "/> ",   "> "  )&&  !tq.consumeWhitespace  ()&&  !tq.isEmpty  ()){  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
while  (  !tq.matchesAny  (   "< ",   "/> ",   "> "  )  &&  !tq.matchesWhitespace  (  )  &&  !tq.isEmpty  (  )  )  {	[BUGGY]  while  (  !tq.matchesAny(   "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace(  )  &&  !tq.chompTo(  ))  {  [CONTEXT]  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      [BUGGY]  while(  !tq.matchesAny  (   "< ",   "/> ",   "> "  )&&  !tq.matchesWhitespace  ()&&  !tq.chompTo  ()){  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
valueAccum.append  (  tq.consume  (  )  )  ;	[BUGGY]  valueAccum.append(  tq.consumeWord(  ));  [CONTEXT]  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  [BUGGY]  valueAccum.append  (  tq.consumeWord  ())  ;  }  value  =  valueAccum.toString();  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
valueAccum.append  (  tq.consume  (  )  )  ;	[BUGGY]    [CONTEXT]  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  [BUGGY]  valueAccum.append(tq.consume());    }  value  =  valueAccum.toString();        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
value  =  valueAccum.toString  (  )  ;	[BUGGY]  value  =  valueAccum.tochar(  );  [CONTEXT]  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  [BUGGY]  value  =  valueAccum.tochar  ()  ;  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
value  =  valueAccum.toString  (  )  ;	[BUGGY]  value  =    null.toString(  );  [CONTEXT]  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  [BUGGY]  value  =null.toString  ()  ;  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
while  (  !tq.matchesAny  (   "< ",   "/> ",   "> "  )  &&  !tq.matchesWhitespace  (  )  &&  !tq.isEmpty  (  )  )  {  valueAccum.append  (  tq.consume  (  )  )  ;	[BUGGY]    [CONTEXT]  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      [BUGGY]  while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {      }  value  =  valueAccum.toString();        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
while  (  !tq.matchesAny  (   "< ",   "/> ",   "> "  )  &&  !tq.matchesWhitespace  (  )  &&  !tq.isEmpty  (  )  )  {	[BUGGY]  while  (  !tq.matchesAny(   "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace(  )  &&  !tq.isEmpty(  ))  {  valueAccum.append(  tq.consume(  ));while  (  !tq.matchesAny(   "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace(  )  &&  !tq.isEmpty(  ))  {  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
while  (  !tq.matchesAny  (   "< ",   "/> ",   "> "  )  &&  !tq.matchesWhitespace  (  )  &&  !tq.isEmpty  (  )  )  {	[BUGGY]  while  (  !tq.matchesAny(   "< ",   "/> ",   "> ")  &&  !tq.isEmpty(  ))  {  Attribute  attribute  =  parseAttribute(  );while  (  !tq.matchesAny(   "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace(  )  &&  !tq.isEmpty(  ))  {  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
valueAccum.append  (  tq.consume  (  )  )  ;	[BUGGY]  valueAccum.append(  tq  .consume(  baseUri)  );  [CONTEXT]  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  [BUGGY]  valueAccum.append  (  tq  .consume  (  baseUri  )  )  ;  }  value  =  valueAccum.toString();  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
value  =  valueAccum.toString  (  )  ;	[BUGGY]    [CONTEXT]  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  [BUGGY]  value  =  valueAccum.toString();          [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
value  =  tq.chompTo  (  DQ  )  ;	[BUGGY]  value  =  tq.chompTo(  tagName);  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  [BUGGY]  value  =  tq.chompTo  (  tagName  )  ;  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
value  =  tq.chompTo  (  DQ  )  ;	[BUGGY]  value  =  DQ.chompTo(  tq);  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  [BUGGY]  value  =  DQ.chompTo  (  tq  )  ;  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
value  =  tq.chompTo  (  DQ  )  ;	[BUGGY]  value  =  tq  .chompTo(  html)  ;  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  [BUGGY]  value  =  tq  .chompTo  (  html  );  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
value  =  tq.chompTo  (  DQ  )  ;	[BUGGY]  value    =    value  ;  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  [BUGGY]  value=value  ;  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
value  =  tq.chompTo  (  DQ  )  ;	[BUGGY]  value  =  tq.chompTo(  value);  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  [BUGGY]  value  =  tq.chompTo  (  value  )  ;  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
value  =  tq.chompTo  (  DQ  )  ;	[BUGGY]  value  =  tq  .chompTo(  href)  ;  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  [BUGGY]  value  =  tq  .chompTo  (  href  );  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
value  =  tq.chompTo  (  DQ  )  ;	[BUGGY]  value  =  tq.chompTo(  key);  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  [BUGGY]  value  =  tq.chompTo  (  key  )  ;  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
value  =  tq.chompTo  (  DQ  )  ;	[BUGGY]    [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  [BUGGY]  value  =  tq.chompTo(DQ);    }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
value  =  valueAccum.toString  (  )  ;	[BUGGY]  value  =  valueAccum.tochar(  );  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  [BUGGY]  value  =  valueAccum.tochar  ()  ;  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
value  =  valueAccum.toString  (  )  ;	[BUGGY]  value  =    null.toString(  );  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  [BUGGY]  value  =null.toString  ()  ;  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
}  else  if  (  tq.matchChomp  (  DQ  )  )  {	[BUGGY]    else  if  (  tq.matchChomp(  value))  {  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  [BUGGY]  }  else  if(  tq.matchChomp  (  value  )){  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
while  (  !tq.matchesAny  (   "< ",   "/> ",   "> "  )  &&  !tq.matchesWhitespace  (  )  &&  !tq.isEmpty  (  )  )  {  valueAccum.append  (  tq.consume  (  )  )  ;	[BUGGY]    [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      [BUGGY]  while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {      }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
while  (  !tq.matchesAny  (   "< ",   "/> ",   "> "  )  &&  !tq.matchesWhitespace  (  )  &&  !tq.isEmpty  (  )  )  {	[BUGGY]  while  (  !tq.matchesAny(   "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace(  )  &&  !tq.isEmpty(  ))  {  valueAccum.append(  tq.consume(  ));while  (  !tq.matchesAny(   "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace(  )  &&  !tq.isEmpty(  ))  {  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
while  (  !tq.matchesAny  (   "< ",   "/> ",   "> "  )  &&  !tq.matchesWhitespace  (  )  &&  !tq.isEmpty  (  )  )  {	[BUGGY]  while  (  !tq.matchesAny(   "< ",   "/> ",   "> ")  &&  !tq.isEmpty(  ))  {  Attribute  attribute  =  parseAttribute(  );while  (  !tq.matchesAny(   "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace(  )  &&  !tq.isEmpty(  ))  {  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
valueAccum.append  (  tq.consume  (  )  )  ;	[BUGGY]  valueAccum.append(  tq  .consume(  href)  );  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  [BUGGY]  valueAccum.append  (  tq  .consume  (  href  )  )  ;  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
value  =  valueAccum.toString  (  )  ;	[BUGGY]    [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  [BUGGY]  value  =  valueAccum.toString();    }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
value  =  tq.chompTo  (  SQ  )  ;	[BUGGY]  value  =  tq.chompTo(  value);  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  [BUGGY]  value  =  tq.chompTo  (  value  )  ;  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
value  =  tq.chompTo  (  SQ  )  ;	[BUGGY]  value  =  SQ.chompTo(  tq);  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  [BUGGY]  value  =  SQ.chompTo  (  tq  )  ;  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
value  =  tq.chompTo  (  SQ  )  ;	[BUGGY]  value  =  tq  .chompTo(  DQ)  ;  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  [BUGGY]  value  =  tq  .chompTo  (  DQ  );  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
value  =  tq.chompTo  (  SQ  )  ;	[BUGGY]  value  ;  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  [BUGGY]  value  ;  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
value  =  tq.chompTo  (  SQ  )  ;	[BUGGY]  value  =  tq  .chompTo(  baseUri)  ;  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  [BUGGY]  value  =  tq  .chompTo  (  baseUri  );  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
value  =  tq.chompTo  (  SQ  )  ;	[BUGGY]  value  =  tq.chompTo(  tagName);  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  [BUGGY]  value  =  tq.chompTo  (  tagName  )  ;  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
value  =  tq.chompTo  (  SQ  )  ;	[BUGGY]    [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  [BUGGY]  value  =  tq.chompTo(SQ);    }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
}  else  if  (  tq.matchChomp  (  DQ  )  )  {	[BUGGY]      if  (  tq.matchChomp(  tagName))  {  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  [BUGGY]  }if(  tq.matchChomp  (  tagName  )){  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
while  (  !tq.matchesAny  (   "< ",   "/> ",   "> "  )  &&  !tq.matchesWhitespace  (  )  &&  !tq.isEmpty  (  )  )  {	[BUGGY]  while  (  !tq.matchesAny(   "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace(  )  &&  !tq  .chompTo(  DQ)  )  {  [CONTEXT]  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      [BUGGY]  while(  !tq.matchesAny  (   "< ",   "/> ",   "> "  )&&  !tq.matchesWhitespace  ()&&  !tq  .chompTo  (  DQ  )  ){  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
valueAccum.append  (  tq.consume  (  )  )  ;	[BUGGY]  valueAccum  .toString(  )  ;  [CONTEXT]  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  [BUGGY]  valueAccum  .toString  ();  }  value  =  valueAccum.toString();  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
while  (  !tq.matchesAny  (   "< ",   "/> ",   "> "  )  &&  !tq.matchesWhitespace  (  )  &&  !tq.isEmpty  (  )  )  {	[BUGGY]  while  (  !tq.matchesAny(   "< ",   "> ",   "> ")  &&  !tq.matchesWhitespace(  )  &&  !tq.isEmpty(  ))  {  [CONTEXT]  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      [BUGGY]  while(  !tq.matchesAny  (   "< ",   "> ",   "> "  )&&  !tq.matchesWhitespace  ()&&  !tq.isEmpty  ()){  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
while  (  !tq.matchesAny  (   "< ",   "/> ",   "> "  )  &&  !tq.matchesWhitespace  (  )  &&  !tq.isEmpty  (  )  )  {	[BUGGY]  while  (  !tq  .matches(  data)    &&  !tq.matchesWhitespace(  )  &&  !tq.isEmpty(  ))  {  [CONTEXT]  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      [BUGGY]  while(  !tq  .matches  (  data  )  &&  !tq.matchesWhitespace  ()&&  !tq.isEmpty  ()){  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
valueAccum.append  (  tq.consume  (  )  )  ;	[BUGGY]  valueAccum.append(  tq  .consume(  href)  );  [CONTEXT]  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  [BUGGY]  valueAccum.append  (  tq  .consume  (  href  )  )  ;  }  value  =  valueAccum.toString();  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
valueAccum.append  (  tq.consume  (  )  )  ;	[BUGGY]  valueAccum.append(  tq  .consume(  value)  );  [CONTEXT]  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  [BUGGY]  valueAccum.append  (  tq  .consume  (  value  )  )  ;  }  value  =  valueAccum.toString();  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
value  =  tq.chompTo  (  DQ  )  ;	[BUGGY]  value  ;  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  [BUGGY]  value  ;  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
value  =  tq.chompTo  (  SQ  )  ;	[BUGGY]  value  =  tq.chompTo(  html);  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  [BUGGY]  value  =  tq.chompTo  (  html  )  ;  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
value  =  tq.chompTo  (  SQ  )  ;	[BUGGY]  value  =  tq  .chompTo(  bodyHtml)  ;  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  [BUGGY]  value  =  tq  .chompTo  (  bodyHtml  );  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
value  =  tq.chompTo  (  SQ  )  ;	[BUGGY]  value    =    value  ;  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  [BUGGY]  value=value  ;  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
value  =  tq.chompTo  (  DQ  )  ;	[BUGGY]  value  =  tq  .chompTo(  SQ)  ;  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  [BUGGY]  value  =  tq  .chompTo  (  SQ  );  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.consumeWhitespace  (  )  ;	[BUGGY]  tq.matchesWhitespace(  );  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  [BUGGY]  tq.matchesWhitespace  ()  ;    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.consumeWhitespace  (  )  ;	[BUGGY]    [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  [BUGGY]  tq.consumeWhitespace();      if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  tq.matchChomp  (  SQ  )  )  {	[BUGGY]  if  (  tq.matchChomp(  tagName))  {  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    [BUGGY]  if(  tq.matchChomp  (  tagName  )){  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
}  else  if  (  tq.matchChomp  (  DQ  )  )  {	[BUGGY]    else  if  (  tq  .matches(  SQ)  )  {  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  [BUGGY]  }  else  if(  tq  .matches  (  SQ  )  ){  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
while  (  !tq.matchesAny  (   "< ",   "/> ",   "> "  )  &&  !tq.matchesWhitespace  (  )  &&  !tq.isEmpty  (  )  )  {	[BUGGY]  while  (  !tq.matchesAny(   "< ",   "> ",   "> ")  &&  !tq.matchesWhitespace(  )  &&  !tq.isEmpty(  ))  {  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      [BUGGY]  while(  !tq.matchesAny  (   "< ",   "> ",   "> "  )&&  !tq.matchesWhitespace  ()&&  !tq.isEmpty  ()){  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.consumeWhitespace  (  )  ;	[BUGGY]  tq.matchesWhitespace(  );  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  [BUGGY]  tq.matchesWhitespace  ()  ;  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.consumeWhitespace  (  )  ;	[BUGGY]    [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  [BUGGY]  tq.consumeWhitespace();    }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
while  (  !tq.matchesAny  (   "< ",   "/> ",   "> "  )  &&  !tq.matchesWhitespace  (  )  &&  !tq.isEmpty  (  )  )  {	[BUGGY]  while  (  !tq  .matches(  DQ)    &&  !tq.matchesWhitespace(  )  &&  !tq.isEmpty(  ))  {  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      [BUGGY]  while(  !tq  .matches  (  DQ  )  &&  !tq.matchesWhitespace  ()&&  !tq.isEmpty  ()){  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
valueAccum.append  (  tq.consume  (  )  )  ;	[BUGGY]  valueAccum.append(  tq  .consume(  tagName)  );  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  [BUGGY]  valueAccum.append  (  tq  .consume  (  tagName  )  )  ;  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
valueAccum.append  (  tq.consume  (  )  )  ;	[BUGGY]  valueAccum.append(  tq  .consume(  DQ)  );  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  [BUGGY]  valueAccum.append  (  tq  .consume  (  DQ  )  )  ;  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
}  else  if  (  tq.matchChomp  (  DQ  )  )  {	[BUGGY]    else  if  (  tq.matchChomp(  tagName))  {  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  [BUGGY]  }  else  if(  tq.matchChomp  (  tagName  )){  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
while  (  !tq.matchesAny  (   "< ",   "/> ",   "> "  )  &&  !tq.matchesWhitespace  (  )  &&  !tq.isEmpty  (  )  )  {	[BUGGY]  while  (  !tq.matchesAny(   "< ",   " ",   "> ")  &&  !tq.matchesWhitespace(  )  &&  !tq.isEmpty(  ))  {  [CONTEXT]  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      [BUGGY]  while(  !tq.matchesAny  (   "< ",   " ",   "> "  )&&  !tq.matchesWhitespace  ()&&  !tq.isEmpty  ()){  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
while  (  !tq.matchesAny  (   "< ",   "/> ",   "> "  )  &&  !tq.matchesWhitespace  (  )  &&  !tq.isEmpty  (  )  )  {	[BUGGY]  while  (  !tq  .matches(  html)    &&  !tq.matchesWhitespace(  )  &&  !tq.isEmpty(  ))  {  [CONTEXT]  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      [BUGGY]  while(  !tq  .matches  (  html  )  &&  !tq.matchesWhitespace  ()&&  !tq.isEmpty  ()){  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
while  (  !tq.matchesAny  (   "< ",   "/> ",   "> "  )  &&  !tq.matchesWhitespace  (  )  &&  !tq.isEmpty  (  )  )  {	[BUGGY]  while  (  !tq.matchesAny(   "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace(  )  &&  !tq  .chompTo(  bodyHtml)  )  {  [CONTEXT]  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      [BUGGY]  while(  !tq.matchesAny  (   "< ",   "/> ",   "> "  )&&  !tq.matchesWhitespace  ()&&  !tq  .chompTo  (  bodyHtml  )  ){  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
}  else  if  (  tq.matchChomp  (  DQ  )  )  {	[BUGGY]    else  if  (  tq  .matches(  html)  )  {  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  [BUGGY]  }  else  if(  tq  .matches  (  html  )  ){  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
}  else  if  (  tq.matchChomp  (  DQ  )  )  {	[BUGGY]    else  if  (  tq.matchChomp(  key))  {  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  [BUGGY]  }  else  if(  tq.matchChomp  (  key  )){  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
while  (  !tq.matchesAny  (   "< ",   "/> ",   "> "  )  &&  !tq.matchesWhitespace  (  )  &&  !tq.isEmpty  (  )  )  {	[BUGGY]  while  (  !tq  .matches(  bodyHtml)    &&  !tq.matchesWhitespace(  )  &&  !tq.isEmpty(  ))  {  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      [BUGGY]  while(  !tq  .matches  (  bodyHtml  )  &&  !tq.matchesWhitespace  ()&&  !tq.isEmpty  ()){  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
while  (  !tq.matchesAny  (   "< ",   "/> ",   "> "  )  &&  !tq.matchesWhitespace  (  )  &&  !tq.isEmpty  (  )  )  {	[BUGGY]  while  (  !tq.matchesAny(   "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace(  )  &&  !tq  .chompTo(  html)  )  {  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      [BUGGY]  while(  !tq.matchesAny  (   "< ",   "/> ",   "> "  )&&  !tq.matchesWhitespace  ()&&  !tq  .chompTo  (  html  )  ){  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
}  else  if  (  tq.matchChomp  (  DQ  )  )  {	[BUGGY]      if  (  tq.matchesWhitespace(  tagName))  {  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  [BUGGY]  }if(  tq.matchesWhitespace  (  tagName  )){  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
while  (  !tq.matchesAny  (   "< ",   "/> ",   "> "  )  &&  !tq.matchesWhitespace  (  )  &&  !tq.isEmpty  (  )  )  {	[BUGGY]  while  (  !tq.matchesAny(   "< ",   "/ ",   "> ")  &&  !tq.matchesWhitespace(  )  &&  !tq.isEmpty(  ))  {  [CONTEXT]  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      [BUGGY]  while(  !tq.matchesAny  (   "< ",   "/ ",   "> "  )&&  !tq.matchesWhitespace  ()&&  !tq.isEmpty  ()){  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
valueAccum.append  (  tq.consume  (  )  )  ;	[BUGGY]  valueAccum.append(  tq  .consume(  key)  );  [CONTEXT]  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  [BUGGY]  valueAccum.append  (  tq  .consume  (  key  )  )  ;  }  value  =  valueAccum.toString();  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
valueAccum.append  (  tq.consume  (  )  )  ;	[BUGGY]  valueAccum.append(  tq  .consume(  html)  );  [CONTEXT]  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  [BUGGY]  valueAccum.append  (  tq  .consume  (  html  )  )  ;  }  value  =  valueAccum.toString();  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
value  =  tq.chompTo  (  DQ  )  ;	[BUGGY]  value    =  null  ;  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  [BUGGY]  value=  null  ;  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
value  =  tq.chompTo  (  SQ  )  ;	[BUGGY]  value  =  tq  .chompTo(  SQ)  ;  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  [BUGGY]  value  =  tq  .chompTo  (  SQ  );  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  tq.matchChomp  (   "= "  )  )  {	[BUGGY]  if  (  tq  .matches(  bodyHtml)  )  {  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  [BUGGY]  if(  tq  .matches  (  bodyHtml  )  ){  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  tq.matchChomp  (  SQ  )  )  {	[BUGGY]  if  (  tq.matchChomp(  html))  {  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    [BUGGY]  if(  tq.matchChomp  (  html  )){  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  tq.matchChomp  (  SQ  )  )  {	[BUGGY]  if  (  tq  .matches(  html)  )  {  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    [BUGGY]  if(  tq  .matches  (  html  )  ){  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
while  (  !tq.matchesAny  (   "< ",   "/> ",   "> "  )  &&  !tq.matchesWhitespace  (  )  &&  !tq.isEmpty  (  )  )  {	[BUGGY]  while  (  !tq.matchesAny(   "< ",   "/ ",   "> ")  &&  !tq.matchesWhitespace(  )  &&  !tq.isEmpty(  ))  {  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      [BUGGY]  while(  !tq.matchesAny  (   "< ",   "/ ",   "> "  )&&  !tq.matchesWhitespace  ()&&  !tq.isEmpty  ()){  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
valueAccum.append  (  tq.consume  (  )  )  ;	[BUGGY]  valueAccum.append(  tq  .consume(  baseUri)  );  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  [BUGGY]  valueAccum.append  (  tq  .consume  (  baseUri  )  )  ;  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  key.length  (  )  !=  0  )  return  Attribute.createFromEncoded  (  key,  value  )  ;	[BUGGY]  if  (  key.length(  )  <  0)return  Attribute.createFromEncoded(  key,  value);  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  [BUGGY]  if(  key.length  ()<  0  )  return  Attribute.createFromEncoded  (  key,  value  )  ;    else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  key.length  (  )  !=  0  )  return  Attribute.createFromEncoded  (  key,  value  )  ;	[BUGGY]  if  (  key.length(  )  !=  8)return  Attribute.createFromEncoded(  key,  value);  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  [BUGGY]  if(  key.length  ()!=  8  )  return  Attribute.createFromEncoded  (  key,  value  )  ;    else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  key.length  (  )  !=  0  )  return  Attribute.createFromEncoded  (  key,  value  )  ;	[BUGGY]  if  (  key.length()  +  8    !=  0)return  Attribute.createFromEncoded(  key,  value);  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  [BUGGY]  if(  key.length()  +  8!=  0  )  return  Attribute.createFromEncoded  (  key,  value  )  ;    else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  key.length  (  )  !=  0  )  return  Attribute.createFromEncoded  (  key,  value  )  ;	[BUGGY]  if  (  tagName.length(  )  !=  0)return  Attribute.createFromEncoded(  key,  value);  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  [BUGGY]  if(  tagName.length  ()!=  0  )  return  Attribute.createFromEncoded  (  key,  value  )  ;    else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  key.length  (  )  !=  0  )  return  Attribute.createFromEncoded  (  key,  value  )  ;	[BUGGY]  if  (  key.length(  )  !=  0)return  Attribute.createFromEncoded(  key,  tagName);  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  [BUGGY]  if(  key.length  ()!=  0  )  return  Attribute.createFromEncoded  (  key,  tagName  )  ;    else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  key.length  (  )  !=  0  )  return  Attribute.createFromEncoded  (  key,  value  )  ;	[BUGGY]  if  (  value.length(  )  !=  0)return  Attribute.createFromEncoded(  key,  key);  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  [BUGGY]  if(  value.length  ()!=  0  )  return  Attribute.createFromEncoded  (  key,  key  )  ;    else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  key.length  (  )  !=  0  )  return  Attribute.createFromEncoded  (  key,  value  )  ;	[BUGGY]  if  (  key.length(  )  !=  0)return  Attribute.createFromEncoded(    value);  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  [BUGGY]  if(  key.length  ()!=  0  )  return  Attribute.createFromEncoded  (value  )  ;    else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  key.length  (  )  !=  0  )  return  Attribute.createFromEncoded  (  key,  value  )  ;	[BUGGY]  if  (  key.length(  )  !=  0)return  Attribute.createFromEncoded(  key);  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  [BUGGY]  if(  key.length  ()!=  0  )  return  Attribute.createFromEncoded  (  key  )  ;    else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  key.length  (  )  !=  0  )  return  Attribute.createFromEncoded  (  key,  value  )  ;	[BUGGY]  if  (  key.substring(  )  !=  0)return  Attribute.createFromEncoded(  key,  value);  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  [BUGGY]  if(  key.substring  ()!=  0  )  return  Attribute.createFromEncoded  (  key,  value  )  ;    else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  key.length  (  )  !=  0  )  return  Attribute.createFromEncoded  (  key,  value  )  ;	[BUGGY]  if  (  key  .endsWith(  SQ)    !=  0)return  Attribute.createFromEncoded(  key,  value);  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  [BUGGY]  if(  key  .endsWith  (  SQ  )  !=  0  )  return  Attribute.createFromEncoded  (  key,  value  )  ;    else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  key.length  (  )  !=  0  )  return  Attribute.createFromEncoded  (  key,  value  )  ;	[BUGGY]  if  (  key.length(  )  !=  0)return  Attribute  .TextNode(  )  ;  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  [BUGGY]  if(  key.length  ()!=  0  )  return  Attribute  .TextNode  ();    else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  key.length  (  )  !=  0  )  return  Attribute.createFromEncoded  (  key,  value  )  ;	[BUGGY]  if  (  key.length(  )  !=  0  )return  Attribute.createFromEncoded(  key,  value);  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  [BUGGY]  if(  key.length  ()!=  0)  return  Attribute.createFromEncoded  (  key,  value  )  ;    else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  key.length  (  )  !=  0  )  return  Attribute.createFromEncoded  (  key,  value  )  ;  else  {  tq.consume  (  )  ;  return  null;  }	[BUGGY]  return  org.jsoup.parser.Attribute.createFromEncoded(key,  value);  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  [BUGGY]  if  (key.length()  !=  0)    return  org.jsoup.parser.Attribute.createFromEncoded(key,  value);        }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  key.length  (  )  !=  0  )  return  Attribute.createFromEncoded  (  key,  value  )  ;  else  {  tq.consume  (  )  ;  return  null;  }	[BUGGY]    [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  [BUGGY]  if  (key.length()  !=  0)            }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
return  null;	[BUGGY]  return  this;  [CONTEXT]  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  [BUGGY]  return  this;  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.consume  (  )  ;	[BUGGY]  tq.consumeWord(  );  [CONTEXT]  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  [BUGGY]  tq.consumeWord  ()  ;  return  null;  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.consume  (  )  ;	[BUGGY]  tq  .consume(  html)  ;  [CONTEXT]  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  [BUGGY]  tq  .consume  (  html  );  return  null;  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.consume  (  )  ;  return  null;	[BUGGY]    [CONTEXT]  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  [BUGGY]  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck            [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.consume  (  )  ;	[BUGGY]  return  null;  tq.consume(  );  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.consume  (  )  ;	[BUGGY]  tq.consumeWhitespace(  );tq.consume(  );  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.consume  (  )  ;	[BUGGY]  tq.matchChomp(   "> ");tq.consume(  );  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.consume  (  )  ;	[BUGGY]  tq.consume(   "</ ");tq.consume(  );  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.consume  (  )  ;	[BUGGY]  tq.chompTo(   "> ");tq.consume(  );  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.consume  (  )  ;	[BUGGY]  tq.consume(   "< ");tq.consume(  );  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.consume  (  )  ;	[BUGGY]  tq.consume(   "<![CDATA[ ");tq.consume(  );  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.consume  (  )  ;	[BUGGY]  tq.consume(   "<!-- ");tq.consume(  );  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
return  Attribute.createFromEncoded  (  key,  value  )  ;	[BUGGY]  return  Attribute.createFromEncoded(  href,  value);  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  [BUGGY]  return  Attribute.createFromEncoded  (  href,  value  )  ;  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
return  Attribute.createFromEncoded  (  key,  value  )  ;	[BUGGY]  return  Attribute.createFromEncoded(  key,  html);  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  [BUGGY]  return  Attribute.createFromEncoded  (  key,  html  )  ;  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
return  Attribute.createFromEncoded  (  key,  value  )  ;	[BUGGY]  return  Attribute.createFromEncoded(  value,  key);  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  [BUGGY]  return  Attribute.createFromEncoded  (  value,  key  )  ;  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
return  Attribute.createFromEncoded  (  key,  value  )  ;	[BUGGY]  return  Attribute.createFromEncoded(    value);  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  [BUGGY]  return  Attribute.createFromEncoded  (value  )  ;  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
return  Attribute.createFromEncoded  (  key,  value  )  ;	[BUGGY]  return  Attribute.createFromEncoded(  key);  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  [BUGGY]  return  Attribute.createFromEncoded  (  key  )  ;  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
return  Attribute.createFromEncoded  (  key,  value  )  ;	[BUGGY]  return  Attribute  .TextNode(  )  ;  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  [BUGGY]  return  Attribute  .TextNode  ();  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
return  Attribute.createFromEncoded  (  key,  value  )  ;	[BUGGY]  return  Attribute.createFromEncoded(  tagName,  value);  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  [BUGGY]  return  Attribute.createFromEncoded  (  tagName,  value  )  ;  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
return  Attribute.createFromEncoded  (  key,  value  )  ;	[BUGGY]  return  Attribute.createFromEncoded(  key,  tagName);  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  [BUGGY]  return  Attribute.createFromEncoded  (  key,  tagName  )  ;  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
return  Attribute.createFromEncoded  (  key,  value  )  ;	[BUGGY]  return  Attribute.createFromEncoded(  key,  href);  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  [BUGGY]  return  Attribute.createFromEncoded  (  key,  href  )  ;  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
return  Attribute.createFromEncoded  (  key,  value  )  ;	[BUGGY]    [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  [BUGGY]  return  Attribute.createFromEncoded(key,  value);    else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
return  null;	[BUGGY]  return  true;  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  [BUGGY]  return  true;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  key.length  (  )  !=  0  )  return  Attribute.createFromEncoded  (  key,  value  )  ;	[BUGGY]  if  (  key.length()  +  9    !=  0)return  Attribute.createFromEncoded(  key,  value);  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  [BUGGY]  if(  key.length()  +  9!=  0  )  return  Attribute.createFromEncoded  (  key,  value  )  ;    else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  key.length  (  )  !=  0  )  return  Attribute.createFromEncoded  (  key,  value  )  ;	[BUGGY]  if  (  href.length(  )  !=  0)return  Attribute.createFromEncoded(  key,  value);  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  [BUGGY]  if(  href.length  ()!=  0  )  return  Attribute.createFromEncoded  (  key,  value  )  ;    else  {  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.consume  (  )  ;	[BUGGY]  tq.consumeWord(  );  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  [BUGGY]  tq.consumeWord  ()  ;  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.consume  (  )  ;	[BUGGY]  tq  .consume(  data)  ;  [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  [BUGGY]  tq  .consume  (  data  );  return  null;  }  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.consume  (  )  ;	[BUGGY]    [CONTEXT]  private  Attribute  parseAttribute()  {  tq.consumeWhitespace();  String  key  =  tq.consumeAttributeKey();  String  value  =   " ";  tq.consumeWhitespace();  if  (tq.matchChomp( "= "))  {  tq.consumeWhitespace();    if  (tq.matchChomp(SQ))  {  value  =  tq.chompTo(SQ);  }  else  if  (tq.matchChomp(DQ))  {  value  =  tq.chompTo(DQ);  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder();      while  (!tq.matchesAny( "< ",   "/> ",   "> ")  &&  !tq.matchesWhitespace()  &&  !tq.isEmpty())  {  valueAccum.append(tq.consume());  }  value  =  valueAccum.toString();  }  tq.consumeWhitespace();  }  if  (key.length()  !=  0)  return  Attribute.createFromEncoded(key,  value);  else  {  [BUGGY]  tq.consume();  //  unknown  char,  keep  popping  so  not  get  stuck    return  null;  }        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.consume  (  )  ;	[BUGGY]    tq.consume(  );  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.consume  (  )  ;	[BUGGY]  tq.consumeWhitespace(  );tq.consume(  );  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.consume  (  )  ;	[BUGGY]  tq.matchChomp(   "> ");tq.consume(  );  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.consume  (  )  ;	[BUGGY]  tq.consume(   "</ ");tq.consume(  );  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.consume  (  )  ;	[BUGGY]  tq.chompTo(   "> ");tq.consume(  );  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.consume  (  )  ;	[BUGGY]  tq.consume(   "< ");tq.consume(  );  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.consume  (  )  ;	[BUGGY]  tq.consume(   "<![CDATA[ ");tq.consume(  );  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.consume  (  )  ;	[BUGGY]  tq.consume(   "<!-- ");tq.consume(  );  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseAttribute  [RETURN_TYPE]  Attribute      [VARIABLES]  TokenQueue    tq    boolean    StringBuilder    valueAccum    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
String  text  =  tq.consumeTo  (   "< "  )  ;	[BUGGY]  char  text  =  tq.consumeTo(   "< ");  [CONTEXT]  private  void  parseTextNode()  {  [BUGGY]  char  text  =  tq.consumeTo  (   "< "  )  ;  TextNode  textNode  =  TextNode.createFromEncoded(text,  baseUri);  last().appendChild(textNode);  }        [CLASS]  Parser    [METHOD]  parseTextNode  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    TextNode    textNode    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    text    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
String  text  =  tq.consumeTo  (   "< "  )  ;	[BUGGY]  String  text  =  tq.consume(   "< ");  [CONTEXT]  private  void  parseTextNode()  {  [BUGGY]  String  text  =  tq.consume  (   "< "  )  ;  TextNode  textNode  =  TextNode.createFromEncoded(text,  baseUri);  last().appendChild(textNode);  }        [CLASS]  Parser    [METHOD]  parseTextNode  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    TextNode    textNode    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    text    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
String  text  =  tq.consumeTo  (   "< "  )  ;	[BUGGY]  String  text  =  tq  .consume(  baseUri)  ;  [CONTEXT]  private  void  parseTextNode()  {  [BUGGY]  String  text  =  tq  .consume  (  baseUri  );  TextNode  textNode  =  TextNode.createFromEncoded(text,  baseUri);  last().appendChild(textNode);  }        [CLASS]  Parser    [METHOD]  parseTextNode  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    TextNode    textNode    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    text    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
String  text  =  tq.consumeTo  (   "< "  )  ;	[BUGGY]  TextNode  textNode  =  TextNode.createFromEncoded(  text,  baseUri);  String  text  =  tq.consumeTo(   "< ");  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseTextNode  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    TextNode    textNode    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    text    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
String  text  =  tq.consumeTo  (   "< "  )  ;	[BUGGY]  String  rawText  =  tq.chompTo(   "]]> ");String  text  =  tq.consumeTo(   "< ");  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseTextNode  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    TextNode    textNode    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    text    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
String  text  =  tq.consumeTo  (   "< "  )  ;	[BUGGY]  String  data  =  tq.chompTo(   "-> ");String  text  =  tq.consumeTo(   "< ");  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseTextNode  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    TextNode    textNode    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    text    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
String  text  =  tq.consumeTo  (   "< "  )  ;	[BUGGY]  String  data  =  tq.chompTo(   "</ "  +  tagName);String  text  =  tq.consumeTo(   "< ");  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseTextNode  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    TextNode    textNode    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    text    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
String  text  =  tq.consumeTo  (   "< "  )  ;	[BUGGY]  String  key  =  tq.consumeAttributeKey(  );String  text  =  tq.consumeTo(   "< ");  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseTextNode  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    TextNode    textNode    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    text    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
String  text  =  tq.consumeTo  (   "< "  )  ;	[BUGGY]  String  data  =  tq.chompTo(   "> ");String  text  =  tq.consumeTo(   "< ");  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseTextNode  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    TextNode    textNode    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    text    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
String  text  =  tq.consumeTo  (   "< "  )  ;	[BUGGY]  String  tagName  =  tq.consumeWord(  );String  text  =  tq.consumeTo(   "< ");  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseTextNode  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    TextNode    textNode    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    text    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
String  text  =  tq.consumeTo  (   "< "  )  ;	[BUGGY]  String  text  =  tq.consumeTo(   " ");  [CONTEXT]  private  void  parseTextNode()  {  [BUGGY]  String  text  =  tq.consumeTo  (   " "  )  ;  TextNode  textNode  =  TextNode.createFromEncoded(text,  baseUri);  last().appendChild(textNode);  }        [CLASS]  Parser    [METHOD]  parseTextNode  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    TextNode    textNode    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    text    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
String  text  =  tq.consumeTo  (   "< "  )  ;	[BUGGY]    [CONTEXT]  private  void  parseTextNode()  {  [BUGGY]  String  text  =  tq.consumeTo( "< ");    TextNode  textNode  =  TextNode.createFromEncoded(text,  baseUri);  last().appendChild(textNode);        [CLASS]  Parser    [METHOD]  parseTextNode  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    TextNode    textNode    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    text    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
String  text  =  tq.consumeTo  (   "< "  )  ;	[BUGGY]  tq.consume(   "</ ");String  text  =  tq.consumeTo(   "< ");  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseTextNode  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    TextNode    textNode    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    text    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
String  text  =  tq.consumeTo  (   "< "  )  ;	[BUGGY]  tq.consume(   "< ");String  text  =  tq.consumeTo(   "< ");  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseTextNode  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    TextNode    textNode    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    text    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
TextNode  textNode  =  TextNode.createFromEncoded  (  text,  baseUri  )  ;	[BUGGY]  TextNode  htmlNode  =  TextNode.createFromEncoded(  text,  baseUri);  [CONTEXT]  private  void  parseTextNode()  {  String  text  =  tq.consumeTo( "< ");  [BUGGY]  TextNode  htmlNode  =  TextNode.createFromEncoded  (  text,  baseUri  )  ;  last().appendChild(textNode);  }        [CLASS]  Parser    [METHOD]  parseTextNode  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    TextNode    textNode    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    text    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
TextNode  textNode  =  TextNode.createFromEncoded  (  text,  baseUri  )  ;	[BUGGY]  TextNode  textNode  =  TextNode.createFromEncoded(  text,  text);  [CONTEXT]  private  void  parseTextNode()  {  String  text  =  tq.consumeTo( "< ");  [BUGGY]  TextNode  textNode  =  TextNode.createFromEncoded  (  text,  text  )  ;  last().appendChild(textNode);  }        [CLASS]  Parser    [METHOD]  parseTextNode  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    TextNode    textNode    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    text    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
TextNode  textNode  =  TextNode.createFromEncoded  (  text,  baseUri  )  ;	[BUGGY]  TextNode  baseUriNode  =  TextNode.createFromEncoded(  text,  text);  [CONTEXT]  private  void  parseTextNode()  {  String  text  =  tq.consumeTo( "< ");  [BUGGY]  TextNode  baseUriNode  =  TextNode.createFromEncoded  (  text,  text  )  ;  last().appendChild(textNode);  }        [CLASS]  Parser    [METHOD]  parseTextNode  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    TextNode    textNode    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    text    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
TextNode  textNode  =  TextNode.createFromEncoded  (  text,  baseUri  )  ;	[BUGGY]  TextNode  textNode  =  TextNode.createFromEncoded(    baseUri);  [CONTEXT]  private  void  parseTextNode()  {  String  text  =  tq.consumeTo( "< ");  [BUGGY]  TextNode  textNode  =  TextNode.createFromEncoded  (baseUri  )  ;  last().appendChild(textNode);  }        [CLASS]  Parser    [METHOD]  parseTextNode  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    TextNode    textNode    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    text    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
TextNode  textNode  =  TextNode.createFromEncoded  (  text,  baseUri  )  ;	[BUGGY]  TextNode  textNode  =  TextNode.createFromEncoded(  text);  [CONTEXT]  private  void  parseTextNode()  {  String  text  =  tq.consumeTo( "< ");  [BUGGY]  TextNode  textNode  =  TextNode.createFromEncoded  (  text  )  ;  last().appendChild(textNode);  }        [CLASS]  Parser    [METHOD]  parseTextNode  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    TextNode    textNode    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    text    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
TextNode  textNode  =  TextNode.createFromEncoded  (  text,  baseUri  )  ;	[BUGGY]  TextNode  textNode  =  TextNode  .TextNode(  )  ;  [CONTEXT]  private  void  parseTextNode()  {  String  text  =  tq.consumeTo( "< ");  [BUGGY]  TextNode  textNode  =  TextNode  .TextNode  ();  last().appendChild(textNode);  }        [CLASS]  Parser    [METHOD]  parseTextNode  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    TextNode    textNode    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    text    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
TextNode  textNode  =  TextNode.createFromEncoded  (  text,  baseUri  )  ;	[BUGGY]  TextNode  hrefNode  =  TextNode.createFromEncoded(  text,  baseUri);  [CONTEXT]  private  void  parseTextNode()  {  String  text  =  tq.consumeTo( "< ");  [BUGGY]  TextNode  hrefNode  =  TextNode.createFromEncoded  (  text,  baseUri  )  ;  last().appendChild(textNode);  }        [CLASS]  Parser    [METHOD]  parseTextNode  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    TextNode    textNode    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    text    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
TextNode  textNode  =  TextNode.createFromEncoded  (  text,  baseUri  )  ;	[BUGGY]  last(  ).appendChild(  textNode);  TextNode  textNode  =  TextNode.createFromEncoded(  text,  baseUri);  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseTextNode  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    TextNode    textNode    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    text    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
TextNode  textNode  =  TextNode.createFromEncoded  (  text,  baseUri  )  ;	[BUGGY]  TextNode  textNode  =  new  TextNode(  rawText,  baseUri);TextNode  textNode  =  TextNode.createFromEncoded(  text,  baseUri);  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseTextNode  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    TextNode    textNode    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    text    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
TextNode  textNode  =  TextNode.createFromEncoded  (  text,  baseUri  )  ;	[BUGGY]  TextNode  valueNode  =  TextNode.createFromEncoded(  text,  baseUri);  [CONTEXT]  private  void  parseTextNode()  {  String  text  =  tq.consumeTo( "< ");  [BUGGY]  TextNode  valueNode  =  TextNode.createFromEncoded  (  text,  baseUri  )  ;  last().appendChild(textNode);  }        [CLASS]  Parser    [METHOD]  parseTextNode  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    TextNode    textNode    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    text    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
TextNode  textNode  =  TextNode.createFromEncoded  (  text,  baseUri  )  ;	[BUGGY]  TextNode  textNode  =  TextNode.createFromEncoded(  text,  html);  [CONTEXT]  private  void  parseTextNode()  {  String  text  =  tq.consumeTo( "< ");  [BUGGY]  TextNode  textNode  =  TextNode.createFromEncoded  (  text,  html  )  ;  last().appendChild(textNode);  }        [CLASS]  Parser    [METHOD]  parseTextNode  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    TextNode    textNode    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    text    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
TextNode  textNode  =  TextNode.createFromEncoded  (  text,  baseUri  )  ;  last  (  )  .appendChild  (  textNode  )  ;	[BUGGY]    [CONTEXT]  private  void  parseTextNode()  {  String  text  =  tq.consumeTo( "< ");  [BUGGY]  TextNode  textNode  =  TextNode.createFromEncoded(text,  baseUri);            [CLASS]  Parser    [METHOD]  parseTextNode  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    TextNode    textNode    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    text    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
TextNode  textNode  =  TextNode.createFromEncoded  (  text,  baseUri  )  ;  last  (  )  .appendChild  (  textNode  )  ;	[BUGGY]  last(  ).appendChild(  textNode);  TextNode  textNode  =  TextNode.createFromEncoded(  text,  baseUri);  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseTextNode  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    TextNode    textNode    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    text    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
TextNode  textNode  =  TextNode.createFromEncoded  (  text,  baseUri  )  ;  last  (  )  .appendChild  (  textNode  )  ;	[BUGGY]  TextNode  textNode  =  TextNode.createFromEncoded(  text,  baseUri);TextNode  textNode  =  TextNode.createFromEncoded(  text,  baseUri);  last(  ).appendChild(  textNode);  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseTextNode  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    TextNode    textNode    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    text    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
last  (  )  .appendChild  (  textNode  )  ;	[BUGGY]  parse(  ).appendChild(  textNode);  [CONTEXT]  private  void  parseTextNode()  {  String  text  =  tq.consumeTo( "< ");  TextNode  textNode  =  TextNode.createFromEncoded(text,  baseUri);  [BUGGY]  parse  ()  .appendChild  (  textNode  )  ;  }        [CLASS]  Parser    [METHOD]  parseTextNode  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    TextNode    textNode    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    text    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
last  (  )  .appendChild  (  textNode  )  ;	[BUGGY]    [CONTEXT]  private  void  parseTextNode()  {  String  text  =  tq.consumeTo( "< ");  TextNode  textNode  =  TextNode.createFromEncoded(text,  baseUri);  [BUGGY]  last().appendChild(textNode);          [CLASS]  Parser    [METHOD]  parseTextNode  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    TextNode    textNode    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    tagName    text    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.consume  (   "<![CDATA[ "  )  ;	[BUGGY]  tq.consume(   "<![CDATA[CD ");  [CONTEXT]  private  void  parseCdata()  {  [BUGGY]  tq.consume  (   "<![CDATA[CD "  )  ;  String  rawText  =  tq.chompTo( "]]> ");  TextNode  textNode  =  new  TextNode(rawText,  baseUri);  //  constructor  does  not  escape  last().appendChild(textNode);  }        [CLASS]  Parser    [METHOD]  parseCdata  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    TextNode    textNode    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.consume  (   "<![CDATA[ "  )  ;	[BUGGY]  tq.consumeTo(   "<![CDATA[ ");  [CONTEXT]  private  void  parseCdata()  {  [BUGGY]  tq.consumeTo  (   "<![CDATA[ "  )  ;  String  rawText  =  tq.chompTo( "]]> ");  TextNode  textNode  =  new  TextNode(rawText,  baseUri);  //  constructor  does  not  escape  last().appendChild(textNode);  }        [CLASS]  Parser    [METHOD]  parseCdata  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    TextNode    textNode    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.consume  (   "<![CDATA[ "  )  ;	[BUGGY]    [CONTEXT]  private  void  parseCdata()  {  [BUGGY]  tq.consume( "<![CDATA[ ");    String  rawText  =  tq.chompTo( "]]> ");  TextNode  textNode  =  new  TextNode(rawText,  baseUri);  //  constructor  does  not  escape  last().appendChild(textNode);        [CLASS]  Parser    [METHOD]  parseCdata  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    TextNode    textNode    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.consume  (   "<![CDATA[ "  )  ;	[BUGGY]  tq.consume(  );tq.consume(   "<![CDATA[ ");  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseCdata  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    TextNode    textNode    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.consume  (   "<![CDATA[ "  )  ;	[BUGGY]  tq.consume(   "</ ");tq.consume(   "<![CDATA[ ");  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseCdata  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    TextNode    textNode    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.consume  (   "<![CDATA[ "  )  ;	[BUGGY]  tq.consume(   "< ");tq.consume(   "<![CDATA[ ");  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseCdata  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    TextNode    textNode    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
tq.consume  (   "<![CDATA[ "  )  ;	[BUGGY]  tq.consume(   "<!-- ");tq.consume(   "<![CDATA[ ");  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseCdata  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    TextNode    textNode    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
String  rawText  =  tq.chompTo  (   "]]> "  )  ;	[BUGGY]  char  rawText  =  tq.chompTo(   "]]> ");  [CONTEXT]  private  void  parseCdata()  {  tq.consume( "<![CDATA[ ");  [BUGGY]  char  rawText  =  tq.chompTo  (   "]]> "  )  ;  TextNode  textNode  =  new  TextNode(rawText,  baseUri);  //  constructor  does  not  escape  last().appendChild(textNode);  }        [CLASS]  Parser    [METHOD]  parseCdata  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    TextNode    textNode    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
String  rawText  =  tq.chompTo  (   "]]> "  )  ;	[BUGGY]  String  rawText  =  tq.chompTo(   "]]]> ");  [CONTEXT]  private  void  parseCdata()  {  tq.consume( "<![CDATA[ ");  [BUGGY]  String  rawText  =  tq.chompTo  (   "]]]> "  )  ;  TextNode  textNode  =  new  TextNode(rawText,  baseUri);  //  constructor  does  not  escape  last().appendChild(textNode);  }        [CLASS]  Parser    [METHOD]  parseCdata  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    TextNode    textNode    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
String  rawText  =  tq.chompTo  (   "]]> "  )  ;	[BUGGY]  String  rawText  =  tq.consumeTo(   "]]> ");  [CONTEXT]  private  void  parseCdata()  {  tq.consume( "<![CDATA[ ");  [BUGGY]  String  rawText  =  tq.consumeTo  (   "]]> "  )  ;  TextNode  textNode  =  new  TextNode(rawText,  baseUri);  //  constructor  does  not  escape  last().appendChild(textNode);  }        [CLASS]  Parser    [METHOD]  parseCdata  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    TextNode    textNode    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
String  rawText  =  tq.chompTo  (   "]]> "  )  ;	[BUGGY]  String  rawText  =  tq  .consumeTo(  SQ)  ;  [CONTEXT]  private  void  parseCdata()  {  tq.consume( "<![CDATA[ ");  [BUGGY]  String  rawText  =  tq  .consumeTo  (  SQ  );  TextNode  textNode  =  new  TextNode(rawText,  baseUri);  //  constructor  does  not  escape  last().appendChild(textNode);  }        [CLASS]  Parser    [METHOD]  parseCdata  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    TextNode    textNode    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
String  rawText  =  tq.chompTo  (   "]]> "  )  ;  TextNode  textNode  =  new  TextNode  (  rawText,  baseUri  )  ;	[BUGGY]  TextNode  textNode  =  new  TextNode(  rawText,  baseUri);  String  rawText  =  tq.chompTo(   "]]> ");  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseCdata  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    TextNode    textNode    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
String  rawText  =  tq.chompTo  (   "]]> "  )  ;  TextNode  textNode  =  new  TextNode  (  rawText,  baseUri  )  ;	[BUGGY]  TextNode  textNode  =  new  TextNode(  rawText,  baseUri);String  rawText  =  tq.chompTo(   "]]> ");  TextNode  textNode  =  new  TextNode(  rawText,  baseUri);  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseCdata  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    TextNode    textNode    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
String  rawText  =  tq.chompTo  (   "]]> "  )  ;	[BUGGY]  String  rawText  =  tq.chompTo(   "]]>]] ");  [CONTEXT]  private  void  parseCdata()  {  tq.consume( "<![CDATA[ ");  [BUGGY]  String  rawText  =  tq.chompTo  (   "]]>]] "  )  ;  TextNode  textNode  =  new  TextNode(rawText,  baseUri);  //  constructor  does  not  escape  last().appendChild(textNode);  }        [CLASS]  Parser    [METHOD]  parseCdata  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    TextNode    textNode    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
String  rawText  =  tq.chompTo  (   "]]> "  )  ;	[BUGGY]  String  rawText  =  tq  .consumeTo(  html)  ;  [CONTEXT]  private  void  parseCdata()  {  tq.consume( "<![CDATA[ ");  [BUGGY]  String  rawText  =  tq  .consumeTo  (  html  );  TextNode  textNode  =  new  TextNode(rawText,  baseUri);  //  constructor  does  not  escape  last().appendChild(textNode);  }        [CLASS]  Parser    [METHOD]  parseCdata  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    TextNode    textNode    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
String  rawText  =  tq.chompTo  (   "]]> "  )  ;  TextNode  textNode  =  new  TextNode  (  rawText,  baseUri  )  ;	[BUGGY]    [CONTEXT]  private  void  parseCdata()  {  tq.consume( "<![CDATA[ ");  [BUGGY]  String  rawText  =  tq.chompTo( "]]> ");      last().appendChild(textNode);        [CLASS]  Parser    [METHOD]  parseCdata  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    TextNode    textNode    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
String  rawText  =  tq.chompTo  (   "]]> "  )  ;	[BUGGY]  TextNode  textNode  =  new  TextNode(  rawText,  baseUri);  String  rawText  =  tq.chompTo(   "]]> ");  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseCdata  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    TextNode    textNode    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
String  rawText  =  tq.chompTo  (   "]]> "  )  ;	[BUGGY]  String  text  =  tq.consumeTo(   "< ");String  rawText  =  tq.chompTo(   "]]> ");  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseCdata  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    TextNode    textNode    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
String  rawText  =  tq.chompTo  (   "]]> "  )  ;	[BUGGY]  String  data  =  tq.chompTo(   "-> ");String  rawText  =  tq.chompTo(   "]]> ");  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseCdata  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    TextNode    textNode    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
String  rawText  =  tq.chompTo  (   "]]> "  )  ;	[BUGGY]  String  data  =  tq.chompTo(   "</ "  +  tagName);String  rawText  =  tq.chompTo(   "]]> ");  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseCdata  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    TextNode    textNode    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
String  rawText  =  tq.chompTo  (   "]]> "  )  ;	[BUGGY]  value  =  tq.chompTo(  SQ);String  rawText  =  tq.chompTo(   "]]> ");  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseCdata  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    TextNode    textNode    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
String  rawText  =  tq.chompTo  (   "]]> "  )  ;	[BUGGY]  tq.chompTo(   "> ");String  rawText  =  tq.chompTo(   "]]> ");  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseCdata  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    TextNode    textNode    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
String  rawText  =  tq.chompTo  (   "]]> "  )  ;	[BUGGY]  String  data  =  tq.chompTo(   "> ");String  rawText  =  tq.chompTo(   "]]> ");  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseCdata  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    TextNode    textNode    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
String  rawText  =  tq.chompTo  (   "]]> "  )  ;	[BUGGY]  String  tagName  =  tq.consumeWord(  );String  rawText  =  tq.chompTo(   "]]> ");  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseCdata  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    TextNode    textNode    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
String  rawText  =  tq.chompTo  (   "]]> "  )  ;	[BUGGY]  value  =  tq.chompTo(  DQ);String  rawText  =  tq.chompTo(   "]]> ");  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseCdata  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    TextNode    textNode    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
TextNode  textNode  =  new  TextNode  (  rawText,  baseUri  )  ;	[BUGGY]  TextNode  textNode  =  new  DataNode(  data,  baseUri)  ;  [CONTEXT]  private  void  parseCdata()  {  tq.consume( "<![CDATA[ ");  String  rawText  =  tq.chompTo( "]]> ");  [BUGGY]  TextNode  textNode  =  new  DataNode  (  data,  baseUri  );  last().appendChild(textNode);  }        [CLASS]  Parser    [METHOD]  parseCdata  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    TextNode    textNode    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
TextNode  textNode  =  new  TextNode  (  rawText,  baseUri  )  ;	[BUGGY]  TextNode  textNode  =  new  TextNode(  text,  baseUri);  [CONTEXT]  private  void  parseCdata()  {  tq.consume( "<![CDATA[ ");  String  rawText  =  tq.chompTo( "]]> ");  [BUGGY]  TextNode  textNode  =  new  TextNode  (  text,  baseUri  )  ;  last().appendChild(textNode);  }        [CLASS]  Parser    [METHOD]  parseCdata  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    TextNode    textNode    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
TextNode  textNode  =  new  TextNode  (  rawText,  baseUri  )  ;	[BUGGY]  TextNode  textNode  =  new  TextNode(  baseUri,  rawText);  [CONTEXT]  private  void  parseCdata()  {  tq.consume( "<![CDATA[ ");  String  rawText  =  tq.chompTo( "]]> ");  [BUGGY]  TextNode  textNode  =  new  TextNode  (  baseUri,  rawText  )  ;  last().appendChild(textNode);  }        [CLASS]  Parser    [METHOD]  parseCdata  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    TextNode    textNode    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
TextNode  textNode  =  new  TextNode  (  rawText,  baseUri  )  ;	[BUGGY]  TextNode  textNode  =  new  TextNode(    baseUri);  [CONTEXT]  private  void  parseCdata()  {  tq.consume( "<![CDATA[ ");  String  rawText  =  tq.chompTo( "]]> ");  [BUGGY]  TextNode  textNode  =  new  TextNode  (baseUri  )  ;  last().appendChild(textNode);  }        [CLASS]  Parser    [METHOD]  parseCdata  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    TextNode    textNode    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
TextNode  textNode  =  new  TextNode  (  rawText,  baseUri  )  ;	[BUGGY]  TextNode  textNode  =  new  TextNode(  rawText);  [CONTEXT]  private  void  parseCdata()  {  tq.consume( "<![CDATA[ ");  String  rawText  =  tq.chompTo( "]]> ");  [BUGGY]  TextNode  textNode  =  new  TextNode  (  rawText  )  ;  last().appendChild(textNode);  }        [CLASS]  Parser    [METHOD]  parseCdata  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    TextNode    textNode    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
TextNode  textNode  =  new  TextNode  (  rawText,  baseUri  )  ;	[BUGGY]  TextNode  textNode  =  new  TextNode(  rawText,  value);  [CONTEXT]  private  void  parseCdata()  {  tq.consume( "<![CDATA[ ");  String  rawText  =  tq.chompTo( "]]> ");  [BUGGY]  TextNode  textNode  =  new  TextNode  (  rawText,  value  )  ;  last().appendChild(textNode);  }        [CLASS]  Parser    [METHOD]  parseCdata  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    TextNode    textNode    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
TextNode  textNode  =  new  TextNode  (  rawText,  baseUri  )  ;	[BUGGY]  TextNode  textNode  =  new  TextNode(  html,  baseUri);  [CONTEXT]  private  void  parseCdata()  {  tq.consume( "<![CDATA[ ");  String  rawText  =  tq.chompTo( "]]> ");  [BUGGY]  TextNode  textNode  =  new  TextNode  (  html,  baseUri  )  ;  last().appendChild(textNode);  }        [CLASS]  Parser    [METHOD]  parseCdata  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    TextNode    textNode    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
TextNode  textNode  =  new  TextNode  (  rawText,  baseUri  )  ;  last  (  )  .appendChild  (  textNode  )  ;	[BUGGY]  last(  ).appendChild(  textNode);  TextNode  textNode  =  new  TextNode(  rawText,  baseUri);  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseCdata  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    TextNode    textNode    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
TextNode  textNode  =  new  TextNode  (  rawText,  baseUri  )  ;  last  (  )  .appendChild  (  textNode  )  ;	[BUGGY]  TextNode  textNode  =  new  TextNode(  rawText,  baseUri);TextNode  textNode  =  new  TextNode(  rawText,  baseUri);  last(  ).appendChild(  textNode);  [CONTEXT]        [CLASS]  Parser    [METHOD]  parseCdata  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    TextNode    textNode    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
last  (  )  .appendChild  (  textNode  )  ;	[BUGGY]  last(  )  .absUrl(  bodyHtml)  ;  [CONTEXT]  private  void  parseCdata()  {  tq.consume( "<![CDATA[ ");  String  rawText  =  tq.chompTo( "]]> ");  TextNode  textNode  =  new  TextNode(rawText,  baseUri);  //  constructor  does  not  escape  [BUGGY]  last  ().absUrl  (  bodyHtml  );  }        [CLASS]  Parser    [METHOD]  parseCdata  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    TextNode    textNode    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
last  (  )  .appendChild  (  textNode  )  ;	[BUGGY]  parse(  ).appendChild(  textNode);  [CONTEXT]  private  void  parseCdata()  {  tq.consume( "<![CDATA[ ");  String  rawText  =  tq.chompTo( "]]> ");  TextNode  textNode  =  new  TextNode(rawText,  baseUri);  //  constructor  does  not  escape  [BUGGY]  parse  ()  .appendChild  (  textNode  )  ;  }        [CLASS]  Parser    [METHOD]  parseCdata  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    TextNode    textNode    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
last  (  )  .appendChild  (  textNode  )  ;	[BUGGY]    [CONTEXT]  private  void  parseCdata()  {  tq.consume( "<![CDATA[ ");  String  rawText  =  tq.chompTo( "]]> ");  TextNode  textNode  =  new  TextNode(rawText,  baseUri);  //  constructor  does  not  escape  [BUGGY]  last().appendChild(textNode);          [CLASS]  Parser    [METHOD]  parseCdata  [RETURN_TYPE]  void      [VARIABLES]  TokenQueue    tq    boolean    TextNode    textNode    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    headTag    htmlTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Element  parent  =  popStackToSuitableContainer  (  child.tag  (  )  )  ;	[BUGGY]  Element  parent  =  popStackToSuitableContainer(  root.tag(  ));  [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  [BUGGY]  Element  parent  =  popStackToSuitableContainer  (  root.tag  ())  ;  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  Element  implicit  =  new  Element(parentTag,  baseUri);      if  (child.tag().equals(bodyTag))  {  Element  head  =  new  Element(headTag,  baseUri);  implicit.appendChild(head);  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  if  (!isEmptyElement)  stack.addLast(child);  return  root;  }    parent.appendChild(child);    if  (!isEmptyElement)  stack.addLast(child);  return  parent;  }        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Element  parent  =  popStackToSuitableContainer  (  child.tag  (  )  )  ;	[BUGGY]  Element  parent  =  popStackToClose(  child.tag(  ));  [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  [BUGGY]  Element  parent  =  popStackToClose  (  child.tag  ())  ;  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  Element  implicit  =  new  Element(parentTag,  baseUri);      if  (child.tag().equals(bodyTag))  {  Element  head  =  new  Element(headTag,  baseUri);  implicit.appendChild(head);  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  if  (!isEmptyElement)  stack.addLast(child);  return  root;  }    parent.appendChild(child);    if  (!isEmptyElement)  stack.addLast(child);  return  parent;  }        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Element  parent  =  popStackToSuitableContainer  (  child.tag  (  )  )  ;	[BUGGY]  Element  parent  =  popStackToSuitableContainer(  child.absUrl(  ));  [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  [BUGGY]  Element  parent  =  popStackToSuitableContainer  (  child.absUrl  ())  ;  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  Element  implicit  =  new  Element(parentTag,  baseUri);      if  (child.tag().equals(bodyTag))  {  Element  head  =  new  Element(headTag,  baseUri);  implicit.appendChild(head);  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  if  (!isEmptyElement)  stack.addLast(child);  return  root;  }    parent.appendChild(child);    if  (!isEmptyElement)  stack.addLast(child);  return  parent;  }        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Element  parent  =  popStackToSuitableContainer  (  child.tag  (  )  )  ;	[BUGGY]  Element  parent  =  popStackToSuitableContainer(  child  .tagName(  )  );  [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  [BUGGY]  Element  parent  =  popStackToSuitableContainer  (  child  .tagName  ()  )  ;  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  Element  implicit  =  new  Element(parentTag,  baseUri);      if  (child.tag().equals(bodyTag))  {  Element  head  =  new  Element(headTag,  baseUri);  implicit.appendChild(head);  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  if  (!isEmptyElement)  stack.addLast(child);  return  root;  }    parent.appendChild(child);    if  (!isEmptyElement)  stack.addLast(child);  return  parent;  }        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Element  parent  =  popStackToSuitableContainer  (  child.tag  (  )  )  ;  Tag  childTag  =  child.tag  (  )  ;	[BUGGY]    [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  [BUGGY]  Element  parent  =  popStackToSuitableContainer(child.tag());      boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  Element  implicit  =  new  Element(parentTag,  baseUri);      if  (child.tag().equals(bodyTag))  {  Element  head  =  new  Element(headTag,  baseUri);  implicit.appendChild(head);  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  if  (!isEmptyElement)  stack.addLast(child);  return  root;  }    parent.appendChild(child);    if  (!isEmptyElement)  stack.addLast(child);  return  parent;        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Element  parent  =  popStackToSuitableContainer  (  child.tag  (  )  )  ;  Tag  childTag  =  child.tag  (  )  ;	[BUGGY]  Tag  childTag  =  child.tag(  );  Element  parent  =  popStackToSuitableContainer(  child.tag(  ));  [CONTEXT]        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Element  parent  =  popStackToSuitableContainer  (  child.tag  (  )  )  ;  Tag  childTag  =  child.tag  (  )  ;	[BUGGY]  Element  parent  =  popStackToSuitableContainer(  child.tag(  ));Element  parent  =  popStackToSuitableContainer(  child.tag(  ));  Tag  childTag  =  child.tag(  );  [CONTEXT]        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Tag  childTag  =  child.tag  (  )  ;	[BUGGY]  Tag  childTag  =  child.absUrl(  );  [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  [BUGGY]  Tag  childTag  =  child.absUrl  ()  ;  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  Element  implicit  =  new  Element(parentTag,  baseUri);      if  (child.tag().equals(bodyTag))  {  Element  head  =  new  Element(headTag,  baseUri);  implicit.appendChild(head);  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  if  (!isEmptyElement)  stack.addLast(child);  return  root;  }    parent.appendChild(child);    if  (!isEmptyElement)  stack.addLast(child);  return  parent;  }        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Tag  childTag  =  child.tag  (  )  ;	[BUGGY]  Tag  rootTag  =  child.tag(  );  [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  [BUGGY]  Tag  rootTag  =  child.tag  ()  ;  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  Element  implicit  =  new  Element(parentTag,  baseUri);      if  (child.tag().equals(bodyTag))  {  Element  head  =  new  Element(headTag,  baseUri);  implicit.appendChild(head);  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  if  (!isEmptyElement)  stack.addLast(child);  return  root;  }    parent.appendChild(child);    if  (!isEmptyElement)  stack.addLast(child);  return  parent;  }        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Tag  childTag  =  child.tag  (  )  ;	[BUGGY]  Tag  parent2  =  el.tag(  );Tag  childTag  =  child.tag(  );  [CONTEXT]        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Tag  childTag  =  child.tag  (  )  ;	[BUGGY]  Tag  elTag  =  el.tag(  );Tag  childTag  =  child.tag(  );  [CONTEXT]        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Tag  childTag  =  child.tag  (  )  ;	[BUGGY]  Tag  parentTag  =  childTag.getImplicitParent(  );Tag  childTag  =  child.tag(  );  [CONTEXT]        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Tag  childTag  =  child.tag  (  )  ;	[BUGGY]  Tag  parentTag  =  child.tag(  );  [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  [BUGGY]  Tag  parentTag  =  child.tag  ()  ;  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  Element  implicit  =  new  Element(parentTag,  baseUri);      if  (child.tag().equals(bodyTag))  {  Element  head  =  new  Element(headTag,  baseUri);  implicit.appendChild(head);  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  if  (!isEmptyElement)  stack.addLast(child);  return  root;  }    parent.appendChild(child);    if  (!isEmptyElement)  stack.addLast(child);  return  parent;  }        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Tag  childTag  =  child.tag  (  )  ;	[BUGGY]    [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  [BUGGY]  Tag  childTag  =  child.tag();    boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  Element  implicit  =  new  Element(parentTag,  baseUri);      if  (child.tag().equals(bodyTag))  {  Element  head  =  new  Element(headTag,  baseUri);  implicit.appendChild(head);  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  if  (!isEmptyElement)  stack.addLast(child);  return  root;  }    parent.appendChild(child);    if  (!isEmptyElement)  stack.addLast(child);  return  parent;        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Tag  childTag  =  child.tag  (  )  ;  boolean  validAncestor  =  stackHasValidParent  (  childTag  )  ;	[BUGGY]  boolean  validAncestor  =  stackHasValidParent(  childTag);  Tag  childTag  =  child.tag(  );  [CONTEXT]        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Tag  childTag  =  child.tag  (  )  ;  boolean  validAncestor  =  stackHasValidParent  (  childTag  )  ;	[BUGGY]  boolean  validAncestor  =  stackHasValidParent(  childTag);Tag  childTag  =  child.tag(  );  boolean  validAncestor  =  stackHasValidParent(  childTag);  [CONTEXT]        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
boolean  validAncestor  =  stackHasValidParent  (  childTag  )  ;	[BUGGY]  boolean  validAncestor  =  stackHasValidParent(  tag);  [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  [BUGGY]  boolean  validAncestor  =  stackHasValidParent  (  tag  )  ;    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  Element  implicit  =  new  Element(parentTag,  baseUri);      if  (child.tag().equals(bodyTag))  {  Element  head  =  new  Element(headTag,  baseUri);  implicit.appendChild(head);  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  if  (!isEmptyElement)  stack.addLast(child);  return  root;  }    parent.appendChild(child);    if  (!isEmptyElement)  stack.addLast(child);  return  parent;  }        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
boolean  validAncestor  =  stackHasValidParent  (  childTag  )  ;	[BUGGY]  boolean  validAncestor  =  popStackToClose(  childTag);  [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  [BUGGY]  boolean  validAncestor  =  popStackToClose  (  childTag  )  ;    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  Element  implicit  =  new  Element(parentTag,  baseUri);      if  (child.tag().equals(bodyTag))  {  Element  head  =  new  Element(headTag,  baseUri);  implicit.appendChild(head);  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  if  (!isEmptyElement)  stack.addLast(child);  return  root;  }    parent.appendChild(child);    if  (!isEmptyElement)  stack.addLast(child);  return  parent;  }        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
boolean  validAncestor  =  stackHasValidParent  (  childTag  )  ;	[BUGGY]  boolean  validAncestor  =  popStackToClose(  tag);  [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  [BUGGY]  boolean  validAncestor  =  popStackToClose  (  tag  )  ;    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  Element  implicit  =  new  Element(parentTag,  baseUri);      if  (child.tag().equals(bodyTag))  {  Element  head  =  new  Element(headTag,  baseUri);  implicit.appendChild(head);  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  if  (!isEmptyElement)  stack.addLast(child);  return  root;  }    parent.appendChild(child);    if  (!isEmptyElement)  stack.addLast(child);  return  parent;  }        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
boolean  validAncestor  =  stackHasValidParent  (  childTag  )  ;	[BUGGY]  boolean  validAncestor  =  popStackToClose(  titleTag);  [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  [BUGGY]  boolean  validAncestor  =  popStackToClose  (  titleTag  )  ;    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  Element  implicit  =  new  Element(parentTag,  baseUri);      if  (child.tag().equals(bodyTag))  {  Element  head  =  new  Element(headTag,  baseUri);  implicit.appendChild(head);  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  if  (!isEmptyElement)  stack.addLast(child);  return  root;  }    parent.appendChild(child);    if  (!isEmptyElement)  stack.addLast(child);  return  parent;  }        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
boolean  validAncestor  =  stackHasValidParent  (  childTag  )  ;	[BUGGY]    [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  [BUGGY]  boolean  validAncestor  =  stackHasValidParent(childTag);      if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  Element  implicit  =  new  Element(parentTag,  baseUri);      if  (child.tag().equals(bodyTag))  {  Element  head  =  new  Element(headTag,  baseUri);  implicit.appendChild(head);  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  if  (!isEmptyElement)  stack.addLast(child);  return  root;  }    parent.appendChild(child);    if  (!isEmptyElement)  stack.addLast(child);  return  parent;        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  !validAncestor  )  {	[BUGGY]  if  (  !isEmptyElement)  {  [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    [BUGGY]  if(  !isEmptyElement  ){      Tag  parentTag  =  childTag.getImplicitParent();  Element  implicit  =  new  Element(parentTag,  baseUri);      if  (child.tag().equals(bodyTag))  {  Element  head  =  new  Element(headTag,  baseUri);  implicit.appendChild(head);  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  if  (!isEmptyElement)  stack.addLast(child);  return  root;  }    parent.appendChild(child);    if  (!isEmptyElement)  stack.addLast(child);  return  parent;  }        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  child.tag  (  )  .equals  (  bodyTag  )  )  {	[BUGGY]  if  (  root.tag(  ).equals(  bodyTag))  {  [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  Element  implicit  =  new  Element(parentTag,  baseUri);      [BUGGY]  if(  root.tag  ()  .equals  (  bodyTag  )){  Element  head  =  new  Element(headTag,  baseUri);  implicit.appendChild(head);  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  if  (!isEmptyElement)  stack.addLast(child);  return  root;  }    parent.appendChild(child);    if  (!isEmptyElement)  stack.addLast(child);  return  parent;  }        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  child.tag  (  )  .equals  (  bodyTag  )  )  {	[BUGGY]  if  (  child.tag(  ).equals(  tag))  {  [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  Element  implicit  =  new  Element(parentTag,  baseUri);      [BUGGY]  if(  child.tag  ()  .equals  (  tag  )){  Element  head  =  new  Element(headTag,  baseUri);  implicit.appendChild(head);  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  if  (!isEmptyElement)  stack.addLast(child);  return  root;  }    parent.appendChild(child);    if  (!isEmptyElement)  stack.addLast(child);  return  parent;  }        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  child.tag  (  )  .equals  (  bodyTag  )  )  {	[BUGGY]  if  (  child.tag(  ).canContain(  bodyTag))  {  [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  Element  implicit  =  new  Element(parentTag,  baseUri);      [BUGGY]  if(  child.tag  ()  .canContain  (  bodyTag  )){  Element  head  =  new  Element(headTag,  baseUri);  implicit.appendChild(head);  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  if  (!isEmptyElement)  stack.addLast(child);  return  root;  }    parent.appendChild(child);    if  (!isEmptyElement)  stack.addLast(child);  return  parent;  }        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  child.tag  (  )  .equals  (  bodyTag  )  )  {	[BUGGY]  if  (  child.absUrl(  ).equals(  bodyTag))  {  [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  Element  implicit  =  new  Element(parentTag,  baseUri);      [BUGGY]  if(  child.absUrl  ()  .equals  (  bodyTag  )){  Element  head  =  new  Element(headTag,  baseUri);  implicit.appendChild(head);  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  if  (!isEmptyElement)  stack.addLast(child);  return  root;  }    parent.appendChild(child);    if  (!isEmptyElement)  stack.addLast(child);  return  parent;  }        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  child.tag  (  )  .equals  (  bodyTag  )  )  {	[BUGGY]  if  (  child  .tagName(  )  .equals(  bodyTag))  {  [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  Element  implicit  =  new  Element(parentTag,  baseUri);      [BUGGY]  if(  child  .tagName  ().equals  (  bodyTag  )){  Element  head  =  new  Element(headTag,  baseUri);  implicit.appendChild(head);  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  if  (!isEmptyElement)  stack.addLast(child);  return  root;  }    parent.appendChild(child);    if  (!isEmptyElement)  stack.addLast(child);  return  parent;  }        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  child.tag  (  )  .equals  (  bodyTag  )  )  {	[BUGGY]  if  (  child.tag(  ).equals(  titleTag))  {  [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  Element  implicit  =  new  Element(parentTag,  baseUri);      [BUGGY]  if(  child.tag  ()  .equals  (  titleTag  )){  Element  head  =  new  Element(headTag,  baseUri);  implicit.appendChild(head);  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  if  (!isEmptyElement)  stack.addLast(child);  return  root;  }    parent.appendChild(child);    if  (!isEmptyElement)  stack.addLast(child);  return  parent;  }        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  child.tag  (  )  .equals  (  bodyTag  )  )  {	[BUGGY]  if  (  child.tagName(  ).equals(   "base "))  {  [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  Element  implicit  =  new  Element(parentTag,  baseUri);      [BUGGY]  if(  child.tagName  ()  .equals  (   "base "  )){  Element  head  =  new  Element(headTag,  baseUri);  implicit.appendChild(head);  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  if  (!isEmptyElement)  stack.addLast(child);  return  root;  }    parent.appendChild(child);    if  (!isEmptyElement)  stack.addLast(child);  return  parent;  }        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  child.tag  (  )  .equals  (  bodyTag  )  )  {  Element  head  =  new  Element  (  headTag,  baseUri  )  ;  implicit.appendChild  (  head  )  ;  }	[BUGGY]  org.jsoup.parser.Element  head  =  new  org.jsoup.parser.Element(org.jsoup.parser.Parser.headTag,  baseUri);  implicit.appendChild(head);  [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  Element  implicit  =  new  Element(parentTag,  baseUri);      [BUGGY]  if  (child.tag().equals(bodyTag))  {    org.jsoup.parser.Element  head  =  new  org.jsoup.parser.Element(org.jsoup.parser.Parser.headTag,  baseUri);  implicit.appendChild(head);      implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  if  (!isEmptyElement)  stack.addLast(child);  return  root;  }    parent.appendChild(child);    if  (!isEmptyElement)  stack.addLast(child);  return  parent;        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  child.tag  (  )  .equals  (  bodyTag  )  )  {  Element  head  =  new  Element  (  headTag,  baseUri  )  ;  implicit.appendChild  (  head  )  ;  }	[BUGGY]    [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  Element  implicit  =  new  Element(parentTag,  baseUri);      [BUGGY]  if  (child.tag().equals(bodyTag))  {          implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  if  (!isEmptyElement)  stack.addLast(child);  return  root;  }    parent.appendChild(child);    if  (!isEmptyElement)  stack.addLast(child);  return  parent;        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Element  head  =  new  Element  (  headTag,  baseUri  )  ;	[BUGGY]  Element  head  =  new  Element(  headTag,  key);  [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  Element  implicit  =  new  Element(parentTag,  baseUri);      if  (child.tag().equals(bodyTag))  {  [BUGGY]  Element  head  =  new  Element  (  headTag,  key  )  ;  implicit.appendChild(head);  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  if  (!isEmptyElement)  stack.addLast(child);  return  root;  }    parent.appendChild(child);    if  (!isEmptyElement)  stack.addLast(child);  return  parent;  }        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Element  head  =  new  Element  (  headTag,  baseUri  )  ;	[BUGGY]  Element  head  =  new  Element(  baseUri,  headTag);  [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  Element  implicit  =  new  Element(parentTag,  baseUri);      if  (child.tag().equals(bodyTag))  {  [BUGGY]  Element  head  =  new  Element  (  baseUri,  headTag  )  ;  implicit.appendChild(head);  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  if  (!isEmptyElement)  stack.addLast(child);  return  root;  }    parent.appendChild(child);    if  (!isEmptyElement)  stack.addLast(child);  return  parent;  }        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Element  head  =  new  Element  (  headTag,  baseUri  )  ;	[BUGGY]  Element  head  =  new  Element(    baseUri);  [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  Element  implicit  =  new  Element(parentTag,  baseUri);      if  (child.tag().equals(bodyTag))  {  [BUGGY]  Element  head  =  new  Element  (baseUri  )  ;  implicit.appendChild(head);  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  if  (!isEmptyElement)  stack.addLast(child);  return  root;  }    parent.appendChild(child);    if  (!isEmptyElement)  stack.addLast(child);  return  parent;  }        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Element  head  =  new  Element  (  headTag,  baseUri  )  ;	[BUGGY]  Element  head  =  new  Element(  headTag);  [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  Element  implicit  =  new  Element(parentTag,  baseUri);      if  (child.tag().equals(bodyTag))  {  [BUGGY]  Element  head  =  new  Element  (  headTag  )  ;  implicit.appendChild(head);  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  if  (!isEmptyElement)  stack.addLast(child);  return  root;  }    parent.appendChild(child);    if  (!isEmptyElement)  stack.addLast(child);  return  parent;  }        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Element  head  =  new  Element  (  headTag,  baseUri  )  ;	[BUGGY]  Element  head  =  new  Element(  titleTag,  baseUri);  [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  Element  implicit  =  new  Element(parentTag,  baseUri);      if  (child.tag().equals(bodyTag))  {  [BUGGY]  Element  head  =  new  Element  (  titleTag,  baseUri  )  ;  implicit.appendChild(head);  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  if  (!isEmptyElement)  stack.addLast(child);  return  root;  }    parent.appendChild(child);    if  (!isEmptyElement)  stack.addLast(child);  return  parent;  }        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Element  head  =  new  Element  (  headTag,  baseUri  )  ;	[BUGGY]  Element  head  =  new  Element(  headTag,  rawText);  [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  Element  implicit  =  new  Element(parentTag,  baseUri);      if  (child.tag().equals(bodyTag))  {  [BUGGY]  Element  head  =  new  Element  (  headTag,  rawText  )  ;  implicit.appendChild(head);  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  if  (!isEmptyElement)  stack.addLast(child);  return  root;  }    parent.appendChild(child);    if  (!isEmptyElement)  stack.addLast(child);  return  parent;  }        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Element  head  =  new  Element  (  headTag,  baseUri  )  ;  implicit.appendChild  (  head  )  ;	[BUGGY]  implicit.appendChild(  head);  Element  head  =  new  Element(  headTag,  baseUri);  [CONTEXT]        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Element  head  =  new  Element  (  headTag,  baseUri  )  ;  implicit.appendChild  (  head  )  ;	[BUGGY]  Element  child  =  new  Element(  tag,  baseUri,  attributes);Element  head  =  new  Element(  headTag,  baseUri);  implicit.appendChild(  head);  [CONTEXT]        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Element  head  =  new  Element  (  headTag,  baseUri  )  ;  implicit.appendChild  (  head  )  ;	[BUGGY]  Element  head  =  new  Element(  headTag,  baseUri);Element  head  =  new  Element(  headTag,  baseUri);  implicit.appendChild(  head);  [CONTEXT]        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
[Delete]	[BUGGY]  if  (  child.tag(  ).equals(  bodyTag))  {          Element  head  =  new  Element(  headTag,  baseUri);          implicit.appendChild(  head);  }  [CONTEXT]        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
implicit.appendChild  (  head  )  ;	[BUGGY]  implicit.appendChild(  root);  [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  Element  implicit  =  new  Element(parentTag,  baseUri);      if  (child.tag().equals(bodyTag))  {  Element  head  =  new  Element(headTag,  baseUri);  [BUGGY]  implicit.appendChild  (  root  )  ;  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  if  (!isEmptyElement)  stack.addLast(child);  return  root;  }    parent.appendChild(child);    if  (!isEmptyElement)  stack.addLast(child);  return  parent;  }        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
implicit.appendChild  (  head  )  ;	[BUGGY]    [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  Element  implicit  =  new  Element(parentTag,  baseUri);      if  (child.tag().equals(bodyTag))  {  Element  head  =  new  Element(headTag,  baseUri);  [BUGGY]  implicit.appendChild(head);    }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  if  (!isEmptyElement)  stack.addLast(child);  return  root;  }    parent.appendChild(child);    if  (!isEmptyElement)  stack.addLast(child);  return  parent;        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  !isEmptyElement  )  stack.addLast  (  child  )  ;	[BUGGY]  if  (  !validAncestor)stack.addLast(  child);  [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  Element  implicit  =  new  Element(parentTag,  baseUri);      if  (child.tag().equals(bodyTag))  {  Element  head  =  new  Element(headTag,  baseUri);  implicit.appendChild(head);  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  [BUGGY]  if(  !validAncestor  )  stack.addLast  (  child  )  ;    return  root;  }    parent.appendChild(child);    if  (!isEmptyElement)  stack.addLast(child);  return  parent;  }        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  !isEmptyElement  )  stack.addLast  (  child  )  ;	[BUGGY]  if  (  !isEmptyElement)stack.addLast(  root);  [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  Element  implicit  =  new  Element(parentTag,  baseUri);      if  (child.tag().equals(bodyTag))  {  Element  head  =  new  Element(headTag,  baseUri);  implicit.appendChild(head);  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  [BUGGY]  if(  !isEmptyElement  )  stack.addLast  (  root  )  ;    return  root;  }    parent.appendChild(child);    if  (!isEmptyElement)  stack.addLast(child);  return  parent;  }        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  !isEmptyElement  )  stack.addLast  (  child  )  ;	[BUGGY]  if  (  !isEmptyElement)child.addLast(  stack);  [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  Element  implicit  =  new  Element(parentTag,  baseUri);      if  (child.tag().equals(bodyTag))  {  Element  head  =  new  Element(headTag,  baseUri);  implicit.appendChild(head);  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  [BUGGY]  if(  !isEmptyElement  )  child.addLast  (  stack  )  ;    return  root;  }    parent.appendChild(child);    if  (!isEmptyElement)  stack.addLast(child);  return  parent;  }        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  !isEmptyElement  )  stack.addLast  (  child  )  ;	[BUGGY]  if  (  !isEmptyElement)stack.add(  child);  [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  Element  implicit  =  new  Element(parentTag,  baseUri);      if  (child.tag().equals(bodyTag))  {  Element  head  =  new  Element(headTag,  baseUri);  implicit.appendChild(head);  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  [BUGGY]  if(  !isEmptyElement  )  stack.add  (  child  )  ;    return  root;  }    parent.appendChild(child);    if  (!isEmptyElement)  stack.addLast(child);  return  parent;  }        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  !isEmptyElement  )  stack.addLast  (  child  )  ;  return  root;  }	[BUGGY]  stack.addLast(child);  [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  Element  implicit  =  new  Element(parentTag,  baseUri);      if  (child.tag().equals(bodyTag))  {  Element  head  =  new  Element(headTag,  baseUri);  implicit.appendChild(head);  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  [BUGGY]  if  (!isEmptyElement)    stack.addLast(child);        parent.appendChild(child);    if  (!isEmptyElement)  stack.addLast(child);  return  parent;        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  !isEmptyElement  )  stack.addLast  (  child  )  ;  return  root;  }	[BUGGY]    [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  Element  implicit  =  new  Element(parentTag,  baseUri);      if  (child.tag().equals(bodyTag))  {  Element  head  =  new  Element(headTag,  baseUri);  implicit.appendChild(head);  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  [BUGGY]  if  (!isEmptyElement)            parent.appendChild(child);    if  (!isEmptyElement)  stack.addLast(child);  return  parent;        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
stack.addLast  (  child  )  ;	[BUGGY]  stack.addLast(  root);  [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  Element  implicit  =  new  Element(parentTag,  baseUri);      if  (child.tag().equals(bodyTag))  {  Element  head  =  new  Element(headTag,  baseUri);  implicit.appendChild(head);  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  if  (!isEmptyElement)  [BUGGY]  stack.addLast  (  root  )  ;  return  root;  }    parent.appendChild(child);    if  (!isEmptyElement)  stack.addLast(child);  return  parent;  }        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
stack.addLast  (  child  )  ;	[BUGGY]  stack.add(  child);  [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  Element  implicit  =  new  Element(parentTag,  baseUri);      if  (child.tag().equals(bodyTag))  {  Element  head  =  new  Element(headTag,  baseUri);  implicit.appendChild(head);  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  if  (!isEmptyElement)  [BUGGY]  stack.add  (  child  )  ;  return  root;  }    parent.appendChild(child);    if  (!isEmptyElement)  stack.addLast(child);  return  parent;  }        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
stack.addLast  (  child  )  ;	[BUGGY]  stack  .getLast(  )  ;  [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  Element  implicit  =  new  Element(parentTag,  baseUri);      if  (child.tag().equals(bodyTag))  {  Element  head  =  new  Element(headTag,  baseUri);  implicit.appendChild(head);  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  if  (!isEmptyElement)  [BUGGY]  stack  .getLast  ();  return  root;  }    parent.appendChild(child);    if  (!isEmptyElement)  stack.addLast(child);  return  parent;  }        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
stack.addLast  (  child  )  ;  return  root;	[BUGGY]    [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  Element  implicit  =  new  Element(parentTag,  baseUri);      if  (child.tag().equals(bodyTag))  {  Element  head  =  new  Element(headTag,  baseUri);  implicit.appendChild(head);  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  if  (!isEmptyElement)  [BUGGY]  stack.addLast(child);      }    parent.appendChild(child);    if  (!isEmptyElement)  stack.addLast(child);  return  parent;        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
stack.addLast  (  child  )  ;	[BUGGY]    stack.addLast(  child);  [CONTEXT]        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
stack.addLast  (  child  )  ;	[BUGGY]  stack.add(  doc);stack.addLast(  child);  [CONTEXT]        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
stack.addLast  (  child  )  ;	[BUGGY]  stack.removeLast(  );stack.addLast(  child);  [CONTEXT]        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
return  root;	[BUGGY]  return  implicit;  [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  Element  implicit  =  new  Element(parentTag,  baseUri);      if  (child.tag().equals(bodyTag))  {  Element  head  =  new  Element(headTag,  baseUri);  implicit.appendChild(head);  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  if  (!isEmptyElement)  stack.addLast(child);  [BUGGY]  return  implicit;  }    parent.appendChild(child);    if  (!isEmptyElement)  stack.addLast(child);  return  parent;  }        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Element  implicit  =  new  Element  (  parentTag,  baseUri  )  ;	[BUGGY]  Element  implicit  =  new  DataNode(  data,  baseUri)  ;  [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  [BUGGY]  Element  implicit  =  new  DataNode  (  data,  baseUri  );      if  (child.tag().equals(bodyTag))  {  Element  head  =  new  Element(headTag,  baseUri);  implicit.appendChild(head);  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  if  (!isEmptyElement)  stack.addLast(child);  return  root;  }    parent.appendChild(child);    if  (!isEmptyElement)  stack.addLast(child);  return  parent;  }        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Element  implicit  =  new  Element  (  parentTag,  baseUri  )  ;	[BUGGY]  Element  implicit  =  new  Element(  titleTag,  baseUri);  [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  [BUGGY]  Element  implicit  =  new  Element  (  titleTag,  baseUri  )  ;      if  (child.tag().equals(bodyTag))  {  Element  head  =  new  Element(headTag,  baseUri);  implicit.appendChild(head);  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  if  (!isEmptyElement)  stack.addLast(child);  return  root;  }    parent.appendChild(child);    if  (!isEmptyElement)  stack.addLast(child);  return  parent;  }        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Element  implicit  =  new  Element  (  parentTag,  baseUri  )  ;	[BUGGY]  Element  implicit  =  new  Element(  baseUri,  parentTag);  [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  [BUGGY]  Element  implicit  =  new  Element  (  baseUri,  parentTag  )  ;      if  (child.tag().equals(bodyTag))  {  Element  head  =  new  Element(headTag,  baseUri);  implicit.appendChild(head);  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  if  (!isEmptyElement)  stack.addLast(child);  return  root;  }    parent.appendChild(child);    if  (!isEmptyElement)  stack.addLast(child);  return  parent;  }        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Element  implicit  =  new  Element  (  parentTag,  baseUri  )  ;	[BUGGY]  Element  implicit  =  new  Element(    baseUri);  [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  [BUGGY]  Element  implicit  =  new  Element  (baseUri  )  ;      if  (child.tag().equals(bodyTag))  {  Element  head  =  new  Element(headTag,  baseUri);  implicit.appendChild(head);  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  if  (!isEmptyElement)  stack.addLast(child);  return  root;  }    parent.appendChild(child);    if  (!isEmptyElement)  stack.addLast(child);  return  parent;  }        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Element  implicit  =  new  Element  (  parentTag,  baseUri  )  ;	[BUGGY]  Element  implicit  =  new  Element(  parentTag);  [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  [BUGGY]  Element  implicit  =  new  Element  (  parentTag  )  ;      if  (child.tag().equals(bodyTag))  {  Element  head  =  new  Element(headTag,  baseUri);  implicit.appendChild(head);  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  if  (!isEmptyElement)  stack.addLast(child);  return  root;  }    parent.appendChild(child);    if  (!isEmptyElement)  stack.addLast(child);  return  parent;  }        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Element  implicit  =  new  Element  (  parentTag,  baseUri  )  ;	[BUGGY]  Element  implicit  =  new  Element(  parentTag,  value);  [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  [BUGGY]  Element  implicit  =  new  Element  (  parentTag,  value  )  ;      if  (child.tag().equals(bodyTag))  {  Element  head  =  new  Element(headTag,  baseUri);  implicit.appendChild(head);  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  if  (!isEmptyElement)  stack.addLast(child);  return  root;  }    parent.appendChild(child);    if  (!isEmptyElement)  stack.addLast(child);  return  parent;  }        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Element  head  =  new  Element  (  headTag,  baseUri  )  ;	[BUGGY]  Element  head  =  new  Element(  headTag,  value);  [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  Element  implicit  =  new  Element(parentTag,  baseUri);      if  (child.tag().equals(bodyTag))  {  [BUGGY]  Element  head  =  new  Element  (  headTag,  value  )  ;  implicit.appendChild(head);  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  if  (!isEmptyElement)  stack.addLast(child);  return  root;  }    parent.appendChild(child);    if  (!isEmptyElement)  stack.addLast(child);  return  parent;  }        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Tag  parentTag  =  childTag.getImplicitParent  (  )  ;	[BUGGY]  Tag  parentTag  =  childTag.equals(  );  [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      [BUGGY]  Tag  parentTag  =  childTag.equals  ()  ;  Element  implicit  =  new  Element(parentTag,  baseUri);      if  (child.tag().equals(bodyTag))  {  Element  head  =  new  Element(headTag,  baseUri);  implicit.appendChild(head);  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  if  (!isEmptyElement)  stack.addLast(child);  return  root;  }    parent.appendChild(child);    if  (!isEmptyElement)  stack.addLast(child);  return  parent;  }        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Tag  parentTag  =  childTag.getImplicitParent  (  )  ;	[BUGGY]  Tag  parentTag  =  textareaTag.getImplicitParent(  );  [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      [BUGGY]  Tag  parentTag  =  textareaTag.getImplicitParent  ()  ;  Element  implicit  =  new  Element(parentTag,  baseUri);      if  (child.tag().equals(bodyTag))  {  Element  head  =  new  Element(headTag,  baseUri);  implicit.appendChild(head);  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  if  (!isEmptyElement)  stack.addLast(child);  return  root;  }    parent.appendChild(child);    if  (!isEmptyElement)  stack.addLast(child);  return  parent;  }        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Tag  parentTag  =  childTag.getImplicitParent  (  )  ;  Element  implicit  =  new  Element  (  parentTag,  baseUri  )  ;	[BUGGY]  Element  implicit  =  new  Element(  parentTag,  baseUri);  Tag  parentTag  =  childTag.getImplicitParent(  );  [CONTEXT]        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Tag  parentTag  =  childTag.getImplicitParent  (  )  ;  Element  implicit  =  new  Element  (  parentTag,  baseUri  )  ;	[BUGGY]  Element  implicit  =  new  Element(  parentTag,  baseUri);Tag  parentTag  =  childTag.getImplicitParent(  );  Element  implicit  =  new  Element(  parentTag,  baseUri);  [CONTEXT]        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Element  implicit  =  new  Element  (  parentTag,  baseUri  )  ;	[BUGGY]  Element  implicit  =  new  Element(  tag,  baseUri);  [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  [BUGGY]  Element  implicit  =  new  Element  (  tag,  baseUri  )  ;      if  (child.tag().equals(bodyTag))  {  Element  head  =  new  Element(headTag,  baseUri);  implicit.appendChild(head);  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  if  (!isEmptyElement)  stack.addLast(child);  return  root;  }    parent.appendChild(child);    if  (!isEmptyElement)  stack.addLast(child);  return  parent;  }        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Element  implicit  =  new  Element  (  parentTag,  baseUri  )  ;	[BUGGY]  Element  implicit  =  new  Element(  parentTag,  key);  [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  [BUGGY]  Element  implicit  =  new  Element  (  parentTag,  key  )  ;      if  (child.tag().equals(bodyTag))  {  Element  head  =  new  Element(headTag,  baseUri);  implicit.appendChild(head);  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  if  (!isEmptyElement)  stack.addLast(child);  return  root;  }    parent.appendChild(child);    if  (!isEmptyElement)  stack.addLast(child);  return  parent;  }        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Element  head  =  new  Element  (  headTag,  baseUri  )  ;	[BUGGY]  Element  head  =  new  Element(  headTag,  tagName);  [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  Element  implicit  =  new  Element(parentTag,  baseUri);      if  (child.tag().equals(bodyTag))  {  [BUGGY]  Element  head  =  new  Element  (  headTag,  tagName  )  ;  implicit.appendChild(head);  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  if  (!isEmptyElement)  stack.addLast(child);  return  root;  }    parent.appendChild(child);    if  (!isEmptyElement)  stack.addLast(child);  return  parent;  }        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Element  head  =  new  Element  (  headTag,  baseUri  )  ;	[BUGGY]  implicit.appendChild(  head);  Element  head  =  new  Element(  headTag,  baseUri);  [CONTEXT]        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Element  head  =  new  Element  (  headTag,  baseUri  )  ;	[BUGGY]  Element  child  =  new  Element(  tag,  baseUri,  attributes);Element  head  =  new  Element(  headTag,  baseUri);  [CONTEXT]        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Element  head  =  new  Element  (  headTag,  baseUri  )  ;	[BUGGY]  Comment  comment  =  new  Comment(  data,  baseUri);Element  head  =  new  Element(  headTag,  baseUri);  [CONTEXT]        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Element  head  =  new  Element  (  headTag,  baseUri  )  ;	[BUGGY]  TextNode  textNode  =  new  TextNode(  rawText,  baseUri);Element  head  =  new  Element(  headTag,  baseUri);  [CONTEXT]        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Element  head  =  new  Element  (  headTag,  baseUri  )  ;	[BUGGY]  Element  implicit  =  new  Element(  parentTag,  baseUri);Element  head  =  new  Element(  headTag,  baseUri);  [CONTEXT]        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Element  root  =  addChildToParent  (  implicit,  false  )  ;	[BUGGY]  Element  root  =  addChildToParent(  implicit,  true);  [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  Element  implicit  =  new  Element(parentTag,  baseUri);      if  (child.tag().equals(bodyTag))  {  Element  head  =  new  Element(headTag,  baseUri);  implicit.appendChild(head);  }  implicit.appendChild(child);        [BUGGY]  Element  root  =  addChildToParent  (  implicit,  true  )  ;  if  (!isEmptyElement)  stack.addLast(child);  return  root;  }    parent.appendChild(child);    if  (!isEmptyElement)  stack.addLast(child);  return  parent;  }        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Element  root  =  addChildToParent  (  implicit,  false  )  ;	[BUGGY]  Element  root  =  addChildToParent(  parent,  false);  [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  Element  implicit  =  new  Element(parentTag,  baseUri);      if  (child.tag().equals(bodyTag))  {  Element  head  =  new  Element(headTag,  baseUri);  implicit.appendChild(head);  }  implicit.appendChild(child);        [BUGGY]  Element  root  =  addChildToParent  (  parent,  false  )  ;  if  (!isEmptyElement)  stack.addLast(child);  return  root;  }    parent.appendChild(child);    if  (!isEmptyElement)  stack.addLast(child);  return  parent;  }        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Element  root  =  addChildToParent  (  implicit,  false  )  ;	[BUGGY]  Element  root  =  parseBodyFragment(  implicit,  false);  [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  Element  implicit  =  new  Element(parentTag,  baseUri);      if  (child.tag().equals(bodyTag))  {  Element  head  =  new  Element(headTag,  baseUri);  implicit.appendChild(head);  }  implicit.appendChild(child);        [BUGGY]  Element  root  =  parseBodyFragment  (  implicit,  false  )  ;  if  (!isEmptyElement)  stack.addLast(child);  return  root;  }    parent.appendChild(child);    if  (!isEmptyElement)  stack.addLast(child);  return  parent;  }        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Tag  parentTag  =  childTag.getImplicitParent  (  )  ;	[BUGGY]  Tag  parentTag  =  titleTag.getImplicitParent(  );  [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      [BUGGY]  Tag  parentTag  =  titleTag.getImplicitParent  ()  ;  Element  implicit  =  new  Element(parentTag,  baseUri);      if  (child.tag().equals(bodyTag))  {  Element  head  =  new  Element(headTag,  baseUri);  implicit.appendChild(head);  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  if  (!isEmptyElement)  stack.addLast(child);  return  root;  }    parent.appendChild(child);    if  (!isEmptyElement)  stack.addLast(child);  return  parent;  }        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Tag  parentTag  =  childTag.getImplicitParent  (  )  ;	[BUGGY]  Tag  parentTag  =  titleTag  .isValidParent(  parentTag)  ;  [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      [BUGGY]  Tag  parentTag  =  titleTag  .isValidParent  (  parentTag  );  Element  implicit  =  new  Element(parentTag,  baseUri);      if  (child.tag().equals(bodyTag))  {  Element  head  =  new  Element(headTag,  baseUri);  implicit.appendChild(head);  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  if  (!isEmptyElement)  stack.addLast(child);  return  root;  }    parent.appendChild(child);    if  (!isEmptyElement)  stack.addLast(child);  return  parent;  }        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Tag  parentTag  =  childTag.getImplicitParent  (  )  ;	[BUGGY]    [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      [BUGGY]  Tag  parentTag  =  childTag.getImplicitParent();    Element  implicit  =  new  Element(parentTag,  baseUri);      if  (child.tag().equals(bodyTag))  {  Element  head  =  new  Element(headTag,  baseUri);  implicit.appendChild(head);  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  if  (!isEmptyElement)  stack.addLast(child);  return  root;  }    parent.appendChild(child);    if  (!isEmptyElement)  stack.addLast(child);  return  parent;        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Tag  parentTag  =  childTag.getImplicitParent  (  )  ;	[BUGGY]  Tag  childTag  =  child.tag(  );Tag  parentTag  =  childTag.getImplicitParent(  );  [CONTEXT]        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  child.tag  (  )  .equals  (  bodyTag  )  )  {	[BUGGY]  if  (  bodyTag.tag(  ).equals(  child))  {  [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  Element  implicit  =  new  Element(parentTag,  baseUri);      [BUGGY]  if(  bodyTag.tag  ()  .equals  (  child  )){  Element  head  =  new  Element(headTag,  baseUri);  implicit.appendChild(head);  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  if  (!isEmptyElement)  stack.addLast(child);  return  root;  }    parent.appendChild(child);    if  (!isEmptyElement)  stack.addLast(child);  return  parent;  }        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  child.tag  (  )  .equals  (  bodyTag  )  )  {	[BUGGY]  if  (  child.tag(  )  .canContain(  titleTag)  )  {  [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  Element  implicit  =  new  Element(parentTag,  baseUri);      [BUGGY]  if(  child.tag  ().canContain  (  titleTag  )  ){  Element  head  =  new  Element(headTag,  baseUri);  implicit.appendChild(head);  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  if  (!isEmptyElement)  stack.addLast(child);  return  root;  }    parent.appendChild(child);    if  (!isEmptyElement)  stack.addLast(child);  return  parent;  }        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  child.tag  (  )  .equals  (  bodyTag  )  )  {	[BUGGY]  if  (  root.absUrl(  ).equals(  bodyTag))  {  [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  Element  implicit  =  new  Element(parentTag,  baseUri);      [BUGGY]  if(  root.absUrl  ()  .equals  (  bodyTag  )){  Element  head  =  new  Element(headTag,  baseUri);  implicit.appendChild(head);  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  if  (!isEmptyElement)  stack.addLast(child);  return  root;  }    parent.appendChild(child);    if  (!isEmptyElement)  stack.addLast(child);  return  parent;  }        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
implicit.appendChild  (  child  )  ;	[BUGGY]  implicit.appendChild(  root);  [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  Element  implicit  =  new  Element(parentTag,  baseUri);      if  (child.tag().equals(bodyTag))  {  Element  head  =  new  Element(headTag,  baseUri);  implicit.appendChild(head);  }  [BUGGY]  implicit.appendChild  (  root  )  ;        Element  root  =  addChildToParent(implicit,  false);  if  (!isEmptyElement)  stack.addLast(child);  return  root;  }    parent.appendChild(child);    if  (!isEmptyElement)  stack.addLast(child);  return  parent;  }        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
implicit.appendChild  (  child  )  ;	[BUGGY]    [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  Element  implicit  =  new  Element(parentTag,  baseUri);      if  (child.tag().equals(bodyTag))  {  Element  head  =  new  Element(headTag,  baseUri);  implicit.appendChild(head);  }  [BUGGY]  implicit.appendChild(child);          Element  root  =  addChildToParent(implicit,  false);  if  (!isEmptyElement)  stack.addLast(child);  return  root;  }    parent.appendChild(child);    if  (!isEmptyElement)  stack.addLast(child);  return  parent;        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Element  root  =  addChildToParent  (  implicit,  false  )  ;	[BUGGY]  Element  root  =  addChildToParent(  root,  false);  [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  Element  implicit  =  new  Element(parentTag,  baseUri);      if  (child.tag().equals(bodyTag))  {  Element  head  =  new  Element(headTag,  baseUri);  implicit.appendChild(head);  }  implicit.appendChild(child);        [BUGGY]  Element  root  =  addChildToParent  (  root,  false  )  ;  if  (!isEmptyElement)  stack.addLast(child);  return  root;  }    parent.appendChild(child);    if  (!isEmptyElement)  stack.addLast(child);  return  parent;  }        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Element  root  =  addChildToParent  (  implicit,  false  )  ;	[BUGGY]  Element  root  =  parseBodyFragment(  root,  false);  [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  Element  implicit  =  new  Element(parentTag,  baseUri);      if  (child.tag().equals(bodyTag))  {  Element  head  =  new  Element(headTag,  baseUri);  implicit.appendChild(head);  }  implicit.appendChild(child);        [BUGGY]  Element  root  =  parseBodyFragment  (  root,  false  )  ;  if  (!isEmptyElement)  stack.addLast(child);  return  root;  }    parent.appendChild(child);    if  (!isEmptyElement)  stack.addLast(child);  return  parent;  }        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Element  root  =  addChildToParent  (  implicit,  false  )  ;	[BUGGY]    [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  Element  implicit  =  new  Element(parentTag,  baseUri);      if  (child.tag().equals(bodyTag))  {  Element  head  =  new  Element(headTag,  baseUri);  implicit.appendChild(head);  }  implicit.appendChild(child);        [BUGGY]  Element  root  =  addChildToParent(implicit,  false);    if  (!isEmptyElement)  stack.addLast(child);  return  root;  }    parent.appendChild(child);    if  (!isEmptyElement)  stack.addLast(child);  return  parent;        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
stack.addLast  (  child  )  ;	[BUGGY]  return  root;  stack.addLast(  child);  [CONTEXT]        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  child.tag  (  )  .equals  (  bodyTag  )  )  {	[BUGGY]  if  (  child.tag(  ).equals(  textareaTag))  {  [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  Element  implicit  =  new  Element(parentTag,  baseUri);      [BUGGY]  if(  child.tag  ()  .equals  (  textareaTag  )){  Element  head  =  new  Element(headTag,  baseUri);  implicit.appendChild(head);  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  if  (!isEmptyElement)  stack.addLast(child);  return  root;  }    parent.appendChild(child);    if  (!isEmptyElement)  stack.addLast(child);  return  parent;  }        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  child.tag  (  )  .equals  (  bodyTag  )  )  {	[BUGGY]  if  (  child.tag(  )  .canContain(  textareaTag)  )  {  [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  Element  implicit  =  new  Element(parentTag,  baseUri);      [BUGGY]  if(  child.tag  ().canContain  (  textareaTag  )  ){  Element  head  =  new  Element(headTag,  baseUri);  implicit.appendChild(head);  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  if  (!isEmptyElement)  stack.addLast(child);  return  root;  }    parent.appendChild(child);    if  (!isEmptyElement)  stack.addLast(child);  return  parent;  }        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Element  head  =  new  Element  (  headTag,  baseUri  )  ;	[BUGGY]  Element  head  =  new  Element(  tag,  baseUri);  [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  Element  implicit  =  new  Element(parentTag,  baseUri);      if  (child.tag().equals(bodyTag))  {  [BUGGY]  Element  head  =  new  Element  (  tag,  baseUri  )  ;  implicit.appendChild(head);  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  if  (!isEmptyElement)  stack.addLast(child);  return  root;  }    parent.appendChild(child);    if  (!isEmptyElement)  stack.addLast(child);  return  parent;  }        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
stack.addLast  (  child  )  ;	[BUGGY]  stack.addLast(  parent);  [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  Element  implicit  =  new  Element(parentTag,  baseUri);      if  (child.tag().equals(bodyTag))  {  Element  head  =  new  Element(headTag,  baseUri);  implicit.appendChild(head);  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  if  (!isEmptyElement)  [BUGGY]  stack.addLast  (  parent  )  ;  return  root;  }    parent.appendChild(child);    if  (!isEmptyElement)  stack.addLast(child);  return  parent;  }        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
return  root;	[BUGGY]  return  parent;  [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  Element  implicit  =  new  Element(parentTag,  baseUri);      if  (child.tag().equals(bodyTag))  {  Element  head  =  new  Element(headTag,  baseUri);  implicit.appendChild(head);  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  if  (!isEmptyElement)  stack.addLast(child);  [BUGGY]  return  parent;  }    parent.appendChild(child);    if  (!isEmptyElement)  stack.addLast(child);  return  parent;  }        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Element  implicit  =  new  Element  (  parentTag,  baseUri  )  ;	[BUGGY]  Element  implicit  =  new  Element(  parentTag,  tagName);  [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  [BUGGY]  Element  implicit  =  new  Element  (  parentTag,  tagName  )  ;      if  (child.tag().equals(bodyTag))  {  Element  head  =  new  Element(headTag,  baseUri);  implicit.appendChild(head);  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  if  (!isEmptyElement)  stack.addLast(child);  return  root;  }    parent.appendChild(child);    if  (!isEmptyElement)  stack.addLast(child);  return  parent;  }        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Tag  parentTag  =  childTag.getImplicitParent  (  )  ;	[BUGGY]  Tag  parentTag  =  titleTag  .isValidParent(  bodyTag)  ;  [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      [BUGGY]  Tag  parentTag  =  titleTag  .isValidParent  (  bodyTag  );  Element  implicit  =  new  Element(parentTag,  baseUri);      if  (child.tag().equals(bodyTag))  {  Element  head  =  new  Element(headTag,  baseUri);  implicit.appendChild(head);  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  if  (!isEmptyElement)  stack.addLast(child);  return  root;  }    parent.appendChild(child);    if  (!isEmptyElement)  stack.addLast(child);  return  parent;  }        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Element  implicit  =  new  Element  (  parentTag,  baseUri  )  ;	[BUGGY]  Element  implicit  =  new  Element(  parentTag,  rawText);  [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  [BUGGY]  Element  implicit  =  new  Element  (  parentTag,  rawText  )  ;      if  (child.tag().equals(bodyTag))  {  Element  head  =  new  Element(headTag,  baseUri);  implicit.appendChild(head);  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  if  (!isEmptyElement)  stack.addLast(child);  return  root;  }    parent.appendChild(child);    if  (!isEmptyElement)  stack.addLast(child);  return  parent;  }        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Element  implicit  =  new  Element  (  parentTag,  baseUri  )  ;	[BUGGY]  Element  implicit  =  new  Element(  parentTag,  text);  [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  [BUGGY]  Element  implicit  =  new  Element  (  parentTag,  text  )  ;      if  (child.tag().equals(bodyTag))  {  Element  head  =  new  Element(headTag,  baseUri);  implicit.appendChild(head);  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  if  (!isEmptyElement)  stack.addLast(child);  return  root;  }    parent.appendChild(child);    if  (!isEmptyElement)  stack.addLast(child);  return  parent;  }        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Tag  parentTag  =  childTag.getImplicitParent  (  )  ;	[BUGGY]  Tag  parentTag  =  tag.getImplicitParent(  );  [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      [BUGGY]  Tag  parentTag  =  tag.getImplicitParent  ()  ;  Element  implicit  =  new  Element(parentTag,  baseUri);      if  (child.tag().equals(bodyTag))  {  Element  head  =  new  Element(headTag,  baseUri);  implicit.appendChild(head);  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  if  (!isEmptyElement)  stack.addLast(child);  return  root;  }    parent.appendChild(child);    if  (!isEmptyElement)  stack.addLast(child);  return  parent;  }        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
Tag  parentTag  =  childTag.getImplicitParent  (  )  ;	[BUGGY]  Tag  parentTag  =  childTag  .isValidParent(  parentTag)  ;  [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      [BUGGY]  Tag  parentTag  =  childTag  .isValidParent  (  parentTag  );  Element  implicit  =  new  Element(parentTag,  baseUri);      if  (child.tag().equals(bodyTag))  {  Element  head  =  new  Element(headTag,  baseUri);  implicit.appendChild(head);  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  if  (!isEmptyElement)  stack.addLast(child);  return  root;  }    parent.appendChild(child);    if  (!isEmptyElement)  stack.addLast(child);  return  parent;  }        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  child.tag  (  )  .equals  (  bodyTag  )  )  {	[BUGGY]  if  (  root.tag(  ).canContain(  bodyTag))  {  [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  Element  implicit  =  new  Element(parentTag,  baseUri);      [BUGGY]  if(  root.tag  ()  .canContain  (  bodyTag  )){  Element  head  =  new  Element(headTag,  baseUri);  implicit.appendChild(head);  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  if  (!isEmptyElement)  stack.addLast(child);  return  root;  }    parent.appendChild(child);    if  (!isEmptyElement)  stack.addLast(child);  return  parent;  }        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
stack.addLast  (  child  )  ;	[BUGGY]    [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  Element  implicit  =  new  Element(parentTag,  baseUri);      if  (child.tag().equals(bodyTag))  {  Element  head  =  new  Element(headTag,  baseUri);  implicit.appendChild(head);  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  if  (!isEmptyElement)  [BUGGY]  stack.addLast(child);    return  root;  }    parent.appendChild(child);    if  (!isEmptyElement)  stack.addLast(child);  return  parent;        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
parent.appendChild  (  child  )  ;	[BUGGY]  parent.appendChild(  root);  [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  Element  implicit  =  new  Element(parentTag,  baseUri);      if  (child.tag().equals(bodyTag))  {  Element  head  =  new  Element(headTag,  baseUri);  implicit.appendChild(head);  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  if  (!isEmptyElement)  stack.addLast(child);  return  root;  }    [BUGGY]  parent.appendChild  (  root  )  ;    if  (!isEmptyElement)  stack.addLast(child);  return  parent;  }        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
parent.appendChild  (  child  )  ;	[BUGGY]    [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  Element  implicit  =  new  Element(parentTag,  baseUri);      if  (child.tag().equals(bodyTag))  {  Element  head  =  new  Element(headTag,  baseUri);  implicit.appendChild(head);  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  if  (!isEmptyElement)  stack.addLast(child);  return  root;  }    [BUGGY]  parent.appendChild(child);      if  (!isEmptyElement)  stack.addLast(child);  return  parent;        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  !isEmptyElement  )  stack.addLast  (  child  )  ;	[BUGGY]  if  (  !validAncestor)stack.addLast(  child);  [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  Element  implicit  =  new  Element(parentTag,  baseUri);      if  (child.tag().equals(bodyTag))  {  Element  head  =  new  Element(headTag,  baseUri);  implicit.appendChild(head);  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  if  (!isEmptyElement)  stack.addLast(child);  return  root;  }    parent.appendChild(child);    [BUGGY]  if(  !validAncestor  )  stack.addLast  (  child  )  ;    return  parent;  }        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  !isEmptyElement  )  stack.addLast  (  child  )  ;	[BUGGY]  if  (  !isEmptyElement)stack.addLast(  root);  [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  Element  implicit  =  new  Element(parentTag,  baseUri);      if  (child.tag().equals(bodyTag))  {  Element  head  =  new  Element(headTag,  baseUri);  implicit.appendChild(head);  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  if  (!isEmptyElement)  stack.addLast(child);  return  root;  }    parent.appendChild(child);    [BUGGY]  if(  !isEmptyElement  )  stack.addLast  (  root  )  ;    return  parent;  }        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  !isEmptyElement  )  stack.addLast  (  child  )  ;	[BUGGY]  if  (  !isEmptyElement)null.addLast(  child);  [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  Element  implicit  =  new  Element(parentTag,  baseUri);      if  (child.tag().equals(bodyTag))  {  Element  head  =  new  Element(headTag,  baseUri);  implicit.appendChild(head);  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  if  (!isEmptyElement)  stack.addLast(child);  return  root;  }    parent.appendChild(child);    [BUGGY]  if(  !isEmptyElement  )  null.addLast  (  child  )  ;    return  parent;  }        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  !isEmptyElement  )  stack.addLast  (  child  )  ;	[BUGGY]  if  (  !isEmptyElement)stack.add(  child);  [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  Element  implicit  =  new  Element(parentTag,  baseUri);      if  (child.tag().equals(bodyTag))  {  Element  head  =  new  Element(headTag,  baseUri);  implicit.appendChild(head);  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  if  (!isEmptyElement)  stack.addLast(child);  return  root;  }    parent.appendChild(child);    [BUGGY]  if(  !isEmptyElement  )  stack.add  (  child  )  ;    return  parent;  }        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  !isEmptyElement  )  stack.addLast  (  child  )  ;	[BUGGY]  if  (  !isEmptyElement)stack  .getLast(  )  ;  [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  Element  implicit  =  new  Element(parentTag,  baseUri);      if  (child.tag().equals(bodyTag))  {  Element  head  =  new  Element(headTag,  baseUri);  implicit.appendChild(head);  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  if  (!isEmptyElement)  stack.addLast(child);  return  root;  }    parent.appendChild(child);    [BUGGY]  if(  !isEmptyElement  )  stack  .getLast  ();    return  parent;  }        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  !isEmptyElement  )  stack.addLast  (  child  )  ;	[BUGGY]  if  (  !isEmptyElement)stack.addLast(  parent);  [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  Element  implicit  =  new  Element(parentTag,  baseUri);      if  (child.tag().equals(bodyTag))  {  Element  head  =  new  Element(headTag,  baseUri);  implicit.appendChild(head);  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  if  (!isEmptyElement)  stack.addLast(child);  return  root;  }    parent.appendChild(child);    [BUGGY]  if(  !isEmptyElement  )  stack.addLast  (  parent  )  ;    return  parent;  }        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  !isEmptyElement  )  stack.addLast  (  child  )  ;  return  parent;  }	[BUGGY]  stack.addLast(child);  [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  Element  implicit  =  new  Element(parentTag,  baseUri);      if  (child.tag().equals(bodyTag))  {  Element  head  =  new  Element(headTag,  baseUri);  implicit.appendChild(head);  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  if  (!isEmptyElement)  stack.addLast(child);  return  root;  }    parent.appendChild(child);    [BUGGY]  if  (!isEmptyElement)    stack.addLast(child);          [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  !isEmptyElement  )  stack.addLast  (  child  )  ;  return  parent;  }	[BUGGY]    [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  Element  implicit  =  new  Element(parentTag,  baseUri);      if  (child.tag().equals(bodyTag))  {  Element  head  =  new  Element(headTag,  baseUri);  implicit.appendChild(head);  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  if  (!isEmptyElement)  stack.addLast(child);  return  root;  }    parent.appendChild(child);    [BUGGY]  if  (!isEmptyElement)              [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
stack.addLast  (  child  )  ;	[BUGGY]  stack.add(  child);  [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  Element  implicit  =  new  Element(parentTag,  baseUri);      if  (child.tag().equals(bodyTag))  {  Element  head  =  new  Element(headTag,  baseUri);  implicit.appendChild(head);  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  if  (!isEmptyElement)  stack.addLast(child);  return  root;  }    parent.appendChild(child);    if  (!isEmptyElement)  [BUGGY]  stack.add  (  child  )  ;  return  parent;  }        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
stack.addLast  (  child  )  ;	[BUGGY]  stack  .getLast(  )  ;  [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  Element  implicit  =  new  Element(parentTag,  baseUri);      if  (child.tag().equals(bodyTag))  {  Element  head  =  new  Element(headTag,  baseUri);  implicit.appendChild(head);  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  if  (!isEmptyElement)  stack.addLast(child);  return  root;  }    parent.appendChild(child);    if  (!isEmptyElement)  [BUGGY]  stack  .getLast  ();  return  parent;  }        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
stack.addLast  (  child  )  ;  return  parent;	[BUGGY]    [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  Element  implicit  =  new  Element(parentTag,  baseUri);      if  (child.tag().equals(bodyTag))  {  Element  head  =  new  Element(headTag,  baseUri);  implicit.appendChild(head);  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  if  (!isEmptyElement)  stack.addLast(child);  return  root;  }    parent.appendChild(child);    if  (!isEmptyElement)  [BUGGY]  stack.addLast(child);            [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
stack.addLast  (  child  )  ;	[BUGGY]  stack.addLast(  root);  [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  Element  implicit  =  new  Element(parentTag,  baseUri);      if  (child.tag().equals(bodyTag))  {  Element  head  =  new  Element(headTag,  baseUri);  implicit.appendChild(head);  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  if  (!isEmptyElement)  stack.addLast(child);  return  root;  }    parent.appendChild(child);    if  (!isEmptyElement)  [BUGGY]  stack.addLast  (  root  )  ;  return  parent;  }        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
stack.addLast  (  child  )  ;	[BUGGY]    [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  Element  implicit  =  new  Element(parentTag,  baseUri);      if  (child.tag().equals(bodyTag))  {  Element  head  =  new  Element(headTag,  baseUri);  implicit.appendChild(head);  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  if  (!isEmptyElement)  stack.addLast(child);  return  root;  }    parent.appendChild(child);    if  (!isEmptyElement)  [BUGGY]  stack.addLast(child);    return  parent;        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
stack.addLast  (  child  )  ;	[BUGGY]    stack.addLast(  child);  [CONTEXT]        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
stack.addLast  (  child  )  ;	[BUGGY]  stack.add(  doc);stack.addLast(  child);  [CONTEXT]        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
stack.addLast  (  child  )  ;	[BUGGY]  stack.removeLast(  );stack.addLast(  child);  [CONTEXT]        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
return  parent;	[BUGGY]  return  root;  [CONTEXT]  private  Element  addChildToParent(Element  child,  boolean  isEmptyElement)  {  Element  parent  =  popStackToSuitableContainer(child.tag());  Tag  childTag  =  child.tag();  boolean  validAncestor  =  stackHasValidParent(childTag);    if  (!validAncestor)  {      Tag  parentTag  =  childTag.getImplicitParent();  Element  implicit  =  new  Element(parentTag,  baseUri);      if  (child.tag().equals(bodyTag))  {  Element  head  =  new  Element(headTag,  baseUri);  implicit.appendChild(head);  }  implicit.appendChild(child);        Element  root  =  addChildToParent(implicit,  false);  if  (!isEmptyElement)  stack.addLast(child);  return  root;  }    parent.appendChild(child);    if  (!isEmptyElement)  stack.addLast(child);  [BUGGY]  return  root;  }        [CLASS]  Parser    [METHOD]  addChildToParent  [RETURN_TYPE]  Element      Element  child  boolean  isEmptyElement  [VARIABLES]  TokenQueue    tq    boolean    isEmptyElement    validAncestor    Element    child    head    implicit    parent    root    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    
if  (  stack.size  (  )  ==  1  &&  childTag.equals  (  htmlTag  )  )  return  true;	[BUGGY]  if  (  stack.size(  )  ==  1  ||  childTag.equals(  htmlTag))return  true;  [CONTEXT]  private  boolean  stackHasValidParent(Tag  childTag)  {  [BUGGY]  if(  stack.size  ()==  1  ||  childTag.equals  (  htmlTag  ))  return  true;      for  (int  i  =  stack.size()  -1;  i  >=  0;  i--)  {  Element  el  =  stack.get(i);  Tag  parent2  =  el.tag();  if  (parent2.isValidParent(childTag))  {  return  true;  }  }  return  false;  }        [CLASS]  Parser    [METHOD]  stackHasValidParent  [RETURN_TYPE]  boolean      Tag  childTag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    i    
if  (  stack.size  (  )  ==  1  &&  childTag.equals  (  htmlTag  )  )  return  true;	[BUGGY]  if  (  stack.size(  )  <=  1  &&  childTag.equals(  htmlTag))return  true;  [CONTEXT]  private  boolean  stackHasValidParent(Tag  childTag)  {  [BUGGY]  if(  stack.size  ()<=  1  &&  childTag.equals  (  htmlTag  ))  return  true;      for  (int  i  =  stack.size()  -1;  i  >=  0;  i--)  {  Element  el  =  stack.get(i);  Tag  parent2  =  el.tag();  if  (parent2.isValidParent(childTag))  {  return  true;  }  }  return  false;  }        [CLASS]  Parser    [METHOD]  stackHasValidParent  [RETURN_TYPE]  boolean      Tag  childTag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    i    
if  (  stack.size  (  )  ==  1  &&  childTag.equals  (  htmlTag  )  )  return  true;	[BUGGY]  if  (  stack.size(  )  ==  i  &&  childTag.equals(  htmlTag))return  true;  [CONTEXT]  private  boolean  stackHasValidParent(Tag  childTag)  {  [BUGGY]  if(  stack.size  ()==  i  &&  childTag.equals  (  htmlTag  ))  return  true;      for  (int  i  =  stack.size()  -1;  i  >=  0;  i--)  {  Element  el  =  stack.get(i);  Tag  parent2  =  el.tag();  if  (parent2.isValidParent(childTag))  {  return  true;  }  }  return  false;  }        [CLASS]  Parser    [METHOD]  stackHasValidParent  [RETURN_TYPE]  boolean      Tag  childTag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    i    
if  (  stack.size  (  )  ==  1  &&  childTag.equals  (  htmlTag  )  )  return  true;	[BUGGY]  if  (  stack.size(  )  ==  1  &&  childTag.equals(  htmlTag))return  false;  [CONTEXT]  private  boolean  stackHasValidParent(Tag  childTag)  {  [BUGGY]  if(  stack.size  ()==  1  &&  childTag.equals  (  htmlTag  ))  return  false;      for  (int  i  =  stack.size()  -1;  i  >=  0;  i--)  {  Element  el  =  stack.get(i);  Tag  parent2  =  el.tag();  if  (parent2.isValidParent(childTag))  {  return  true;  }  }  return  false;  }        [CLASS]  Parser    [METHOD]  stackHasValidParent  [RETURN_TYPE]  boolean      Tag  childTag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    i    
if  (  stack.size  (  )  ==  1  &&  childTag.equals  (  htmlTag  )  )  return  true;	[BUGGY]  if  (  stack.size()  -  8    ==  1  &&  childTag.equals(  htmlTag))return  true;  [CONTEXT]  private  boolean  stackHasValidParent(Tag  childTag)  {  [BUGGY]  if(  stack.size()  -  8==  1  &&  childTag.equals  (  htmlTag  ))  return  true;      for  (int  i  =  stack.size()  -1;  i  >=  0;  i--)  {  Element  el  =  stack.get(i);  Tag  parent2  =  el.tag();  if  (parent2.isValidParent(childTag))  {  return  true;  }  }  return  false;  }        [CLASS]  Parser    [METHOD]  stackHasValidParent  [RETURN_TYPE]  boolean      Tag  childTag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    i    
if  (  stack.size  (  )  ==  1  &&  childTag.equals  (  htmlTag  )  )  return  true;	[BUGGY]  if  (  stack.size(  )  ==  1  &&  tag.equals(  htmlTag))return  true;  [CONTEXT]  private  boolean  stackHasValidParent(Tag  childTag)  {  [BUGGY]  if(  stack.size  ()==  1  &&  tag.equals  (  htmlTag  ))  return  true;      for  (int  i  =  stack.size()  -1;  i  >=  0;  i--)  {  Element  el  =  stack.get(i);  Tag  parent2  =  el.tag();  if  (parent2.isValidParent(childTag))  {  return  true;  }  }  return  false;  }        [CLASS]  Parser    [METHOD]  stackHasValidParent  [RETURN_TYPE]  boolean      Tag  childTag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    i    
if  (  stack.size  (  )  ==  1  &&  childTag.equals  (  htmlTag  )  )  return  true;	[BUGGY]  if  (  stack.size(  )  ==  1  &&  childTag.equals(  tag))return  true;  [CONTEXT]  private  boolean  stackHasValidParent(Tag  childTag)  {  [BUGGY]  if(  stack.size  ()==  1  &&  childTag.equals  (  tag  ))  return  true;      for  (int  i  =  stack.size()  -1;  i  >=  0;  i--)  {  Element  el  =  stack.get(i);  Tag  parent2  =  el.tag();  if  (parent2.isValidParent(childTag))  {  return  true;  }  }  return  false;  }        [CLASS]  Parser    [METHOD]  stackHasValidParent  [RETURN_TYPE]  boolean      Tag  childTag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    i    
if  (  stack.size  (  )  ==  1  &&  childTag.equals  (  htmlTag  )  )  return  true;	[BUGGY]  if  (  childTag.size(  )  ==  1  &&  stack.equals(  htmlTag))return  true;  [CONTEXT]  private  boolean  stackHasValidParent(Tag  childTag)  {  [BUGGY]  if(  childTag.size  ()==  1  &&  stack.equals  (  htmlTag  ))  return  true;      for  (int  i  =  stack.size()  -1;  i  >=  0;  i--)  {  Element  el  =  stack.get(i);  Tag  parent2  =  el.tag();  if  (parent2.isValidParent(childTag))  {  return  true;  }  }  return  false;  }        [CLASS]  Parser    [METHOD]  stackHasValidParent  [RETURN_TYPE]  boolean      Tag  childTag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    i    
if  (  stack.size  (  )  ==  1  &&  childTag.equals  (  htmlTag  )  )  return  true;	[BUGGY]  if  (  htmlTag.size(  )  ==  1  &&  childTag.equals(  stack))return  true;  [CONTEXT]  private  boolean  stackHasValidParent(Tag  childTag)  {  [BUGGY]  if(  htmlTag.size  ()==  1  &&  childTag.equals  (  stack  ))  return  true;      for  (int  i  =  stack.size()  -1;  i  >=  0;  i--)  {  Element  el  =  stack.get(i);  Tag  parent2  =  el.tag();  if  (parent2.isValidParent(childTag))  {  return  true;  }  }  return  false;  }        [CLASS]  Parser    [METHOD]  stackHasValidParent  [RETURN_TYPE]  boolean      Tag  childTag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    i    
if  (  stack.size  (  )  ==  1  &&  childTag.equals  (  htmlTag  )  )  return  true;	[BUGGY]  if  (  stack.size(  )  ==  1  &&  htmlTag.equals(  childTag))return  true;  [CONTEXT]  private  boolean  stackHasValidParent(Tag  childTag)  {  [BUGGY]  if(  stack.size  ()==  1  &&  htmlTag.equals  (  childTag  ))  return  true;      for  (int  i  =  stack.size()  -1;  i  >=  0;  i--)  {  Element  el  =  stack.get(i);  Tag  parent2  =  el.tag();  if  (parent2.isValidParent(childTag))  {  return  true;  }  }  return  false;  }        [CLASS]  Parser    [METHOD]  stackHasValidParent  [RETURN_TYPE]  boolean      Tag  childTag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    i    
if  (  stack.size  (  )  ==  1  &&  childTag.equals  (  htmlTag  )  )  return  true;	[BUGGY]  if  (  stack.size(  )  ==  1)return  true;  [CONTEXT]  private  boolean  stackHasValidParent(Tag  childTag)  {  [BUGGY]  if(  stack.size  ()==  1  )  return  true;      for  (int  i  =  stack.size()  -1;  i  >=  0;  i--)  {  Element  el  =  stack.get(i);  Tag  parent2  =  el.tag();  if  (parent2.isValidParent(childTag))  {  return  true;  }  }  return  false;  }        [CLASS]  Parser    [METHOD]  stackHasValidParent  [RETURN_TYPE]  boolean      Tag  childTag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    i    
if  (  stack.size  (  )  ==  1  &&  childTag.equals  (  htmlTag  )  )  return  true;	[BUGGY]  if  (  stack.add(  )  ==  1  &&  childTag.equals(  htmlTag))return  true;  [CONTEXT]  private  boolean  stackHasValidParent(Tag  childTag)  {  [BUGGY]  if(  stack.add  ()==  1  &&  childTag.equals  (  htmlTag  ))  return  true;      for  (int  i  =  stack.size()  -1;  i  >=  0;  i--)  {  Element  el  =  stack.get(i);  Tag  parent2  =  el.tag();  if  (parent2.isValidParent(childTag))  {  return  true;  }  }  return  false;  }        [CLASS]  Parser    [METHOD]  stackHasValidParent  [RETURN_TYPE]  boolean      Tag  childTag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    i    
if  (  stack.size  (  )  ==  1  &&  childTag.equals  (  htmlTag  )  )  return  true;	[BUGGY]  if  (  stack  .isEmpty(  )    ==  1  &&  childTag.equals(  htmlTag))return  true;  [CONTEXT]  private  boolean  stackHasValidParent(Tag  childTag)  {  [BUGGY]  if(  stack  .isEmpty  ()  ==  1  &&  childTag.equals  (  htmlTag  ))  return  true;      for  (int  i  =  stack.size()  -1;  i  >=  0;  i--)  {  Element  el  =  stack.get(i);  Tag  parent2  =  el.tag();  if  (parent2.isValidParent(childTag))  {  return  true;  }  }  return  false;  }        [CLASS]  Parser    [METHOD]  stackHasValidParent  [RETURN_TYPE]  boolean      Tag  childTag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    i    
if  (  stack.size  (  )  ==  1  &&  childTag.equals  (  htmlTag  )  )  return  true;	[BUGGY]  if  (  stack.size(  )  ==  1  &&  childTag.isValidParent(  htmlTag))return  true;  [CONTEXT]  private  boolean  stackHasValidParent(Tag  childTag)  {  [BUGGY]  if(  stack.size  ()==  1  &&  childTag.isValidParent  (  htmlTag  ))  return  true;      for  (int  i  =  stack.size()  -1;  i  >=  0;  i--)  {  Element  el  =  stack.get(i);  Tag  parent2  =  el.tag();  if  (parent2.isValidParent(childTag))  {  return  true;  }  }  return  false;  }        [CLASS]  Parser    [METHOD]  stackHasValidParent  [RETURN_TYPE]  boolean      Tag  childTag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    i    
if  (  stack.size  (  )  ==  1  &&  childTag.equals  (  htmlTag  )  )  return  true;	[BUGGY]  if  (  stack.size(  )  ==  1  &&  childTag  .canContain(  parent2)  )return  true;  [CONTEXT]  private  boolean  stackHasValidParent(Tag  childTag)  {  [BUGGY]  if(  stack.size  ()==  1  &&  childTag  .canContain  (  parent2  )  )  return  true;      for  (int  i  =  stack.size()  -1;  i  >=  0;  i--)  {  Element  el  =  stack.get(i);  Tag  parent2  =  el.tag();  if  (parent2.isValidParent(childTag))  {  return  true;  }  }  return  false;  }        [CLASS]  Parser    [METHOD]  stackHasValidParent  [RETURN_TYPE]  boolean      Tag  childTag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    i    
if  (  stack.size  (  )  ==  1  &&  childTag.equals  (  htmlTag  )  )  return  true;	[BUGGY]  if  (  stack.size(  )  ==  0    &&  childTag.equals(  htmlTag))return  true;  [CONTEXT]  private  boolean  stackHasValidParent(Tag  childTag)  {  [BUGGY]  if(  stack.size  ()==  0&&  childTag.equals  (  htmlTag  ))  return  true;      for  (int  i  =  stack.size()  -1;  i  >=  0;  i--)  {  Element  el  =  stack.get(i);  Tag  parent2  =  el.tag();  if  (parent2.isValidParent(childTag))  {  return  true;  }  }  return  false;  }        [CLASS]  Parser    [METHOD]  stackHasValidParent  [RETURN_TYPE]  boolean      Tag  childTag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    i    
return  true;	[BUGGY]  return  false;  [CONTEXT]  private  boolean  stackHasValidParent(Tag  childTag)  {  if  (stack.size()  ==  1  &&  childTag.equals(htmlTag))  [BUGGY]  return  false;    for  (int  i  =  stack.size()  -1;  i  >=  0;  i--)  {  Element  el  =  stack.get(i);  Tag  parent2  =  el.tag();  if  (parent2.isValidParent(childTag))  {  return  true;  }  }  return  false;  }        [CLASS]  Parser    [METHOD]  stackHasValidParent  [RETURN_TYPE]  boolean      Tag  childTag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    i    
if  (  stack.size  (  )  ==  1  &&  childTag.equals  (  htmlTag  )  )  return  true;	[BUGGY]  if  (  stack.size()  +  3    ==  1  &&  childTag.equals(  htmlTag))return  true;  [CONTEXT]  private  boolean  stackHasValidParent(Tag  childTag)  {  [BUGGY]  if(  stack.size()  +  3==  1  &&  childTag.equals  (  htmlTag  ))  return  true;      for  (int  i  =  stack.size()  -1;  i  >=  0;  i--)  {  Element  el  =  stack.get(i);  Tag  parent2  =  el.tag();  if  (parent2.isValidParent(childTag))  {  return  true;  }  }  return  false;  }        [CLASS]  Parser    [METHOD]  stackHasValidParent  [RETURN_TYPE]  boolean      Tag  childTag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    i    
if  (  stack.size  (  )  ==  1  &&  childTag.equals  (  htmlTag  )  )  return  true;	[BUGGY]  if  (  1.add(  )  ==  1  &&  childTag.equals(  htmlTag))return  true;  [CONTEXT]  private  boolean  stackHasValidParent(Tag  childTag)  {  [BUGGY]  if(  1.add  ()==  1  &&  childTag.equals  (  htmlTag  ))  return  true;      for  (int  i  =  stack.size()  -1;  i  >=  0;  i--)  {  Element  el  =  stack.get(i);  Tag  parent2  =  el.tag();  if  (parent2.isValidParent(childTag))  {  return  true;  }  }  return  false;  }        [CLASS]  Parser    [METHOD]  stackHasValidParent  [RETURN_TYPE]  boolean      Tag  childTag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    i    
if  (  stack.size  (  )  ==  1  &&  childTag.equals  (  htmlTag  )  )  return  true;	[BUGGY]  if  (  stack.size()  -  2    ==  1  &&  childTag.equals(  htmlTag))return  true;  [CONTEXT]  private  boolean  stackHasValidParent(Tag  childTag)  {  [BUGGY]  if(  stack.size()  -  2==  1  &&  childTag.equals  (  htmlTag  ))  return  true;      for  (int  i  =  stack.size()  -1;  i  >=  0;  i--)  {  Element  el  =  stack.get(i);  Tag  parent2  =  el.tag();  if  (parent2.isValidParent(childTag))  {  return  true;  }  }  return  false;  }        [CLASS]  Parser    [METHOD]  stackHasValidParent  [RETURN_TYPE]  boolean      Tag  childTag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    i    
if  (  stack.size  (  )  ==  1  &&  childTag.equals  (  htmlTag  )  )  return  true;	[BUGGY]  if  (  stack.size(  )  ==  1  &&  childTag.isValidParent(  titleTag))return  true;  [CONTEXT]  private  boolean  stackHasValidParent(Tag  childTag)  {  [BUGGY]  if(  stack.size  ()==  1  &&  childTag.isValidParent  (  titleTag  ))  return  true;      for  (int  i  =  stack.size()  -1;  i  >=  0;  i--)  {  Element  el  =  stack.get(i);  Tag  parent2  =  el.tag();  if  (parent2.isValidParent(childTag))  {  return  true;  }  }  return  false;  }        [CLASS]  Parser    [METHOD]  stackHasValidParent  [RETURN_TYPE]  boolean      Tag  childTag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    i    
if  (  parent2.isValidParent  (  childTag  )  )  {	[BUGGY]  if  (  titleTag.isValidParent(  childTag))  {  [CONTEXT]  private  boolean  stackHasValidParent(Tag  childTag)  {  if  (stack.size()  ==  1  &&  childTag.equals(htmlTag))  return  true;  //  root  is  valid  for  html  node    for  (int  i  =  stack.size()  -1;  i  >=  0;  i--)  {  Element  el  =  stack.get(i);  Tag  parent2  =  el.tag();  [BUGGY]  if(  titleTag.isValidParent  (  childTag  )){  return  true;  }  }  return  false;  }        [CLASS]  Parser    [METHOD]  stackHasValidParent  [RETURN_TYPE]  boolean      Tag  childTag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    i    
if  (  parent2.isValidParent  (  childTag  )  )  {	[BUGGY]  if  (  parent2.isValidParent(  tag))  {  [CONTEXT]  private  boolean  stackHasValidParent(Tag  childTag)  {  if  (stack.size()  ==  1  &&  childTag.equals(htmlTag))  return  true;  //  root  is  valid  for  html  node    for  (int  i  =  stack.size()  -1;  i  >=  0;  i--)  {  Element  el  =  stack.get(i);  Tag  parent2  =  el.tag();  [BUGGY]  if(  parent2.isValidParent  (  tag  )){  return  true;  }  }  return  false;  }        [CLASS]  Parser    [METHOD]  stackHasValidParent  [RETURN_TYPE]  boolean      Tag  childTag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    i    
if  (  parent2.isValidParent  (  childTag  )  )  {	[BUGGY]  if  (  childTag.isValidParent(  parent2))  {  [CONTEXT]  private  boolean  stackHasValidParent(Tag  childTag)  {  if  (stack.size()  ==  1  &&  childTag.equals(htmlTag))  return  true;  //  root  is  valid  for  html  node    for  (int  i  =  stack.size()  -1;  i  >=  0;  i--)  {  Element  el  =  stack.get(i);  Tag  parent2  =  el.tag();  [BUGGY]  if(  childTag.isValidParent  (  parent2  )){  return  true;  }  }  return  false;  }        [CLASS]  Parser    [METHOD]  stackHasValidParent  [RETURN_TYPE]  boolean      Tag  childTag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    i    
if  (  parent2.isValidParent  (  childTag  )  )  {	[BUGGY]  if  (  parent2  .getImplicitParent(  )  )  {  [CONTEXT]  private  boolean  stackHasValidParent(Tag  childTag)  {  if  (stack.size()  ==  1  &&  childTag.equals(htmlTag))  return  true;  //  root  is  valid  for  html  node    for  (int  i  =  stack.size()  -1;  i  >=  0;  i--)  {  Element  el  =  stack.get(i);  Tag  parent2  =  el.tag();  [BUGGY]  if(  parent2  .getImplicitParent  ()  ){  return  true;  }  }  return  false;  }        [CLASS]  Parser    [METHOD]  stackHasValidParent  [RETURN_TYPE]  boolean      Tag  childTag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    i    
if  (  parent2.isValidParent  (  childTag  )  )  {  return  true;  }	[BUGGY]  return  true;  [CONTEXT]  private  boolean  stackHasValidParent(Tag  childTag)  {  if  (stack.size()  ==  1  &&  childTag.equals(htmlTag))  return  true;  //  root  is  valid  for  html  node    for  (int  i  =  stack.size()  -1;  i  >=  0;  i--)  {  Element  el  =  stack.get(i);  Tag  parent2  =  el.tag();  [BUGGY]  if  (parent2.isValidParent(childTag))  {    return  true;    }  return  false;        [CLASS]  Parser    [METHOD]  stackHasValidParent  [RETURN_TYPE]  boolean      Tag  childTag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    i    
if  (  parent2.isValidParent  (  childTag  )  )  {  return  true;  }	[BUGGY]    [CONTEXT]  private  boolean  stackHasValidParent(Tag  childTag)  {  if  (stack.size()  ==  1  &&  childTag.equals(htmlTag))  return  true;  //  root  is  valid  for  html  node    for  (int  i  =  stack.size()  -1;  i  >=  0;  i--)  {  Element  el  =  stack.get(i);  Tag  parent2  =  el.tag();  [BUGGY]  if  (parent2.isValidParent(childTag))  {        }  return  false;        [CLASS]  Parser    [METHOD]  stackHasValidParent  [RETURN_TYPE]  boolean      Tag  childTag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    i    
return  true;	[BUGGY]  return  false;  [CONTEXT]  private  boolean  stackHasValidParent(Tag  childTag)  {  if  (stack.size()  ==  1  &&  childTag.equals(htmlTag))  return  true;  //  root  is  valid  for  html  node    for  (int  i  =  stack.size()  -1;  i  >=  0;  i--)  {  Element  el  =  stack.get(i);  Tag  parent2  =  el.tag();  if  (parent2.isValidParent(childTag))  {  [BUGGY]  return  false;  }  }  return  false;  }        [CLASS]  Parser    [METHOD]  stackHasValidParent  [RETURN_TYPE]  boolean      Tag  childTag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    i    
for  (  int  i  =  stack.size  (  )  -1;  i  >=  0;  i--  )  {	[BUGGY]  for  (    long    i  =  stack.size(  )  -1;  i  >=  0;  i--)  {  [CONTEXT]  private  boolean  stackHasValidParent(Tag  childTag)  {  if  (stack.size()  ==  1  &&  childTag.equals(htmlTag))  return  true;  //  root  is  valid  for  html  node    [BUGGY]  for(longi  =  stack.size  ()-1;  i  >=  0;  i--  ){  Element  el  =  stack.get(i);  Tag  parent2  =  el.tag();  if  (parent2.isValidParent(childTag))  {  return  true;  }  }  return  false;  }        [CLASS]  Parser    [METHOD]  stackHasValidParent  [RETURN_TYPE]  boolean      Tag  childTag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    i    
for  (  int  i  =  stack.size  (  )  -1;  i  >=  0;  i--  )  {	[BUGGY]  for  (  int  i  =  stack.size(  )  -1;  i  >  0;  i--)  {  [CONTEXT]  private  boolean  stackHasValidParent(Tag  childTag)  {  if  (stack.size()  ==  1  &&  childTag.equals(htmlTag))  return  true;  //  root  is  valid  for  html  node    [BUGGY]  for(  int  i  =  stack.size  ()-1;  i  >  0;  i--  ){  Element  el  =  stack.get(i);  Tag  parent2  =  el.tag();  if  (parent2.isValidParent(childTag))  {  return  true;  }  }  return  false;  }        [CLASS]  Parser    [METHOD]  stackHasValidParent  [RETURN_TYPE]  boolean      Tag  childTag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    i    
for  (  int  i  =  stack.size  (  )  -1;  i  >=  0;  i--  )  {	[BUGGY]  for  (  int  i  =  stack.size(  )  -i;  i  >=  0;  i--)  {  [CONTEXT]  private  boolean  stackHasValidParent(Tag  childTag)  {  if  (stack.size()  ==  1  &&  childTag.equals(htmlTag))  return  true;  //  root  is  valid  for  html  node    [BUGGY]  for(  int  i  =  stack.size  ()-i;  i  >=  0;  i--  ){  Element  el  =  stack.get(i);  Tag  parent2  =  el.tag();  if  (parent2.isValidParent(childTag))  {  return  true;  }  }  return  false;  }        [CLASS]  Parser    [METHOD]  stackHasValidParent  [RETURN_TYPE]  boolean      Tag  childTag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    i    
for  (  int  i  =  stack.size  (  )  -1;  i  >=  0;  i--  )  {	[BUGGY]  for  (  int  i  =  stack.size(  )  -1;  i  >=  i;  i--)  {  [CONTEXT]  private  boolean  stackHasValidParent(Tag  childTag)  {  if  (stack.size()  ==  1  &&  childTag.equals(htmlTag))  return  true;  //  root  is  valid  for  html  node    [BUGGY]  for(  int  i  =  stack.size  ()-1;  i  >=  i;  i--  ){  Element  el  =  stack.get(i);  Tag  parent2  =  el.tag();  if  (parent2.isValidParent(childTag))  {  return  true;  }  }  return  false;  }        [CLASS]  Parser    [METHOD]  stackHasValidParent  [RETURN_TYPE]  boolean      Tag  childTag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    i    
for  (  int  i  =  stack.size  (  )  -1;  i  >=  0;  i--  )  {	[BUGGY]  for  (  int  i  =  stack.size()  -  5    -1;  i  >=  0;  i--)  {  [CONTEXT]  private  boolean  stackHasValidParent(Tag  childTag)  {  if  (stack.size()  ==  1  &&  childTag.equals(htmlTag))  return  true;  //  root  is  valid  for  html  node    [BUGGY]  for(  int  i  =  stack.size()  -  5-1;  i  >=  0;  i--  ){  Element  el  =  stack.get(i);  Tag  parent2  =  el.tag();  if  (parent2.isValidParent(childTag))  {  return  true;  }  }  return  false;  }        [CLASS]  Parser    [METHOD]  stackHasValidParent  [RETURN_TYPE]  boolean      Tag  childTag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    i    
for  (  int  i  =  stack.size  (  )  -1;  i  >=  0;  i--  )  {	[BUGGY]  for  (  stacknt  i  =  i.size(  )  -1;  i  >=  0;  i--)  {  [CONTEXT]  private  boolean  stackHasValidParent(Tag  childTag)  {  if  (stack.size()  ==  1  &&  childTag.equals(htmlTag))  return  true;  //  root  is  valid  for  html  node    [BUGGY]  for(  stacknt  i  =  i.size  ()-1;  i  >=  0;  i--  ){  Element  el  =  stack.get(i);  Tag  parent2  =  el.tag();  if  (parent2.isValidParent(childTag))  {  return  true;  }  }  return  false;  }        [CLASS]  Parser    [METHOD]  stackHasValidParent  [RETURN_TYPE]  boolean      Tag  childTag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    i    
for  (  int  i  =  stack.size  (  )  -1;  i  >=  0;  i--  )  {	[BUGGY]  for  (  int  i  =  stack.add(  )  -1;  i  >=  0;  i--)  {  [CONTEXT]  private  boolean  stackHasValidParent(Tag  childTag)  {  if  (stack.size()  ==  1  &&  childTag.equals(htmlTag))  return  true;  //  root  is  valid  for  html  node    [BUGGY]  for(  int  i  =  stack.add  ()-1;  i  >=  0;  i--  ){  Element  el  =  stack.get(i);  Tag  parent2  =  el.tag();  if  (parent2.isValidParent(childTag))  {  return  true;  }  }  return  false;  }        [CLASS]  Parser    [METHOD]  stackHasValidParent  [RETURN_TYPE]  boolean      Tag  childTag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    i    
if  (  parent2.isValidParent  (  childTag  )  )  {	[BUGGY]  if  (  tag.isValidParent(  childTag))  {  [CONTEXT]  private  boolean  stackHasValidParent(Tag  childTag)  {  if  (stack.size()  ==  1  &&  childTag.equals(htmlTag))  return  true;  //  root  is  valid  for  html  node    for  (int  i  =  stack.size()  -1;  i  >=  0;  i--)  {  Element  el  =  stack.get(i);  Tag  parent2  =  el.tag();  [BUGGY]  if(  tag.isValidParent  (  childTag  )){  return  true;  }  }  return  false;  }        [CLASS]  Parser    [METHOD]  stackHasValidParent  [RETURN_TYPE]  boolean      Tag  childTag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    i    
if  (  parent2.isValidParent  (  childTag  )  )  {	[BUGGY]  if  (  parent2.isValidParent(  titleTag))  {  [CONTEXT]  private  boolean  stackHasValidParent(Tag  childTag)  {  if  (stack.size()  ==  1  &&  childTag.equals(htmlTag))  return  true;  //  root  is  valid  for  html  node    for  (int  i  =  stack.size()  -1;  i  >=  0;  i--)  {  Element  el  =  stack.get(i);  Tag  parent2  =  el.tag();  [BUGGY]  if(  parent2.isValidParent  (  titleTag  )){  return  true;  }  }  return  false;  }        [CLASS]  Parser    [METHOD]  stackHasValidParent  [RETURN_TYPE]  boolean      Tag  childTag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    i    
Element  el  =  stack.get  (  i  )  ;	[BUGGY]  Element  el  =  i.get(  stack);  [CONTEXT]  private  boolean  stackHasValidParent(Tag  childTag)  {  if  (stack.size()  ==  1  &&  childTag.equals(htmlTag))  return  true;  //  root  is  valid  for  html  node    for  (int  i  =  stack.size()  -1;  i  >=  0;  i--)  {  [BUGGY]  Element  el  =  i.get  (  stack  )  ;  Tag  parent2  =  el.tag();  if  (parent2.isValidParent(childTag))  {  return  true;  }  }  return  false;  }        [CLASS]  Parser    [METHOD]  stackHasValidParent  [RETURN_TYPE]  boolean      Tag  childTag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    i    
Element  el  =  stack.get  (  i  )  ;	[BUGGY]  Element  el  =  stack.add(  i);  [CONTEXT]  private  boolean  stackHasValidParent(Tag  childTag)  {  if  (stack.size()  ==  1  &&  childTag.equals(htmlTag))  return  true;  //  root  is  valid  for  html  node    for  (int  i  =  stack.size()  -1;  i  >=  0;  i--)  {  [BUGGY]  Element  el  =  stack.add  (  i  )  ;  Tag  parent2  =  el.tag();  if  (parent2.isValidParent(childTag))  {  return  true;  }  }  return  false;  }        [CLASS]  Parser    [METHOD]  stackHasValidParent  [RETURN_TYPE]  boolean      Tag  childTag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    i    
Element  el  =  stack.get  (  i  )  ;	[BUGGY]  Element  el  =  4  .getLast(  )  ;  [CONTEXT]  private  boolean  stackHasValidParent(Tag  childTag)  {  if  (stack.size()  ==  1  &&  childTag.equals(htmlTag))  return  true;  //  root  is  valid  for  html  node    for  (int  i  =  stack.size()  -1;  i  >=  0;  i--)  {  [BUGGY]  Element  el  =  4  .getLast  ();  Tag  parent2  =  el.tag();  if  (parent2.isValidParent(childTag))  {  return  true;  }  }  return  false;  }        [CLASS]  Parser    [METHOD]  stackHasValidParent  [RETURN_TYPE]  boolean      Tag  childTag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    i    
Element  el  =  stack.get  (  i  )  ;	[BUGGY]  if  (  parent2.isValidParent(  childTag))  {  Element  el  =  stack.get(  i);  [CONTEXT]        [CLASS]  Parser    [METHOD]  stackHasValidParent  [RETURN_TYPE]  boolean      Tag  childTag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    i    
Element  el  =  stack.get  (  i  )  ;	[BUGGY]  Element  elToClose  =  null;Element  el  =  stack.get(  i);  [CONTEXT]        [CLASS]  Parser    [METHOD]  stackHasValidParent  [RETURN_TYPE]  boolean      Tag  childTag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    i    
Tag  parent2  =  el.tag  (  )  ;	[BUGGY]  Tag  parent2  =  el.absUrl(  );  [CONTEXT]  private  boolean  stackHasValidParent(Tag  childTag)  {  if  (stack.size()  ==  1  &&  childTag.equals(htmlTag))  return  true;  //  root  is  valid  for  html  node    for  (int  i  =  stack.size()  -1;  i  >=  0;  i--)  {  Element  el  =  stack.get(i);  [BUGGY]  Tag  parent2  =  el.absUrl  ()  ;  if  (parent2.isValidParent(childTag))  {  return  true;  }  }  return  false;  }        [CLASS]  Parser    [METHOD]  stackHasValidParent  [RETURN_TYPE]  boolean      Tag  childTag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    i    
Element  el  =  stack.get  (  i  )  ;	[BUGGY]  Element  el  =  0.get(  i);  [CONTEXT]  private  boolean  stackHasValidParent(Tag  childTag)  {  if  (stack.size()  ==  1  &&  childTag.equals(htmlTag))  return  true;  //  root  is  valid  for  html  node    for  (int  i  =  stack.size()  -1;  i  >=  0;  i--)  {  [BUGGY]  Element  el  =  0.get  (  i  )  ;  Tag  parent2  =  el.tag();  if  (parent2.isValidParent(childTag))  {  return  true;  }  }  return  false;  }        [CLASS]  Parser    [METHOD]  stackHasValidParent  [RETURN_TYPE]  boolean      Tag  childTag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    i    
Element  el  =  stack.get  (  i  )  ;	[BUGGY]    [CONTEXT]  private  boolean  stackHasValidParent(Tag  childTag)  {  if  (stack.size()  ==  1  &&  childTag.equals(htmlTag))  return  true;  //  root  is  valid  for  html  node    for  (int  i  =  stack.size()  -1;  i  >=  0;  i--)  {  [BUGGY]  Element  el  =  stack.get(i);    Tag  parent2  =  el.tag();  if  (parent2.isValidParent(childTag))  {  return  true;  }  }  return  false;        [CLASS]  Parser    [METHOD]  stackHasValidParent  [RETURN_TYPE]  boolean      Tag  childTag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    i    
Tag  parent2  =  el.tag  (  )  ;	[BUGGY]    [CONTEXT]  private  boolean  stackHasValidParent(Tag  childTag)  {  if  (stack.size()  ==  1  &&  childTag.equals(htmlTag))  return  true;  //  root  is  valid  for  html  node    for  (int  i  =  stack.size()  -1;  i  >=  0;  i--)  {  Element  el  =  stack.get(i);  [BUGGY]  Tag  parent2  =  el.tag();    if  (parent2.isValidParent(childTag))  {  return  true;  }  }  return  false;        [CLASS]  Parser    [METHOD]  stackHasValidParent  [RETURN_TYPE]  boolean      Tag  childTag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    i    
[Delete]	[BUGGY]  if  (  parent2.isValidParent(  childTag))  {          return  true;  }  [CONTEXT]        [CLASS]  Parser    [METHOD]  stackHasValidParent  [RETURN_TYPE]  boolean      Tag  childTag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    i    
for  (  int  i  =  stack.size  (  )  -1;  i  >=  0;  i--  )  {	[BUGGY]  for  (  int  i  =  stack.size(  )  --3;  i  >=  0;  i--)  {  [CONTEXT]  private  boolean  stackHasValidParent(Tag  childTag)  {  if  (stack.size()  ==  1  &&  childTag.equals(htmlTag))  return  true;  //  root  is  valid  for  html  node    [BUGGY]  for(  int  i  =  stack.size  ()--3;  i  >=  0;  i--  ){  Element  el  =  stack.get(i);  Tag  parent2  =  el.tag();  if  (parent2.isValidParent(childTag))  {  return  true;  }  }  return  false;  }        [CLASS]  Parser    [METHOD]  stackHasValidParent  [RETURN_TYPE]  boolean      Tag  childTag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    i    
for  (  int  i  =  stack.size  (  )  -1;  i  >=  0;  i--  )  {	[BUGGY]  for  (  int  i  =  stack.size()  -  6    -1;  i  >=  0;  i--)  {  [CONTEXT]  private  boolean  stackHasValidParent(Tag  childTag)  {  if  (stack.size()  ==  1  &&  childTag.equals(htmlTag))  return  true;  //  root  is  valid  for  html  node    [BUGGY]  for(  int  i  =  stack.size()  -  6-1;  i  >=  0;  i--  ){  Element  el  =  stack.get(i);  Tag  parent2  =  el.tag();  if  (parent2.isValidParent(childTag))  {  return  true;  }  }  return  false;  }        [CLASS]  Parser    [METHOD]  stackHasValidParent  [RETURN_TYPE]  boolean      Tag  childTag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    i    
for  (  int  i  =  stack.size  (  )  -1;  i  >=  0;  i--  )  {	[BUGGY]  for  (  int  i  =  this.size(  )  -1;  i  >=  0;  i--)  {  [CONTEXT]  private  boolean  stackHasValidParent(Tag  childTag)  {  if  (stack.size()  ==  1  &&  childTag.equals(htmlTag))  return  true;  //  root  is  valid  for  html  node    [BUGGY]  for(  int  i  =  this.size  ()-1;  i  >=  0;  i--  ){  Element  el  =  stack.get(i);  Tag  parent2  =  el.tag();  if  (parent2.isValidParent(childTag))  {  return  true;  }  }  return  false;  }        [CLASS]  Parser    [METHOD]  stackHasValidParent  [RETURN_TYPE]  boolean      Tag  childTag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    i    
for  (  int  i  =  stack.size  (  )  -1;  i  >=  0;  i--  )  {	[BUGGY]  for  (  int  i  =  stack  .isEmpty(  )    -1;  i  >=  0;  i--)  {  [CONTEXT]  private  boolean  stackHasValidParent(Tag  childTag)  {  if  (stack.size()  ==  1  &&  childTag.equals(htmlTag))  return  true;  //  root  is  valid  for  html  node    [BUGGY]  for(  int  i  =  stack  .isEmpty  ()  -1;  i  >=  0;  i--  ){  Element  el  =  stack.get(i);  Tag  parent2  =  el.tag();  if  (parent2.isValidParent(childTag))  {  return  true;  }  }  return  false;  }        [CLASS]  Parser    [METHOD]  stackHasValidParent  [RETURN_TYPE]  boolean      Tag  childTag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    i    
Tag  parent2  =  el.tag  (  )  ;	[BUGGY]  Tag  parent2  =  el  .tagName(  )  ;  [CONTEXT]  private  boolean  stackHasValidParent(Tag  childTag)  {  if  (stack.size()  ==  1  &&  childTag.equals(htmlTag))  return  true;  //  root  is  valid  for  html  node    for  (int  i  =  stack.size()  -1;  i  >=  0;  i--)  {  Element  el  =  stack.get(i);  [BUGGY]  Tag  parent2  =  el  .tagName  ();  if  (parent2.isValidParent(childTag))  {  return  true;  }  }  return  false;  }        [CLASS]  Parser    [METHOD]  stackHasValidParent  [RETURN_TYPE]  boolean      Tag  childTag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    i    
for  (  int  i  =  stack.size  (  )  -1;  i  >=  0;  i--  )  {	[BUGGY]  for  (  int  i  =  stack.size()  -  8    -1;  i  >=  0;  i--)  {  [CONTEXT]  private  boolean  stackHasValidParent(Tag  childTag)  {  if  (stack.size()  ==  1  &&  childTag.equals(htmlTag))  return  true;  //  root  is  valid  for  html  node    [BUGGY]  for(  int  i  =  stack.size()  -  8-1;  i  >=  0;  i--  ){  Element  el  =  stack.get(i);  Tag  parent2  =  el.tag();  if  (parent2.isValidParent(childTag))  {  return  true;  }  }  return  false;  }        [CLASS]  Parser    [METHOD]  stackHasValidParent  [RETURN_TYPE]  boolean      Tag  childTag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    i    
for  (  int  i  =  stack.size  (  )  -1;  i  >=  0;  i--  )  {  Element  el  =  stack.get  (  i  )  ;  Tag  parent2  =  el.tag  (  )  ;  if  (  parent2.isValidParent  (  childTag  )  )  {  return  true;  }	[BUGGY]    [CONTEXT]  private  boolean  stackHasValidParent(Tag  childTag)  {  if  (stack.size()  ==  1  &&  childTag.equals(htmlTag))  return  true;  //  root  is  valid  for  html  node    [BUGGY]  for  (int  i  =  stack.size()  -1;  i  >=  0;  i--)  {            }  }  return  false;        [CLASS]  Parser    [METHOD]  stackHasValidParent  [RETURN_TYPE]  boolean      Tag  childTag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    i    
Element  el  =  stack.get  (  i  )  ;  Tag  parent2  =  el.tag  (  )  ;	[BUGGY]    [CONTEXT]  private  boolean  stackHasValidParent(Tag  childTag)  {  if  (stack.size()  ==  1  &&  childTag.equals(htmlTag))  return  true;  //  root  is  valid  for  html  node    for  (int  i  =  stack.size()  -1;  i  >=  0;  i--)  {  [BUGGY]  Element  el  =  stack.get(i);      if  (parent2.isValidParent(childTag))  {  return  true;  }  }  return  false;        [CLASS]  Parser    [METHOD]  stackHasValidParent  [RETURN_TYPE]  boolean      Tag  childTag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    i    
Element  el  =  stack.get  (  i  )  ;  Tag  parent2  =  el.tag  (  )  ;	[BUGGY]  Tag  parent2  =  el.tag(  );  Element  el  =  stack.get(  i);  [CONTEXT]        [CLASS]  Parser    [METHOD]  stackHasValidParent  [RETURN_TYPE]  boolean      Tag  childTag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    i    
Element  el  =  stack.get  (  i  )  ;  Tag  parent2  =  el.tag  (  )  ;	[BUGGY]  Element  el  =  stack.get(  i);Element  el  =  stack.get(  i);  Tag  parent2  =  el.tag(  );  [CONTEXT]        [CLASS]  Parser    [METHOD]  stackHasValidParent  [RETURN_TYPE]  boolean      Tag  childTag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    i    
if  (  parent2.isValidParent  (  childTag  )  )  {	[BUGGY]  if  (  parent2.isValidParent(  textareaTag))  {  [CONTEXT]  private  boolean  stackHasValidParent(Tag  childTag)  {  if  (stack.size()  ==  1  &&  childTag.equals(htmlTag))  return  true;  //  root  is  valid  for  html  node    for  (int  i  =  stack.size()  -1;  i  >=  0;  i--)  {  Element  el  =  stack.get(i);  Tag  parent2  =  el.tag();  [BUGGY]  if(  parent2.isValidParent  (  textareaTag  )){  return  true;  }  }  return  false;  }        [CLASS]  Parser    [METHOD]  stackHasValidParent  [RETURN_TYPE]  boolean      Tag  childTag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    i    
return  false;	[BUGGY]  return  true;  [CONTEXT]  private  boolean  stackHasValidParent(Tag  childTag)  {  if  (stack.size()  ==  1  &&  childTag.equals(htmlTag))  return  true;  //  root  is  valid  for  html  node    for  (int  i  =  stack.size()  -1;  i  >=  0;  i--)  {  Element  el  =  stack.get(i);  Tag  parent2  =  el.tag();  if  (parent2.isValidParent(childTag))  {  return  true;  }  }  [BUGGY]  return  true;  }        [CLASS]  Parser    [METHOD]  stackHasValidParent  [RETURN_TYPE]  boolean      Tag  childTag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    i    
while  (  !stack.isEmpty  (  )  )  {	[BUGGY]  while  (  !stack.size(  ))  {  [CONTEXT]  private  Element  popStackToSuitableContainer(Tag  tag)  {  [BUGGY]  while(  !stack.size  ()){  if  (last().tag().canContain(tag))  return  last();  else  stack.removeLast();  }  return  null;  }        [CLASS]  Parser    [METHOD]  popStackToSuitableContainer  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
while  (  !stack.isEmpty  (  )  )  {	[BUGGY]  while  (  !stack  .chompTo(  href)  )  {  [CONTEXT]  private  Element  popStackToSuitableContainer(Tag  tag)  {  [BUGGY]  while(  !stack  .chompTo  (  href  )  ){  if  (last().tag().canContain(tag))  return  last();  else  stack.removeLast();  }  return  null;  }        [CLASS]  Parser    [METHOD]  popStackToSuitableContainer  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
while  (  !stack.isEmpty  (  )  )  {	[BUGGY]  while  (  !stack  .chompTo(  text)  )  {  [CONTEXT]  private  Element  popStackToSuitableContainer(Tag  tag)  {  [BUGGY]  while(  !stack  .chompTo  (  text  )  ){  if  (last().tag().canContain(tag))  return  last();  else  stack.removeLast();  }  return  null;  }        [CLASS]  Parser    [METHOD]  popStackToSuitableContainer  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
if  (  last  (  )  .tag  (  )  .canContain  (  tag  )  )  return  last  (  )  ;	[BUGGY]  if  (  last(  ).tag(  ).canContain(  parentTag))return  last(  );  [CONTEXT]  private  Element  popStackToSuitableContainer(Tag  tag)  {  while  (!stack.isEmpty())  {  [BUGGY]  if(  last  ()  .tag  ()  .canContain  (  parentTag  ))  return  last  ()  ;    else  stack.removeLast();  }  return  null;  }        [CLASS]  Parser    [METHOD]  popStackToSuitableContainer  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
if  (  last  (  )  .tag  (  )  .canContain  (  tag  )  )  return  last  (  )  ;	[BUGGY]  if  (  last(  ).tag(  ).equals(  tag))return  last(  );  [CONTEXT]  private  Element  popStackToSuitableContainer(Tag  tag)  {  while  (!stack.isEmpty())  {  [BUGGY]  if(  last  ()  .tag  ()  .equals  (  tag  ))  return  last  ()  ;    else  stack.removeLast();  }  return  null;  }        [CLASS]  Parser    [METHOD]  popStackToSuitableContainer  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
if  (  last  (  )  .tag  (  )  .canContain  (  tag  )  )  return  last  (  )  ;	[BUGGY]  if  (  last(  ).tagName(  ).canContain(  tag))return  last(  );  [CONTEXT]  private  Element  popStackToSuitableContainer(Tag  tag)  {  while  (!stack.isEmpty())  {  [BUGGY]  if(  last  ()  .tagName  ()  .canContain  (  tag  ))  return  last  ()  ;    else  stack.removeLast();  }  return  null;  }        [CLASS]  Parser    [METHOD]  popStackToSuitableContainer  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
if  (  last  (  )  .tag  (  )  .canContain  (  tag  )  )  return  last  (  )  ;	[BUGGY]  if  (  parse(  ).tag(  ).canContain(  tag))return  last(  );  [CONTEXT]  private  Element  popStackToSuitableContainer(Tag  tag)  {  while  (!stack.isEmpty())  {  [BUGGY]  if(  parse  ()  .tag  ()  .canContain  (  tag  ))  return  last  ()  ;    else  stack.removeLast();  }  return  null;  }        [CLASS]  Parser    [METHOD]  popStackToSuitableContainer  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
if  (  last  (  )  .tag  (  )  .canContain  (  tag  )  )  return  last  (  )  ;	[BUGGY]  if  (  last(  ).tagName(  ).canContain(  parent2))return  last(  );  [CONTEXT]  private  Element  popStackToSuitableContainer(Tag  tag)  {  while  (!stack.isEmpty())  {  [BUGGY]  if(  last  ()  .tagName  ()  .canContain  (  parent2  ))  return  last  ()  ;    else  stack.removeLast();  }  return  null;  }        [CLASS]  Parser    [METHOD]  popStackToSuitableContainer  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
if  (  last  (  )  .tag  (  )  .canContain  (  tag  )  )  return  last  (  )  ;  else  stack.removeLast  (  )  ;  }	[BUGGY]  return  last();  [CONTEXT]  private  Element  popStackToSuitableContainer(Tag  tag)  {  while  (!stack.isEmpty())  {  [BUGGY]  if  (last().tag().canContain(tag))    return  last();        return  null;        [CLASS]  Parser    [METHOD]  popStackToSuitableContainer  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
if  (  last  (  )  .tag  (  )  .canContain  (  tag  )  )  return  last  (  )  ;  else  stack.removeLast  (  )  ;  }	[BUGGY]    [CONTEXT]  private  Element  popStackToSuitableContainer(Tag  tag)  {  while  (!stack.isEmpty())  {  [BUGGY]  if  (last().tag().canContain(tag))            return  null;        [CLASS]  Parser    [METHOD]  popStackToSuitableContainer  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
stack.removeLast  (  )  ;	[BUGGY]  stack.getLast(  );  [CONTEXT]  private  Element  popStackToSuitableContainer(Tag  tag)  {  while  (!stack.isEmpty())  {  if  (last().tag().canContain(tag))  return  last();  else  [BUGGY]  stack.getLast  ()  ;  }  return  null;  }        [CLASS]  Parser    [METHOD]  popStackToSuitableContainer  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
stack.removeLast  (  )  ;	[BUGGY]    [CONTEXT]  private  Element  popStackToSuitableContainer(Tag  tag)  {  while  (!stack.isEmpty())  {  if  (last().tag().canContain(tag))  return  last();  else  [BUGGY]  stack.removeLast();    }  return  null;        [CLASS]  Parser    [METHOD]  popStackToSuitableContainer  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
return  last  (  )  ;	[BUGGY]  return  parse(  );  [CONTEXT]  private  Element  popStackToSuitableContainer(Tag  tag)  {  while  (!stack.isEmpty())  {  if  (last().tag().canContain(tag))  [BUGGY]  return  parse  ()  ;  else  stack.removeLast();  }  return  null;  }        [CLASS]  Parser    [METHOD]  popStackToSuitableContainer  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
return  last  (  )  ;	[BUGGY]    [CONTEXT]  private  Element  popStackToSuitableContainer(Tag  tag)  {  while  (!stack.isEmpty())  {  if  (last().tag().canContain(tag))  [BUGGY]  return  last();    else  stack.removeLast();  }  return  null;        [CLASS]  Parser    [METHOD]  popStackToSuitableContainer  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
if  (  last  (  )  .tag  (  )  .canContain  (  tag  )  )  return  last  (  )  ;	[BUGGY]  if  (  last(  ).tag(  )  .equals(  text)  )return  last(  );  [CONTEXT]  private  Element  popStackToSuitableContainer(Tag  tag)  {  while  (!stack.isEmpty())  {  [BUGGY]  if(  last  ()  .tag  ().equals  (  text  )  )  return  last  ()  ;    else  stack.removeLast();  }  return  null;  }        [CLASS]  Parser    [METHOD]  popStackToSuitableContainer  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
if  (  last  (  )  .tag  (  )  .canContain  (  tag  )  )  return  last  (  )  ;	[BUGGY]  if  (  last(  ).tag(  ).canContain(  parent2))return  last(  );  [CONTEXT]  private  Element  popStackToSuitableContainer(Tag  tag)  {  while  (!stack.isEmpty())  {  [BUGGY]  if(  last  ()  .tag  ()  .canContain  (  parent2  ))  return  last  ()  ;    else  stack.removeLast();  }  return  null;  }        [CLASS]  Parser    [METHOD]  popStackToSuitableContainer  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
if  (  last  (  )  .tag  (  )  .canContain  (  tag  )  )  return  last  (  )  ;	[BUGGY]  if  (  last(  ).tag(  )  .equals(  bodyHtml)  )return  last(  );  [CONTEXT]  private  Element  popStackToSuitableContainer(Tag  tag)  {  while  (!stack.isEmpty())  {  [BUGGY]  if(  last  ()  .tag  ().equals  (  bodyHtml  )  )  return  last  ()  ;    else  stack.removeLast();  }  return  null;  }        [CLASS]  Parser    [METHOD]  popStackToSuitableContainer  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
while  (  !stack.isEmpty  (  )  )  {	[BUGGY]  while  (  !stack  .chompTo(  data)  )  {  [CONTEXT]  private  Element  popStackToSuitableContainer(Tag  tag)  {  [BUGGY]  while(  !stack  .chompTo  (  data  )  ){  if  (last().tag().canContain(tag))  return  last();  else  stack.removeLast();  }  return  null;  }        [CLASS]  Parser    [METHOD]  popStackToSuitableContainer  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
while  (  !stack.isEmpty  (  )  )  {	[BUGGY]  while  (  !stack  .chompTo(  DQ)  )  {  [CONTEXT]  private  Element  popStackToSuitableContainer(Tag  tag)  {  [BUGGY]  while(  !stack  .chompTo  (  DQ  )  ){  if  (last().tag().canContain(tag))  return  last();  else  stack.removeLast();  }  return  null;  }        [CLASS]  Parser    [METHOD]  popStackToSuitableContainer  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
while  (  !stack.isEmpty  (  )  )  {  if  (  last  (  )  .tag  (  )  .canContain  (  tag  )  )  return  last  (  )  ;	[BUGGY]    [CONTEXT]  private  Element  popStackToSuitableContainer(Tag  tag)  {  [BUGGY]  while  (!stack.isEmpty())  {        else  stack.removeLast();  }  return  null;        [CLASS]  Parser    [METHOD]  popStackToSuitableContainer  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
if  (  last  (  )  .tag  (  )  .canContain  (  tag  )  )  return  last  (  )  ;	[BUGGY]  if  (  last(  ).tag(  ).canContain(  titleTag))return  last(  );  [CONTEXT]  private  Element  popStackToSuitableContainer(Tag  tag)  {  while  (!stack.isEmpty())  {  [BUGGY]  if(  last  ()  .tag  ()  .canContain  (  titleTag  ))  return  last  ()  ;    else  stack.removeLast();  }  return  null;  }        [CLASS]  Parser    [METHOD]  popStackToSuitableContainer  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
return  null;	[BUGGY]  return  this;  [CONTEXT]  private  Element  popStackToSuitableContainer(Tag  tag)  {  while  (!stack.isEmpty())  {  if  (last().tag().canContain(tag))  return  last();  else  stack.removeLast();  }  [BUGGY]  return  this;  }        [CLASS]  Parser    [METHOD]  popStackToSuitableContainer  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
int  counter  =  0;	[BUGGY]  short    counter  =  0;  [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      [BUGGY]  shortcounter  =  0;  Element  elToClose  =  null;  for  (int  i  =  stack.size()  -1;  i  >  0;  i--)  {  counter++;  Element  el  =  stack.get(i);  Tag  elTag  =  el.tag();  if  (elTag.equals(bodyTag)  ||  elTag.equals(htmlTag))  {  //  once  in  body,  don't  close  past  body  break;  }  else  if  (elTag.equals(tag))  {  elToClose  =  el;  break;  }  }  if  (elToClose  !=  null)  {  for  (int  i  =  0;  i  <  counter;  i++)  {  stack.removeLast();  }  }  return  elToClose;  }        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
int  counter  =  0;	[BUGGY]  int  counter  =  -7;  [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      [BUGGY]  int  counter  =  -7;  Element  elToClose  =  null;  for  (int  i  =  stack.size()  -1;  i  >  0;  i--)  {  counter++;  Element  el  =  stack.get(i);  Tag  elTag  =  el.tag();  if  (elTag.equals(bodyTag)  ||  elTag.equals(htmlTag))  {  //  once  in  body,  don't  close  past  body  break;  }  else  if  (elTag.equals(tag))  {  elToClose  =  el;  break;  }  }  if  (elToClose  !=  null)  {  for  (int  i  =  0;  i  <  counter;  i++)  {  stack.removeLast();  }  }  return  elToClose;  }        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
Element  elToClose  =  null;	[BUGGY]  if  (  elToClose  !=  null)  {  Element  elToClose  =  null;  }  [CONTEXT]        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
if  (  elTag.equals  (  bodyTag  )  ||  elTag.equals  (  htmlTag  )  )  {	[BUGGY]  if  (  elTag.equals(  bodyTag)  &&  elTag.equals(  htmlTag))  {  [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      int  counter  =  0;  Element  elToClose  =  null;  for  (int  i  =  stack.size()  -1;  i  >  0;  i--)  {  counter++;  Element  el  =  stack.get(i);  Tag  elTag  =  el.tag();  [BUGGY]  if(  elTag.equals  (  bodyTag  )&&  elTag.equals  (  htmlTag  )){  break;  }  else  if  (elTag.equals(tag))  {  elToClose  =  el;  break;  }  }  if  (elToClose  !=  null)  {  for  (int  i  =  0;  i  <  counter;  i++)  {  stack.removeLast();  }  }  return  elToClose;  }        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
if  (  elTag.equals  (  bodyTag  )  ||  elTag.equals  (  htmlTag  )  )  {	[BUGGY]  if  (  titleTag.equals(  bodyTag)  ||  elTag.equals(  htmlTag))  {  [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      int  counter  =  0;  Element  elToClose  =  null;  for  (int  i  =  stack.size()  -1;  i  >  0;  i--)  {  counter++;  Element  el  =  stack.get(i);  Tag  elTag  =  el.tag();  [BUGGY]  if(  titleTag.equals  (  bodyTag  )||  elTag.equals  (  htmlTag  )){  break;  }  else  if  (elTag.equals(tag))  {  elToClose  =  el;  break;  }  }  if  (elToClose  !=  null)  {  for  (int  i  =  0;  i  <  counter;  i++)  {  stack.removeLast();  }  }  return  elToClose;  }        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
if  (  elTag.equals  (  bodyTag  )  ||  elTag.equals  (  htmlTag  )  )  {	[BUGGY]  if  (  elToCloseTag.equals(  bodyTag)  ||  elTag.equals(  htmlTag))  {  [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      int  counter  =  0;  Element  elToClose  =  null;  for  (int  i  =  stack.size()  -1;  i  >  0;  i--)  {  counter++;  Element  el  =  stack.get(i);  Tag  elTag  =  el.tag();  [BUGGY]  if(  elToCloseTag.equals  (  bodyTag  )||  elTag.equals  (  htmlTag  )){  break;  }  else  if  (elTag.equals(tag))  {  elToClose  =  el;  break;  }  }  if  (elToClose  !=  null)  {  for  (int  i  =  0;  i  <  counter;  i++)  {  stack.removeLast();  }  }  return  elToClose;  }        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
if  (  elTag.equals  (  bodyTag  )  ||  elTag.equals  (  htmlTag  )  )  {	[BUGGY]  if  (  elTag.equals(  parentTag)  ||  elTag.equals(  htmlTag))  {  [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      int  counter  =  0;  Element  elToClose  =  null;  for  (int  i  =  stack.size()  -1;  i  >  0;  i--)  {  counter++;  Element  el  =  stack.get(i);  Tag  elTag  =  el.tag();  [BUGGY]  if(  elTag.equals  (  parentTag  )||  elTag.equals  (  htmlTag  )){  break;  }  else  if  (elTag.equals(tag))  {  elToClose  =  el;  break;  }  }  if  (elToClose  !=  null)  {  for  (int  i  =  0;  i  <  counter;  i++)  {  stack.removeLast();  }  }  return  elToClose;  }        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
if  (  elTag.equals  (  bodyTag  )  ||  elTag.equals  (  htmlTag  )  )  {	[BUGGY]  if  (  elTag.equals(  bodyTag)  ||  elTag.equals(  tag))  {  [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      int  counter  =  0;  Element  elToClose  =  null;  for  (int  i  =  stack.size()  -1;  i  >  0;  i--)  {  counter++;  Element  el  =  stack.get(i);  Tag  elTag  =  el.tag();  [BUGGY]  if(  elTag.equals  (  bodyTag  )||  elTag.equals  (  tag  )){  break;  }  else  if  (elTag.equals(tag))  {  elToClose  =  el;  break;  }  }  if  (elToClose  !=  null)  {  for  (int  i  =  0;  i  <  counter;  i++)  {  stack.removeLast();  }  }  return  elToClose;  }        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
if  (  elTag.equals  (  bodyTag  )  ||  elTag.equals  (  htmlTag  )  )  {	[BUGGY]  if  (  bodyTagTag.equals(  el)  ||  elTag.equals(  htmlTag))  {  [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      int  counter  =  0;  Element  elToClose  =  null;  for  (int  i  =  stack.size()  -1;  i  >  0;  i--)  {  counter++;  Element  el  =  stack.get(i);  Tag  elTag  =  el.tag();  [BUGGY]  if(  bodyTagTag.equals  (  el  )||  elTag.equals  (  htmlTag  )){  break;  }  else  if  (elTag.equals(tag))  {  elToClose  =  el;  break;  }  }  if  (elToClose  !=  null)  {  for  (int  i  =  0;  i  <  counter;  i++)  {  stack.removeLast();  }  }  return  elToClose;  }        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
if  (  elTag.equals  (  bodyTag  )  ||  elTag.equals  (  htmlTag  )  )  {	[BUGGY]  if  (  elTag.equals(  htmlTag)  ||  elTag.equals(  bodyTag))  {  [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      int  counter  =  0;  Element  elToClose  =  null;  for  (int  i  =  stack.size()  -1;  i  >  0;  i--)  {  counter++;  Element  el  =  stack.get(i);  Tag  elTag  =  el.tag();  [BUGGY]  if(  elTag.equals  (  htmlTag  )||  elTag.equals  (  bodyTag  )){  break;  }  else  if  (elTag.equals(tag))  {  elToClose  =  el;  break;  }  }  if  (elToClose  !=  null)  {  for  (int  i  =  0;  i  <  counter;  i++)  {  stack.removeLast();  }  }  return  elToClose;  }        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
if  (  elTag.equals  (  bodyTag  )  ||  elTag.equals  (  htmlTag  )  )  {	[BUGGY]  if  (  elTag.equals(  bodyTag)){  [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      int  counter  =  0;  Element  elToClose  =  null;  for  (int  i  =  stack.size()  -1;  i  >  0;  i--)  {  counter++;  Element  el  =  stack.get(i);  Tag  elTag  =  el.tag();  [BUGGY]  if(  elTag.equals  (  bodyTag  ))  {  break;  }  else  if  (elTag.equals(tag))  {  elToClose  =  el;  break;  }  }  if  (elToClose  !=  null)  {  for  (int  i  =  0;  i  <  counter;  i++)  {  stack.removeLast();  }  }  return  elToClose;  }        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
if  (  elTag.equals  (  bodyTag  )  ||  elTag.equals  (  htmlTag  )  )  {	[BUGGY]  if  (    elTag.equals(  htmlTag))  {  [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      int  counter  =  0;  Element  elToClose  =  null;  for  (int  i  =  stack.size()  -1;  i  >  0;  i--)  {  counter++;  Element  el  =  stack.get(i);  Tag  elTag  =  el.tag();  [BUGGY]  if(elTag.equals  (  htmlTag  )){  break;  }  else  if  (elTag.equals(tag))  {  elToClose  =  el;  break;  }  }  if  (elToClose  !=  null)  {  for  (int  i  =  0;  i  <  counter;  i++)  {  stack.removeLast();  }  }  return  elToClose;  }        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
if  (  elTag.equals  (  bodyTag  )  ||  elTag.equals  (  htmlTag  )  )  {	[BUGGY]  if  (  elTag.isValidParent(  bodyTag)  ||  elTag.equals(  htmlTag))  {  [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      int  counter  =  0;  Element  elToClose  =  null;  for  (int  i  =  stack.size()  -1;  i  >  0;  i--)  {  counter++;  Element  el  =  stack.get(i);  Tag  elTag  =  el.tag();  [BUGGY]  if(  elTag.isValidParent  (  bodyTag  )||  elTag.equals  (  htmlTag  )){  break;  }  else  if  (elTag.equals(tag))  {  elToClose  =  el;  break;  }  }  if  (elToClose  !=  null)  {  for  (int  i  =  0;  i  <  counter;  i++)  {  stack.removeLast();  }  }  return  elToClose;  }        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
if  (  elTag.equals  (  bodyTag  )  ||  elTag.equals  (  htmlTag  )  )  {  break;  }  else  if  (  elTag.equals  (  tag  )  )  {  elToClose  =  el;  break;  }	[BUGGY]  break;  [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      int  counter  =  0;  Element  elToClose  =  null;  for  (int  i  =  stack.size()  -1;  i  >  0;  i--)  {  counter++;  Element  el  =  stack.get(i);  Tag  elTag  =  el.tag();  [BUGGY]  if  (elTag.equals(bodyTag)  ||  elTag.equals(htmlTag))  {  //  once  in  body,  don't  close  past  body    break;        }  }  if  (elToClose  !=  null)  {  for  (int  i  =  0;  i  <  counter;  i++)  {  stack.removeLast();  }  }  return  elToClose;        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
if  (  elTag.equals  (  bodyTag  )  ||  elTag.equals  (  htmlTag  )  )  {  break;  }  else  if  (  elTag.equals  (  tag  )  )  {  elToClose  =  el;  break;  }	[BUGGY]    [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      int  counter  =  0;  Element  elToClose  =  null;  for  (int  i  =  stack.size()  -1;  i  >  0;  i--)  {  counter++;  Element  el  =  stack.get(i);  Tag  elTag  =  el.tag();  [BUGGY]  if  (elTag.equals(bodyTag)  ||  elTag.equals(htmlTag))  {  //  once  in  body,  don't  close  past  body            }  }  if  (elToClose  !=  null)  {  for  (int  i  =  0;  i  <  counter;  i++)  {  stack.removeLast();  }  }  return  elToClose;        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
}  else  if  (  elTag.equals  (  tag  )  )  {	[BUGGY]    else  if  (  tag.equals(  tag))  {  [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      int  counter  =  0;  Element  elToClose  =  null;  for  (int  i  =  stack.size()  -1;  i  >  0;  i--)  {  counter++;  Element  el  =  stack.get(i);  Tag  elTag  =  el.tag();  if  (elTag.equals(bodyTag)  ||  elTag.equals(htmlTag))  {  //  once  in  body,  don't  close  past  body  break;  [BUGGY]  }  else  if(  tag.equals  (  tag  )){  elToClose  =  el;  break;  }  }  if  (elToClose  !=  null)  {  for  (int  i  =  0;  i  <  counter;  i++)  {  stack.removeLast();  }  }  return  elToClose;  }        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
}  else  if  (  elTag.equals  (  tag  )  )  {	[BUGGY]    else  if  (  elTag.equals(  parentTag))  {  [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      int  counter  =  0;  Element  elToClose  =  null;  for  (int  i  =  stack.size()  -1;  i  >  0;  i--)  {  counter++;  Element  el  =  stack.get(i);  Tag  elTag  =  el.tag();  if  (elTag.equals(bodyTag)  ||  elTag.equals(htmlTag))  {  //  once  in  body,  don't  close  past  body  break;  [BUGGY]  }  else  if(  elTag.equals  (  parentTag  )){  elToClose  =  el;  break;  }  }  if  (elToClose  !=  null)  {  for  (int  i  =  0;  i  <  counter;  i++)  {  stack.removeLast();  }  }  return  elToClose;  }        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
}  else  if  (  elTag.equals  (  tag  )  )  {	[BUGGY]    elToClosese  if  (  elTag.equals(  tag))  {  [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      int  counter  =  0;  Element  elToClose  =  null;  for  (int  i  =  stack.size()  -1;  i  >  0;  i--)  {  counter++;  Element  el  =  stack.get(i);  Tag  elTag  =  el.tag();  if  (elTag.equals(bodyTag)  ||  elTag.equals(htmlTag))  {  //  once  in  body,  don't  close  past  body  break;  [BUGGY]  }  elToClosese  if(  elTag.equals  (  tag  )){  elToClose  =  el;  break;  }  }  if  (elToClose  !=  null)  {  for  (int  i  =  0;  i  <  counter;  i++)  {  stack.removeLast();  }  }  return  elToClose;  }        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
}  else  if  (  elTag.equals  (  tag  )  )  {	[BUGGY]    elTagse  if  (  el.equals(  tag))  {  [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      int  counter  =  0;  Element  elToClose  =  null;  for  (int  i  =  stack.size()  -1;  i  >  0;  i--)  {  counter++;  Element  el  =  stack.get(i);  Tag  elTag  =  el.tag();  if  (elTag.equals(bodyTag)  ||  elTag.equals(htmlTag))  {  //  once  in  body,  don't  close  past  body  break;  [BUGGY]  }  elTagse  if(  el.equals  (  tag  )){  elToClose  =  el;  break;  }  }  if  (elToClose  !=  null)  {  for  (int  i  =  0;  i  <  counter;  i++)  {  stack.removeLast();  }  }  return  elToClose;  }        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
}  else  if  (  elTag.equals  (  tag  )  )  {	[BUGGY]    else  if  (  tag.equals(  elTag))  {  [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      int  counter  =  0;  Element  elToClose  =  null;  for  (int  i  =  stack.size()  -1;  i  >  0;  i--)  {  counter++;  Element  el  =  stack.get(i);  Tag  elTag  =  el.tag();  if  (elTag.equals(bodyTag)  ||  elTag.equals(htmlTag))  {  //  once  in  body,  don't  close  past  body  break;  [BUGGY]  }  else  if(  tag.equals  (  elTag  )){  elToClose  =  el;  break;  }  }  if  (elToClose  !=  null)  {  for  (int  i  =  0;  i  <  counter;  i++)  {  stack.removeLast();  }  }  return  elToClose;  }        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
}  else  if  (  elTag.equals  (  tag  )  )  {	[BUGGY]    else  {  [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      int  counter  =  0;  Element  elToClose  =  null;  for  (int  i  =  stack.size()  -1;  i  >  0;  i--)  {  counter++;  Element  el  =  stack.get(i);  Tag  elTag  =  el.tag();  if  (elTag.equals(bodyTag)  ||  elTag.equals(htmlTag))  {  //  once  in  body,  don't  close  past  body  break;  [BUGGY]  }  else  {  elToClose  =  el;  break;  }  }  if  (elToClose  !=  null)  {  for  (int  i  =  0;  i  <  counter;  i++)  {  stack.removeLast();  }  }  return  elToClose;  }        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
}  else  if  (  elTag.equals  (  tag  )  )  {	[BUGGY]    else  if  (  tq.matches(   "< "))  {  [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      int  counter  =  0;  Element  elToClose  =  null;  for  (int  i  =  stack.size()  -1;  i  >  0;  i--)  {  counter++;  Element  el  =  stack.get(i);  Tag  elTag  =  el.tag();  if  (elTag.equals(bodyTag)  ||  elTag.equals(htmlTag))  {  //  once  in  body,  don't  close  past  body  break;  [BUGGY]  }  else  if(  tq.matches  (   "< "  )){  elToClose  =  el;  break;  }  }  if  (elToClose  !=  null)  {  for  (int  i  =  0;  i  <  counter;  i++)  {  stack.removeLast();  }  }  return  elToClose;  }        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
}  else  if  (  elTag.equals  (  tag  )  )  {  elToClose  =  el;  break;  }	[BUGGY]  elToClose  =  el;  break;  [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      int  counter  =  0;  Element  elToClose  =  null;  for  (int  i  =  stack.size()  -1;  i  >  0;  i--)  {  counter++;  Element  el  =  stack.get(i);  Tag  elTag  =  el.tag();  if  (elTag.equals(bodyTag)  ||  elTag.equals(htmlTag))  {  //  once  in  body,  don't  close  past  body  break;  [BUGGY]  }  else  if  (elTag.equals(tag))  {    elToClose  =  el;  break;      }  if  (elToClose  !=  null)  {  for  (int  i  =  0;  i  <  counter;  i++)  {  stack.removeLast();  }  }  return  elToClose;        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
}  else  if  (  elTag.equals  (  tag  )  )  {  elToClose  =  el;  break;  }	[BUGGY]    [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      int  counter  =  0;  Element  elToClose  =  null;  for  (int  i  =  stack.size()  -1;  i  >  0;  i--)  {  counter++;  Element  el  =  stack.get(i);  Tag  elTag  =  el.tag();  if  (elTag.equals(bodyTag)  ||  elTag.equals(htmlTag))  {  //  once  in  body,  don't  close  past  body  break;  [BUGGY]  }  else  if  (elTag.equals(tag))  {          }  if  (elToClose  !=  null)  {  for  (int  i  =  0;  i  <  counter;  i++)  {  stack.removeLast();  }  }  return  elToClose;        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
elToClose  =  el;	[BUGGY]  elToClose  =  elToClose;  [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      int  counter  =  0;  Element  elToClose  =  null;  for  (int  i  =  stack.size()  -1;  i  >  0;  i--)  {  counter++;  Element  el  =  stack.get(i);  Tag  elTag  =  el.tag();  if  (elTag.equals(bodyTag)  ||  elTag.equals(htmlTag))  {  //  once  in  body,  don't  close  past  body  break;  }  else  if  (elTag.equals(tag))  {  [BUGGY]  elToClose  =  elToClose;  break;  }  }  if  (elToClose  !=  null)  {  for  (int  i  =  0;  i  <  counter;  i++)  {  stack.removeLast();  }  }  return  elToClose;  }        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
elToClose  =  el;	[BUGGY]  elToClose  =    null;  [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      int  counter  =  0;  Element  elToClose  =  null;  for  (int  i  =  stack.size()  -1;  i  >  0;  i--)  {  counter++;  Element  el  =  stack.get(i);  Tag  elTag  =  el.tag();  if  (elTag.equals(bodyTag)  ||  elTag.equals(htmlTag))  {  //  once  in  body,  don't  close  past  body  break;  }  else  if  (elTag.equals(tag))  {  [BUGGY]  elToClose  =null;  break;  }  }  if  (elToClose  !=  null)  {  for  (int  i  =  0;  i  <  counter;  i++)  {  stack.removeLast();  }  }  return  elToClose;  }        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
}  else  if  (  elTag.equals  (  tag  )  )  {	[BUGGY]    else  if  (  titleTag.equals(  tag))  {  [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      int  counter  =  0;  Element  elToClose  =  null;  for  (int  i  =  stack.size()  -1;  i  >  0;  i--)  {  counter++;  Element  el  =  stack.get(i);  Tag  elTag  =  el.tag();  if  (elTag.equals(bodyTag)  ||  elTag.equals(htmlTag))  {  //  once  in  body,  don't  close  past  body  break;  [BUGGY]  }  else  if(  titleTag.equals  (  tag  )){  elToClose  =  el;  break;  }  }  if  (elToClose  !=  null)  {  for  (int  i  =  0;  i  <  counter;  i++)  {  stack.removeLast();  }  }  return  elToClose;  }        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
}  else  if  (  elTag.equals  (  tag  )  )  {	[BUGGY]    else  if  (  elTag.equals(  titleTag))  {  [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      int  counter  =  0;  Element  elToClose  =  null;  for  (int  i  =  stack.size()  -1;  i  >  0;  i--)  {  counter++;  Element  el  =  stack.get(i);  Tag  elTag  =  el.tag();  if  (elTag.equals(bodyTag)  ||  elTag.equals(htmlTag))  {  //  once  in  body,  don't  close  past  body  break;  [BUGGY]  }  else  if(  elTag.equals  (  titleTag  )){  elToClose  =  el;  break;  }  }  if  (elToClose  !=  null)  {  for  (int  i  =  0;  i  <  counter;  i++)  {  stack.removeLast();  }  }  return  elToClose;  }        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
}  else  if  (  elTag.equals  (  tag  )  )  {	[BUGGY]    tagse  if  (  elTag.equals(  el))  {  [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      int  counter  =  0;  Element  elToClose  =  null;  for  (int  i  =  stack.size()  -1;  i  >  0;  i--)  {  counter++;  Element  el  =  stack.get(i);  Tag  elTag  =  el.tag();  if  (elTag.equals(bodyTag)  ||  elTag.equals(htmlTag))  {  //  once  in  body,  don't  close  past  body  break;  [BUGGY]  }  tagse  if(  elTag.equals  (  el  )){  elToClose  =  el;  break;  }  }  if  (elToClose  !=  null)  {  for  (int  i  =  0;  i  <  counter;  i++)  {  stack.removeLast();  }  }  return  elToClose;  }        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
}  else  if  (  elTag.equals  (  tag  )  )  {	[BUGGY]    else  if  (  textareaTag.equals(  tag))  {  [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      int  counter  =  0;  Element  elToClose  =  null;  for  (int  i  =  stack.size()  -1;  i  >  0;  i--)  {  counter++;  Element  el  =  stack.get(i);  Tag  elTag  =  el.tag();  if  (elTag.equals(bodyTag)  ||  elTag.equals(htmlTag))  {  //  once  in  body,  don't  close  past  body  break;  [BUGGY]  }  else  if(  textareaTag.equals  (  tag  )){  elToClose  =  el;  break;  }  }  if  (elToClose  !=  null)  {  for  (int  i  =  0;  i  <  counter;  i++)  {  stack.removeLast();  }  }  return  elToClose;  }        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
for  (  int  i  =  stack.size  (  )  -1;  i  >  0;  i--  )  {	[BUGGY]  for  (    long    i  =  stack.size(  )  -1;  i  >  0;  i--)  {  [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      int  counter  =  0;  Element  elToClose  =  null;  [BUGGY]  for(longi  =  stack.size  ()-1;  i  >  0;  i--  ){  counter++;  Element  el  =  stack.get(i);  Tag  elTag  =  el.tag();  if  (elTag.equals(bodyTag)  ||  elTag.equals(htmlTag))  {  //  once  in  body,  don't  close  past  body  break;  }  else  if  (elTag.equals(tag))  {  elToClose  =  el;  break;  }  }  if  (elToClose  !=  null)  {  for  (int  i  =  0;  i  <  counter;  i++)  {  stack.removeLast();  }  }  return  elToClose;  }        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
for  (  int  i  =  stack.size  (  )  -1;  i  >  0;  i--  )  {	[BUGGY]  for  (  int  i  =  stack.size(  )  -1;  i  <  0;  i--)  {  [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      int  counter  =  0;  Element  elToClose  =  null;  [BUGGY]  for(  int  i  =  stack.size  ()-1;  i  <  0;  i--  ){  counter++;  Element  el  =  stack.get(i);  Tag  elTag  =  el.tag();  if  (elTag.equals(bodyTag)  ||  elTag.equals(htmlTag))  {  //  once  in  body,  don't  close  past  body  break;  }  else  if  (elTag.equals(tag))  {  elToClose  =  el;  break;  }  }  if  (elToClose  !=  null)  {  for  (int  i  =  0;  i  <  counter;  i++)  {  stack.removeLast();  }  }  return  elToClose;  }        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
for  (  int  i  =  stack.size  (  )  -1;  i  >  0;  i--  )  {	[BUGGY]  for  (  int  i  =  stack.size(  )  -6;  i  >  0;  i--)  {  [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      int  counter  =  0;  Element  elToClose  =  null;  [BUGGY]  for(  int  i  =  stack.size  ()-6;  i  >  0;  i--  ){  counter++;  Element  el  =  stack.get(i);  Tag  elTag  =  el.tag();  if  (elTag.equals(bodyTag)  ||  elTag.equals(htmlTag))  {  //  once  in  body,  don't  close  past  body  break;  }  else  if  (elTag.equals(tag))  {  elToClose  =  el;  break;  }  }  if  (elToClose  !=  null)  {  for  (int  i  =  0;  i  <  counter;  i++)  {  stack.removeLast();  }  }  return  elToClose;  }        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
for  (  int  i  =  stack.size  (  )  -1;  i  >  0;  i--  )  {	[BUGGY]  for  (  int  i  =  stack.size(  )  -1;  i  >  counter;  i--)  {  [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      int  counter  =  0;  Element  elToClose  =  null;  [BUGGY]  for(  int  i  =  stack.size  ()-1;  i  >  counter;  i--  ){  counter++;  Element  el  =  stack.get(i);  Tag  elTag  =  el.tag();  if  (elTag.equals(bodyTag)  ||  elTag.equals(htmlTag))  {  //  once  in  body,  don't  close  past  body  break;  }  else  if  (elTag.equals(tag))  {  elToClose  =  el;  break;  }  }  if  (elToClose  !=  null)  {  for  (int  i  =  0;  i  <  counter;  i++)  {  stack.removeLast();  }  }  return  elToClose;  }        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
for  (  int  i  =  stack.size  (  )  -1;  i  >  0;  i--  )  {	[BUGGY]  for  (  int  i  =  stack.size()  +  4    -1;  i  >  0;  i--)  {  [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      int  counter  =  0;  Element  elToClose  =  null;  [BUGGY]  for(  int  i  =  stack.size()  +  4-1;  i  >  0;  i--  ){  counter++;  Element  el  =  stack.get(i);  Tag  elTag  =  el.tag();  if  (elTag.equals(bodyTag)  ||  elTag.equals(htmlTag))  {  //  once  in  body,  don't  close  past  body  break;  }  else  if  (elTag.equals(tag))  {  elToClose  =  el;  break;  }  }  if  (elToClose  !=  null)  {  for  (int  i  =  0;  i  <  counter;  i++)  {  stack.removeLast();  }  }  return  elToClose;  }        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
for  (  int  i  =  stack.size  (  )  -1;  i  >  0;  i--  )  {	[BUGGY]  for  (  counternt  i  =  stack.size(  )  -1;  i  >  0;  i--)  {  [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      int  counter  =  0;  Element  elToClose  =  null;  [BUGGY]  for(  counternt  i  =  stack.size  ()-1;  i  >  0;  i--  ){  counter++;  Element  el  =  stack.get(i);  Tag  elTag  =  el.tag();  if  (elTag.equals(bodyTag)  ||  elTag.equals(htmlTag))  {  //  once  in  body,  don't  close  past  body  break;  }  else  if  (elTag.equals(tag))  {  elToClose  =  el;  break;  }  }  if  (elToClose  !=  null)  {  for  (int  i  =  0;  i  <  counter;  i++)  {  stack.removeLast();  }  }  return  elToClose;  }        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
for  (  int  i  =  stack.size  (  )  -1;  i  >  0;  i--  )  {	[BUGGY]  for  (  int  i  =  stack.add(  )  -1;  i  >  0;  i--)  {  [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      int  counter  =  0;  Element  elToClose  =  null;  [BUGGY]  for(  int  i  =  stack.add  ()-1;  i  >  0;  i--  ){  counter++;  Element  el  =  stack.get(i);  Tag  elTag  =  el.tag();  if  (elTag.equals(bodyTag)  ||  elTag.equals(htmlTag))  {  //  once  in  body,  don't  close  past  body  break;  }  else  if  (elTag.equals(tag))  {  elToClose  =  el;  break;  }  }  if  (elToClose  !=  null)  {  for  (int  i  =  0;  i  <  counter;  i++)  {  stack.removeLast();  }  }  return  elToClose;  }        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
if  (  elTag.equals  (  bodyTag  )  ||  elTag.equals  (  htmlTag  )  )  {	[BUGGY]  if  (  elTag.equals(  titleTag)  ||  elTag.equals(  htmlTag))  {  [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      int  counter  =  0;  Element  elToClose  =  null;  for  (int  i  =  stack.size()  -1;  i  >  0;  i--)  {  counter++;  Element  el  =  stack.get(i);  Tag  elTag  =  el.tag();  [BUGGY]  if(  elTag.equals  (  titleTag  )||  elTag.equals  (  htmlTag  )){  break;  }  else  if  (elTag.equals(tag))  {  elToClose  =  el;  break;  }  }  if  (elToClose  !=  null)  {  for  (int  i  =  0;  i  <  counter;  i++)  {  stack.removeLast();  }  }  return  elToClose;  }        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
if  (  elTag.equals  (  bodyTag  )  ||  elTag.equals  (  htmlTag  )  )  {	[BUGGY]  if  (  elTag.equals(  bodyTag)  ||  elTag.equals(  parentTag))  {  [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      int  counter  =  0;  Element  elToClose  =  null;  for  (int  i  =  stack.size()  -1;  i  >  0;  i--)  {  counter++;  Element  el  =  stack.get(i);  Tag  elTag  =  el.tag();  [BUGGY]  if(  elTag.equals  (  bodyTag  )||  elTag.equals  (  parentTag  )){  break;  }  else  if  (elTag.equals(tag))  {  elToClose  =  el;  break;  }  }  if  (elToClose  !=  null)  {  for  (int  i  =  0;  i  <  counter;  i++)  {  stack.removeLast();  }  }  return  elToClose;  }        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
if  (  elTag.equals  (  bodyTag  )  ||  elTag.equals  (  htmlTag  )  )  {	[BUGGY]  if  (  htmlTag.equals(  bodyTag)  ||  elTag.equals(  elTag))  {  [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      int  counter  =  0;  Element  elToClose  =  null;  for  (int  i  =  stack.size()  -1;  i  >  0;  i--)  {  counter++;  Element  el  =  stack.get(i);  Tag  elTag  =  el.tag();  [BUGGY]  if(  htmlTag.equals  (  bodyTag  )||  elTag.equals  (  elTag  )){  break;  }  else  if  (elTag.equals(tag))  {  elToClose  =  el;  break;  }  }  if  (elToClose  !=  null)  {  for  (int  i  =  0;  i  <  counter;  i++)  {  stack.removeLast();  }  }  return  elToClose;  }        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
if  (  elTag.equals  (  bodyTag  )  ||  elTag.equals  (  htmlTag  )  )  {	[BUGGY]  if  (  elTagTag.equals(  bodyTag)  ||  el.equals(  htmlTag))  {  [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      int  counter  =  0;  Element  elToClose  =  null;  for  (int  i  =  stack.size()  -1;  i  >  0;  i--)  {  counter++;  Element  el  =  stack.get(i);  Tag  elTag  =  el.tag();  [BUGGY]  if(  elTagTag.equals  (  bodyTag  )||  el.equals  (  htmlTag  )){  break;  }  else  if  (elTag.equals(tag))  {  elToClose  =  el;  break;  }  }  if  (elToClose  !=  null)  {  for  (int  i  =  0;  i  <  counter;  i++)  {  stack.removeLast();  }  }  return  elToClose;  }        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
if  (  elTag.equals  (  bodyTag  )  ||  elTag.equals  (  htmlTag  )  )  {	[BUGGY]  if  (  elTag  .equals(  baseUri)    ||  elTag  [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      int  counter  =  0;  Element  elToClose  =  null;  for  (int  i  =  stack.size()  -1;  i  >  0;  i--)  {  counter++;  Element  el  =  stack.get(i);  Tag  elTag  =  el.tag();  [BUGGY]  if(  elTag  .equals  (  baseUri  )  ||  elTag  break;  }  else  if  (elTag.equals(tag))  {  elToClose  =  el;  break;  }  }  if  (elToClose  !=  null)  {  for  (int  i  =  0;  i  <  counter;  i++)  {  stack.removeLast();  }  }  return  elToClose;  }        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
}  else  if  (  elTag.equals  (  tag  )  )  {	[BUGGY]    else  if  (  parentTag.equals(  tag))  {  [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      int  counter  =  0;  Element  elToClose  =  null;  for  (int  i  =  stack.size()  -1;  i  >  0;  i--)  {  counter++;  Element  el  =  stack.get(i);  Tag  elTag  =  el.tag();  if  (elTag.equals(bodyTag)  ||  elTag.equals(htmlTag))  {  //  once  in  body,  don't  close  past  body  break;  [BUGGY]  }  else  if(  parentTag.equals  (  tag  )){  elToClose  =  el;  break;  }  }  if  (elToClose  !=  null)  {  for  (int  i  =  0;  i  <  counter;  i++)  {  stack.removeLast();  }  }  return  elToClose;  }        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
}  else  if  (  elTag.equals  (  tag  )  )  {	[BUGGY]    else  if  (  elTag  .equals(  data)  )  {  [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      int  counter  =  0;  Element  elToClose  =  null;  for  (int  i  =  stack.size()  -1;  i  >  0;  i--)  {  counter++;  Element  el  =  stack.get(i);  Tag  elTag  =  el.tag();  if  (elTag.equals(bodyTag)  ||  elTag.equals(htmlTag))  {  //  once  in  body,  don't  close  past  body  break;  [BUGGY]  }  else  if(  elTag  .equals  (  data  )  ){  elToClose  =  el;  break;  }  }  if  (elToClose  !=  null)  {  for  (int  i  =  0;  i  <  counter;  i++)  {  stack.removeLast();  }  }  return  elToClose;  }        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
}  else  if  (  elTag.equals  (  tag  )  )  {	[BUGGY]    else  if  (  elTag.equals(  parent2))  {  [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      int  counter  =  0;  Element  elToClose  =  null;  for  (int  i  =  stack.size()  -1;  i  >  0;  i--)  {  counter++;  Element  el  =  stack.get(i);  Tag  elTag  =  el.tag();  if  (elTag.equals(bodyTag)  ||  elTag.equals(htmlTag))  {  //  once  in  body,  don't  close  past  body  break;  [BUGGY]  }  else  if(  elTag.equals  (  parent2  )){  elToClose  =  el;  break;  }  }  if  (elToClose  !=  null)  {  for  (int  i  =  0;  i  <  counter;  i++)  {  stack.removeLast();  }  }  return  elToClose;  }        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
}  else  if  (  elTag.equals  (  tag  )  )  {	[BUGGY]    else  if  (  elTag  .equals(  text)  )  {  [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      int  counter  =  0;  Element  elToClose  =  null;  for  (int  i  =  stack.size()  -1;  i  >  0;  i--)  {  counter++;  Element  el  =  stack.get(i);  Tag  elTag  =  el.tag();  if  (elTag.equals(bodyTag)  ||  elTag.equals(htmlTag))  {  //  once  in  body,  don't  close  past  body  break;  [BUGGY]  }  else  if(  elTag  .equals  (  text  )  ){  elToClose  =  el;  break;  }  }  if  (elToClose  !=  null)  {  for  (int  i  =  0;  i  <  counter;  i++)  {  stack.removeLast();  }  }  return  elToClose;  }        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
Element  el  =  stack.get  (  i  )  ;	[BUGGY]  Element  el  =  stack.get(  counter);  [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      int  counter  =  0;  Element  elToClose  =  null;  for  (int  i  =  stack.size()  -1;  i  >  0;  i--)  {  counter++;  [BUGGY]  Element  el  =  stack.get  (  counter  )  ;  Tag  elTag  =  el.tag();  if  (elTag.equals(bodyTag)  ||  elTag.equals(htmlTag))  {  //  once  in  body,  don't  close  past  body  break;  }  else  if  (elTag.equals(tag))  {  elToClose  =  el;  break;  }  }  if  (elToClose  !=  null)  {  for  (int  i  =  0;  i  <  counter;  i++)  {  stack.removeLast();  }  }  return  elToClose;  }        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
Element  el  =  stack.get  (  i  )  ;	[BUGGY]  Element  el  =  i.get(  stack);  [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      int  counter  =  0;  Element  elToClose  =  null;  for  (int  i  =  stack.size()  -1;  i  >  0;  i--)  {  counter++;  [BUGGY]  Element  el  =  i.get  (  stack  )  ;  Tag  elTag  =  el.tag();  if  (elTag.equals(bodyTag)  ||  elTag.equals(htmlTag))  {  //  once  in  body,  don't  close  past  body  break;  }  else  if  (elTag.equals(tag))  {  elToClose  =  el;  break;  }  }  if  (elToClose  !=  null)  {  for  (int  i  =  0;  i  <  counter;  i++)  {  stack.removeLast();  }  }  return  elToClose;  }        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
Element  el  =  stack.get  (  i  )  ;	[BUGGY]  Element  el  =  stack.add(  i);  [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      int  counter  =  0;  Element  elToClose  =  null;  for  (int  i  =  stack.size()  -1;  i  >  0;  i--)  {  counter++;  [BUGGY]  Element  el  =  stack.add  (  i  )  ;  Tag  elTag  =  el.tag();  if  (elTag.equals(bodyTag)  ||  elTag.equals(htmlTag))  {  //  once  in  body,  don't  close  past  body  break;  }  else  if  (elTag.equals(tag))  {  elToClose  =  el;  break;  }  }  if  (elToClose  !=  null)  {  for  (int  i  =  0;  i  <  counter;  i++)  {  stack.removeLast();  }  }  return  elToClose;  }        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
Element  el  =  stack.get  (  i  )  ;	[BUGGY]  Element  el  =  stack.add(  counter);  [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      int  counter  =  0;  Element  elToClose  =  null;  for  (int  i  =  stack.size()  -1;  i  >  0;  i--)  {  counter++;  [BUGGY]  Element  el  =  stack.add  (  counter  )  ;  Tag  elTag  =  el.tag();  if  (elTag.equals(bodyTag)  ||  elTag.equals(htmlTag))  {  //  once  in  body,  don't  close  past  body  break;  }  else  if  (elTag.equals(tag))  {  elToClose  =  el;  break;  }  }  if  (elToClose  !=  null)  {  for  (int  i  =  0;  i  <  counter;  i++)  {  stack.removeLast();  }  }  return  elToClose;  }        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
Element  el  =  stack.get  (  i  )  ;  Tag  elTag  =  el.tag  (  )  ;	[BUGGY]  Tag  elTag  =  el.tag(  );  Element  el  =  stack.get(  i);  [CONTEXT]        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
Element  el  =  stack.get  (  i  )  ;  Tag  elTag  =  el.tag  (  )  ;	[BUGGY]  Element  el  =  stack.get(  i);Element  el  =  stack.get(  i);  Tag  elTag  =  el.tag(  );  [CONTEXT]        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
Tag  elTag  =  el.tag  (  )  ;	[BUGGY]  Tag  elToCloseTag  =  el.tag(  );  [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      int  counter  =  0;  Element  elToClose  =  null;  for  (int  i  =  stack.size()  -1;  i  >  0;  i--)  {  counter++;  Element  el  =  stack.get(i);  [BUGGY]  Tag  elToCloseTag  =  el.tag  ()  ;  if  (elTag.equals(bodyTag)  ||  elTag.equals(htmlTag))  {  //  once  in  body,  don't  close  past  body  break;  }  else  if  (elTag.equals(tag))  {  elToClose  =  el;  break;  }  }  if  (elToClose  !=  null)  {  for  (int  i  =  0;  i  <  counter;  i++)  {  stack.removeLast();  }  }  return  elToClose;  }        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
Tag  elTag  =  el.tag  (  )  ;	[BUGGY]  Tag  elTag  =  el.absUrl(  );  [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      int  counter  =  0;  Element  elToClose  =  null;  for  (int  i  =  stack.size()  -1;  i  >  0;  i--)  {  counter++;  Element  el  =  stack.get(i);  [BUGGY]  Tag  elTag  =  el.absUrl  ()  ;  if  (elTag.equals(bodyTag)  ||  elTag.equals(htmlTag))  {  //  once  in  body,  don't  close  past  body  break;  }  else  if  (elTag.equals(tag))  {  elToClose  =  el;  break;  }  }  if  (elToClose  !=  null)  {  for  (int  i  =  0;  i  <  counter;  i++)  {  stack.removeLast();  }  }  return  elToClose;  }        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
Element  el  =  stack.get  (  i  )  ;	[BUGGY]  Element  el  =  stack  .getLast(  )  ;  [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      int  counter  =  0;  Element  elToClose  =  null;  for  (int  i  =  stack.size()  -1;  i  >  0;  i--)  {  counter++;  [BUGGY]  Element  el  =  stack  .getLast  ();  Tag  elTag  =  el.tag();  if  (elTag.equals(bodyTag)  ||  elTag.equals(htmlTag))  {  //  once  in  body,  don't  close  past  body  break;  }  else  if  (elTag.equals(tag))  {  elToClose  =  el;  break;  }  }  if  (elToClose  !=  null)  {  for  (int  i  =  0;  i  <  counter;  i++)  {  stack.removeLast();  }  }  return  elToClose;  }        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
Element  el  =  stack.get  (  i  )  ;  Tag  elTag  =  el.tag  (  )  ;	[BUGGY]    [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      int  counter  =  0;  Element  elToClose  =  null;  for  (int  i  =  stack.size()  -1;  i  >  0;  i--)  {  counter++;  [BUGGY]  Element  el  =  stack.get(i);      if  (elTag.equals(bodyTag)  ||  elTag.equals(htmlTag))  {  //  once  in  body,  don't  close  past  body  break;  }  else  if  (elTag.equals(tag))  {  elToClose  =  el;  break;  }  }  if  (elToClose  !=  null)  {  for  (int  i  =  0;  i  <  counter;  i++)  {  stack.removeLast();  }  }  return  elToClose;        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
Tag  elTag  =  el.tag  (  )  ;	[BUGGY]  Tag  elTag  =  el  .tagName(  )  ;  [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      int  counter  =  0;  Element  elToClose  =  null;  for  (int  i  =  stack.size()  -1;  i  >  0;  i--)  {  counter++;  Element  el  =  stack.get(i);  [BUGGY]  Tag  elTag  =  el  .tagName  ();  if  (elTag.equals(bodyTag)  ||  elTag.equals(htmlTag))  {  //  once  in  body,  don't  close  past  body  break;  }  else  if  (elTag.equals(tag))  {  elToClose  =  el;  break;  }  }  if  (elToClose  !=  null)  {  for  (int  i  =  0;  i  <  counter;  i++)  {  stack.removeLast();  }  }  return  elToClose;  }        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
Tag  elTag  =  el.tag  (  )  ;	[BUGGY]  Tag  elToCloseTag  =  el.absUrl(  );  [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      int  counter  =  0;  Element  elToClose  =  null;  for  (int  i  =  stack.size()  -1;  i  >  0;  i--)  {  counter++;  Element  el  =  stack.get(i);  [BUGGY]  Tag  elToCloseTag  =  el.absUrl  ()  ;  if  (elTag.equals(bodyTag)  ||  elTag.equals(htmlTag))  {  //  once  in  body,  don't  close  past  body  break;  }  else  if  (elTag.equals(tag))  {  elToClose  =  el;  break;  }  }  if  (elToClose  !=  null)  {  for  (int  i  =  0;  i  <  counter;  i++)  {  stack.removeLast();  }  }  return  elToClose;  }        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
Tag  elTag  =  el.tag  (  )  ;	[BUGGY]    [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      int  counter  =  0;  Element  elToClose  =  null;  for  (int  i  =  stack.size()  -1;  i  >  0;  i--)  {  counter++;  Element  el  =  stack.get(i);  [BUGGY]  Tag  elTag  =  el.tag();    if  (elTag.equals(bodyTag)  ||  elTag.equals(htmlTag))  {  //  once  in  body,  don't  close  past  body  break;  }  else  if  (elTag.equals(tag))  {  elToClose  =  el;  break;  }  }  if  (elToClose  !=  null)  {  for  (int  i  =  0;  i  <  counter;  i++)  {  stack.removeLast();  }  }  return  elToClose;        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
if  (  elTag.equals  (  bodyTag  )  ||  elTag.equals  (  htmlTag  )  )  {	[BUGGY]  if  (  elTag.equals(  tag)  ||  elTag.equals(  htmlTag))  {  [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      int  counter  =  0;  Element  elToClose  =  null;  for  (int  i  =  stack.size()  -1;  i  >  0;  i--)  {  counter++;  Element  el  =  stack.get(i);  Tag  elTag  =  el.tag();  [BUGGY]  if(  elTag.equals  (  tag  )||  elTag.equals  (  htmlTag  )){  break;  }  else  if  (elTag.equals(tag))  {  elToClose  =  el;  break;  }  }  if  (elToClose  !=  null)  {  for  (int  i  =  0;  i  <  counter;  i++)  {  stack.removeLast();  }  }  return  elToClose;  }        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
if  (  elTag.equals  (  bodyTag  )  ||  elTag.equals  (  htmlTag  )  )  {	[BUGGY]  if  (  bodyTag.equals(  elTag)  ||  elTag.equals(  htmlTag))  {  [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      int  counter  =  0;  Element  elToClose  =  null;  for  (int  i  =  stack.size()  -1;  i  >  0;  i--)  {  counter++;  Element  el  =  stack.get(i);  Tag  elTag  =  el.tag();  [BUGGY]  if(  bodyTag.equals  (  elTag  )||  elTag.equals  (  htmlTag  )){  break;  }  else  if  (elTag.equals(tag))  {  elToClose  =  el;  break;  }  }  if  (elToClose  !=  null)  {  for  (int  i  =  0;  i  <  counter;  i++)  {  stack.removeLast();  }  }  return  elToClose;  }        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
if  (  elTag.equals  (  bodyTag  )  ||  elTag.equals  (  htmlTag  )  )  {	[BUGGY]  if  (  elTag.isValidParent(  tag)  ||  elTag.equals(  htmlTag))  {  [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      int  counter  =  0;  Element  elToClose  =  null;  for  (int  i  =  stack.size()  -1;  i  >  0;  i--)  {  counter++;  Element  el  =  stack.get(i);  Tag  elTag  =  el.tag();  [BUGGY]  if(  elTag.isValidParent  (  tag  )||  elTag.equals  (  htmlTag  )){  break;  }  else  if  (elTag.equals(tag))  {  elToClose  =  el;  break;  }  }  if  (elToClose  !=  null)  {  for  (int  i  =  0;  i  <  counter;  i++)  {  stack.removeLast();  }  }  return  elToClose;  }        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
if  (  elTag.equals  (  bodyTag  )  ||  elTag.equals  (  htmlTag  )  )  {	[BUGGY]  if  (  elTag.equals(  bodyTag)  ||  elTag.equals(  titleTag))  {  [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      int  counter  =  0;  Element  elToClose  =  null;  for  (int  i  =  stack.size()  -1;  i  >  0;  i--)  {  counter++;  Element  el  =  stack.get(i);  Tag  elTag  =  el.tag();  [BUGGY]  if(  elTag.equals  (  bodyTag  )||  elTag.equals  (  titleTag  )){  break;  }  else  if  (elTag.equals(tag))  {  elToClose  =  el;  break;  }  }  if  (elToClose  !=  null)  {  for  (int  i  =  0;  i  <  counter;  i++)  {  stack.removeLast();  }  }  return  elToClose;  }        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
if  (  elTag.equals  (  bodyTag  )  ||  elTag.equals  (  htmlTag  )  )  {	[BUGGY]  if  (  tag.equals(  bodyTag)  ||  elTag.equals(  htmlTag))  {  [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      int  counter  =  0;  Element  elToClose  =  null;  for  (int  i  =  stack.size()  -1;  i  >  0;  i--)  {  counter++;  Element  el  =  stack.get(i);  Tag  elTag  =  el.tag();  [BUGGY]  if(  tag.equals  (  bodyTag  )||  elTag.equals  (  htmlTag  )){  break;  }  else  if  (elTag.equals(tag))  {  elToClose  =  el;  break;  }  }  if  (elToClose  !=  null)  {  for  (int  i  =  0;  i  <  counter;  i++)  {  stack.removeLast();  }  }  return  elToClose;  }        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
}  else  if  (  elTag.equals  (  tag  )  )  {	[BUGGY]    else  if  (  elTag.equals(  textareaTag))  {  [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      int  counter  =  0;  Element  elToClose  =  null;  for  (int  i  =  stack.size()  -1;  i  >  0;  i--)  {  counter++;  Element  el  =  stack.get(i);  Tag  elTag  =  el.tag();  if  (elTag.equals(bodyTag)  ||  elTag.equals(htmlTag))  {  //  once  in  body,  don't  close  past  body  break;  [BUGGY]  }  else  if(  elTag.equals  (  textareaTag  )){  elToClose  =  el;  break;  }  }  if  (elToClose  !=  null)  {  for  (int  i  =  0;  i  <  counter;  i++)  {  stack.removeLast();  }  }  return  elToClose;  }        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
elToClose  =  el;  break;	[BUGGY]  break;  elToClose  =  el;  [CONTEXT]        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
elToClose  =  el;  break;	[BUGGY]  elToClose  =  el;elToClose  =  el;  break;  [CONTEXT]        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
for  (  int  i  =  stack.size  (  )  -1;  i  >  0;  i--  )  {	[BUGGY]  for  (    short    i  =  stack.size(  )  -1;  i  >  0;  i--)  {  [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      int  counter  =  0;  Element  elToClose  =  null;  [BUGGY]  for(shorti  =  stack.size  ()-1;  i  >  0;  i--  ){  counter++;  Element  el  =  stack.get(i);  Tag  elTag  =  el.tag();  if  (elTag.equals(bodyTag)  ||  elTag.equals(htmlTag))  {  //  once  in  body,  don't  close  past  body  break;  }  else  if  (elTag.equals(tag))  {  elToClose  =  el;  break;  }  }  if  (elToClose  !=  null)  {  for  (int  i  =  0;  i  <  counter;  i++)  {  stack.removeLast();  }  }  return  elToClose;  }        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
for  (  int  i  =  stack.size  (  )  -1;  i  >  0;  i--  )  {	[BUGGY]  for  (  int  i  =  stack.size(  )  -7;  i  >  0;  i--)  {  [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      int  counter  =  0;  Element  elToClose  =  null;  [BUGGY]  for(  int  i  =  stack.size  ()-7;  i  >  0;  i--  ){  counter++;  Element  el  =  stack.get(i);  Tag  elTag  =  el.tag();  if  (elTag.equals(bodyTag)  ||  elTag.equals(htmlTag))  {  //  once  in  body,  don't  close  past  body  break;  }  else  if  (elTag.equals(tag))  {  elToClose  =  el;  break;  }  }  if  (elToClose  !=  null)  {  for  (int  i  =  0;  i  <  counter;  i++)  {  stack.removeLast();  }  }  return  elToClose;  }        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
for  (  int  i  =  stack.size  (  )  -1;  i  >  0;  i--  )  {	[BUGGY]  for  (  int  i  =  stack.size()  -  1    -1;  i  >  0;  i--)  {  [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      int  counter  =  0;  Element  elToClose  =  null;  [BUGGY]  for(  int  i  =  stack.size()  -  1-1;  i  >  0;  i--  ){  counter++;  Element  el  =  stack.get(i);  Tag  elTag  =  el.tag();  if  (elTag.equals(bodyTag)  ||  elTag.equals(htmlTag))  {  //  once  in  body,  don't  close  past  body  break;  }  else  if  (elTag.equals(tag))  {  elToClose  =  el;  break;  }  }  if  (elToClose  !=  null)  {  for  (int  i  =  0;  i  <  counter;  i++)  {  stack.removeLast();  }  }  return  elToClose;  }        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
for  (  int  i  =  stack.size  (  )  -1;  i  >  0;  i--  )  {	[BUGGY]  for  (  int  i  =  stack.size()  +  0    -1;  i  >  0;  i--)  {  [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      int  counter  =  0;  Element  elToClose  =  null;  [BUGGY]  for(  int  i  =  stack.size()  +  0-1;  i  >  0;  i--  ){  counter++;  Element  el  =  stack.get(i);  Tag  elTag  =  el.tag();  if  (elTag.equals(bodyTag)  ||  elTag.equals(htmlTag))  {  //  once  in  body,  don't  close  past  body  break;  }  else  if  (elTag.equals(tag))  {  elToClose  =  el;  break;  }  }  if  (elToClose  !=  null)  {  for  (int  i  =  0;  i  <  counter;  i++)  {  stack.removeLast();  }  }  return  elToClose;  }        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
for  (  int  i  =  stack.size  (  )  -1;  i  >  0;  i--  )  {	[BUGGY]  for  (  int  i  =  null.size(  )  -1;  i  >  0;  i--)  {  [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      int  counter  =  0;  Element  elToClose  =  null;  [BUGGY]  for(  int  i  =  null.size  ()-1;  i  >  0;  i--  ){  counter++;  Element  el  =  stack.get(i);  Tag  elTag  =  el.tag();  if  (elTag.equals(bodyTag)  ||  elTag.equals(htmlTag))  {  //  once  in  body,  don't  close  past  body  break;  }  else  if  (elTag.equals(tag))  {  elToClose  =  el;  break;  }  }  if  (elToClose  !=  null)  {  for  (int  i  =  0;  i  <  counter;  i++)  {  stack.removeLast();  }  }  return  elToClose;  }        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
for  (  int  i  =  stack.size  (  )  -1;  i  >  0;  i--  )  {	[BUGGY]  for  (  int  i  =  stack  .isEmpty(  )    -1;  i  >  0;  i--)  {  [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      int  counter  =  0;  Element  elToClose  =  null;  [BUGGY]  for(  int  i  =  stack  .isEmpty  ()  -1;  i  >  0;  i--  ){  counter++;  Element  el  =  stack.get(i);  Tag  elTag  =  el.tag();  if  (elTag.equals(bodyTag)  ||  elTag.equals(htmlTag))  {  //  once  in  body,  don't  close  past  body  break;  }  else  if  (elTag.equals(tag))  {  elToClose  =  el;  break;  }  }  if  (elToClose  !=  null)  {  for  (int  i  =  0;  i  <  counter;  i++)  {  stack.removeLast();  }  }  return  elToClose;  }        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
if  (  elTag.equals  (  bodyTag  )  ||  elTag.equals  (  htmlTag  )  )  {	[BUGGY]  if  (  titleTag.isValidParent(  bodyTag)  ||  elTag.equals(  htmlTag))  {  [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      int  counter  =  0;  Element  elToClose  =  null;  for  (int  i  =  stack.size()  -1;  i  >  0;  i--)  {  counter++;  Element  el  =  stack.get(i);  Tag  elTag  =  el.tag();  [BUGGY]  if(  titleTag.isValidParent  (  bodyTag  )||  elTag.equals  (  htmlTag  )){  break;  }  else  if  (elTag.equals(tag))  {  elToClose  =  el;  break;  }  }  if  (elToClose  !=  null)  {  for  (int  i  =  0;  i  <  counter;  i++)  {  stack.removeLast();  }  }  return  elToClose;  }        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
}  else  if  (  elTag.equals  (  tag  )  )  {	[BUGGY]    else  if  (  elTag  .equals(  rawText)  )  {  [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      int  counter  =  0;  Element  elToClose  =  null;  for  (int  i  =  stack.size()  -1;  i  >  0;  i--)  {  counter++;  Element  el  =  stack.get(i);  Tag  elTag  =  el.tag();  if  (elTag.equals(bodyTag)  ||  elTag.equals(htmlTag))  {  //  once  in  body,  don't  close  past  body  break;  [BUGGY]  }  else  if(  elTag  .equals  (  rawText  )  ){  elToClose  =  el;  break;  }  }  if  (elToClose  !=  null)  {  for  (int  i  =  0;  i  <  counter;  i++)  {  stack.removeLast();  }  }  return  elToClose;  }        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
if  (  elToClose  !=  null  )  {	[BUGGY]  if  (  elToClose  ==  null)  {  [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      int  counter  =  0;  Element  elToClose  =  null;  for  (int  i  =  stack.size()  -1;  i  >  0;  i--)  {  counter++;  Element  el  =  stack.get(i);  Tag  elTag  =  el.tag();  if  (elTag.equals(bodyTag)  ||  elTag.equals(htmlTag))  {  //  once  in  body,  don't  close  past  body  break;  }  else  if  (elTag.equals(tag))  {  elToClose  =  el;  break;  }  }  [BUGGY]  if(  elToClose  ==  null  ){  for  (int  i  =  0;  i  <  counter;  i++)  {  stack.removeLast();  }  }  return  elToClose;  }        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
if  (  elToClose  !=  null  )  {	[BUGGY]  if  (  el  !=  null)  {  [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      int  counter  =  0;  Element  elToClose  =  null;  for  (int  i  =  stack.size()  -1;  i  >  0;  i--)  {  counter++;  Element  el  =  stack.get(i);  Tag  elTag  =  el.tag();  if  (elTag.equals(bodyTag)  ||  elTag.equals(htmlTag))  {  //  once  in  body,  don't  close  past  body  break;  }  else  if  (elTag.equals(tag))  {  elToClose  =  el;  break;  }  }  [BUGGY]  if(  el  !=  null  ){  for  (int  i  =  0;  i  <  counter;  i++)  {  stack.removeLast();  }  }  return  elToClose;  }        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
if  (  elToClose  !=  null  )  {	[BUGGY]  if  (  i  <  counter)  {  [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      int  counter  =  0;  Element  elToClose  =  null;  for  (int  i  =  stack.size()  -1;  i  >  0;  i--)  {  counter++;  Element  el  =  stack.get(i);  Tag  elTag  =  el.tag();  if  (elTag.equals(bodyTag)  ||  elTag.equals(htmlTag))  {  //  once  in  body,  don't  close  past  body  break;  }  else  if  (elTag.equals(tag))  {  elToClose  =  el;  break;  }  }  [BUGGY]  if(  i  <  counter  ){  for  (int  i  =  0;  i  <  counter;  i++)  {  stack.removeLast();  }  }  return  elToClose;  }        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
if  (  elToClose  !=  null  )  {	[BUGGY]  if  (  el  !=  false)  {  [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      int  counter  =  0;  Element  elToClose  =  null;  for  (int  i  =  stack.size()  -1;  i  >  0;  i--)  {  counter++;  Element  el  =  stack.get(i);  Tag  elTag  =  el.tag();  if  (elTag.equals(bodyTag)  ||  elTag.equals(htmlTag))  {  //  once  in  body,  don't  close  past  body  break;  }  else  if  (elTag.equals(tag))  {  elToClose  =  el;  break;  }  }  [BUGGY]  if(  el  !=  false  ){  for  (int  i  =  0;  i  <  counter;  i++)  {  stack.removeLast();  }  }  return  elToClose;  }        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
if  (  elToClose  !=  null  )  {  for  (  int  i  =  0;  i  <  counter;  i++  )  {  stack.removeLast  (  )  ;  }	[BUGGY]  for(int  i  =  0;  i  <  counter;  i++)  {        stack.removeLast();};  [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      int  counter  =  0;  Element  elToClose  =  null;  for  (int  i  =  stack.size()  -1;  i  >  0;  i--)  {  counter++;  Element  el  =  stack.get(i);  Tag  elTag  =  el.tag();  if  (elTag.equals(bodyTag)  ||  elTag.equals(htmlTag))  {  //  once  in  body,  don't  close  past  body  break;  }  else  if  (elTag.equals(tag))  {  elToClose  =  el;  break;  }  }  [BUGGY]  if  (elToClose  !=  null)  {    for  (int  i  =  0;  i  <  counter;  i++)  {stack.removeLast();};      }  return  elToClose;        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
if  (  elToClose  !=  null  )  {  for  (  int  i  =  0;  i  <  counter;  i++  )  {  stack.removeLast  (  )  ;  }	[BUGGY]    [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      int  counter  =  0;  Element  elToClose  =  null;  for  (int  i  =  stack.size()  -1;  i  >  0;  i--)  {  counter++;  Element  el  =  stack.get(i);  Tag  elTag  =  el.tag();  if  (elTag.equals(bodyTag)  ||  elTag.equals(htmlTag))  {  //  once  in  body,  don't  close  past  body  break;  }  else  if  (elTag.equals(tag))  {  elToClose  =  el;  break;  }  }  [BUGGY]  if  (elToClose  !=  null)  {          }  return  elToClose;        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
for  (  int  i  =  0;  i  <  counter;  i++  )  {	[BUGGY]  for  (    short    i  =  0;  i  <  counter;  i++)  {  [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      int  counter  =  0;  Element  elToClose  =  null;  for  (int  i  =  stack.size()  -1;  i  >  0;  i--)  {  counter++;  Element  el  =  stack.get(i);  Tag  elTag  =  el.tag();  if  (elTag.equals(bodyTag)  ||  elTag.equals(htmlTag))  {  //  once  in  body,  don't  close  past  body  break;  }  else  if  (elTag.equals(tag))  {  elToClose  =  el;  break;  }  }  if  (elToClose  !=  null)  {  [BUGGY]  for(shorti  =  0;  i  <  counter;  i++  ){  stack.removeLast();  }  }  return  elToClose;  }        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
for  (  int  i  =  0;  i  <  counter;  i++  )  {	[BUGGY]  for  (  int  i  =  0;  i  <=  counter;  i++)  {  [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      int  counter  =  0;  Element  elToClose  =  null;  for  (int  i  =  stack.size()  -1;  i  >  0;  i--)  {  counter++;  Element  el  =  stack.get(i);  Tag  elTag  =  el.tag();  if  (elTag.equals(bodyTag)  ||  elTag.equals(htmlTag))  {  //  once  in  body,  don't  close  past  body  break;  }  else  if  (elTag.equals(tag))  {  elToClose  =  el;  break;  }  }  if  (elToClose  !=  null)  {  [BUGGY]  for(  int  i  =  0;  i  <=  counter;  i++  ){  stack.removeLast();  }  }  return  elToClose;  }        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
for  (  int  i  =  0;  i  <  counter;  i++  )  {	[BUGGY]  for  (  int  i  =  counter;  i  <  counter;  i++)  {  [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      int  counter  =  0;  Element  elToClose  =  null;  for  (int  i  =  stack.size()  -1;  i  >  0;  i--)  {  counter++;  Element  el  =  stack.get(i);  Tag  elTag  =  el.tag();  if  (elTag.equals(bodyTag)  ||  elTag.equals(htmlTag))  {  //  once  in  body,  don't  close  past  body  break;  }  else  if  (elTag.equals(tag))  {  elToClose  =  el;  break;  }  }  if  (elToClose  !=  null)  {  [BUGGY]  for(  int  i  =  counter;  i  <  counter;  i++  ){  stack.removeLast();  }  }  return  elToClose;  }        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
for  (  int  i  =  0;  i  <  counter;  i++  )  {	[BUGGY]  for  (  counternt  i  =  0;  i  <  counter;  i++)  {  [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      int  counter  =  0;  Element  elToClose  =  null;  for  (int  i  =  stack.size()  -1;  i  >  0;  i--)  {  counter++;  Element  el  =  stack.get(i);  Tag  elTag  =  el.tag();  if  (elTag.equals(bodyTag)  ||  elTag.equals(htmlTag))  {  //  once  in  body,  don't  close  past  body  break;  }  else  if  (elTag.equals(tag))  {  elToClose  =  el;  break;  }  }  if  (elToClose  !=  null)  {  [BUGGY]  for(  counternt  i  =  0;  i  <  counter;  i++  ){  stack.removeLast();  }  }  return  elToClose;  }        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
for  (  int  i  =  0;  i  <  counter;  i++  )  {	[BUGGY]  for  (  counternt  i  =  0;  i  <  i;  i++)  {  [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      int  counter  =  0;  Element  elToClose  =  null;  for  (int  i  =  stack.size()  -1;  i  >  0;  i--)  {  counter++;  Element  el  =  stack.get(i);  Tag  elTag  =  el.tag();  if  (elTag.equals(bodyTag)  ||  elTag.equals(htmlTag))  {  //  once  in  body,  don't  close  past  body  break;  }  else  if  (elTag.equals(tag))  {  elToClose  =  el;  break;  }  }  if  (elToClose  !=  null)  {  [BUGGY]  for(  counternt  i  =  0;  i  <  i;  i++  ){  stack.removeLast();  }  }  return  elToClose;  }        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
[Delete]	[BUGGY]  if  (  elToClose  !=  null)  {          for  (  int  i  =  0;  i  <  counter;  i++)  {                  stack.removeLast(  );          }  }  [CONTEXT]        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
stack.removeLast  (  )  ;	[BUGGY]  stack.getLast(  );  [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      int  counter  =  0;  Element  elToClose  =  null;  for  (int  i  =  stack.size()  -1;  i  >  0;  i--)  {  counter++;  Element  el  =  stack.get(i);  Tag  elTag  =  el.tag();  if  (elTag.equals(bodyTag)  ||  elTag.equals(htmlTag))  {  //  once  in  body,  don't  close  past  body  break;  }  else  if  (elTag.equals(tag))  {  elToClose  =  el;  break;  }  }  if  (elToClose  !=  null)  {  for  (int  i  =  0;  i  <  counter;  i++)  {  [BUGGY]  stack.getLast  ()  ;  }  }  return  elToClose;  }        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
stack.removeLast  (  )  ;	[BUGGY]    [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      int  counter  =  0;  Element  elToClose  =  null;  for  (int  i  =  stack.size()  -1;  i  >  0;  i--)  {  counter++;  Element  el  =  stack.get(i);  Tag  elTag  =  el.tag();  if  (elTag.equals(bodyTag)  ||  elTag.equals(htmlTag))  {  //  once  in  body,  don't  close  past  body  break;  }  else  if  (elTag.equals(tag))  {  elToClose  =  el;  break;  }  }  if  (elToClose  !=  null)  {  for  (int  i  =  0;  i  <  counter;  i++)  {  [BUGGY]  stack.removeLast();    }  }  return  elToClose;        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
for  (  int  i  =  0;  i  <  counter;  i++  )  {	[BUGGY]  for  (  int  i  =  7;  i  <  counter;  i++)  {  [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      int  counter  =  0;  Element  elToClose  =  null;  for  (int  i  =  stack.size()  -1;  i  >  0;  i--)  {  counter++;  Element  el  =  stack.get(i);  Tag  elTag  =  el.tag();  if  (elTag.equals(bodyTag)  ||  elTag.equals(htmlTag))  {  //  once  in  body,  don't  close  past  body  break;  }  else  if  (elTag.equals(tag))  {  elToClose  =  el;  break;  }  }  if  (elToClose  !=  null)  {  [BUGGY]  for(  int  i  =  7;  i  <  counter;  i++  ){  stack.removeLast();  }  }  return  elToClose;  }        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
for  (  int  i  =  0;  i  <  counter;  i++  )  {	[BUGGY]  for  (    long    i  =  0;  i  <  counter;  i++)  {  [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      int  counter  =  0;  Element  elToClose  =  null;  for  (int  i  =  stack.size()  -1;  i  >  0;  i--)  {  counter++;  Element  el  =  stack.get(i);  Tag  elTag  =  el.tag();  if  (elTag.equals(bodyTag)  ||  elTag.equals(htmlTag))  {  //  once  in  body,  don't  close  past  body  break;  }  else  if  (elTag.equals(tag))  {  elToClose  =  el;  break;  }  }  if  (elToClose  !=  null)  {  [BUGGY]  for(longi  =  0;  i  <  counter;  i++  ){  stack.removeLast();  }  }  return  elToClose;  }        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
for  (  int  i  =  0;  i  <  counter;  i++  )  {	[BUGGY]  for  (  int  i  =  -1;  i  <  counter;  i++)  {  [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      int  counter  =  0;  Element  elToClose  =  null;  for  (int  i  =  stack.size()  -1;  i  >  0;  i--)  {  counter++;  Element  el  =  stack.get(i);  Tag  elTag  =  el.tag();  if  (elTag.equals(bodyTag)  ||  elTag.equals(htmlTag))  {  //  once  in  body,  don't  close  past  body  break;  }  else  if  (elTag.equals(tag))  {  elToClose  =  el;  break;  }  }  if  (elToClose  !=  null)  {  [BUGGY]  for(  int  i  =  -1;  i  <  counter;  i++  ){  stack.removeLast();  }  }  return  elToClose;  }        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
return  elToClose;	[BUGGY]  return  el;  [CONTEXT]  private  Element  popStackToClose(Tag  tag)  {      int  counter  =  0;  Element  elToClose  =  null;  for  (int  i  =  stack.size()  -1;  i  >  0;  i--)  {  counter++;  Element  el  =  stack.get(i);  Tag  elTag  =  el.tag();  if  (elTag.equals(bodyTag)  ||  elTag.equals(htmlTag))  {  //  once  in  body,  don't  close  past  body  break;  }  else  if  (elTag.equals(tag))  {  elToClose  =  el;  break;  }  }  if  (elToClose  !=  null)  {  for  (int  i  =  0;  i  <  counter;  i++)  {  stack.removeLast();  }  }  [BUGGY]  return  el;  }        [CLASS]  Parser    [METHOD]  popStackToClose  [RETURN_TYPE]  Element      Tag  tag  [VARIABLES]  TokenQueue    tq    boolean    Element    el    elToClose    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    Document    doc    LinkedList    stack    int    counter    i    
return  stack.getLast  (  )  ;	[BUGGY]  return  stack.removeLast(  );  [CONTEXT]  private  Element  last()  {  [BUGGY]  return  stack.removeLast  ()  ;  }        [CLASS]  Parser    [METHOD]  last  [RETURN_TYPE]  Element      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
return  stack.getLast  (  )  ;	[BUGGY]    [CONTEXT]  private  Element  last()  {  [BUGGY]  return  stack.getLast();          [CLASS]  Parser    [METHOD]  last  [RETURN_TYPE]  Element      [VARIABLES]  TokenQueue    tq    String    DQ    SQ    baseUri    bodyHtml    data    href    html    key    rawText    tagName    text    value    Tag    bodyTag    childTag    elTag    headTag    htmlTag    parent2    parentTag    tag    textareaTag    titleTag    boolean    Document    doc    LinkedList    stack    
Validate.notNull  (  data  )  ;	[BUGGY]    [CONTEXT]  public  TokenQueue(String  data)  {  [BUGGY]  Validate.notNull(data);      queue  =  new  LinkedList<Character>();  char[]  chars  =  data.toCharArray();  for  (char  c  :  chars)  {  queue.add(c);  }        [CLASS]  TokenQueue    [METHOD]  <init>  [RETURN_TYPE]  String)      String  data  [VARIABLES]  char    c    String    data    boolean    LinkedList    queue    char[]    chars    
queue  =  new  LinkedList<Character>  (  )  ;	[BUGGY]  queue    =    queue  ;  [CONTEXT]  public  TokenQueue(String  data)  {  Validate.notNull(data);    [BUGGY]  queue=queue  ;  char[]  chars  =  data.toCharArray();  for  (char  c  :  chars)  {  queue.add(c);  }  }        [CLASS]  TokenQueue    [METHOD]  <init>  [RETURN_TYPE]  String)      String  data  [VARIABLES]  char    c    String    data    boolean    LinkedList    queue    char[]    chars    
char[]  chars  =  data.toCharArray  (  )  ;	[BUGGY]    [CONTEXT]  public  TokenQueue(String  data)  {  Validate.notNull(data);    queue  =  new  LinkedList<Character>();  [BUGGY]  char[]  chars  =  data.toCharArray();    for  (char  c  :  chars)  {  queue.add(c);  }        [CLASS]  TokenQueue    [METHOD]  <init>  [RETURN_TYPE]  String)      String  data  [VARIABLES]  char    c    String    data    boolean    LinkedList    queue    char[]    chars    
for  (  char  c  :  chars  )  {	[BUGGY]  for  (  int  c  :  chars)  {  [CONTEXT]  public  TokenQueue(String  data)  {  Validate.notNull(data);    queue  =  new  LinkedList<Character>();  char[]  chars  =  data.toCharArray();  [BUGGY]  for(  int  c  :  chars  ){  queue.add(c);  }  }        [CLASS]  TokenQueue    [METHOD]  <init>  [RETURN_TYPE]  String)      String  data  [VARIABLES]  char    c    String    data    boolean    LinkedList    queue    char[]    chars    
queue.add  (  c  )  ;	[BUGGY]  queue.addFirst(  c);  [CONTEXT]  public  TokenQueue(String  data)  {  Validate.notNull(data);    queue  =  new  LinkedList<Character>();  char[]  chars  =  data.toCharArray();  for  (char  c  :  chars)  {  [BUGGY]  queue.addFirst  (  c  )  ;  }  }        [CLASS]  TokenQueue    [METHOD]  <init>  [RETURN_TYPE]  String)      String  data  [VARIABLES]  char    c    String    data    boolean    LinkedList    queue    char[]    chars    
queue.add  (  c  )  ;	[BUGGY]    [CONTEXT]  public  TokenQueue(String  data)  {  Validate.notNull(data);    queue  =  new  LinkedList<Character>();  char[]  chars  =  data.toCharArray();  for  (char  c  :  chars)  {  [BUGGY]  queue.add(c);    }        [CLASS]  TokenQueue    [METHOD]  <init>  [RETURN_TYPE]  String)      String  data  [VARIABLES]  char    c    String    data    boolean    LinkedList    queue    char[]    chars    
return  queue.isEmpty  (  )  ;	[BUGGY]  return  queue.peek(  );  [CONTEXT]  public  boolean  isEmpty()  {  [BUGGY]  return  queue.peek  ()  ;  }        [CLASS]  TokenQueue    [METHOD]  isEmpty  [RETURN_TYPE]  boolean      [VARIABLES]  LinkedList    queue    boolean    
return  queue.isEmpty  (  )  ;	[BUGGY]    [CONTEXT]  public  boolean  isEmpty()  {  [BUGGY]  return  queue.isEmpty();          [CLASS]  TokenQueue    [METHOD]  isEmpty  [RETURN_TYPE]  boolean      [VARIABLES]  LinkedList    queue    boolean    
return  queue.peek  (  )  ;	[BUGGY]  return  queue.size(  );  [CONTEXT]  public  Character  peek()  {  [BUGGY]  return  queue.size  ()  ;  }        [CLASS]  TokenQueue    [METHOD]  peek  [RETURN_TYPE]  Character      [VARIABLES]  LinkedList    queue    boolean    
return  queue.peek  (  )  ;	[BUGGY]  return  queue  .removeFirst(  )  ;  [CONTEXT]  public  Character  peek()  {  [BUGGY]  return  queue  .removeFirst  ();  }        [CLASS]  TokenQueue    [METHOD]  peek  [RETURN_TYPE]  Character      [VARIABLES]  LinkedList    queue    boolean    
return  queue.peek  (  )  ;	[BUGGY]    [CONTEXT]  public  Character  peek()  {  [BUGGY]  return  queue.peek();          [CLASS]  TokenQueue    [METHOD]  peek  [RETURN_TYPE]  Character      [VARIABLES]  LinkedList    queue    boolean    
queue.addFirst  (  c  )  ;	[BUGGY]  queue.add(  c);  [CONTEXT]  public  void  addFirst(Character  c)  {  [BUGGY]  queue.add  (  c  )  ;  }        [CLASS]  TokenQueue    [METHOD]  addFirst  [RETURN_TYPE]  void      Character  c  [VARIABLES]  Character    c    LinkedList    queue    boolean    
queue.addFirst  (  c  )  ;	[BUGGY]    [CONTEXT]  public  void  addFirst(Character  c)  {  [BUGGY]  queue.addFirst(c);          [CLASS]  TokenQueue    [METHOD]  addFirst  [RETURN_TYPE]  void      Character  c  [VARIABLES]  Character    c    LinkedList    queue    boolean    
char[]  chars  =  seq.toCharArray  (  )  ;	[BUGGY]    [CONTEXT]  public  void  addFirst(String  seq)  {  [BUGGY]  char[]  chars  =  seq.toCharArray();    for  (int  i  =  chars.length  -  1;  i  >=  0;  i--)  {  addFirst(chars[i]);  }        [CLASS]  TokenQueue    [METHOD]  addFirst  [RETURN_TYPE]  void      String  seq  [VARIABLES]  String    seq    boolean    LinkedList    queue    int    i    char[]    chars    
for  (  int  i  =  chars.length  -  1;  i  >=  0;  i--  )  {	[BUGGY]  for  (    long    i  =  chars.length  -  1;  i  >=  0;  i--)  {  [CONTEXT]  public  void  addFirst(String  seq)  {  char[]  chars  =  seq.toCharArray();  [BUGGY]  for(longi  =  chars.length  -  1;  i  >=  0;  i--  ){  addFirst(chars[i]);  }  }        [CLASS]  TokenQueue    [METHOD]  addFirst  [RETURN_TYPE]  void      String  seq  [VARIABLES]  String    seq    boolean    LinkedList    queue    int    i    char[]    chars    
for  (  int  i  =  chars.length  -  1;  i  >=  0;  i--  )  {	[BUGGY]  for  (  int  i  =  chars.length    |    1;  i  >=  0;  i--)  {  [CONTEXT]  public  void  addFirst(String  seq)  {  char[]  chars  =  seq.toCharArray();  [BUGGY]  for(  int  i  =  chars.length|1;  i  >=  0;  i--  ){  addFirst(chars[i]);  }  }        [CLASS]  TokenQueue    [METHOD]  addFirst  [RETURN_TYPE]  void      String  seq  [VARIABLES]  String    seq    boolean    LinkedList    queue    int    i    char[]    chars    
for  (  int  i  =  chars.length  -  1;  i  >=  0;  i--  )  {	[BUGGY]  for  (  int  i  =  chars.length  -  1;  i  ==  0;  i--)  {  [CONTEXT]  public  void  addFirst(String  seq)  {  char[]  chars  =  seq.toCharArray();  [BUGGY]  for(  int  i  =  chars.length  -  1;  i  ==  0;  i--  ){  addFirst(chars[i]);  }  }        [CLASS]  TokenQueue    [METHOD]  addFirst  [RETURN_TYPE]  void      String  seq  [VARIABLES]  String    seq    boolean    LinkedList    queue    int    i    char[]    chars    
for  (  int  i  =  chars.length  -  1;  i  >=  0;  i--  )  {	[BUGGY]  for  (  int  i  =  chars.length  -  i;  i  >=  0;  i--)  {  [CONTEXT]  public  void  addFirst(String  seq)  {  char[]  chars  =  seq.toCharArray();  [BUGGY]  for(  int  i  =  chars.length  -  i;  i  >=  0;  i--  ){  addFirst(chars[i]);  }  }        [CLASS]  TokenQueue    [METHOD]  addFirst  [RETURN_TYPE]  void      String  seq  [VARIABLES]  String    seq    boolean    LinkedList    queue    int    i    char[]    chars    
for  (  int  i  =  chars.length  -  1;  i  >=  0;  i--  )  {	[BUGGY]  for  (  int  i  =  chars.length  -  1;  i  >=  i;  i--)  {  [CONTEXT]  public  void  addFirst(String  seq)  {  char[]  chars  =  seq.toCharArray();  [BUGGY]  for(  int  i  =  chars.length  -  1;  i  >=  i;  i--  ){  addFirst(chars[i]);  }  }        [CLASS]  TokenQueue    [METHOD]  addFirst  [RETURN_TYPE]  void      String  seq  [VARIABLES]  String    seq    boolean    LinkedList    queue    int    i    char[]    chars    
for  (  int  i  =  chars.length  -  1;  i  >=  0;  i--  )  {	[BUGGY]  for  (  charsnt  i  =  i.length  -  1;  i  >=  0;  i--)  {  [CONTEXT]  public  void  addFirst(String  seq)  {  char[]  chars  =  seq.toCharArray();  [BUGGY]  for(  charsnt  i  =  i.length  -  1;  i  >=  0;  i--  ){  addFirst(chars[i]);  }  }        [CLASS]  TokenQueue    [METHOD]  addFirst  [RETURN_TYPE]  void      String  seq  [VARIABLES]  String    seq    boolean    LinkedList    queue    int    i    char[]    chars    
for  (  int  i  =  chars.length  -  1;  i  >=  0;  i--  )  {	[BUGGY]  for  (  chars.lengthnt  i  =  i  -  1;  i  >=  0;  i--)  {  [CONTEXT]  public  void  addFirst(String  seq)  {  char[]  chars  =  seq.toCharArray();  [BUGGY]  for(  chars.lengthnt  i  =  i  -  1;  i  >=  0;  i--  ){  addFirst(chars[i]);  }  }        [CLASS]  TokenQueue    [METHOD]  addFirst  [RETURN_TYPE]  void      String  seq  [VARIABLES]  String    seq    boolean    LinkedList    queue    int    i    char[]    chars    
addFirst  (  chars[i]  )  ;	[BUGGY]    [CONTEXT]  public  void  addFirst(String  seq)  {  char[]  chars  =  seq.toCharArray();  for  (int  i  =  chars.length  -  1;  i  >=  0;  i--)  {  [BUGGY]  addFirst(chars[i]);    }        [CLASS]  TokenQueue    [METHOD]  addFirst  [RETURN_TYPE]  void      String  seq  [VARIABLES]  String    seq    boolean    LinkedList    queue    int    i    char[]    chars    
for  (  int  i  =  chars.length  -  1;  i  >=  0;  i--  )  {	[BUGGY]  for  (  int  i  =  chars.length    &    1;  i  >=  0;  i--)  {  [CONTEXT]  public  void  addFirst(String  seq)  {  char[]  chars  =  seq.toCharArray();  [BUGGY]  for(  int  i  =  chars.length&1;  i  >=  0;  i--  ){  addFirst(chars[i]);  }  }        [CLASS]  TokenQueue    [METHOD]  addFirst  [RETURN_TYPE]  void      String  seq  [VARIABLES]  String    seq    boolean    LinkedList    queue    int    i    char[]    chars    
for  (  int  i  =  chars.length  -  1;  i  >=  0;  i--  )  {	[BUGGY]  for  (  int  i  =  chars.length.length  -  1;  i  >=  0;  i--)  {  [CONTEXT]  public  void  addFirst(String  seq)  {  char[]  chars  =  seq.toCharArray();  [BUGGY]  for(  int  i  =  chars.length.length  -  1;  i  >=  0;  i--  ){  addFirst(chars[i]);  }  }        [CLASS]  TokenQueue    [METHOD]  addFirst  [RETURN_TYPE]  void      String  seq  [VARIABLES]  String    seq    boolean    LinkedList    queue    int    i    char[]    chars    
for  (  int  i  =  chars.length  -  1;  i  >=  0;  i--  )  {	[BUGGY]  for  (  int  i  =  chars  -  1;  i  >=  0;  i--)  {  [CONTEXT]  public  void  addFirst(String  seq)  {  char[]  chars  =  seq.toCharArray();  [BUGGY]  for(  int  i  =  chars  -  1;  i  >=  0;  i--  ){  addFirst(chars[i]);  }  }        [CLASS]  TokenQueue    [METHOD]  addFirst  [RETURN_TYPE]  void      String  seq  [VARIABLES]  String    seq    boolean    LinkedList    queue    int    i    char[]    chars    
int  len  =  seq.length  (  )  ;	[BUGGY]  long    len  =  seq.length(  );  [CONTEXT]  public  boolean  matches(String  seq)  {  [BUGGY]  longlen  =  seq.length  ()  ;  if  (len  >  queue.size())  return  false;  List<Character>  chars  =  queue.subList(0,  len);  char[]  seqChars  =  seq.toCharArray();  for  (int  i  =  0;  i  <  len;  i++)  {  Character  found  =  Character.toLowerCase(chars.get(i));  Character  check  =  Character.toLowerCase(seqChars[i]);  if  (!found.equals(check))  return  false;  }  return  true;  }        [CLASS]  TokenQueue    [METHOD]  matches  [RETURN_TYPE]  boolean      String  seq  [VARIABLES]  boolean    Character    check    found    List    chars    String    seq    LinkedList    queue    int    i    len    char[]    seqChars    
int  len  =  seq.length  (  )  ;	[BUGGY]  int  len  =  seq.length()  -  1  ;  [CONTEXT]  public  boolean  matches(String  seq)  {  [BUGGY]  int  len  =  seq.length()  -  1  ;  if  (len  >  queue.size())  return  false;  List<Character>  chars  =  queue.subList(0,  len);  char[]  seqChars  =  seq.toCharArray();  for  (int  i  =  0;  i  <  len;  i++)  {  Character  found  =  Character.toLowerCase(chars.get(i));  Character  check  =  Character.toLowerCase(seqChars[i]);  if  (!found.equals(check))  return  false;  }  return  true;  }        [CLASS]  TokenQueue    [METHOD]  matches  [RETURN_TYPE]  boolean      String  seq  [VARIABLES]  boolean    Character    check    found    List    chars    String    seq    LinkedList    queue    int    i    len    char[]    seqChars    
int  len  =  seq.length  (  )  ;	[BUGGY]  int  len  =  seq.length()  +  3  ;  [CONTEXT]  public  boolean  matches(String  seq)  {  [BUGGY]  int  len  =  seq.length()  +  3  ;  if  (len  >  queue.size())  return  false;  List<Character>  chars  =  queue.subList(0,  len);  char[]  seqChars  =  seq.toCharArray();  for  (int  i  =  0;  i  <  len;  i++)  {  Character  found  =  Character.toLowerCase(chars.get(i));  Character  check  =  Character.toLowerCase(seqChars[i]);  if  (!found.equals(check))  return  false;  }  return  true;  }        [CLASS]  TokenQueue    [METHOD]  matches  [RETURN_TYPE]  boolean      String  seq  [VARIABLES]  boolean    Character    check    found    List    chars    String    seq    LinkedList    queue    int    i    len    char[]    seqChars    
int  len  =  seq.length  (  )  ;	[BUGGY]    [CONTEXT]  public  boolean  matches(String  seq)  {  [BUGGY]  int  len  =  seq.length();    if  (len  >  queue.size())  return  false;  List<Character>  chars  =  queue.subList(0,  len);  char[]  seqChars  =  seq.toCharArray();  for  (int  i  =  0;  i  <  len;  i++)  {  Character  found  =  Character.toLowerCase(chars.get(i));  Character  check  =  Character.toLowerCase(seqChars[i]);  if  (!found.equals(check))  return  false;  }  return  true;        [CLASS]  TokenQueue    [METHOD]  matches  [RETURN_TYPE]  boolean      String  seq  [VARIABLES]  boolean    Character    check    found    List    chars    String    seq    LinkedList    queue    int    i    len    char[]    seqChars    
if  (  len  >  queue.size  (  )  )  return  false;	[BUGGY]  if  (  len  <  queue.size(  ))return  false;  [CONTEXT]  public  boolean  matches(String  seq)  {  int  len  =  seq.length();  [BUGGY]  if(  len  <  queue.size  ())  return  false;    List<Character>  chars  =  queue.subList(0,  len);  char[]  seqChars  =  seq.toCharArray();  for  (int  i  =  0;  i  <  len;  i++)  {  Character  found  =  Character.toLowerCase(chars.get(i));  Character  check  =  Character.toLowerCase(seqChars[i]);  if  (!found.equals(check))  return  false;  }  return  true;  }        [CLASS]  TokenQueue    [METHOD]  matches  [RETURN_TYPE]  boolean      String  seq  [VARIABLES]  boolean    Character    check    found    List    chars    String    seq    LinkedList    queue    int    i    len    char[]    seqChars    
if  (  len  >  queue.size  (  )  )  return  false;	[BUGGY]  if  (  len  >  queue.size(  ))return  true;  [CONTEXT]  public  boolean  matches(String  seq)  {  int  len  =  seq.length();  [BUGGY]  if(  len  >  queue.size  ())  return  true;    List<Character>  chars  =  queue.subList(0,  len);  char[]  seqChars  =  seq.toCharArray();  for  (int  i  =  0;  i  <  len;  i++)  {  Character  found  =  Character.toLowerCase(chars.get(i));  Character  check  =  Character.toLowerCase(seqChars[i]);  if  (!found.equals(check))  return  false;  }  return  true;  }        [CLASS]  TokenQueue    [METHOD]  matches  [RETURN_TYPE]  boolean      String  seq  [VARIABLES]  boolean    Character    check    found    List    chars    String    seq    LinkedList    queue    int    i    len    char[]    seqChars    
if  (  len  >  queue.size  (  )  )  return  false;	[BUGGY]  if  (  len  >  queue.size()  +  2  )return  false;  [CONTEXT]  public  boolean  matches(String  seq)  {  int  len  =  seq.length();  [BUGGY]  if(  len  >  queue.size()  +  2)  return  false;    List<Character>  chars  =  queue.subList(0,  len);  char[]  seqChars  =  seq.toCharArray();  for  (int  i  =  0;  i  <  len;  i++)  {  Character  found  =  Character.toLowerCase(chars.get(i));  Character  check  =  Character.toLowerCase(seqChars[i]);  if  (!found.equals(check))  return  false;  }  return  true;  }        [CLASS]  TokenQueue    [METHOD]  matches  [RETURN_TYPE]  boolean      String  seq  [VARIABLES]  boolean    Character    check    found    List    chars    String    seq    LinkedList    queue    int    i    len    char[]    seqChars    
if  (  len  >  queue.size  (  )  )  return  false;	[BUGGY]  if  (  i  >  queue.size(  ))return  false;  [CONTEXT]  public  boolean  matches(String  seq)  {  int  len  =  seq.length();  [BUGGY]  if(  i  >  queue.size  ())  return  false;    List<Character>  chars  =  queue.subList(0,  len);  char[]  seqChars  =  seq.toCharArray();  for  (int  i  =  0;  i  <  len;  i++)  {  Character  found  =  Character.toLowerCase(chars.get(i));  Character  check  =  Character.toLowerCase(seqChars[i]);  if  (!found.equals(check))  return  false;  }  return  true;  }        [CLASS]  TokenQueue    [METHOD]  matches  [RETURN_TYPE]  boolean      String  seq  [VARIABLES]  boolean    Character    check    found    List    chars    String    seq    LinkedList    queue    int    i    len    char[]    seqChars    
if  (  len  >  queue.size  (  )  )  return  false;	[BUGGY]  if  (  queue  >  len.size(  ))return  false;  [CONTEXT]  public  boolean  matches(String  seq)  {  int  len  =  seq.length();  [BUGGY]  if(  queue  >  len.size  ())  return  false;    List<Character>  chars  =  queue.subList(0,  len);  char[]  seqChars  =  seq.toCharArray();  for  (int  i  =  0;  i  <  len;  i++)  {  Character  found  =  Character.toLowerCase(chars.get(i));  Character  check  =  Character.toLowerCase(seqChars[i]);  if  (!found.equals(check))  return  false;  }  return  true;  }        [CLASS]  TokenQueue    [METHOD]  matches  [RETURN_TYPE]  boolean      String  seq  [VARIABLES]  boolean    Character    check    found    List    chars    String    seq    LinkedList    queue    int    i    len    char[]    seqChars    
if  (  len  >  queue.size  (  )  )  return  false;	[BUGGY]  if  (  len  >  queue.peek(  ))return  false;  [CONTEXT]  public  boolean  matches(String  seq)  {  int  len  =  seq.length();  [BUGGY]  if(  len  >  queue.peek  ())  return  false;    List<Character>  chars  =  queue.subList(0,  len);  char[]  seqChars  =  seq.toCharArray();  for  (int  i  =  0;  i  <  len;  i++)  {  Character  found  =  Character.toLowerCase(chars.get(i));  Character  check  =  Character.toLowerCase(seqChars[i]);  if  (!found.equals(check))  return  false;  }  return  true;  }        [CLASS]  TokenQueue    [METHOD]  matches  [RETURN_TYPE]  boolean      String  seq  [VARIABLES]  boolean    Character    check    found    List    chars    String    seq    LinkedList    queue    int    i    len    char[]    seqChars    
if  (  len  >  queue.size  (  )  )  return  false;	[BUGGY]  if  (  len  >  queue  .subList(  i  ,  len)  )return  false;  [CONTEXT]  public  boolean  matches(String  seq)  {  int  len  =  seq.length();  [BUGGY]  if(  len  >  queue  .subList  (  i  ,  len  )  )  return  false;    List<Character>  chars  =  queue.subList(0,  len);  char[]  seqChars  =  seq.toCharArray();  for  (int  i  =  0;  i  <  len;  i++)  {  Character  found  =  Character.toLowerCase(chars.get(i));  Character  check  =  Character.toLowerCase(seqChars[i]);  if  (!found.equals(check))  return  false;  }  return  true;  }        [CLASS]  TokenQueue    [METHOD]  matches  [RETURN_TYPE]  boolean      String  seq  [VARIABLES]  boolean    Character    check    found    List    chars    String    seq    LinkedList    queue    int    i    len    char[]    seqChars    
return  false;	[BUGGY]  return  true;  [CONTEXT]  public  boolean  matches(String  seq)  {  int  len  =  seq.length();  if  (len  >  queue.size())  [BUGGY]  return  true;  List<Character>  chars  =  queue.subList(0,  len);  char[]  seqChars  =  seq.toCharArray();  for  (int  i  =  0;  i  <  len;  i++)  {  Character  found  =  Character.toLowerCase(chars.get(i));  Character  check  =  Character.toLowerCase(seqChars[i]);  if  (!found.equals(check))  return  false;  }  return  true;  }        [CLASS]  TokenQueue    [METHOD]  matches  [RETURN_TYPE]  boolean      String  seq  [VARIABLES]  boolean    Character    check    found    List    chars    String    seq    LinkedList    queue    int    i    len    char[]    seqChars    
if  (  len  >  queue.size  (  )  )  return  false;	[BUGGY]  if  (  len  >  queue.size()  -  7  )return  false;  [CONTEXT]  public  boolean  matches(String  seq)  {  int  len  =  seq.length();  [BUGGY]  if(  len  >  queue.size()  -  7)  return  false;    List<Character>  chars  =  queue.subList(0,  len);  char[]  seqChars  =  seq.toCharArray();  for  (int  i  =  0;  i  <  len;  i++)  {  Character  found  =  Character.toLowerCase(chars.get(i));  Character  check  =  Character.toLowerCase(seqChars[i]);  if  (!found.equals(check))  return  false;  }  return  true;  }        [CLASS]  TokenQueue    [METHOD]  matches  [RETURN_TYPE]  boolean      String  seq  [VARIABLES]  boolean    Character    check    found    List    chars    String    seq    LinkedList    queue    int    i    len    char[]    seqChars    
if  (  len  >  queue.size  (  )  )  return  false;	[BUGGY]  if  (  len  >  3.size(  ))return  false;  [CONTEXT]  public  boolean  matches(String  seq)  {  int  len  =  seq.length();  [BUGGY]  if(  len  >  3.size  ())  return  false;    List<Character>  chars  =  queue.subList(0,  len);  char[]  seqChars  =  seq.toCharArray();  for  (int  i  =  0;  i  <  len;  i++)  {  Character  found  =  Character.toLowerCase(chars.get(i));  Character  check  =  Character.toLowerCase(seqChars[i]);  if  (!found.equals(check))  return  false;  }  return  true;  }        [CLASS]  TokenQueue    [METHOD]  matches  [RETURN_TYPE]  boolean      String  seq  [VARIABLES]  boolean    Character    check    found    List    chars    String    seq    LinkedList    queue    int    i    len    char[]    seqChars    
List<Character>  chars  =  queue.subList  (  0,  len  )  ;	[BUGGY]  List<Character>  chars  =  queue.subList(  len,  len);  [CONTEXT]  public  boolean  matches(String  seq)  {  int  len  =  seq.length();  if  (len  >  queue.size())  return  false;  [BUGGY]  List<Character>  chars  =  queue.subList  (  len,  len  )  ;  char[]  seqChars  =  seq.toCharArray();  for  (int  i  =  0;  i  <  len;  i++)  {  Character  found  =  Character.toLowerCase(chars.get(i));  Character  check  =  Character.toLowerCase(seqChars[i]);  if  (!found.equals(check))  return  false;  }  return  true;  }        [CLASS]  TokenQueue    [METHOD]  matches  [RETURN_TYPE]  boolean      String  seq  [VARIABLES]  boolean    Character    check    found    List    chars    String    seq    LinkedList    queue    int    i    len    char[]    seqChars    
List<Character>  chars  =  queue.subList  (  0,  len  )  ;	[BUGGY]  List<Character>  chars  =  queue.subList(  0,  i);  [CONTEXT]  public  boolean  matches(String  seq)  {  int  len  =  seq.length();  if  (len  >  queue.size())  return  false;  [BUGGY]  List<Character>  chars  =  queue.subList  (  0,  i  )  ;  char[]  seqChars  =  seq.toCharArray();  for  (int  i  =  0;  i  <  len;  i++)  {  Character  found  =  Character.toLowerCase(chars.get(i));  Character  check  =  Character.toLowerCase(seqChars[i]);  if  (!found.equals(check))  return  false;  }  return  true;  }        [CLASS]  TokenQueue    [METHOD]  matches  [RETURN_TYPE]  boolean      String  seq  [VARIABLES]  boolean    Character    check    found    List    chars    String    seq    LinkedList    queue    int    i    len    char[]    seqChars    
List<Character>  chars  =  queue.subList  (  0,  len  )  ;	[BUGGY]  List<Character>  chars  =  len.subList(  0,  queue);  [CONTEXT]  public  boolean  matches(String  seq)  {  int  len  =  seq.length();  if  (len  >  queue.size())  return  false;  [BUGGY]  List<Character>  chars  =  len.subList  (  0,  queue  )  ;  char[]  seqChars  =  seq.toCharArray();  for  (int  i  =  0;  i  <  len;  i++)  {  Character  found  =  Character.toLowerCase(chars.get(i));  Character  check  =  Character.toLowerCase(seqChars[i]);  if  (!found.equals(check))  return  false;  }  return  true;  }        [CLASS]  TokenQueue    [METHOD]  matches  [RETURN_TYPE]  boolean      String  seq  [VARIABLES]  boolean    Character    check    found    List    chars    String    seq    LinkedList    queue    int    i    len    char[]    seqChars    
List<Character>  chars  =  queue.subList  (  0,  len  )  ;	[BUGGY]  List<Character>  chars  =  queue.subList(  0);  [CONTEXT]  public  boolean  matches(String  seq)  {  int  len  =  seq.length();  if  (len  >  queue.size())  return  false;  [BUGGY]  List<Character>  chars  =  queue.subList  (  0  )  ;  char[]  seqChars  =  seq.toCharArray();  for  (int  i  =  0;  i  <  len;  i++)  {  Character  found  =  Character.toLowerCase(chars.get(i));  Character  check  =  Character.toLowerCase(seqChars[i]);  if  (!found.equals(check))  return  false;  }  return  true;  }        [CLASS]  TokenQueue    [METHOD]  matches  [RETURN_TYPE]  boolean      String  seq  [VARIABLES]  boolean    Character    check    found    List    chars    String    seq    LinkedList    queue    int    i    len    char[]    seqChars    
List<Character>  chars  =  queue.subList  (  0,  len  )  ;	[BUGGY]  List<Character>  chars  =  queue  .addFirst(  found)  ;  [CONTEXT]  public  boolean  matches(String  seq)  {  int  len  =  seq.length();  if  (len  >  queue.size())  return  false;  [BUGGY]  List<Character>  chars  =  queue  .addFirst  (  found  );  char[]  seqChars  =  seq.toCharArray();  for  (int  i  =  0;  i  <  len;  i++)  {  Character  found  =  Character.toLowerCase(chars.get(i));  Character  check  =  Character.toLowerCase(seqChars[i]);  if  (!found.equals(check))  return  false;  }  return  true;  }        [CLASS]  TokenQueue    [METHOD]  matches  [RETURN_TYPE]  boolean      String  seq  [VARIABLES]  boolean    Character    check    found    List    chars    String    seq    LinkedList    queue    int    i    len    char[]    seqChars    
List<Character>  chars  =  queue.subList  (  0,  len  )  ;	[BUGGY]  char[]  seqChars  =  seq.toCharArray(  );  List<Character>  chars  =  queue.subList(  0,  len);  [CONTEXT]        [CLASS]  TokenQueue    [METHOD]  matches  [RETURN_TYPE]  boolean      String  seq  [VARIABLES]  boolean    Character    check    found    List    chars    String    seq    LinkedList    queue    int    i    len    char[]    seqChars    
List<Character>  chars  =  queue.subList  (  0,  len  )  ;	[BUGGY]  Character  c  =  queue.peek(  );List<Character>  chars  =  queue.subList(  0,  len);  [CONTEXT]        [CLASS]  TokenQueue    [METHOD]  matches  [RETURN_TYPE]  boolean      String  seq  [VARIABLES]  boolean    Character    check    found    List    chars    String    seq    LinkedList    queue    int    i    len    char[]    seqChars    
List<Character>  chars  =  queue.subList  (  0,  len  )  ;	[BUGGY]  List<Character>  chars  =  queue.subList(  -1,  len);  [CONTEXT]  public  boolean  matches(String  seq)  {  int  len  =  seq.length();  if  (len  >  queue.size())  return  false;  [BUGGY]  List<Character>  chars  =  queue.subList  (  -1,  len  )  ;  char[]  seqChars  =  seq.toCharArray();  for  (int  i  =  0;  i  <  len;  i++)  {  Character  found  =  Character.toLowerCase(chars.get(i));  Character  check  =  Character.toLowerCase(seqChars[i]);  if  (!found.equals(check))  return  false;  }  return  true;  }        [CLASS]  TokenQueue    [METHOD]  matches  [RETURN_TYPE]  boolean      String  seq  [VARIABLES]  boolean    Character    check    found    List    chars    String    seq    LinkedList    queue    int    i    len    char[]    seqChars    
List<Character>  chars  =  queue.subList  (  0,  len  )  ;	[BUGGY]  List<Character>  chars  =  queue  .addFirst(  check)  ;  [CONTEXT]  public  boolean  matches(String  seq)  {  int  len  =  seq.length();  if  (len  >  queue.size())  return  false;  [BUGGY]  List<Character>  chars  =  queue  .addFirst  (  check  );  char[]  seqChars  =  seq.toCharArray();  for  (int  i  =  0;  i  <  len;  i++)  {  Character  found  =  Character.toLowerCase(chars.get(i));  Character  check  =  Character.toLowerCase(seqChars[i]);  if  (!found.equals(check))  return  false;  }  return  true;  }        [CLASS]  TokenQueue    [METHOD]  matches  [RETURN_TYPE]  boolean      String  seq  [VARIABLES]  boolean    Character    check    found    List    chars    String    seq    LinkedList    queue    int    i    len    char[]    seqChars    
List<Character>  chars  =  queue.subList  (  0,  len  )  ;	[BUGGY]  List<Character>  chars  =  null.subList(  0,  len);  [CONTEXT]  public  boolean  matches(String  seq)  {  int  len  =  seq.length();  if  (len  >  queue.size())  return  false;  [BUGGY]  List<Character>  chars  =  null.subList  (  0,  len  )  ;  char[]  seqChars  =  seq.toCharArray();  for  (int  i  =  0;  i  <  len;  i++)  {  Character  found  =  Character.toLowerCase(chars.get(i));  Character  check  =  Character.toLowerCase(seqChars[i]);  if  (!found.equals(check))  return  false;  }  return  true;  }        [CLASS]  TokenQueue    [METHOD]  matches  [RETURN_TYPE]  boolean      String  seq  [VARIABLES]  boolean    Character    check    found    List    chars    String    seq    LinkedList    queue    int    i    len    char[]    seqChars    
List<Character>  chars  =  queue.subList  (  0,  len  )  ;	[BUGGY]    [CONTEXT]  public  boolean  matches(String  seq)  {  int  len  =  seq.length();  if  (len  >  queue.size())  return  false;  [BUGGY]  List<Character>  chars  =  queue.subList(0,  len);    char[]  seqChars  =  seq.toCharArray();  for  (int  i  =  0;  i  <  len;  i++)  {  Character  found  =  Character.toLowerCase(chars.get(i));  Character  check  =  Character.toLowerCase(seqChars[i]);  if  (!found.equals(check))  return  false;  }  return  true;        [CLASS]  TokenQueue    [METHOD]  matches  [RETURN_TYPE]  boolean      String  seq  [VARIABLES]  boolean    Character    check    found    List    chars    String    seq    LinkedList    queue    int    i    len    char[]    seqChars    
List<Character>  chars  =  queue.subList  (  0,  len  )  ;  char[]  seqChars  =  seq.toCharArray  (  )  ;	[BUGGY]  char[]  seqChars  =  seq.toCharArray(  );  List<Character>  chars  =  queue.subList(  0,  len);  [CONTEXT]        [CLASS]  TokenQueue    [METHOD]  matches  [RETURN_TYPE]  boolean      String  seq  [VARIABLES]  boolean    Character    check    found    List    chars    String    seq    LinkedList    queue    int    i    len    char[]    seqChars    
List<Character>  chars  =  queue.subList  (  0,  len  )  ;  char[]  seqChars  =  seq.toCharArray  (  )  ;	[BUGGY]  List<Character>  chars  =  queue.subList(  0,  len);List<Character>  chars  =  queue.subList(  0,  len);  char[]  seqChars  =  seq.toCharArray(  );  [CONTEXT]        [CLASS]  TokenQueue    [METHOD]  matches  [RETURN_TYPE]  boolean      String  seq  [VARIABLES]  boolean    Character    check    found    List    chars    String    seq    LinkedList    queue    int    i    len    char[]    seqChars    
char[]  seqChars  =  seq.toCharArray  (  )  ;	[BUGGY]    [CONTEXT]  public  boolean  matches(String  seq)  {  int  len  =  seq.length();  if  (len  >  queue.size())  return  false;  List<Character>  chars  =  queue.subList(0,  len);  [BUGGY]  char[]  seqChars  =  seq.toCharArray();    for  (int  i  =  0;  i  <  len;  i++)  {  Character  found  =  Character.toLowerCase(chars.get(i));  Character  check  =  Character.toLowerCase(seqChars[i]);  if  (!found.equals(check))  return  false;  }  return  true;        [CLASS]  TokenQueue    [METHOD]  matches  [RETURN_TYPE]  boolean      String  seq  [VARIABLES]  boolean    Character    check    found    List    chars    String    seq    LinkedList    queue    int    i    len    char[]    seqChars    
if  (  !found.equals  (  check  )  )  return  false;	[BUGGY]  if  (  !found.equals(  check))return  true;  [CONTEXT]  public  boolean  matches(String  seq)  {  int  len  =  seq.length();  if  (len  >  queue.size())  return  false;  List<Character>  chars  =  queue.subList(0,  len);  char[]  seqChars  =  seq.toCharArray();  for  (int  i  =  0;  i  <  len;  i++)  {  Character  found  =  Character.toLowerCase(chars.get(i));  Character  check  =  Character.toLowerCase(seqChars[i]);  [BUGGY]  if(  !found.equals  (  check  ))  return  true;    }  return  true;  }        [CLASS]  TokenQueue    [METHOD]  matches  [RETURN_TYPE]  boolean      String  seq  [VARIABLES]  boolean    Character    check    found    List    chars    String    seq    LinkedList    queue    int    i    len    char[]    seqChars    
if  (  !found.equals  (  check  )  )  return  false;	[BUGGY]  if  (  !found  .equals(  found)  )return  false;  [CONTEXT]  public  boolean  matches(String  seq)  {  int  len  =  seq.length();  if  (len  >  queue.size())  return  false;  List<Character>  chars  =  queue.subList(0,  len);  char[]  seqChars  =  seq.toCharArray();  for  (int  i  =  0;  i  <  len;  i++)  {  Character  found  =  Character.toLowerCase(chars.get(i));  Character  check  =  Character.toLowerCase(seqChars[i]);  [BUGGY]  if(  !found  .equals  (  found  )  )  return  false;    }  return  true;  }        [CLASS]  TokenQueue    [METHOD]  matches  [RETURN_TYPE]  boolean      String  seq  [VARIABLES]  boolean    Character    check    found    List    chars    String    seq    LinkedList    queue    int    i    len    char[]    seqChars    
if  (  !found.equals  (  check  )  )  return  false;  }	[BUGGY]  return  false;  [CONTEXT]  public  boolean  matches(String  seq)  {  int  len  =  seq.length();  if  (len  >  queue.size())  return  false;  List<Character>  chars  =  queue.subList(0,  len);  char[]  seqChars  =  seq.toCharArray();  for  (int  i  =  0;  i  <  len;  i++)  {  Character  found  =  Character.toLowerCase(chars.get(i));  Character  check  =  Character.toLowerCase(seqChars[i]);  [BUGGY]  if  (!found.equals(check))    return  false;    return  true;        [CLASS]  TokenQueue    [METHOD]  matches  [RETURN_TYPE]  boolean      String  seq  [VARIABLES]  boolean    Character    check    found    List    chars    String    seq    LinkedList    queue    int    i    len    char[]    seqChars    
if  (  !found.equals  (  check  )  )  return  false;  }	[BUGGY]    [CONTEXT]  public  boolean  matches(String  seq)  {  int  len  =  seq.length();  if  (len  >  queue.size())  return  false;  List<Character>  chars  =  queue.subList(0,  len);  char[]  seqChars  =  seq.toCharArray();  for  (int  i  =  0;  i  <  len;  i++)  {  Character  found  =  Character.toLowerCase(chars.get(i));  Character  check  =  Character.toLowerCase(seqChars[i]);  [BUGGY]  if  (!found.equals(check))        return  true;        [CLASS]  TokenQueue    [METHOD]  matches  [RETURN_TYPE]  boolean      String  seq  [VARIABLES]  boolean    Character    check    found    List    chars    String    seq    LinkedList    queue    int    i    len    char[]    seqChars    
return  false;	[BUGGY]  return  true;  [CONTEXT]  public  boolean  matches(String  seq)  {  int  len  =  seq.length();  if  (len  >  queue.size())  return  false;  List<Character>  chars  =  queue.subList(0,  len);  char[]  seqChars  =  seq.toCharArray();  for  (int  i  =  0;  i  <  len;  i++)  {  Character  found  =  Character.toLowerCase(chars.get(i));  Character  check  =  Character.toLowerCase(seqChars[i]);  if  (!found.equals(check))  [BUGGY]  return  true;  }  return  true;  }        [CLASS]  TokenQueue    [METHOD]  matches  [RETURN_TYPE]  boolean      String  seq  [VARIABLES]  boolean    Character    check    found    List    chars    String    seq    LinkedList    queue    int    i    len    char[]    seqChars    
for  (  int  i  =  0;  i  <  len;  i++  )  {	[BUGGY]  for  (    long    i  =  0;  i  <  len;  i++)  {  [CONTEXT]  public  boolean  matches(String  seq)  {  int  len  =  seq.length();  if  (len  >  queue.size())  return  false;  List<Character>  chars  =  queue.subList(0,  len);  char[]  seqChars  =  seq.toCharArray();  [BUGGY]  for(longi  =  0;  i  <  len;  i++  ){  Character  found  =  Character.toLowerCase(chars.get(i));  Character  check  =  Character.toLowerCase(seqChars[i]);  if  (!found.equals(check))  return  false;  }  return  true;  }        [CLASS]  TokenQueue    [METHOD]  matches  [RETURN_TYPE]  boolean      String  seq  [VARIABLES]  boolean    Character    check    found    List    chars    String    seq    LinkedList    queue    int    i    len    char[]    seqChars    
for  (  int  i  =  0;  i  <  len;  i++  )  {	[BUGGY]  for  (  int  i  =  0;  i  <=  len;  i++)  {  [CONTEXT]  public  boolean  matches(String  seq)  {  int  len  =  seq.length();  if  (len  >  queue.size())  return  false;  List<Character>  chars  =  queue.subList(0,  len);  char[]  seqChars  =  seq.toCharArray();  [BUGGY]  for(  int  i  =  0;  i  <=  len;  i++  ){  Character  found  =  Character.toLowerCase(chars.get(i));  Character  check  =  Character.toLowerCase(seqChars[i]);  if  (!found.equals(check))  return  false;  }  return  true;  }        [CLASS]  TokenQueue    [METHOD]  matches  [RETURN_TYPE]  boolean      String  seq  [VARIABLES]  boolean    Character    check    found    List    chars    String    seq    LinkedList    queue    int    i    len    char[]    seqChars    
for  (  int  i  =  0;  i  <  len;  i++  )  {	[BUGGY]  for  (  int  i  =  ;  i  <  len;  i++)  {  [CONTEXT]  public  boolean  matches(String  seq)  {  int  len  =  seq.length();  if  (len  >  queue.size())  return  false;  List<Character>  chars  =  queue.subList(0,  len);  char[]  seqChars  =  seq.toCharArray();  [BUGGY]  for(  int  i  =  ;  i  <  len;  i++  ){  Character  found  =  Character.toLowerCase(chars.get(i));  Character  check  =  Character.toLowerCase(seqChars[i]);  if  (!found.equals(check))  return  false;  }  return  true;  }        [CLASS]  TokenQueue    [METHOD]  matches  [RETURN_TYPE]  boolean      String  seq  [VARIABLES]  boolean    Character    check    found    List    chars    String    seq    LinkedList    queue    int    i    len    char[]    seqChars    
for  (  int  i  =  0;  i  <  len;  i++  )  {	[BUGGY]  for  (  lennt  i  =  0;  i  <  len;  i++)  {  [CONTEXT]  public  boolean  matches(String  seq)  {  int  len  =  seq.length();  if  (len  >  queue.size())  return  false;  List<Character>  chars  =  queue.subList(0,  len);  char[]  seqChars  =  seq.toCharArray();  [BUGGY]  for(  lennt  i  =  0;  i  <  len;  i++  ){  Character  found  =  Character.toLowerCase(chars.get(i));  Character  check  =  Character.toLowerCase(seqChars[i]);  if  (!found.equals(check))  return  false;  }  return  true;  }        [CLASS]  TokenQueue    [METHOD]  matches  [RETURN_TYPE]  boolean      String  seq  [VARIABLES]  boolean    Character    check    found    List    chars    String    seq    LinkedList    queue    int    i    len    char[]    seqChars    
for  (  int  i  =  0;  i  <  len;  i++  )  {	[BUGGY]  for  (  lennt  i  =  0;  i  <  i;  i++)  {  [CONTEXT]  public  boolean  matches(String  seq)  {  int  len  =  seq.length();  if  (len  >  queue.size())  return  false;  List<Character>  chars  =  queue.subList(0,  len);  char[]  seqChars  =  seq.toCharArray();  [BUGGY]  for(  lennt  i  =  0;  i  <  i;  i++  ){  Character  found  =  Character.toLowerCase(chars.get(i));  Character  check  =  Character.toLowerCase(seqChars[i]);  if  (!found.equals(check))  return  false;  }  return  true;  }        [CLASS]  TokenQueue    [METHOD]  matches  [RETURN_TYPE]  boolean      String  seq  [VARIABLES]  boolean    Character    check    found    List    chars    String    seq    LinkedList    queue    int    i    len    char[]    seqChars    
if  (  !found.equals  (  check  )  )  return  false;	[BUGGY]  if  (  !found  .equals(  check)  )return  false;  [CONTEXT]  public  boolean  matches(String  seq)  {  int  len  =  seq.length();  if  (len  >  queue.size())  return  false;  List<Character>  chars  =  queue.subList(0,  len);  char[]  seqChars  =  seq.toCharArray();  for  (int  i  =  0;  i  <  len;  i++)  {  Character  found  =  Character.toLowerCase(chars.get(i));  Character  check  =  Character.toLowerCase(seqChars[i]);  [BUGGY]  if(  !found  .equals  (  check  )  )  return  false;    }  return  true;  }        [CLASS]  TokenQueue    [METHOD]  matches  [RETURN_TYPE]  boolean      String  seq  [VARIABLES]  boolean    Character    check    found    List    chars    String    seq    LinkedList    queue    int    i    len    char[]    seqChars    
Character  found  =  Character.toLowerCase  (  chars.get  (  i  )  )  ;	[BUGGY]  Character  found  =  Character.toLowerCase(  chars.get(  len));  [CONTEXT]  public  boolean  matches(String  seq)  {  int  len  =  seq.length();  if  (len  >  queue.size())  return  false;  List<Character>  chars  =  queue.subList(0,  len);  char[]  seqChars  =  seq.toCharArray();  for  (int  i  =  0;  i  <  len;  i++)  {  [BUGGY]  Character  found  =  Character.toLowerCase  (  chars.get  (  len  ))  ;  Character  check  =  Character.toLowerCase(seqChars[i]);  if  (!found.equals(check))  return  false;  }  return  true;  }        [CLASS]  TokenQueue    [METHOD]  matches  [RETURN_TYPE]  boolean      String  seq  [VARIABLES]  boolean    Character    check    found    List    chars    String    seq    LinkedList    queue    int    i    len    char[]    seqChars    
Character  found  =  Character.toLowerCase  (  chars.get  (  i  )  )  ;	[BUGGY]  Character  found  =  Character.toLowerCase(  i.get(  chars));  [CONTEXT]  public  boolean  matches(String  seq)  {  int  len  =  seq.length();  if  (len  >  queue.size())  return  false;  List<Character>  chars  =  queue.subList(0,  len);  char[]  seqChars  =  seq.toCharArray();  for  (int  i  =  0;  i  <  len;  i++)  {  [BUGGY]  Character  found  =  Character.toLowerCase  (  i.get  (  chars  ))  ;  Character  check  =  Character.toLowerCase(seqChars[i]);  if  (!found.equals(check))  return  false;  }  return  true;  }        [CLASS]  TokenQueue    [METHOD]  matches  [RETURN_TYPE]  boolean      String  seq  [VARIABLES]  boolean    Character    check    found    List    chars    String    seq    LinkedList    queue    int    i    len    char[]    seqChars    
Character  check  =  Character.toLowerCase  (  seqChars[i]  )  ;	[BUGGY]  Character  check  =  Character  .toLowerCase(  )  ;  [CONTEXT]  public  boolean  matches(String  seq)  {  int  len  =  seq.length();  if  (len  >  queue.size())  return  false;  List<Character>  chars  =  queue.subList(0,  len);  char[]  seqChars  =  seq.toCharArray();  for  (int  i  =  0;  i  <  len;  i++)  {  Character  found  =  Character.toLowerCase(chars.get(i));  [BUGGY]  Character  check  =  Character  .toLowerCase  ();  if  (!found.equals(check))  return  false;  }  return  true;  }        [CLASS]  TokenQueue    [METHOD]  matches  [RETURN_TYPE]  boolean      String  seq  [VARIABLES]  boolean    Character    check    found    List    chars    String    seq    LinkedList    queue    int    i    len    char[]    seqChars    
Character  found  =  Character.toLowerCase  (  chars.get  (  i  )  )  ;	[BUGGY]  Character  found  =  Character.toLowerCase(  1.get(  i));  [CONTEXT]  public  boolean  matches(String  seq)  {  int  len  =  seq.length();  if  (len  >  queue.size())  return  false;  List<Character>  chars  =  queue.subList(0,  len);  char[]  seqChars  =  seq.toCharArray();  for  (int  i  =  0;  i  <  len;  i++)  {  [BUGGY]  Character  found  =  Character.toLowerCase  (  1.get  (  i  ))  ;  Character  check  =  Character.toLowerCase(seqChars[i]);  if  (!found.equals(check))  return  false;  }  return  true;  }        [CLASS]  TokenQueue    [METHOD]  matches  [RETURN_TYPE]  boolean      String  seq  [VARIABLES]  boolean    Character    check    found    List    chars    String    seq    LinkedList    queue    int    i    len    char[]    seqChars    
Character  found  =  Character.toLowerCase  (  chars.get  (  i  )  )  ;	[BUGGY]    [CONTEXT]  public  boolean  matches(String  seq)  {  int  len  =  seq.length();  if  (len  >  queue.size())  return  false;  List<Character>  chars  =  queue.subList(0,  len);  char[]  seqChars  =  seq.toCharArray();  for  (int  i  =  0;  i  <  len;  i++)  {  [BUGGY]  Character  found  =  Character.toLowerCase(chars.get(i));    Character  check  =  Character.toLowerCase(seqChars[i]);  if  (!found.equals(check))  return  false;  }  return  true;        [CLASS]  TokenQueue    [METHOD]  matches  [RETURN_TYPE]  boolean      String  seq  [VARIABLES]  boolean    Character    check    found    List    chars    String    seq    LinkedList    queue    int    i    len    char[]    seqChars    
Character  found  =  Character.toLowerCase  (  chars.get  (  i  )  )  ;	[BUGGY]  if  (  !found.equals(  check))Character  found  =  Character.toLowerCase(  chars.get(  i));  [CONTEXT]        [CLASS]  TokenQueue    [METHOD]  matches  [RETURN_TYPE]  boolean      String  seq  [VARIABLES]  boolean    Character    check    found    List    chars    String    seq    LinkedList    queue    int    i    len    char[]    seqChars    
Character  found  =  Character.toLowerCase  (  chars.get  (  i  )  )  ;	[BUGGY]  Character  check  =  Character.toLowerCase(  seqChars[i]);Character  found  =  Character.toLowerCase(  chars.get(  i));  [CONTEXT]        [CLASS]  TokenQueue    [METHOD]  matches  [RETURN_TYPE]  boolean      String  seq  [VARIABLES]  boolean    Character    check    found    List    chars    String    seq    LinkedList    queue    int    i    len    char[]    seqChars    
Character  check  =  Character.toLowerCase  (  seqChars[i]  )  ;	[BUGGY]    [CONTEXT]  public  boolean  matches(String  seq)  {  int  len  =  seq.length();  if  (len  >  queue.size())  return  false;  List<Character>  chars  =  queue.subList(0,  len);  char[]  seqChars  =  seq.toCharArray();  for  (int  i  =  0;  i  <  len;  i++)  {  Character  found  =  Character.toLowerCase(chars.get(i));  [BUGGY]  Character  check  =  Character.toLowerCase(seqChars[i]);    if  (!found.equals(check))  return  false;  }  return  true;        [CLASS]  TokenQueue    [METHOD]  matches  [RETURN_TYPE]  boolean      String  seq  [VARIABLES]  boolean    Character    check    found    List    chars    String    seq    LinkedList    queue    int    i    len    char[]    seqChars    
for  (  int  i  =  0;  i  <  len;  i++  )  {	[BUGGY]  for  (  int  i  =  len;  i  <  len;  i++)  {  [CONTEXT]  public  boolean  matches(String  seq)  {  int  len  =  seq.length();  if  (len  >  queue.size())  return  false;  List<Character>  chars  =  queue.subList(0,  len);  char[]  seqChars  =  seq.toCharArray();  [BUGGY]  for(  int  i  =  len;  i  <  len;  i++  ){  Character  found  =  Character.toLowerCase(chars.get(i));  Character  check  =  Character.toLowerCase(seqChars[i]);  if  (!found.equals(check))  return  false;  }  return  true;  }        [CLASS]  TokenQueue    [METHOD]  matches  [RETURN_TYPE]  boolean      String  seq  [VARIABLES]  boolean    Character    check    found    List    chars    String    seq    LinkedList    queue    int    i    len    char[]    seqChars    
Character  found  =  Character.toLowerCase  (  chars.get  (  i  )  )  ;	[BUGGY]  Character  found  =  Character  .toLowerCase(  )  ;  [CONTEXT]  public  boolean  matches(String  seq)  {  int  len  =  seq.length();  if  (len  >  queue.size())  return  false;  List<Character>  chars  =  queue.subList(0,  len);  char[]  seqChars  =  seq.toCharArray();  for  (int  i  =  0;  i  <  len;  i++)  {  [BUGGY]  Character  found  =  Character  .toLowerCase  ();  Character  check  =  Character.toLowerCase(seqChars[i]);  if  (!found.equals(check))  return  false;  }  return  true;  }        [CLASS]  TokenQueue    [METHOD]  matches  [RETURN_TYPE]  boolean      String  seq  [VARIABLES]  boolean    Character    check    found    List    chars    String    seq    LinkedList    queue    int    i    len    char[]    seqChars    
return  true;	[BUGGY]  return  false;  [CONTEXT]  public  boolean  matches(String  seq)  {  int  len  =  seq.length();  if  (len  >  queue.size())  return  false;  List<Character>  chars  =  queue.subList(0,  len);  char[]  seqChars  =  seq.toCharArray();  for  (int  i  =  0;  i  <  len;  i++)  {  Character  found  =  Character.toLowerCase(chars.get(i));  Character  check  =  Character.toLowerCase(seqChars[i]);  if  (!found.equals(check))  return  false;  }  [BUGGY]  return  false;  }        [CLASS]  TokenQueue    [METHOD]  matches  [RETURN_TYPE]  boolean      String  seq  [VARIABLES]  boolean    Character    check    found    List    chars    String    seq    LinkedList    queue    int    i    len    char[]    seqChars    
if  (  matches  (  s  )  )  return  true;	[BUGGY]  if  (  matches(  s))return  false;  [CONTEXT]  public  boolean  matchesAny(String...  seq)  {  for  (String  s  :  seq)  {  [BUGGY]  if(  matches  (  s  ))  return  false;    }  return  false;  }        [CLASS]  TokenQueue    [METHOD]  matchesAny  [RETURN_TYPE]  boolean        seq  [VARIABLES]  String[]    seq    String    s    boolean    LinkedList    queue    
if  (  matches  (  s  )  )  return  true;	[BUGGY]  if  (  matchesAny(  s))return  true;  [CONTEXT]  public  boolean  matchesAny(String...  seq)  {  for  (String  s  :  seq)  {  [BUGGY]  if(  matchesAny  (  s  ))  return  true;    }  return  false;  }        [CLASS]  TokenQueue    [METHOD]  matchesAny  [RETURN_TYPE]  boolean        seq  [VARIABLES]  String[]    seq    String    s    boolean    LinkedList    queue    
if  (  matches  (  s  )  )  return  true;	[BUGGY]  if  (  matchesAny(  s))return  false;  [CONTEXT]  public  boolean  matchesAny(String...  seq)  {  for  (String  s  :  seq)  {  [BUGGY]  if(  matchesAny  (  s  ))  return  false;    }  return  false;  }        [CLASS]  TokenQueue    [METHOD]  matchesAny  [RETURN_TYPE]  boolean        seq  [VARIABLES]  String[]    seq    String    s    boolean    LinkedList    queue    
if  (  matches  (  s  )  )  return  true;  }	[BUGGY]  return  true;  [CONTEXT]  public  boolean  matchesAny(String...  seq)  {  for  (String  s  :  seq)  {  [BUGGY]  if  (matches(s))    return  true;    return  false;        [CLASS]  TokenQueue    [METHOD]  matchesAny  [RETURN_TYPE]  boolean        seq  [VARIABLES]  String[]    seq    String    s    boolean    LinkedList    queue    
if  (  matches  (  s  )  )  return  true;  }	[BUGGY]    [CONTEXT]  public  boolean  matchesAny(String...  seq)  {  for  (String  s  :  seq)  {  [BUGGY]  if  (matches(s))        return  false;        [CLASS]  TokenQueue    [METHOD]  matchesAny  [RETURN_TYPE]  boolean        seq  [VARIABLES]  String[]    seq    String    s    boolean    LinkedList    queue    
return  true;	[BUGGY]  return  false;  [CONTEXT]  public  boolean  matchesAny(String...  seq)  {  for  (String  s  :  seq)  {  if  (matches(s))  [BUGGY]  return  false;  }  return  false;  }        [CLASS]  TokenQueue    [METHOD]  matchesAny  [RETURN_TYPE]  boolean        seq  [VARIABLES]  String[]    seq    String    s    boolean    LinkedList    queue    
for  (  String  s  :  seq  )  {	[BUGGY]  for  (  char  s  :  seq)  {  [CONTEXT]  public  boolean  matchesAny(String...  seq)  {  [BUGGY]  for(  char  s  :  seq  ){  if  (matches(s))  return  true;  }  return  false;  }        [CLASS]  TokenQueue    [METHOD]  matchesAny  [RETURN_TYPE]  boolean        seq  [VARIABLES]  String[]    seq    String    s    boolean    LinkedList    queue    
return  false;	[BUGGY]  return  true;  [CONTEXT]  public  boolean  matchesAny(String...  seq)  {  for  (String  s  :  seq)  {  if  (matches(s))  return  true;  }  [BUGGY]  return  true;  }        [CLASS]  TokenQueue    [METHOD]  matchesAny  [RETURN_TYPE]  boolean        seq  [VARIABLES]  String[]    seq    String    s    boolean    LinkedList    queue    
if  (  matches  (  seq  )  )  {	[BUGGY]  if  (  matchesAny(  seq))  {  [CONTEXT]  public  boolean  matchChomp(String  seq)  {  [BUGGY]  if(  matchesAny  (  seq  )){  consume(seq);  return  true;  }  else  {  return  false;  }  }        [CLASS]  TokenQueue    [METHOD]  matchChomp  [RETURN_TYPE]  boolean      String  seq  [VARIABLES]  LinkedList    queue    String    seq    boolean    
if  (  matches  (  seq  )  )  {  consume  (  seq  )  ;  return  true;  }  else  {  return  false;  }	[BUGGY]  consume(seq);  return  true;  [CONTEXT]  public  boolean  matchChomp(String  seq)  {  [BUGGY]  if  (matches(seq))  {    consume(seq);  return  true;        }        [CLASS]  TokenQueue    [METHOD]  matchChomp  [RETURN_TYPE]  boolean      String  seq  [VARIABLES]  LinkedList    queue    String    seq    boolean    
if  (  matches  (  seq  )  )  {  consume  (  seq  )  ;  return  true;  }  else  {  return  false;  }	[BUGGY]    [CONTEXT]  public  boolean  matchChomp(String  seq)  {  [BUGGY]  if  (matches(seq))  {            }        [CLASS]  TokenQueue    [METHOD]  matchChomp  [RETURN_TYPE]  boolean      String  seq  [VARIABLES]  LinkedList    queue    String    seq    boolean    
return  false;	[BUGGY]  return  true;  [CONTEXT]  public  boolean  matchChomp(String  seq)  {  if  (matches(seq))  {  consume(seq);  return  true;  }  else  {  [BUGGY]  return  true;  }  }        [CLASS]  TokenQueue    [METHOD]  matchChomp  [RETURN_TYPE]  boolean      String  seq  [VARIABLES]  LinkedList    queue    String    seq    boolean    
return  true;	[BUGGY]  return  false;  [CONTEXT]  public  boolean  matchChomp(String  seq)  {  if  (matches(seq))  {  consume(seq);  [BUGGY]  return  false;  }  else  {  return  false;  }  }        [CLASS]  TokenQueue    [METHOD]  matchChomp  [RETURN_TYPE]  boolean      String  seq  [VARIABLES]  LinkedList    queue    String    seq    boolean    
consume  (  seq  )  ;	[BUGGY]  consumeTo(  seq);  [CONTEXT]  public  boolean  matchChomp(String  seq)  {  if  (matches(seq))  {  [BUGGY]  consumeTo  (  seq  )  ;  return  true;  }  else  {  return  false;  }  }        [CLASS]  TokenQueue    [METHOD]  matchChomp  [RETURN_TYPE]  boolean      String  seq  [VARIABLES]  LinkedList    queue    String    seq    boolean    
consume  (  seq  )  ;	[BUGGY]    [CONTEXT]  public  boolean  matchChomp(String  seq)  {  if  (matches(seq))  {  [BUGGY]  consume(seq);    return  true;  }  else  {  return  false;  }        [CLASS]  TokenQueue    [METHOD]  matchChomp  [RETURN_TYPE]  boolean      String  seq  [VARIABLES]  LinkedList    queue    String    seq    boolean    
consume  (  seq  )  ;  return  true;	[BUGGY]    [CONTEXT]  public  boolean  matchChomp(String  seq)  {  if  (matches(seq))  {  [BUGGY]  consume(seq);      }  else  {  return  false;  }        [CLASS]  TokenQueue    [METHOD]  matchChomp  [RETURN_TYPE]  boolean      String  seq  [VARIABLES]  LinkedList    queue    String    seq    boolean    
consume  (  seq  )  ;	[BUGGY]    else  {  consume(  seq);  [CONTEXT]        [CLASS]  TokenQueue    [METHOD]  matchChomp  [RETURN_TYPE]  boolean      String  seq  [VARIABLES]  LinkedList    queue    String    seq    boolean    
consume  (  seq  )  ;	[BUGGY]  String  data  =  consumeTo(  seq);consume(  seq);  [CONTEXT]        [CLASS]  TokenQueue    [METHOD]  matchChomp  [RETURN_TYPE]  boolean      String  seq  [VARIABLES]  LinkedList    queue    String    seq    boolean    
consume  (  seq  )  ;	[BUGGY]  return  consumeToAny(  seq);consume(  seq);  [CONTEXT]        [CLASS]  TokenQueue    [METHOD]  matchChomp  [RETURN_TYPE]  boolean      String  seq  [VARIABLES]  LinkedList    queue    String    seq    boolean    
consume  (  seq  )  ;	[BUGGY]  consume(  );consume(  seq);  [CONTEXT]        [CLASS]  TokenQueue    [METHOD]  matchChomp  [RETURN_TYPE]  boolean      String  seq  [VARIABLES]  LinkedList    queue    String    seq    boolean    
consume  (  seq  )  ;	[BUGGY]  matchChomp(  seq);consume(  seq);  [CONTEXT]        [CLASS]  TokenQueue    [METHOD]  matchChomp  [RETURN_TYPE]  boolean      String  seq  [VARIABLES]  LinkedList    queue    String    seq    boolean    
return  !queue.isEmpty  (  )  &&  Character.isWhitespace  (  queue.peek  (  )  )  ;	[BUGGY]  return  !queue.isEmpty(  )  ||  Character.isWhitespace(  queue.peek(  ));  [CONTEXT]  public  boolean  matchesWhitespace()  {  [BUGGY]  return  !queue.isEmpty  ()||  Character.isWhitespace  (  queue.peek  ())  ;  }        [CLASS]  TokenQueue    [METHOD]  matchesWhitespace  [RETURN_TYPE]  boolean      [VARIABLES]  LinkedList    queue    boolean    
return  !queue.isEmpty  (  )  &&  Character.isWhitespace  (  queue.peek  (  )  )  ;	[BUGGY]  return  !queue.isEmpty(  )  &&  Character.isWhitespace(  2.peek(  ));  [CONTEXT]  public  boolean  matchesWhitespace()  {  [BUGGY]  return  !queue.isEmpty  ()&&  Character.isWhitespace  (  2.peek  ())  ;  }        [CLASS]  TokenQueue    [METHOD]  matchesWhitespace  [RETURN_TYPE]  boolean      [VARIABLES]  LinkedList    queue    boolean    
return  !queue.isEmpty  (  )  &&  Character.isWhitespace  (  queue.peek  (  )  )  ;	[BUGGY]  return  !queue.peek(  )  &&  Character.isWhitespace(  queue.peek(  ));  [CONTEXT]  public  boolean  matchesWhitespace()  {  [BUGGY]  return  !queue.peek  ()&&  Character.isWhitespace  (  queue.peek  ())  ;  }        [CLASS]  TokenQueue    [METHOD]  matchesWhitespace  [RETURN_TYPE]  boolean      [VARIABLES]  LinkedList    queue    boolean    
return  !queue.isEmpty  (  )  &&  Character.isWhitespace  (  queue.peek  (  )  )  ;	[BUGGY]  return  !queue.isEmpty(  )  &&  Character.toLowerCase(  queue.peek(  ));  [CONTEXT]  public  boolean  matchesWhitespace()  {  [BUGGY]  return  !queue.isEmpty  ()&&  Character.toLowerCase  (  queue.peek  ())  ;  }        [CLASS]  TokenQueue    [METHOD]  matchesWhitespace  [RETURN_TYPE]  boolean      [VARIABLES]  LinkedList    queue    boolean    
return  !queue.isEmpty  (  )  &&  Character.isWhitespace  (  queue.peek  (  )  )  ;	[BUGGY]  return  !queue.isEmpty(  )  &&  Character.isWhitespace(  queue.size(  ));  [CONTEXT]  public  boolean  matchesWhitespace()  {  [BUGGY]  return  !queue.isEmpty  ()&&  Character.isWhitespace  (  queue.size  ())  ;  }        [CLASS]  TokenQueue    [METHOD]  matchesWhitespace  [RETURN_TYPE]  boolean      [VARIABLES]  LinkedList    queue    boolean    
return  !queue.isEmpty  (  )  &&  Character.isWhitespace  (  queue.peek  (  )  )  ;	[BUGGY]  return  !queue.isEmpty(  )  &&  Character.isWhitespace(  queue  .removeFirst(  )  );  [CONTEXT]  public  boolean  matchesWhitespace()  {  [BUGGY]  return  !queue.isEmpty  ()&&  Character.isWhitespace  (  queue  .removeFirst  ()  )  ;  }        [CLASS]  TokenQueue    [METHOD]  matchesWhitespace  [RETURN_TYPE]  boolean      [VARIABLES]  LinkedList    queue    boolean    
return  !queue.isEmpty  (  )  &&  Character.isWhitespace  (  queue.peek  (  )  )  ;	[BUGGY]    [CONTEXT]  public  boolean  matchesWhitespace()  {  [BUGGY]  return  !queue.isEmpty()  &&  Character.isWhitespace(queue.peek());          [CLASS]  TokenQueue    [METHOD]  matchesWhitespace  [RETURN_TYPE]  boolean      [VARIABLES]  LinkedList    queue    boolean    
return  !queue.isEmpty  (  )  &&  Character.isWhitespace  (  queue.peek  (  )  )  ;	[BUGGY]  return  !queue.isEmpty(  )  &&  Character.isWhitespace(  this.peek(  ));  [CONTEXT]  public  boolean  matchesWhitespace()  {  [BUGGY]  return  !queue.isEmpty  ()&&  Character.isWhitespace  (  this.peek  ())  ;  }        [CLASS]  TokenQueue    [METHOD]  matchesWhitespace  [RETURN_TYPE]  boolean      [VARIABLES]  LinkedList    queue    boolean    
return  !queue.isEmpty  (  )  &&  Character.isLetterOrDigit  (  queue.peek  (  )  )  ;	[BUGGY]  return  !queue.isEmpty(  )  ||  Character.isLetterOrDigit(  queue.peek(  ));  [CONTEXT]  public  boolean  matchesWord()  {  [BUGGY]  return  !queue.isEmpty  ()||  Character.isLetterOrDigit  (  queue.peek  ())  ;  }        [CLASS]  TokenQueue    [METHOD]  matchesWord  [RETURN_TYPE]  boolean      [VARIABLES]  LinkedList    queue    boolean    
return  !queue.isEmpty  (  )  &&  Character.isLetterOrDigit  (  queue.peek  (  )  )  ;	[BUGGY]  return  !queue.isEmpty(  )  &&  Character.isLetterOrDigit(  null.peek(  ));  [CONTEXT]  public  boolean  matchesWord()  {  [BUGGY]  return  !queue.isEmpty  ()&&  Character.isLetterOrDigit  (  null.peek  ())  ;  }        [CLASS]  TokenQueue    [METHOD]  matchesWord  [RETURN_TYPE]  boolean      [VARIABLES]  LinkedList    queue    boolean    
return  !queue.isEmpty  (  )  &&  Character.isLetterOrDigit  (  queue.peek  (  )  )  ;	[BUGGY]  return  !queue.peek(  )  &&  Character.isLetterOrDigit(  queue.peek(  ));  [CONTEXT]  public  boolean  matchesWord()  {  [BUGGY]  return  !queue.peek  ()&&  Character.isLetterOrDigit  (  queue.peek  ())  ;  }        [CLASS]  TokenQueue    [METHOD]  matchesWord  [RETURN_TYPE]  boolean      [VARIABLES]  LinkedList    queue    boolean    
return  !queue.isEmpty  (  )  &&  Character.isLetterOrDigit  (  queue.peek  (  )  )  ;	[BUGGY]  return  !queue.isEmpty(  )  &&  Character.isWhitespace(  queue.peek(  ));  [CONTEXT]  public  boolean  matchesWord()  {  [BUGGY]  return  !queue.isEmpty  ()&&  Character.isWhitespace  (  queue.peek  ())  ;  }        [CLASS]  TokenQueue    [METHOD]  matchesWord  [RETURN_TYPE]  boolean      [VARIABLES]  LinkedList    queue    boolean    
return  !queue.isEmpty  (  )  &&  Character.isLetterOrDigit  (  queue.peek  (  )  )  ;	[BUGGY]  return  !queue.isEmpty(  )  &&  Character.isLetterOrDigit(  queue.size(  ));  [CONTEXT]  public  boolean  matchesWord()  {  [BUGGY]  return  !queue.isEmpty  ()&&  Character.isLetterOrDigit  (  queue.size  ())  ;  }        [CLASS]  TokenQueue    [METHOD]  matchesWord  [RETURN_TYPE]  boolean      [VARIABLES]  LinkedList    queue    boolean    
return  !queue.isEmpty  (  )  &&  Character.isLetterOrDigit  (  queue.peek  (  )  )  ;	[BUGGY]  return  !queue.isEmpty(  )  &&  Character.isLetterOrDigit(  queue  .removeFirst(  )  );  [CONTEXT]  public  boolean  matchesWord()  {  [BUGGY]  return  !queue.isEmpty  ()&&  Character.isLetterOrDigit  (  queue  .removeFirst  ()  )  ;  }        [CLASS]  TokenQueue    [METHOD]  matchesWord  [RETURN_TYPE]  boolean      [VARIABLES]  LinkedList    queue    boolean    
return  !queue.isEmpty  (  )  &&  Character.isLetterOrDigit  (  queue.peek  (  )  )  ;	[BUGGY]  return  !queue.peek(  )  ;  [CONTEXT]  public  boolean  matchesWord()  {  [BUGGY]  return  !queue.peek  ();  }        [CLASS]  TokenQueue    [METHOD]  matchesWord  [RETURN_TYPE]  boolean      [VARIABLES]  LinkedList    queue    boolean    
return  !queue.isEmpty  (  )  &&  Character.isLetterOrDigit  (  queue.peek  (  )  )  ;	[BUGGY]    [CONTEXT]  public  boolean  matchesWord()  {  [BUGGY]  return  !queue.isEmpty()  &&  Character.isLetterOrDigit(queue.peek());          [CLASS]  TokenQueue    [METHOD]  matchesWord  [RETURN_TYPE]  boolean      [VARIABLES]  LinkedList    queue    boolean    
return  !queue.isEmpty  (  )  &&  Character.isLetterOrDigit  (  queue.peek  (  )  )  ;	[BUGGY]  return  !queue.isEmpty(  )  &&  Character  .isLetterOrDigit(  )  ;  [CONTEXT]  public  boolean  matchesWord()  {  [BUGGY]  return  !queue.isEmpty  ()&&  Character  .isLetterOrDigit  ();  }        [CLASS]  TokenQueue    [METHOD]  matchesWord  [RETURN_TYPE]  boolean      [VARIABLES]  LinkedList    queue    boolean    
return  !queue.isEmpty  (  )  &&  Character.isLetterOrDigit  (  queue.peek  (  )  )  ;	[BUGGY]  return  !queue.isEmpty(  )  &&  Character.isLetterOrDigit(  0.peek(  ));  [CONTEXT]  public  boolean  matchesWord()  {  [BUGGY]  return  !queue.isEmpty  ()&&  Character.isLetterOrDigit  (  0.peek  ())  ;  }        [CLASS]  TokenQueue    [METHOD]  matchesWord  [RETURN_TYPE]  boolean      [VARIABLES]  LinkedList    queue    boolean    
return  queue.removeFirst  (  )  ;	[BUGGY]  return  queue.peek(  );  [CONTEXT]  public  Character  consume()  {  [BUGGY]  return  queue.peek  ()  ;  }        [CLASS]  TokenQueue    [METHOD]  consume  [RETURN_TYPE]  Character      [VARIABLES]  LinkedList    queue    boolean    
return  queue.removeFirst  (  )  ;	[BUGGY]    [CONTEXT]  public  Character  consume()  {  [BUGGY]  return  queue.removeFirst();          [CLASS]  TokenQueue    [METHOD]  consume  [RETURN_TYPE]  Character      [VARIABLES]  LinkedList    queue    boolean    
if  (  !matches  (  seq  )  )  throw  new  IllegalStateException  ( "   ")  ;	[BUGGY]  if  (  !matches(  seq))throw  if  (  !matches(  seq))throw    new  IllegalStateException(   "Queue  not  long  enough  to  consume  sequence ")    ;  [CONTEXT]  public  void  consume(String  seq)  {  [BUGGY]  if(  !matches  (  seq  ))  throw  if(  !matches  (  seq  ))  thrownew  IllegalStateException  (   "Queue  not  long  enough  to  consume  sequence "  )  ;    int  len  =  seq.length();  if  (len  >  queue.size())  throw  new  IllegalStateException( "Queue  not  long  enough  to  consume  sequence ");  for  (int  i  =  0;  i  <  len;  i++)  {  consume();  }  }        [CLASS]  TokenQueue    [METHOD]  consume  [RETURN_TYPE]  void      String  seq  [VARIABLES]  String    seq    boolean    LinkedList    queue    int    i    len    
if  (  !matches  (  seq  )  )  throw  new  IllegalStateException  ( "   ")  ;	[BUGGY]  if  (  !matchesAny(  seq))throw  new  IllegalStateException  ( "   ")    ;  [CONTEXT]  public  void  consume(String  seq)  {  [BUGGY]  if(  !matchesAny  (  seq  ))  throw  new  IllegalStateException( "   ");    int  len  =  seq.length();  if  (len  >  queue.size())  throw  new  IllegalStateException( "Queue  not  long  enough  to  consume  sequence ");  for  (int  i  =  0;  i  <  len;  i++)  {  consume();  }  }        [CLASS]  TokenQueue    [METHOD]  consume  [RETURN_TYPE]  void      String  seq  [VARIABLES]  String    seq    boolean    LinkedList    queue    int    i    len    
throw  new  IllegalStateException  ( "   ")  ;	[BUGGY]  throw  throw    new  IllegalStateException(   "Queue  not  long  enough  to  consume  sequence ")    ;  [CONTEXT]  public  void  consume(String  seq)  {  if  (!matches(seq))  [BUGGY]  throw  thrownew  IllegalStateException  (   "Queue  not  long  enough  to  consume  sequence "  )  ;  int  len  =  seq.length();  if  (len  >  queue.size())  throw  new  IllegalStateException( "Queue  not  long  enough  to  consume  sequence ");  for  (int  i  =  0;  i  <  len;  i++)  {  consume();  }  }        [CLASS]  TokenQueue    [METHOD]  consume  [RETURN_TYPE]  void      String  seq  [VARIABLES]  String    seq    boolean    LinkedList    queue    int    i    len    
throw  new  IllegalStateException  ( "   ")  ;	[BUGGY]  return  ;  [CONTEXT]  public  void  consume(String  seq)  {  if  (!matches(seq))  [BUGGY]  return  ;  int  len  =  seq.length();  if  (len  >  queue.size())  throw  new  IllegalStateException( "Queue  not  long  enough  to  consume  sequence ");  for  (int  i  =  0;  i  <  len;  i++)  {  consume();  }  }        [CLASS]  TokenQueue    [METHOD]  consume  [RETURN_TYPE]  void      String  seq  [VARIABLES]  String    seq    boolean    LinkedList    queue    int    i    len    
int  len  =  seq.length  (  )  ;	[BUGGY]  short    len  =  seq.length(  );  [CONTEXT]  public  void  consume(String  seq)  {  if  (!matches(seq))  throw  new  IllegalStateException( "Queue  did  not  match  expected  sequence ");  [BUGGY]  shortlen  =  seq.length  ()  ;  if  (len  >  queue.size())  throw  new  IllegalStateException( "Queue  not  long  enough  to  consume  sequence ");  for  (int  i  =  0;  i  <  len;  i++)  {  consume();  }  }        [CLASS]  TokenQueue    [METHOD]  consume  [RETURN_TYPE]  void      String  seq  [VARIABLES]  String    seq    boolean    LinkedList    queue    int    i    len    
int  len  =  seq.length  (  )  ;	[BUGGY]  int  len  =  seq.length()  +  3  ;  [CONTEXT]  public  void  consume(String  seq)  {  if  (!matches(seq))  throw  new  IllegalStateException( "Queue  did  not  match  expected  sequence ");  [BUGGY]  int  len  =  seq.length()  +  3  ;  if  (len  >  queue.size())  throw  new  IllegalStateException( "Queue  not  long  enough  to  consume  sequence ");  for  (int  i  =  0;  i  <  len;  i++)  {  consume();  }  }        [CLASS]  TokenQueue    [METHOD]  consume  [RETURN_TYPE]  void      String  seq  [VARIABLES]  String    seq    boolean    LinkedList    queue    int    i    len    
int  len  =  seq.length  (  )  ;	[BUGGY]  int  len  =  seq.length()  +  4  ;  [CONTEXT]  public  void  consume(String  seq)  {  if  (!matches(seq))  throw  new  IllegalStateException( "Queue  did  not  match  expected  sequence ");  [BUGGY]  int  len  =  seq.length()  +  4  ;  if  (len  >  queue.size())  throw  new  IllegalStateException( "Queue  not  long  enough  to  consume  sequence ");  for  (int  i  =  0;  i  <  len;  i++)  {  consume();  }  }        [CLASS]  TokenQueue    [METHOD]  consume  [RETURN_TYPE]  void      String  seq  [VARIABLES]  String    seq    boolean    LinkedList    queue    int    i    len    
int  len  =  seq.length  (  )  ;	[BUGGY]    [CONTEXT]  public  void  consume(String  seq)  {  if  (!matches(seq))  throw  new  IllegalStateException( "Queue  did  not  match  expected  sequence ");  [BUGGY]  int  len  =  seq.length();    if  (len  >  queue.size())  throw  new  IllegalStateException( "Queue  not  long  enough  to  consume  sequence ");  for  (int  i  =  0;  i  <  len;  i++)  {  consume();  }        [CLASS]  TokenQueue    [METHOD]  consume  [RETURN_TYPE]  void      String  seq  [VARIABLES]  String    seq    boolean    LinkedList    queue    int    i    len    
if  (  len  >  queue.size  (  )  )  throw  new  IllegalStateException  ( "   ")  ;	[BUGGY]  if  (  len  >=  queue.size(  ))throw  new  IllegalStateException  ( "   ")    ;  [CONTEXT]  public  void  consume(String  seq)  {  if  (!matches(seq))  throw  new  IllegalStateException( "Queue  did  not  match  expected  sequence ");  int  len  =  seq.length();  [BUGGY]  if(  len  >=  queue.size  ())  throw  new  IllegalStateException( "   ");    for  (int  i  =  0;  i  <  len;  i++)  {  consume();  }  }        [CLASS]  TokenQueue    [METHOD]  consume  [RETURN_TYPE]  void      String  seq  [VARIABLES]  String    seq    boolean    LinkedList    queue    int    i    len    
if  (  len  >  queue.size  (  )  )  throw  new  IllegalStateException  ( "   ")  ;	[BUGGY]  if  (  len  >  queue.size()  +  4  )throw  new  IllegalStateException  ( "   ")    ;  [CONTEXT]  public  void  consume(String  seq)  {  if  (!matches(seq))  throw  new  IllegalStateException( "Queue  did  not  match  expected  sequence ");  int  len  =  seq.length();  [BUGGY]  if(  len  >  queue.size()  +  4)  throw  new  IllegalStateException( "   ");    for  (int  i  =  0;  i  <  len;  i++)  {  consume();  }  }        [CLASS]  TokenQueue    [METHOD]  consume  [RETURN_TYPE]  void      String  seq  [VARIABLES]  String    seq    boolean    LinkedList    queue    int    i    len    
if  (  len  >  queue.size  (  )  )  throw  new  IllegalStateException  ( "   ")  ;	[BUGGY]  if  (  len  >  queue.size(  ))throw  if  (  len  >  queue.size(  ))throw    new  IllegalStateException(   "Queue  did  not  match  expected  sequence ")    ;  [CONTEXT]  public  void  consume(String  seq)  {  if  (!matches(seq))  throw  new  IllegalStateException( "Queue  did  not  match  expected  sequence ");  int  len  =  seq.length();  [BUGGY]  if(  len  >  queue.size  ())  throw  if(  len  >  queue.size  ())  thrownew  IllegalStateException  (   "Queue  did  not  match  expected  sequence "  )  ;    for  (int  i  =  0;  i  <  len;  i++)  {  consume();  }  }        [CLASS]  TokenQueue    [METHOD]  consume  [RETURN_TYPE]  void      String  seq  [VARIABLES]  String    seq    boolean    LinkedList    queue    int    i    len    
if  (  len  >  queue.size  (  )  )  throw  new  IllegalStateException  ( "   ")  ;	[BUGGY]  if  (  i  >  queue.size(  ))throw  new  IllegalStateException  ( "   ")    ;  [CONTEXT]  public  void  consume(String  seq)  {  if  (!matches(seq))  throw  new  IllegalStateException( "Queue  did  not  match  expected  sequence ");  int  len  =  seq.length();  [BUGGY]  if(  i  >  queue.size  ())  throw  new  IllegalStateException( "   ");    for  (int  i  =  0;  i  <  len;  i++)  {  consume();  }  }        [CLASS]  TokenQueue    [METHOD]  consume  [RETURN_TYPE]  void      String  seq  [VARIABLES]  String    seq    boolean    LinkedList    queue    int    i    len    
if  (  len  >  queue.size  (  )  )  throw  new  IllegalStateException  ( "   ")  ;	[BUGGY]  if  (  queue  >  len.size(  ))throw  new  IllegalStateException  ( "   ")    ;  [CONTEXT]  public  void  consume(String  seq)  {  if  (!matches(seq))  throw  new  IllegalStateException( "Queue  did  not  match  expected  sequence ");  int  len  =  seq.length();  [BUGGY]  if(  queue  >  len.size  ())  throw  new  IllegalStateException( "   ");    for  (int  i  =  0;  i  <  len;  i++)  {  consume();  }  }        [CLASS]  TokenQueue    [METHOD]  consume  [RETURN_TYPE]  void      String  seq  [VARIABLES]  String    seq    boolean    LinkedList    queue    int    i    len    
if  (  len  >  queue.size  (  )  )  throw  new  IllegalStateException  ( "   ")  ;	[BUGGY]  if  (  len  >  queue.peek(  ))throw  new  IllegalStateException  ( "   ")    ;  [CONTEXT]  public  void  consume(String  seq)  {  if  (!matches(seq))  throw  new  IllegalStateException( "Queue  did  not  match  expected  sequence ");  int  len  =  seq.length();  [BUGGY]  if(  len  >  queue.peek  ())  throw  new  IllegalStateException( "   ");    for  (int  i  =  0;  i  <  len;  i++)  {  consume();  }  }        [CLASS]  TokenQueue    [METHOD]  consume  [RETURN_TYPE]  void      String  seq  [VARIABLES]  String    seq    boolean    LinkedList    queue    int    i    len    
if  (  len  >  queue.size  (  )  )  throw  new  IllegalStateException  ( "   ")  ;  for  (  int  i  =  0;  i  <  len;  i++  )  {  consume  (  )  ;  }	[BUGGY]  throw  new  java.lang.IllegalStateException( "Queue  not  long  enough  to  consume  sequence ");  [CONTEXT]  public  void  consume(String  seq)  {  if  (!matches(seq))  throw  new  IllegalStateException( "Queue  did  not  match  expected  sequence ");  int  len  =  seq.length();  [BUGGY]  if  (len  >  queue.size())    throw  new  java.lang.IllegalStateException( "Queue  not  long  enough  to  consume  sequence ");              [CLASS]  TokenQueue    [METHOD]  consume  [RETURN_TYPE]  void      String  seq  [VARIABLES]  String    seq    boolean    LinkedList    queue    int    i    len    
if  (  len  >  queue.size  (  )  )  throw  new  IllegalStateException  ( "   ")  ;  for  (  int  i  =  0;  i  <  len;  i++  )  {  consume  (  )  ;  }	[BUGGY]    [CONTEXT]  public  void  consume(String  seq)  {  if  (!matches(seq))  throw  new  IllegalStateException( "Queue  did  not  match  expected  sequence ");  int  len  =  seq.length();  [BUGGY]  if  (len  >  queue.size())                  [CLASS]  TokenQueue    [METHOD]  consume  [RETURN_TYPE]  void      String  seq  [VARIABLES]  String    seq    boolean    LinkedList    queue    int    i    len    
throw  new  IllegalStateException  ( "   ")  ;	[BUGGY]  throw  throw    new  IllegalStateException(   "Queue  did  not  match  expected  sequence ")    ;  [CONTEXT]  public  void  consume(String  seq)  {  if  (!matches(seq))  throw  new  IllegalStateException( "Queue  did  not  match  expected  sequence ");  int  len  =  seq.length();  if  (len  >  queue.size())  [BUGGY]  throw  thrownew  IllegalStateException  (   "Queue  did  not  match  expected  sequence "  )  ;  for  (int  i  =  0;  i  <  len;  i++)  {  consume();  }  }        [CLASS]  TokenQueue    [METHOD]  consume  [RETURN_TYPE]  void      String  seq  [VARIABLES]  String    seq    boolean    LinkedList    queue    int    i    len    
if  (  len  >  queue.size  (  )  )  throw  new  IllegalStateException  ( "   ")  ;	[BUGGY]  if  (  len  >  queue.size()  +  2  )throw  new  IllegalStateException  ( "   ")    ;  [CONTEXT]  public  void  consume(String  seq)  {  if  (!matches(seq))  throw  new  IllegalStateException( "Queue  did  not  match  expected  sequence ");  int  len  =  seq.length();  [BUGGY]  if(  len  >  queue.size()  +  2)  throw  new  IllegalStateException( "   ");    for  (int  i  =  0;  i  <  len;  i++)  {  consume();  }  }        [CLASS]  TokenQueue    [METHOD]  consume  [RETURN_TYPE]  void      String  seq  [VARIABLES]  String    seq    boolean    LinkedList    queue    int    i    len    
for  (  int  i  =  0;  i  <  len;  i++  )  {	[BUGGY]  for  (    short    i  =  0;  i  <  len;  i++)  {  [CONTEXT]  public  void  consume(String  seq)  {  if  (!matches(seq))  throw  new  IllegalStateException( "Queue  did  not  match  expected  sequence ");  int  len  =  seq.length();  if  (len  >  queue.size())  throw  new  IllegalStateException( "Queue  not  long  enough  to  consume  sequence ");  [BUGGY]  for(shorti  =  0;  i  <  len;  i++  ){  consume();  }  }        [CLASS]  TokenQueue    [METHOD]  consume  [RETURN_TYPE]  void      String  seq  [VARIABLES]  String    seq    boolean    LinkedList    queue    int    i    len    
for  (  int  i  =  0;  i  <  len;  i++  )  {	[BUGGY]  for  (  int  i  =  0;  i  >  len;  i++)  {  [CONTEXT]  public  void  consume(String  seq)  {  if  (!matches(seq))  throw  new  IllegalStateException( "Queue  did  not  match  expected  sequence ");  int  len  =  seq.length();  if  (len  >  queue.size())  throw  new  IllegalStateException( "Queue  not  long  enough  to  consume  sequence ");  [BUGGY]  for(  int  i  =  0;  i  >  len;  i++  ){  consume();  }  }        [CLASS]  TokenQueue    [METHOD]  consume  [RETURN_TYPE]  void      String  seq  [VARIABLES]  String    seq    boolean    LinkedList    queue    int    i    len    
for  (  int  i  =  0;  i  <  len;  i++  )  {	[BUGGY]  for  (  int  i  =  9;  i  <  len;  i++)  {  [CONTEXT]  public  void  consume(String  seq)  {  if  (!matches(seq))  throw  new  IllegalStateException( "Queue  did  not  match  expected  sequence ");  int  len  =  seq.length();  if  (len  >  queue.size())  throw  new  IllegalStateException( "Queue  not  long  enough  to  consume  sequence ");  [BUGGY]  for(  int  i  =  9;  i  <  len;  i++  ){  consume();  }  }        [CLASS]  TokenQueue    [METHOD]  consume  [RETURN_TYPE]  void      String  seq  [VARIABLES]  String    seq    boolean    LinkedList    queue    int    i    len    
for  (  int  i  =  0;  i  <  len;  i++  )  {	[BUGGY]  for  (  lennt  i  =  0;  i  <  len;  i++)  {  [CONTEXT]  public  void  consume(String  seq)  {  if  (!matches(seq))  throw  new  IllegalStateException( "Queue  did  not  match  expected  sequence ");  int  len  =  seq.length();  if  (len  >  queue.size())  throw  new  IllegalStateException( "Queue  not  long  enough  to  consume  sequence ");  [BUGGY]  for(  lennt  i  =  0;  i  <  len;  i++  ){  consume();  }  }        [CLASS]  TokenQueue    [METHOD]  consume  [RETURN_TYPE]  void      String  seq  [VARIABLES]  String    seq    boolean    LinkedList    queue    int    i    len    
for  (  int  i  =  0;  i  <  len;  i++  )  {	[BUGGY]  for  (  lennt  i  =  0;  i  <  i;  i++)  {  [CONTEXT]  public  void  consume(String  seq)  {  if  (!matches(seq))  throw  new  IllegalStateException( "Queue  did  not  match  expected  sequence ");  int  len  =  seq.length();  if  (len  >  queue.size())  throw  new  IllegalStateException( "Queue  not  long  enough  to  consume  sequence ");  [BUGGY]  for(  lennt  i  =  0;  i  <  i;  i++  ){  consume();  }  }        [CLASS]  TokenQueue    [METHOD]  consume  [RETURN_TYPE]  void      String  seq  [VARIABLES]  String    seq    boolean    LinkedList    queue    int    i    len    
consume  (  )  ;	[BUGGY]    [CONTEXT]  public  void  consume(String  seq)  {  if  (!matches(seq))  throw  new  IllegalStateException( "Queue  did  not  match  expected  sequence ");  int  len  =  seq.length();  if  (len  >  queue.size())  throw  new  IllegalStateException( "Queue  not  long  enough  to  consume  sequence ");  for  (int  i  =  0;  i  <  len;  i++)  {  [BUGGY]  consume();    }        [CLASS]  TokenQueue    [METHOD]  consume  [RETURN_TYPE]  void      String  seq  [VARIABLES]  String    seq    boolean    LinkedList    queue    int    i    len    
for  (  int  i  =  0;  i  <  len;  i++  )  {	[BUGGY]  for  (  int  i  =  i;  i  <  len;  i++)  {  [CONTEXT]  public  void  consume(String  seq)  {  if  (!matches(seq))  throw  new  IllegalStateException( "Queue  did  not  match  expected  sequence ");  int  len  =  seq.length();  if  (len  >  queue.size())  throw  new  IllegalStateException( "Queue  not  long  enough  to  consume  sequence ");  [BUGGY]  for(  int  i  =  i;  i  <  len;  i++  ){  consume();  }  }        [CLASS]  TokenQueue    [METHOD]  consume  [RETURN_TYPE]  void      String  seq  [VARIABLES]  String    seq    boolean    LinkedList    queue    int    i    len    
return  consumeToAny  (  seq  )  ;	[BUGGY]  return  consumeTo(  seq);  [CONTEXT]  public  String  consumeTo(String  seq)  {  [BUGGY]  return  consumeTo  (  seq  )  ;  }        [CLASS]  TokenQueue    [METHOD]  consumeTo  [RETURN_TYPE]  String      String  seq  [VARIABLES]  LinkedList    queue    String    seq    boolean    
return  consumeToAny  (  seq  )  ;	[BUGGY]    [CONTEXT]  public  String  consumeTo(String  seq)  {  [BUGGY]  return  consumeToAny(seq);          [CLASS]  TokenQueue    [METHOD]  consumeTo  [RETURN_TYPE]  String      String  seq  [VARIABLES]  LinkedList    queue    String    seq    boolean    
while  (  !queue.isEmpty  (  )  &&  !matchesAny  (  seq  )  )  accum.append  (  consume  (  )  )  ;	[BUGGY]  while  (  !queue.isEmpty(  )  ||  !matchesAny(  seq))accum.append(  consume(  ));  [CONTEXT]  public  String  consumeToAny(String...  seq)  {  StringBuilder  accum  =  new  StringBuilder();  [BUGGY]  while(  !queue.isEmpty  ()||  !matchesAny  (  seq  ))  accum.append  (  consume  ())  ;      return  accum.toString();  }        [CLASS]  TokenQueue    [METHOD]  consumeToAny  [RETURN_TYPE]  String        seq  [VARIABLES]  String[]    seq    boolean    StringBuilder    accum    LinkedList    queue    
while  (  !queue.isEmpty  (  )  &&  !matchesAny  (  seq  )  )  accum.append  (  consume  (  )  )  ;	[BUGGY]  while  (  !queue.isEmpty(  )  &&  !matchesAny(  accum))seq.append(  consume(  ));  [CONTEXT]  public  String  consumeToAny(String...  seq)  {  StringBuilder  accum  =  new  StringBuilder();  [BUGGY]  while(  !queue.isEmpty  ()&&  !matchesAny  (  accum  ))  seq.append  (  consume  ())  ;      return  accum.toString();  }        [CLASS]  TokenQueue    [METHOD]  consumeToAny  [RETURN_TYPE]  String        seq  [VARIABLES]  String[]    seq    boolean    StringBuilder    accum    LinkedList    queue    
while  (  !queue.isEmpty  (  )  &&  !matchesAny  (  seq  )  )  accum.append  (  consume  (  )  )  ;	[BUGGY]  while  (  !queue.peek(  )  &&  !matchesAny(  seq))accum.append(  consume(  ));  [CONTEXT]  public  String  consumeToAny(String...  seq)  {  StringBuilder  accum  =  new  StringBuilder();  [BUGGY]  while(  !queue.peek  ()&&  !matchesAny  (  seq  ))  accum.append  (  consume  ())  ;      return  accum.toString();  }        [CLASS]  TokenQueue    [METHOD]  consumeToAny  [RETURN_TYPE]  String        seq  [VARIABLES]  String[]    seq    boolean    StringBuilder    accum    LinkedList    queue    
while  (  !queue.isEmpty  (  )  &&  !matchesAny  (  seq  )  )  accum.append  (  consume  (  )  )  ;	[BUGGY]  while  (  !queue.isEmpty(  )  &&  !matches(  seq))accum.append(  consume(  ));  [CONTEXT]  public  String  consumeToAny(String...  seq)  {  StringBuilder  accum  =  new  StringBuilder();  [BUGGY]  while(  !queue.isEmpty  ()&&  !matches  (  seq  ))  accum.append  (  consume  ())  ;      return  accum.toString();  }        [CLASS]  TokenQueue    [METHOD]  consumeToAny  [RETURN_TYPE]  String        seq  [VARIABLES]  String[]    seq    boolean    StringBuilder    accum    LinkedList    queue    
accum.append  (  consume  (  )  )  ;	[BUGGY]    [CONTEXT]  public  String  consumeToAny(String...  seq)  {  StringBuilder  accum  =  new  StringBuilder();  while  (!queue.isEmpty()  &&  !matchesAny(seq))  [BUGGY]  accum.append(consume());      return  accum.toString();        [CLASS]  TokenQueue    [METHOD]  consumeToAny  [RETURN_TYPE]  String        seq  [VARIABLES]  String[]    seq    boolean    StringBuilder    accum    LinkedList    queue    
while  (  !queue.isEmpty  (  )  &&  !matchesAny  (  seq  )  )  accum.append  (  consume  (  )  )  ;	[BUGGY]    [CONTEXT]  public  String  consumeToAny(String...  seq)  {  StringBuilder  accum  =  new  StringBuilder();  [BUGGY]  while  (!queue.isEmpty()  &&  !matchesAny(seq))        return  accum.toString();        [CLASS]  TokenQueue    [METHOD]  consumeToAny  [RETURN_TYPE]  String        seq  [VARIABLES]  String[]    seq    boolean    StringBuilder    accum    LinkedList    queue    
while  (  !queue.isEmpty  (  )  &&  !matchesAny  (  seq  )  )  accum.append  (  consume  (  )  )  ;	[BUGGY]  while  (  !queue.isEmpty(  )  &&  Character.isWhitespace(  queue.peek(  )))  {  consume(  );while  (  !queue.isEmpty(  )  &&  !matchesAny(  seq))accum.append(  consume(  ));  [CONTEXT]        [CLASS]  TokenQueue    [METHOD]  consumeToAny  [RETURN_TYPE]  String        seq  [VARIABLES]  String[]    seq    boolean    StringBuilder    accum    LinkedList    queue    
while  (  !queue.isEmpty  (  )  &&  !matchesAny  (  seq  )  )  accum.append  (  consume  (  )  )  ;	[BUGGY]  while  (  !queue.isEmpty(  ))  {  accum.append(  consume(  ));while  (  !queue.isEmpty(  )  &&  !matchesAny(  seq))accum.append(  consume(  ));  [CONTEXT]        [CLASS]  TokenQueue    [METHOD]  consumeToAny  [RETURN_TYPE]  String        seq  [VARIABLES]  String[]    seq    boolean    StringBuilder    accum    LinkedList    queue    
while  (  !queue.isEmpty  (  )  &&  !matchesAny  (  seq  )  )  accum.append  (  consume  (  )  )  ;	[BUGGY]  while  (  !queue.isEmpty(  )  &&  Character.isLetterOrDigit(  queue.peek(  )))  {  wordAccum.append(  queue.removeFirst(  ));while  (  !queue.isEmpty(  )  &&  !matchesAny(  seq))accum.append(  consume(  ));  [CONTEXT]        [CLASS]  TokenQueue    [METHOD]  consumeToAny  [RETURN_TYPE]  String        seq  [VARIABLES]  String[]    seq    boolean    StringBuilder    accum    LinkedList    queue    
accum.append  (  consume  (  )  )  ;	[BUGGY]  accum  .toString(  )  ;  [CONTEXT]  public  String  consumeToAny(String...  seq)  {  StringBuilder  accum  =  new  StringBuilder();  while  (!queue.isEmpty()  &&  !matchesAny(seq))  [BUGGY]  accum  .toString  ();    return  accum.toString();  }        [CLASS]  TokenQueue    [METHOD]  consumeToAny  [RETURN_TYPE]  String        seq  [VARIABLES]  String[]    seq    boolean    StringBuilder    accum    LinkedList    queue    
return  accum.toString  (  )  ;	[BUGGY]  return  accum.append(  );  [CONTEXT]  public  String  consumeToAny(String...  seq)  {  StringBuilder  accum  =  new  StringBuilder();  while  (!queue.isEmpty()  &&  !matchesAny(seq))  accum.append(consume());    [BUGGY]  return  accum.append  ()  ;  }        [CLASS]  TokenQueue    [METHOD]  consumeToAny  [RETURN_TYPE]  String        seq  [VARIABLES]  String[]    seq    boolean    StringBuilder    accum    LinkedList    queue    
return  accum.toString  (  )  ;	[BUGGY]    [CONTEXT]  public  String  consumeToAny(String...  seq)  {  StringBuilder  accum  =  new  StringBuilder();  while  (!queue.isEmpty()  &&  !matchesAny(seq))  accum.append(consume());    [BUGGY]  return  accum.toString();          [CLASS]  TokenQueue    [METHOD]  consumeToAny  [RETURN_TYPE]  String        seq  [VARIABLES]  String[]    seq    boolean    StringBuilder    accum    LinkedList    queue    
String  data  =  consumeTo  (  seq  )  ;	[BUGGY]  char  data  =  consumeTo(  seq);  [CONTEXT]  public  String  chompTo(String  seq)  {  [BUGGY]  char  data  =  consumeTo  (  seq  )  ;  matchChomp(seq);  return  data;  }        [CLASS]  TokenQueue    [METHOD]  chompTo  [RETURN_TYPE]  String      String  seq  [VARIABLES]  LinkedList    queue    String    data    seq    boolean    
String  data  =  consumeTo  (  seq  )  ;	[BUGGY]  String  data  =  consume(  seq);  [CONTEXT]  public  String  chompTo(String  seq)  {  [BUGGY]  String  data  =  consume  (  seq  )  ;  matchChomp(seq);  return  data;  }        [CLASS]  TokenQueue    [METHOD]  chompTo  [RETURN_TYPE]  String      String  seq  [VARIABLES]  LinkedList    queue    String    data    seq    boolean    
String  data  =  consumeTo  (  seq  )  ;	[BUGGY]  String  data  =  consumeTo(  data);  [CONTEXT]  public  String  chompTo(String  seq)  {  [BUGGY]  String  data  =  consumeTo  (  data  )  ;  matchChomp(seq);  return  data;  }        [CLASS]  TokenQueue    [METHOD]  chompTo  [RETURN_TYPE]  String      String  seq  [VARIABLES]  LinkedList    queue    String    data    seq    boolean    
String  data  =  consumeTo  (  seq  )  ;  matchChomp  (  seq  )  ;	[BUGGY]    [CONTEXT]  public  String  chompTo(String  seq)  {  [BUGGY]  String  data  =  consumeTo(seq);      return  data;        [CLASS]  TokenQueue    [METHOD]  chompTo  [RETURN_TYPE]  String      String  seq  [VARIABLES]  LinkedList    queue    String    data    seq    boolean    
String  data  =  consumeTo  (  seq  )  ;	[BUGGY]  return  consumeToAny(  seq);String  data  =  consumeTo(  seq);  [CONTEXT]        [CLASS]  TokenQueue    [METHOD]  chompTo  [RETURN_TYPE]  String      String  seq  [VARIABLES]  LinkedList    queue    String    data    seq    boolean    
String  data  =  consumeTo  (  seq  )  ;	[BUGGY]  consume(  seq);String  data  =  consumeTo(  seq);  [CONTEXT]        [CLASS]  TokenQueue    [METHOD]  chompTo  [RETURN_TYPE]  String      String  seq  [VARIABLES]  LinkedList    queue    String    data    seq    boolean    
matchChomp  (  seq  )  ;	[BUGGY]  matchChomp(  data);  [CONTEXT]  public  String  chompTo(String  seq)  {  String  data  =  consumeTo(seq);  [BUGGY]  matchChomp  (  data  )  ;  return  data;  }        [CLASS]  TokenQueue    [METHOD]  chompTo  [RETURN_TYPE]  String      String  seq  [VARIABLES]  LinkedList    queue    String    data    seq    boolean    
matchChomp  (  seq  )  ;	[BUGGY]  matches(  seq);  [CONTEXT]  public  String  chompTo(String  seq)  {  String  data  =  consumeTo(seq);  [BUGGY]  matches  (  seq  )  ;  return  data;  }        [CLASS]  TokenQueue    [METHOD]  chompTo  [RETURN_TYPE]  String      String  seq  [VARIABLES]  LinkedList    queue    String    data    seq    boolean    
matchChomp  (  seq  )  ;	[BUGGY]    [CONTEXT]  public  String  chompTo(String  seq)  {  String  data  =  consumeTo(seq);  [BUGGY]  matchChomp(seq);    return  data;        [CLASS]  TokenQueue    [METHOD]  chompTo  [RETURN_TYPE]  String      String  seq  [VARIABLES]  LinkedList    queue    String    data    seq    boolean    
matchChomp  (  seq  )  ;	[BUGGY]  return  data;  matchChomp(  seq);  [CONTEXT]        [CLASS]  TokenQueue    [METHOD]  chompTo  [RETURN_TYPE]  String      String  seq  [VARIABLES]  LinkedList    queue    String    data    seq    boolean    
matchChomp  (  seq  )  ;	[BUGGY]  consume(  seq);matchChomp(  seq);  [CONTEXT]        [CLASS]  TokenQueue    [METHOD]  chompTo  [RETURN_TYPE]  String      String  seq  [VARIABLES]  LinkedList    queue    String    data    seq    boolean    
return  data;	[BUGGY]  return  seq;  [CONTEXT]  public  String  chompTo(String  seq)  {  String  data  =  consumeTo(seq);  matchChomp(seq);  [BUGGY]  return  seq;  }        [CLASS]  TokenQueue    [METHOD]  chompTo  [RETURN_TYPE]  String      String  seq  [VARIABLES]  LinkedList    queue    String    data    seq    boolean    
boolean  seen  =  false;	[BUGGY]  boolean  seen  =  true;  [CONTEXT]  public  boolean  consumeWhitespace()  {  [BUGGY]  boolean  seen  =  true;  while  (!queue.isEmpty()  &&  Character.isWhitespace(queue.peek()))  {  consume();  seen  =  true;  }  return  seen;  }        [CLASS]  TokenQueue    [METHOD]  consumeWhitespace  [RETURN_TYPE]  boolean      [VARIABLES]  LinkedList    queue    boolean    seen    
while  (  !queue.isEmpty  (  )  &&  Character.isWhitespace  (  queue.peek  (  )  )  )  {	[BUGGY]  while  (  !queue.isEmpty(  )  ||  Character.isWhitespace(  queue.peek(  )))  {  [CONTEXT]  public  boolean  consumeWhitespace()  {  boolean  seen  =  false;  [BUGGY]  while(  !queue.isEmpty  ()||  Character.isWhitespace  (  queue.peek  ())){  consume();  seen  =  true;  }  return  seen;  }        [CLASS]  TokenQueue    [METHOD]  consumeWhitespace  [RETURN_TYPE]  boolean      [VARIABLES]  LinkedList    queue    boolean    seen    
while  (  !queue.isEmpty  (  )  &&  Character.isWhitespace  (  queue.peek  (  )  )  )  {	[BUGGY]  while  (  !queue.peek(  )  &&  Character.isWhitespace(  queue.peek(  )))  {  [CONTEXT]  public  boolean  consumeWhitespace()  {  boolean  seen  =  false;  [BUGGY]  while(  !queue.peek  ()&&  Character.isWhitespace  (  queue.peek  ())){  consume();  seen  =  true;  }  return  seen;  }        [CLASS]  TokenQueue    [METHOD]  consumeWhitespace  [RETURN_TYPE]  boolean      [VARIABLES]  LinkedList    queue    boolean    seen    
while  (  !queue.isEmpty  (  )  &&  Character.isWhitespace  (  queue.peek  (  )  )  )  {	[BUGGY]  while  (  !queue.isEmpty(  )  &&  Character.toLowerCase(  queue.peek(  )))  {  [CONTEXT]  public  boolean  consumeWhitespace()  {  boolean  seen  =  false;  [BUGGY]  while(  !queue.isEmpty  ()&&  Character.toLowerCase  (  queue.peek  ())){  consume();  seen  =  true;  }  return  seen;  }        [CLASS]  TokenQueue    [METHOD]  consumeWhitespace  [RETURN_TYPE]  boolean      [VARIABLES]  LinkedList    queue    boolean    seen    
while  (  !queue.isEmpty  (  )  &&  Character.isWhitespace  (  queue.peek  (  )  )  )  {	[BUGGY]  while  (  !queue.isEmpty(  )  &&  Character.isWhitespace(  queue.size(  )))  {  [CONTEXT]  public  boolean  consumeWhitespace()  {  boolean  seen  =  false;  [BUGGY]  while(  !queue.isEmpty  ()&&  Character.isWhitespace  (  queue.size  ())){  consume();  seen  =  true;  }  return  seen;  }        [CLASS]  TokenQueue    [METHOD]  consumeWhitespace  [RETURN_TYPE]  boolean      [VARIABLES]  LinkedList    queue    boolean    seen    
seen  =  true;	[BUGGY]  seen  =  false;  [CONTEXT]  public  boolean  consumeWhitespace()  {  boolean  seen  =  false;  while  (!queue.isEmpty()  &&  Character.isWhitespace(queue.peek()))  {  consume();  [BUGGY]  seen  =  false;  }  return  seen;  }        [CLASS]  TokenQueue    [METHOD]  consumeWhitespace  [RETURN_TYPE]  boolean      [VARIABLES]  LinkedList    queue    boolean    seen    
consume  (  )  ;  seen  =  true;	[BUGGY]    [CONTEXT]  public  boolean  consumeWhitespace()  {  boolean  seen  =  false;  while  (!queue.isEmpty()  &&  Character.isWhitespace(queue.peek()))  {  [BUGGY]  consume();      }  return  seen;        [CLASS]  TokenQueue    [METHOD]  consumeWhitespace  [RETURN_TYPE]  boolean      [VARIABLES]  LinkedList    queue    boolean    seen    
consume  (  )  ;	[BUGGY]    consume(  );  [CONTEXT]        [CLASS]  TokenQueue    [METHOD]  consumeWhitespace  [RETURN_TYPE]  boolean      [VARIABLES]  LinkedList    queue    boolean    seen    
consume  (  )  ;	[BUGGY]  consume(  seq);consume(  );  [CONTEXT]        [CLASS]  TokenQueue    [METHOD]  consumeWhitespace  [RETURN_TYPE]  boolean      [VARIABLES]  LinkedList    queue    boolean    seen    
while  (  !queue.isEmpty  (  )  &&  Character.isWhitespace  (  queue.peek  (  )  )  )  {	[BUGGY]  while  (  !queue.isEmpty(  )  &&  Character.isWhitespace(  3.peek(  )))  {  [CONTEXT]  public  boolean  consumeWhitespace()  {  boolean  seen  =  false;  [BUGGY]  while(  !queue.isEmpty  ()&&  Character.isWhitespace  (  3.peek  ())){  consume();  seen  =  true;  }  return  seen;  }        [CLASS]  TokenQueue    [METHOD]  consumeWhitespace  [RETURN_TYPE]  boolean      [VARIABLES]  LinkedList    queue    boolean    seen    
while  (  !queue.isEmpty  (  )  &&  Character.isWhitespace  (  queue.peek  (  )  )  )  {  consume  (  )  ;	[BUGGY]    [CONTEXT]  public  boolean  consumeWhitespace()  {  boolean  seen  =  false;  [BUGGY]  while  (!queue.isEmpty()  &&  Character.isWhitespace(queue.peek()))  {      seen  =  true;  }  return  seen;        [CLASS]  TokenQueue    [METHOD]  consumeWhitespace  [RETURN_TYPE]  boolean      [VARIABLES]  LinkedList    queue    boolean    seen    
while  (  !queue.isEmpty  (  )  &&  Character.isWhitespace  (  queue.peek  (  )  )  )  {	[BUGGY]  while  (  !queue.isEmpty(  )  &&  Character.isWhitespace(  queue.peek(  )))  {  consume(  );while  (  !queue.isEmpty(  )  &&  Character.isWhitespace(  queue.peek(  )))  {  [CONTEXT]        [CLASS]  TokenQueue    [METHOD]  consumeWhitespace  [RETURN_TYPE]  boolean      [VARIABLES]  LinkedList    queue    boolean    seen    
while  (  !queue.isEmpty  (  )  &&  Character.isWhitespace  (  queue.peek  (  )  )  )  {	[BUGGY]  while  (  !queue.isEmpty(  ))  {  accum.append(  consume(  ));while  (  !queue.isEmpty(  )  &&  Character.isWhitespace(  queue.peek(  )))  {  [CONTEXT]        [CLASS]  TokenQueue    [METHOD]  consumeWhitespace  [RETURN_TYPE]  boolean      [VARIABLES]  LinkedList    queue    boolean    seen    
while  (  !queue.isEmpty  (  )  &&  Character.isWhitespace  (  queue.peek  (  )  )  )  {	[BUGGY]  while  (  !queue.isEmpty(  )  &&  Character.isLetterOrDigit(  queue.peek(  )))  {  wordAccum.append(  queue.removeFirst(  ));while  (  !queue.isEmpty(  )  &&  Character.isWhitespace(  queue.peek(  )))  {  [CONTEXT]        [CLASS]  TokenQueue    [METHOD]  consumeWhitespace  [RETURN_TYPE]  boolean      [VARIABLES]  LinkedList    queue    boolean    seen    
while  (  !queue.isEmpty  (  )  &&  Character.isWhitespace  (  queue.peek  (  )  )  )  {	[BUGGY]  return  !queue.isEmpty(  )  &&  Character.isWhitespace(  queue.peek(  ));while  (  !queue.isEmpty(  )  &&  Character.isWhitespace(  queue.peek(  )))  {  [CONTEXT]        [CLASS]  TokenQueue    [METHOD]  consumeWhitespace  [RETURN_TYPE]  boolean      [VARIABLES]  LinkedList    queue    boolean    seen    
while  (  !queue.isEmpty  (  )  &&  Character.isWhitespace  (  queue.peek  (  )  )  )  {	[BUGGY]  while  (  !queue.isEmpty(  )  &&  !matchesAny(  seq))accum.append(  consume(  ));while  (  !queue.isEmpty(  )  &&  Character.isWhitespace(  queue.peek(  )))  {  [CONTEXT]        [CLASS]  TokenQueue    [METHOD]  consumeWhitespace  [RETURN_TYPE]  boolean      [VARIABLES]  LinkedList    queue    boolean    seen    
while  (  !queue.isEmpty  (  )  &&  Character.isWhitespace  (  queue.peek  (  )  )  )  {	[BUGGY]  return  !queue.isEmpty(  )  &&  Character.isLetterOrDigit(  queue.peek(  ));while  (  !queue.isEmpty(  )  &&  Character.isWhitespace(  queue.peek(  )))  {  [CONTEXT]        [CLASS]  TokenQueue    [METHOD]  consumeWhitespace  [RETURN_TYPE]  boolean      [VARIABLES]  LinkedList    queue    boolean    seen    
while  (  !queue.isEmpty  (  )  &&  Character.isWhitespace  (  queue.peek  (  )  )  )  {	[BUGGY]  while  (  !queue.isEmpty(  )  &&  Character  .isLetterOrDigit(  )  )  {  [CONTEXT]  public  boolean  consumeWhitespace()  {  boolean  seen  =  false;  [BUGGY]  while(  !queue.isEmpty  ()&&  Character  .isLetterOrDigit  ()  ){  consume();  seen  =  true;  }  return  seen;  }        [CLASS]  TokenQueue    [METHOD]  consumeWhitespace  [RETURN_TYPE]  boolean      [VARIABLES]  LinkedList    queue    boolean    seen    
while  (  !queue.isEmpty  (  )  &&  Character.isWhitespace  (  queue.peek  (  )  )  )  {	[BUGGY]  while  (  !queue.isEmpty(  )  &&  Character.isWhitespace(  queue  .removeFirst(  )  ))  {  [CONTEXT]  public  boolean  consumeWhitespace()  {  boolean  seen  =  false;  [BUGGY]  while(  !queue.isEmpty  ()&&  Character.isWhitespace  (  queue  .removeFirst  ()  )){  consume();  seen  =  true;  }  return  seen;  }        [CLASS]  TokenQueue    [METHOD]  consumeWhitespace  [RETURN_TYPE]  boolean      [VARIABLES]  LinkedList    queue    boolean    seen    
consume  (  )  ;	[BUGGY]    [CONTEXT]  public  boolean  consumeWhitespace()  {  boolean  seen  =  false;  while  (!queue.isEmpty()  &&  Character.isWhitespace(queue.peek()))  {  [BUGGY]  consume();    seen  =  true;  }  return  seen;        [CLASS]  TokenQueue    [METHOD]  consumeWhitespace  [RETURN_TYPE]  boolean      [VARIABLES]  LinkedList    queue    boolean    seen    
while  (  !queue.isEmpty  (  )  &&  Character.isLetterOrDigit  (  queue.peek  (  )  )  )  {	[BUGGY]  while  (  !queue.isEmpty(  )  ||  Character.isLetterOrDigit(  queue.peek(  )))  {  [CONTEXT]  public  String  consumeWord()  {  StringBuilder  wordAccum  =  new  StringBuilder();  [BUGGY]  while(  !queue.isEmpty  ()||  Character.isLetterOrDigit  (  queue.peek  ())){  wordAccum.append(queue.removeFirst());  }  return  wordAccum.toString();  }        [CLASS]  TokenQueue    [METHOD]  consumeWord  [RETURN_TYPE]  String      [VARIABLES]  StringBuilder    wordAccum    LinkedList    queue    boolean    
while  (  !queue.isEmpty  (  )  &&  Character.isLetterOrDigit  (  queue.peek  (  )  )  )  {	[BUGGY]  while  (  !queue.peek(  )  &&  Character.isLetterOrDigit(  queue.peek(  )))  {  [CONTEXT]  public  String  consumeWord()  {  StringBuilder  wordAccum  =  new  StringBuilder();  [BUGGY]  while(  !queue.peek  ()&&  Character.isLetterOrDigit  (  queue.peek  ())){  wordAccum.append(queue.removeFirst());  }  return  wordAccum.toString();  }        [CLASS]  TokenQueue    [METHOD]  consumeWord  [RETURN_TYPE]  String      [VARIABLES]  StringBuilder    wordAccum    LinkedList    queue    boolean    
while  (  !queue.isEmpty  (  )  &&  Character.isLetterOrDigit  (  queue.peek  (  )  )  )  {	[BUGGY]  while  (  !queue.isEmpty(  )  &&  Character.isWhitespace(  queue.peek(  )))  {  [CONTEXT]  public  String  consumeWord()  {  StringBuilder  wordAccum  =  new  StringBuilder();  [BUGGY]  while(  !queue.isEmpty  ()&&  Character.isWhitespace  (  queue.peek  ())){  wordAccum.append(queue.removeFirst());  }  return  wordAccum.toString();  }        [CLASS]  TokenQueue    [METHOD]  consumeWord  [RETURN_TYPE]  String      [VARIABLES]  StringBuilder    wordAccum    LinkedList    queue    boolean    
while  (  !queue.isEmpty  (  )  &&  Character.isLetterOrDigit  (  queue.peek  (  )  )  )  {	[BUGGY]  while  (  !queue.isEmpty(  )  &&  Character.isLetterOrDigit(  queue.size(  )))  {  [CONTEXT]  public  String  consumeWord()  {  StringBuilder  wordAccum  =  new  StringBuilder();  [BUGGY]  while(  !queue.isEmpty  ()&&  Character.isLetterOrDigit  (  queue.size  ())){  wordAccum.append(queue.removeFirst());  }  return  wordAccum.toString();  }        [CLASS]  TokenQueue    [METHOD]  consumeWord  [RETURN_TYPE]  String      [VARIABLES]  StringBuilder    wordAccum    LinkedList    queue    boolean    
wordAccum.append  (  queue.removeFirst  (  )  )  ;	[BUGGY]  wordAccum  .toString(  )  ;  [CONTEXT]  public  String  consumeWord()  {  StringBuilder  wordAccum  =  new  StringBuilder();  while  (!queue.isEmpty()  &&  Character.isLetterOrDigit(queue.peek()))  {  [BUGGY]  wordAccum  .toString  ();  }  return  wordAccum.toString();  }        [CLASS]  TokenQueue    [METHOD]  consumeWord  [RETURN_TYPE]  String      [VARIABLES]  StringBuilder    wordAccum    LinkedList    queue    boolean    
wordAccum.append  (  queue.removeFirst  (  )  )  ;	[BUGGY]  wordAccum.append(  queue.peek(  ));  [CONTEXT]  public  String  consumeWord()  {  StringBuilder  wordAccum  =  new  StringBuilder();  while  (!queue.isEmpty()  &&  Character.isLetterOrDigit(queue.peek()))  {  [BUGGY]  wordAccum.append  (  queue.peek  ())  ;  }  return  wordAccum.toString();  }        [CLASS]  TokenQueue    [METHOD]  consumeWord  [RETURN_TYPE]  String      [VARIABLES]  StringBuilder    wordAccum    LinkedList    queue    boolean    
wordAccum.append  (  queue.removeFirst  (  )  )  ;	[BUGGY]    [CONTEXT]  public  String  consumeWord()  {  StringBuilder  wordAccum  =  new  StringBuilder();  while  (!queue.isEmpty()  &&  Character.isLetterOrDigit(queue.peek()))  {  [BUGGY]  wordAccum.append(queue.removeFirst());    }  return  wordAccum.toString();        [CLASS]  TokenQueue    [METHOD]  consumeWord  [RETURN_TYPE]  String      [VARIABLES]  StringBuilder    wordAccum    LinkedList    queue    boolean    
while  (  !queue.isEmpty  (  )  &&  Character.isLetterOrDigit  (  queue.peek  (  )  )  )  {  wordAccum.append  (  queue.removeFirst  (  )  )  ;	[BUGGY]    [CONTEXT]  public  String  consumeWord()  {  StringBuilder  wordAccum  =  new  StringBuilder();  [BUGGY]  while  (!queue.isEmpty()  &&  Character.isLetterOrDigit(queue.peek()))  {      }  return  wordAccum.toString();        [CLASS]  TokenQueue    [METHOD]  consumeWord  [RETURN_TYPE]  String      [VARIABLES]  StringBuilder    wordAccum    LinkedList    queue    boolean    
while  (  !queue.isEmpty  (  )  &&  Character.isLetterOrDigit  (  queue.peek  (  )  )  )  {	[BUGGY]  while  (  !queue.isEmpty(  )  &&  Character.isWhitespace(  queue.peek(  )))  {  consume(  );while  (  !queue.isEmpty(  )  &&  Character.isLetterOrDigit(  queue.peek(  )))  {  [CONTEXT]        [CLASS]  TokenQueue    [METHOD]  consumeWord  [RETURN_TYPE]  String      [VARIABLES]  StringBuilder    wordAccum    LinkedList    queue    boolean    
while  (  !queue.isEmpty  (  )  &&  Character.isLetterOrDigit  (  queue.peek  (  )  )  )  {	[BUGGY]  while  (  !queue.isEmpty(  ))  {  accum.append(  consume(  ));while  (  !queue.isEmpty(  )  &&  Character.isLetterOrDigit(  queue.peek(  )))  {  [CONTEXT]        [CLASS]  TokenQueue    [METHOD]  consumeWord  [RETURN_TYPE]  String      [VARIABLES]  StringBuilder    wordAccum    LinkedList    queue    boolean    
while  (  !queue.isEmpty  (  )  &&  Character.isLetterOrDigit  (  queue.peek  (  )  )  )  {	[BUGGY]  while  (  !queue.isEmpty(  )  &&  Character.isLetterOrDigit(  queue.peek(  )))  {  wordAccum.append(  queue.removeFirst(  ));while  (  !queue.isEmpty(  )  &&  Character.isLetterOrDigit(  queue.peek(  )))  {  [CONTEXT]        [CLASS]  TokenQueue    [METHOD]  consumeWord  [RETURN_TYPE]  String      [VARIABLES]  StringBuilder    wordAccum    LinkedList    queue    boolean    
while  (  !queue.isEmpty  (  )  &&  Character.isLetterOrDigit  (  queue.peek  (  )  )  )  {	[BUGGY]  return  !queue.isEmpty(  )  &&  Character.isWhitespace(  queue.peek(  ));while  (  !queue.isEmpty(  )  &&  Character.isLetterOrDigit(  queue.peek(  )))  {  [CONTEXT]        [CLASS]  TokenQueue    [METHOD]  consumeWord  [RETURN_TYPE]  String      [VARIABLES]  StringBuilder    wordAccum    LinkedList    queue    boolean    
while  (  !queue.isEmpty  (  )  &&  Character.isLetterOrDigit  (  queue.peek  (  )  )  )  {	[BUGGY]  while  (  !queue.isEmpty(  )  &&  !matchesAny(  seq))accum.append(  consume(  ));while  (  !queue.isEmpty(  )  &&  Character.isLetterOrDigit(  queue.peek(  )))  {  [CONTEXT]        [CLASS]  TokenQueue    [METHOD]  consumeWord  [RETURN_TYPE]  String      [VARIABLES]  StringBuilder    wordAccum    LinkedList    queue    boolean    
while  (  !queue.isEmpty  (  )  &&  Character.isLetterOrDigit  (  queue.peek  (  )  )  )  {	[BUGGY]  return  !queue.isEmpty(  )  &&  Character.isLetterOrDigit(  queue.peek(  ));while  (  !queue.isEmpty(  )  &&  Character.isLetterOrDigit(  queue.peek(  )))  {  [CONTEXT]        [CLASS]  TokenQueue    [METHOD]  consumeWord  [RETURN_TYPE]  String      [VARIABLES]  StringBuilder    wordAccum    LinkedList    queue    boolean    
while  (  !queue.isEmpty  (  )  &&  Character.isLetterOrDigit  (  queue.peek  (  )  )  )  {	[BUGGY]  while  (  !queue.isEmpty(  )  &&  (  Character.isLetterOrDigit(  queue.peek(  ))  ||  matchesAny(   "- ",   "_ ",   ": ")))  {  accum.append(  queue.removeFirst(  ));while  (  !queue.isEmpty(  )  &&  Character.isLetterOrDigit(  queue.peek(  )))  {  [CONTEXT]        [CLASS]  TokenQueue    [METHOD]  consumeWord  [RETURN_TYPE]  String      [VARIABLES]  StringBuilder    wordAccum    LinkedList    queue    boolean    
while  (  !queue.isEmpty  (  )  &&  Character.isLetterOrDigit  (  queue.peek  (  )  )  )  {	[BUGGY]  while  (  !queue.isEmpty(  )  &&  Character  .isLetterOrDigit(  )  )  {  [CONTEXT]  public  String  consumeWord()  {  StringBuilder  wordAccum  =  new  StringBuilder();  [BUGGY]  while(  !queue.isEmpty  ()&&  Character  .isLetterOrDigit  ()  ){  wordAccum.append(queue.removeFirst());  }  return  wordAccum.toString();  }        [CLASS]  TokenQueue    [METHOD]  consumeWord  [RETURN_TYPE]  String      [VARIABLES]  StringBuilder    wordAccum    LinkedList    queue    boolean    
wordAccum.append  (  queue.removeFirst  (  )  )  ;	[BUGGY]  wordAccum.append(  0.removeFirst(  ));  [CONTEXT]  public  String  consumeWord()  {  StringBuilder  wordAccum  =  new  StringBuilder();  while  (!queue.isEmpty()  &&  Character.isLetterOrDigit(queue.peek()))  {  [BUGGY]  wordAccum.append  (  0.removeFirst  ())  ;  }  return  wordAccum.toString();  }        [CLASS]  TokenQueue    [METHOD]  consumeWord  [RETURN_TYPE]  String      [VARIABLES]  StringBuilder    wordAccum    LinkedList    queue    boolean    
return  wordAccum.toString  (  )  ;	[BUGGY]  return  wordAccum.append(  );  [CONTEXT]  public  String  consumeWord()  {  StringBuilder  wordAccum  =  new  StringBuilder();  while  (!queue.isEmpty()  &&  Character.isLetterOrDigit(queue.peek()))  {  wordAccum.append(queue.removeFirst());  }  [BUGGY]  return  wordAccum.append  ()  ;  }        [CLASS]  TokenQueue    [METHOD]  consumeWord  [RETURN_TYPE]  String      [VARIABLES]  StringBuilder    wordAccum    LinkedList    queue    boolean    
return  wordAccum.toString  (  )  ;	[BUGGY]    [CONTEXT]  public  String  consumeWord()  {  StringBuilder  wordAccum  =  new  StringBuilder();  while  (!queue.isEmpty()  &&  Character.isLetterOrDigit(queue.peek()))  {  wordAccum.append(queue.removeFirst());  }  [BUGGY]  return  wordAccum.toString();          [CLASS]  TokenQueue    [METHOD]  consumeWord  [RETURN_TYPE]  String      [VARIABLES]  StringBuilder    wordAccum    LinkedList    queue    boolean    
StringBuilder  accum  =  new  StringBuilder  (  )  ;	[BUGGY]  while  (  !queue.isEmpty(  )  &&  (  Character.isLetterOrDigit(  c)  ||  c.equals(  '-')  ||  c.equals(  '_')))  {  StringBuilder  accum  =  new  StringBuilder(  );  [CONTEXT]        [CLASS]  TokenQueue    [METHOD]  consumeCssIdentifier  [RETURN_TYPE]  String      [VARIABLES]  boolean    StringBuilder    accum    Character    c    LinkedList    queue    
StringBuilder  accum  =  new  StringBuilder  (  )  ;	[BUGGY]  StringBuilder  wordAccum  =  new  StringBuilder(  );StringBuilder  accum  =  new  StringBuilder(  );  [CONTEXT]        [CLASS]  TokenQueue    [METHOD]  consumeCssIdentifier  [RETURN_TYPE]  String      [VARIABLES]  boolean    StringBuilder    accum    Character    c    LinkedList    queue    
Character  c  =  queue.peek  (  )  ;	[BUGGY]  Character  c  =  queue.size(  );  [CONTEXT]  public  String  consumeCssIdentifier()  {  StringBuilder  accum  =  new  StringBuilder();  [BUGGY]  Character  c  =  queue.size  ()  ;  while  (!queue.isEmpty()  &&  (Character.isLetterOrDigit(c)  ||  c.equals('-')  ||  c.equals('_')))  {  accum.append(queue.removeFirst());  c  =  queue.peek();  }  return  accum.toString();  }        [CLASS]  TokenQueue    [METHOD]  consumeCssIdentifier  [RETURN_TYPE]  String      [VARIABLES]  boolean    StringBuilder    accum    Character    c    LinkedList    queue    
Character  c  =  queue.peek  (  )  ;	[BUGGY]  Character  c  =  queue  .removeFirst(  )  ;  [CONTEXT]  public  String  consumeCssIdentifier()  {  StringBuilder  accum  =  new  StringBuilder();  [BUGGY]  Character  c  =  queue  .removeFirst  ();  while  (!queue.isEmpty()  &&  (Character.isLetterOrDigit(c)  ||  c.equals('-')  ||  c.equals('_')))  {  accum.append(queue.removeFirst());  c  =  queue.peek();  }  return  accum.toString();  }        [CLASS]  TokenQueue    [METHOD]  consumeCssIdentifier  [RETURN_TYPE]  String      [VARIABLES]  boolean    StringBuilder    accum    Character    c    LinkedList    queue    
Character  c  =  queue.peek  (  )  ;	[BUGGY]    [CONTEXT]  public  String  consumeCssIdentifier()  {  StringBuilder  accum  =  new  StringBuilder();  [BUGGY]  Character  c  =  queue.peek();    while  (!queue.isEmpty()  &&  (Character.isLetterOrDigit(c)  ||  c.equals('-')  ||  c.equals('_')))  {  accum.append(queue.removeFirst());  c  =  queue.peek();  }  return  accum.toString();        [CLASS]  TokenQueue    [METHOD]  consumeCssIdentifier  [RETURN_TYPE]  String      [VARIABLES]  boolean    StringBuilder    accum    Character    c    LinkedList    queue    
while  (  !queue.isEmpty  (  )  &&  (  Character.isLetterOrDigit  (  c  )  ||  c.equals  (  '-'  )  ||  c.equals  (  '_'  )  )  )  {	[BUGGY]  while  (  !queue.isEmpty(  )  ||  (  Character.isLetterOrDigit(  c)  ||  c.equals(  '-')  ||  c.equals(  '_')))  {  [CONTEXT]  public  String  consumeCssIdentifier()  {  StringBuilder  accum  =  new  StringBuilder();  Character  c  =  queue.peek();  [BUGGY]  while(  !queue.isEmpty  ()||(  Character.isLetterOrDigit  (  c  )||  c.equals  (  '-'  )||  c.equals  (  '_'  ))){  accum.append(queue.removeFirst());  c  =  queue.peek();  }  return  accum.toString();  }        [CLASS]  TokenQueue    [METHOD]  consumeCssIdentifier  [RETURN_TYPE]  String      [VARIABLES]  boolean    StringBuilder    accum    Character    c    LinkedList    queue    
while  (  !queue.isEmpty  (  )  &&  (  Character.isLetterOrDigit  (  c  )  ||  c.equals  (  '-'  )  ||  c.equals  (  '_'  )  )  )  {	[BUGGY]  while  (  !queue.isEmpty(  )  &&  (  Character.isLetterOrDigit(  c)  &&  c.equals(  '-')  ||  c.equals(  '_')))  {  [CONTEXT]  public  String  consumeCssIdentifier()  {  StringBuilder  accum  =  new  StringBuilder();  Character  c  =  queue.peek();  [BUGGY]  while(  !queue.isEmpty  ()&&(  Character.isLetterOrDigit  (  c  )&&  c.equals  (  '-'  )||  c.equals  (  '_'  ))){  accum.append(queue.removeFirst());  c  =  queue.peek();  }  return  accum.toString();  }        [CLASS]  TokenQueue    [METHOD]  consumeCssIdentifier  [RETURN_TYPE]  String      [VARIABLES]  boolean    StringBuilder    accum    Character    c    LinkedList    queue    
while  (  !queue.isEmpty  (  )  &&  (  Character.isLetterOrDigit  (  c  )  ||  c.equals  (  '-'  )  ||  c.equals  (  '_'  )  )  )  {	[BUGGY]  while  (  !queue.peek(  )  &&  (  Character.isLetterOrDigit(  c)  ||  c.equals(  '-')  ||  c.equals(  '_')))  {  [CONTEXT]  public  String  consumeCssIdentifier()  {  StringBuilder  accum  =  new  StringBuilder();  Character  c  =  queue.peek();  [BUGGY]  while(  !queue.peek  ()&&(  Character.isLetterOrDigit  (  c  )||  c.equals  (  '-'  )||  c.equals  (  '_'  ))){  accum.append(queue.removeFirst());  c  =  queue.peek();  }  return  accum.toString();  }        [CLASS]  TokenQueue    [METHOD]  consumeCssIdentifier  [RETURN_TYPE]  String      [VARIABLES]  boolean    StringBuilder    accum    Character    c    LinkedList    queue    
while  (  !queue.isEmpty  (  )  &&  (  Character.isLetterOrDigit  (  c  )  ||  c.equals  (  '-'  )  ||  c.equals  (  '_'  )  )  )  {	[BUGGY]  while  (  !queue.isEmpty(  )  &&  (  Character.toLowerCase(  c)  ||  c.equals(  '-')  ||  c.equals(  '_')))  {  [CONTEXT]  public  String  consumeCssIdentifier()  {  StringBuilder  accum  =  new  StringBuilder();  Character  c  =  queue.peek();  [BUGGY]  while(  !queue.isEmpty  ()&&(  Character.toLowerCase  (  c  )||  c.equals  (  '-'  )||  c.equals  (  '_'  ))){  accum.append(queue.removeFirst());  c  =  queue.peek();  }  return  accum.toString();  }        [CLASS]  TokenQueue    [METHOD]  consumeCssIdentifier  [RETURN_TYPE]  String      [VARIABLES]  boolean    StringBuilder    accum    Character    c    LinkedList    queue    
while  (  !queue.isEmpty  (  )  &&  (  Character.isLetterOrDigit  (  c  )  ||  c.equals  (  '-'  )  ||  c.equals  (  '_'  )  )  )  {	[BUGGY]  while  (  !queue.isEmpty(  )  &&  (  Character  .isWhitespace(  )    ||  c.equals(  '-')  ||  c.equals(  '_')))  {  [CONTEXT]  public  String  consumeCssIdentifier()  {  StringBuilder  accum  =  new  StringBuilder();  Character  c  =  queue.peek();  [BUGGY]  while(  !queue.isEmpty  ()&&(  Character  .isWhitespace  ()  ||  c.equals  (  '-'  )||  c.equals  (  '_'  ))){  accum.append(queue.removeFirst());  c  =  queue.peek();  }  return  accum.toString();  }        [CLASS]  TokenQueue    [METHOD]  consumeCssIdentifier  [RETURN_TYPE]  String      [VARIABLES]  boolean    StringBuilder    accum    Character    c    LinkedList    queue    
c  =  queue.peek  (  )  ;	[BUGGY]  c  =  queue.size(  );  [CONTEXT]  public  String  consumeCssIdentifier()  {  StringBuilder  accum  =  new  StringBuilder();  Character  c  =  queue.peek();  while  (!queue.isEmpty()  &&  (Character.isLetterOrDigit(c)  ||  c.equals('-')  ||  c.equals('_')))  {  accum.append(queue.removeFirst());  [BUGGY]  c  =  queue.size  ()  ;  }  return  accum.toString();  }        [CLASS]  TokenQueue    [METHOD]  consumeCssIdentifier  [RETURN_TYPE]  String      [VARIABLES]  boolean    StringBuilder    accum    Character    c    LinkedList    queue    
c  =  queue.peek  (  )  ;	[BUGGY]  c    =    c  ;  [CONTEXT]  public  String  consumeCssIdentifier()  {  StringBuilder  accum  =  new  StringBuilder();  Character  c  =  queue.peek();  while  (!queue.isEmpty()  &&  (Character.isLetterOrDigit(c)  ||  c.equals('-')  ||  c.equals('_')))  {  accum.append(queue.removeFirst());  [BUGGY]  c=c  ;  }  return  accum.toString();  }        [CLASS]  TokenQueue    [METHOD]  consumeCssIdentifier  [RETURN_TYPE]  String      [VARIABLES]  boolean    StringBuilder    accum    Character    c    LinkedList    queue    
accum.append  (  queue.removeFirst  (  )  )  ;	[BUGGY]  accum.append(  queue.peek(  ));  [CONTEXT]  public  String  consumeCssIdentifier()  {  StringBuilder  accum  =  new  StringBuilder();  Character  c  =  queue.peek();  while  (!queue.isEmpty()  &&  (Character.isLetterOrDigit(c)  ||  c.equals('-')  ||  c.equals('_')))  {  [BUGGY]  accum.append  (  queue.peek  ())  ;  c  =  queue.peek();  }  return  accum.toString();  }        [CLASS]  TokenQueue    [METHOD]  consumeCssIdentifier  [RETURN_TYPE]  String      [VARIABLES]  boolean    StringBuilder    accum    Character    c    LinkedList    queue    
accum.append  (  queue.removeFirst  (  )  )  ;	[BUGGY]    [CONTEXT]  public  String  consumeCssIdentifier()  {  StringBuilder  accum  =  new  StringBuilder();  Character  c  =  queue.peek();  while  (!queue.isEmpty()  &&  (Character.isLetterOrDigit(c)  ||  c.equals('-')  ||  c.equals('_')))  {  [BUGGY]  accum.append(queue.removeFirst());    c  =  queue.peek();  }  return  accum.toString();        [CLASS]  TokenQueue    [METHOD]  consumeCssIdentifier  [RETURN_TYPE]  String      [VARIABLES]  boolean    StringBuilder    accum    Character    c    LinkedList    queue    
accum.append  (  queue.removeFirst  (  )  )  ;	[BUGGY]  c  =  queue.peek(  );  accum.append(  queue.removeFirst(  ));  [CONTEXT]        [CLASS]  TokenQueue    [METHOD]  consumeCssIdentifier  [RETURN_TYPE]  String      [VARIABLES]  boolean    StringBuilder    accum    Character    c    LinkedList    queue    
accum.append  (  queue.removeFirst  (  )  )  ;	[BUGGY]  wordAccum.append(  queue.removeFirst(  ));accum.append(  queue.removeFirst(  ));  [CONTEXT]        [CLASS]  TokenQueue    [METHOD]  consumeCssIdentifier  [RETURN_TYPE]  String      [VARIABLES]  boolean    StringBuilder    accum    Character    c    LinkedList    queue    
accum.append  (  queue.removeFirst  (  )  )  ;	[BUGGY]  accum.append(  consume(  ));accum.append(  queue.removeFirst(  ));  [CONTEXT]        [CLASS]  TokenQueue    [METHOD]  consumeCssIdentifier  [RETURN_TYPE]  String      [VARIABLES]  boolean    StringBuilder    accum    Character    c    LinkedList    queue    
accum.append  (  queue.removeFirst  (  )  )  ;	[BUGGY]  return  queue.removeFirst(  );accum.append(  queue.removeFirst(  ));  [CONTEXT]        [CLASS]  TokenQueue    [METHOD]  consumeCssIdentifier  [RETURN_TYPE]  String      [VARIABLES]  boolean    StringBuilder    accum    Character    c    LinkedList    queue    
accum.append  (  queue.removeFirst  (  )  )  ;	[BUGGY]  accum.append(  queue  .addFirst(  c)  );  [CONTEXT]  public  String  consumeCssIdentifier()  {  StringBuilder  accum  =  new  StringBuilder();  Character  c  =  queue.peek();  while  (!queue.isEmpty()  &&  (Character.isLetterOrDigit(c)  ||  c.equals('-')  ||  c.equals('_')))  {  [BUGGY]  accum.append  (  queue  .addFirst  (  c  )  )  ;  c  =  queue.peek();  }  return  accum.toString();  }        [CLASS]  TokenQueue    [METHOD]  consumeCssIdentifier  [RETURN_TYPE]  String      [VARIABLES]  boolean    StringBuilder    accum    Character    c    LinkedList    queue    
accum.append  (  queue.removeFirst  (  )  )  ;  c  =  queue.peek  (  )  ;	[BUGGY]  c  =  queue.peek(  );  accum.append(  queue.removeFirst(  ));  [CONTEXT]        [CLASS]  TokenQueue    [METHOD]  consumeCssIdentifier  [RETURN_TYPE]  String      [VARIABLES]  boolean    StringBuilder    accum    Character    c    LinkedList    queue    
accum.append  (  queue.removeFirst  (  )  )  ;  c  =  queue.peek  (  )  ;	[BUGGY]  wordAccum.append(  queue.removeFirst(  ));accum.append(  queue.removeFirst(  ));  c  =  queue.peek(  );  [CONTEXT]        [CLASS]  TokenQueue    [METHOD]  consumeCssIdentifier  [RETURN_TYPE]  String      [VARIABLES]  boolean    StringBuilder    accum    Character    c    LinkedList    queue    
accum.append  (  queue.removeFirst  (  )  )  ;  c  =  queue.peek  (  )  ;	[BUGGY]  accum.append(  queue.removeFirst(  ));accum.append(  queue.removeFirst(  ));  c  =  queue.peek(  );  [CONTEXT]        [CLASS]  TokenQueue    [METHOD]  consumeCssIdentifier  [RETURN_TYPE]  String      [VARIABLES]  boolean    StringBuilder    accum    Character    c    LinkedList    queue    
c  =  queue.peek  (  )  ;	[BUGGY]  c  =  this.peek(  );  [CONTEXT]  public  String  consumeCssIdentifier()  {  StringBuilder  accum  =  new  StringBuilder();  Character  c  =  queue.peek();  while  (!queue.isEmpty()  &&  (Character.isLetterOrDigit(c)  ||  c.equals('-')  ||  c.equals('_')))  {  accum.append(queue.removeFirst());  [BUGGY]  c  =  this.peek  ()  ;  }  return  accum.toString();  }        [CLASS]  TokenQueue    [METHOD]  consumeCssIdentifier  [RETURN_TYPE]  String      [VARIABLES]  boolean    StringBuilder    accum    Character    c    LinkedList    queue    
c  =  queue.peek  (  )  ;	[BUGGY]  c  =  queue  .removeFirst(  )  ;  [CONTEXT]  public  String  consumeCssIdentifier()  {  StringBuilder  accum  =  new  StringBuilder();  Character  c  =  queue.peek();  while  (!queue.isEmpty()  &&  (Character.isLetterOrDigit(c)  ||  c.equals('-')  ||  c.equals('_')))  {  accum.append(queue.removeFirst());  [BUGGY]  c  =  queue  .removeFirst  ();  }  return  accum.toString();  }        [CLASS]  TokenQueue    [METHOD]  consumeCssIdentifier  [RETURN_TYPE]  String      [VARIABLES]  boolean    StringBuilder    accum    Character    c    LinkedList    queue    
c  =  queue.peek  (  )  ;	[BUGGY]    [CONTEXT]  public  String  consumeCssIdentifier()  {  StringBuilder  accum  =  new  StringBuilder();  Character  c  =  queue.peek();  while  (!queue.isEmpty()  &&  (Character.isLetterOrDigit(c)  ||  c.equals('-')  ||  c.equals('_')))  {  accum.append(queue.removeFirst());  [BUGGY]  c  =  queue.peek();    }  return  accum.toString();        [CLASS]  TokenQueue    [METHOD]  consumeCssIdentifier  [RETURN_TYPE]  String      [VARIABLES]  boolean    StringBuilder    accum    Character    c    LinkedList    queue    
c  =  queue.peek  (  )  ;	[BUGGY]  c  ;  [CONTEXT]  public  String  consumeCssIdentifier()  {  StringBuilder  accum  =  new  StringBuilder();  Character  c  =  queue.peek();  while  (!queue.isEmpty()  &&  (Character.isLetterOrDigit(c)  ||  c.equals('-')  ||  c.equals('_')))  {  accum.append(queue.removeFirst());  [BUGGY]  c  ;  }  return  accum.toString();  }        [CLASS]  TokenQueue    [METHOD]  consumeCssIdentifier  [RETURN_TYPE]  String      [VARIABLES]  boolean    StringBuilder    accum    Character    c    LinkedList    queue    
while  (  !queue.isEmpty  (  )  &&  (  Character.isLetterOrDigit  (  c  )  ||  c.equals  (  '-'  )  ||  c.equals  (  '_'  )  )  )  {  accum.append  (  queue.removeFirst  (  )  )  ;	[BUGGY]    [CONTEXT]  public  String  consumeCssIdentifier()  {  StringBuilder  accum  =  new  StringBuilder();  Character  c  =  queue.peek();  [BUGGY]  while  (!queue.isEmpty()  &&  (Character.isLetterOrDigit(c)  ||  c.equals('-')  ||  c.equals('_')))  {      c  =  queue.peek();  }  return  accum.toString();        [CLASS]  TokenQueue    [METHOD]  consumeCssIdentifier  [RETURN_TYPE]  String      [VARIABLES]  boolean    StringBuilder    accum    Character    c    LinkedList    queue    
while  (  !queue.isEmpty  (  )  &&  (  Character.isLetterOrDigit  (  c  )  ||  c.equals  (  '-'  )  ||  c.equals  (  '_'  )  )  )  {	[BUGGY]  while  (  !queue.isEmpty(  )  &&  Character.isWhitespace(  queue.peek(  )))  {  consume(  );while  (  !queue.isEmpty(  )  &&  (  Character.isLetterOrDigit(  c)  ||  c.equals(  '-')  ||  c.equals(  '_')))  {  [CONTEXT]        [CLASS]  TokenQueue    [METHOD]  consumeCssIdentifier  [RETURN_TYPE]  String      [VARIABLES]  boolean    StringBuilder    accum    Character    c    LinkedList    queue    
while  (  !queue.isEmpty  (  )  &&  (  Character.isLetterOrDigit  (  c  )  ||  c.equals  (  '-'  )  ||  c.equals  (  '_'  )  )  )  {	[BUGGY]  while  (  !queue.isEmpty(  )  &&  Character.isLetterOrDigit(  queue.peek(  )))  {  wordAccum.append(  queue.removeFirst(  ));while  (  !queue.isEmpty(  )  &&  (  Character.isLetterOrDigit(  c)  ||  c.equals(  '-')  ||  c.equals(  '_')))  {  [CONTEXT]        [CLASS]  TokenQueue    [METHOD]  consumeCssIdentifier  [RETURN_TYPE]  String      [VARIABLES]  boolean    StringBuilder    accum    Character    c    LinkedList    queue    
while  (  !queue.isEmpty  (  )  &&  (  Character.isLetterOrDigit  (  c  )  ||  c.equals  (  '-'  )  ||  c.equals  (  '_'  )  )  )  {	[BUGGY]  return  !queue.isEmpty(  )  &&  Character.isLetterOrDigit(  queue.peek(  ));while  (  !queue.isEmpty(  )  &&  (  Character.isLetterOrDigit(  c)  ||  c.equals(  '-')  ||  c.equals(  '_')))  {  [CONTEXT]        [CLASS]  TokenQueue    [METHOD]  consumeCssIdentifier  [RETURN_TYPE]  String      [VARIABLES]  boolean    StringBuilder    accum    Character    c    LinkedList    queue    
while  (  !queue.isEmpty  (  )  &&  (  Character.isLetterOrDigit  (  c  )  ||  c.equals  (  '-'  )  ||  c.equals  (  '_'  )  )  )  {	[BUGGY]  while  (  !queue.isEmpty(  )  &&  (  Character.isLetterOrDigit(  c)  ||  c.equals(  '-')  ||  c.equals(  '_')))  {  accum.append(  queue.removeFirst(  ));while  (  !queue.isEmpty(  )  &&  (  Character.isLetterOrDigit(  c)  ||  c.equals(  '-')  ||  c.equals(  '_')))  {  [CONTEXT]        [CLASS]  TokenQueue    [METHOD]  consumeCssIdentifier  [RETURN_TYPE]  String      [VARIABLES]  boolean    StringBuilder    accum    Character    c    LinkedList    queue    
while  (  !queue.isEmpty  (  )  &&  (  Character.isLetterOrDigit  (  c  )  ||  c.equals  (  '-'  )  ||  c.equals  (  '_'  )  )  )  {	[BUGGY]  while  (  !queue.isEmpty(  )  &&  (  Character.isLetterOrDigit(  queue.peek(  ))  ||  matchesAny(   "- ",   "_ ",   ": ")))  {  accum.append(  queue.removeFirst(  ));while  (  !queue.isEmpty(  )  &&  (  Character.isLetterOrDigit(  c)  ||  c.equals(  '-')  ||  c.equals(  '_')))  {  [CONTEXT]        [CLASS]  TokenQueue    [METHOD]  consumeCssIdentifier  [RETURN_TYPE]  String      [VARIABLES]  boolean    StringBuilder    accum    Character    c    LinkedList    queue    
accum.append  (  queue.removeFirst  (  )  )  ;	[BUGGY]  accum  .toString(  )  ;  [CONTEXT]  public  String  consumeCssIdentifier()  {  StringBuilder  accum  =  new  StringBuilder();  Character  c  =  queue.peek();  while  (!queue.isEmpty()  &&  (Character.isLetterOrDigit(c)  ||  c.equals('-')  ||  c.equals('_')))  {  [BUGGY]  accum  .toString  ();  c  =  queue.peek();  }  return  accum.toString();  }        [CLASS]  TokenQueue    [METHOD]  consumeCssIdentifier  [RETURN_TYPE]  String      [VARIABLES]  boolean    StringBuilder    accum    Character    c    LinkedList    queue    
accum.append  (  queue.removeFirst  (  )  )  ;  c  =  queue.peek  (  )  ;	[BUGGY]    [CONTEXT]  public  String  consumeCssIdentifier()  {  StringBuilder  accum  =  new  StringBuilder();  Character  c  =  queue.peek();  while  (!queue.isEmpty()  &&  (Character.isLetterOrDigit(c)  ||  c.equals('-')  ||  c.equals('_')))  {  [BUGGY]  accum.append(queue.removeFirst());      }  return  accum.toString();        [CLASS]  TokenQueue    [METHOD]  consumeCssIdentifier  [RETURN_TYPE]  String      [VARIABLES]  boolean    StringBuilder    accum    Character    c    LinkedList    queue    
accum.append  (  queue.removeFirst  (  )  )  ;	[BUGGY]  accum.append(  this.removeFirst(  ));  [CONTEXT]  public  String  consumeCssIdentifier()  {  StringBuilder  accum  =  new  StringBuilder();  Character  c  =  queue.peek();  while  (!queue.isEmpty()  &&  (Character.isLetterOrDigit(c)  ||  c.equals('-')  ||  c.equals('_')))  {  [BUGGY]  accum.append  (  this.removeFirst  ())  ;  c  =  queue.peek();  }  return  accum.toString();  }        [CLASS]  TokenQueue    [METHOD]  consumeCssIdentifier  [RETURN_TYPE]  String      [VARIABLES]  boolean    StringBuilder    accum    Character    c    LinkedList    queue    
accum.append  (  queue.removeFirst  (  )  )  ;	[BUGGY]    accum.append(  queue.removeFirst(  ));  [CONTEXT]        [CLASS]  TokenQueue    [METHOD]  consumeCssIdentifier  [RETURN_TYPE]  String      [VARIABLES]  boolean    StringBuilder    accum    Character    c    LinkedList    queue    
return  accum.toString  (  )  ;	[BUGGY]  return  accum.append(  );  [CONTEXT]  public  String  consumeCssIdentifier()  {  StringBuilder  accum  =  new  StringBuilder();  Character  c  =  queue.peek();  while  (!queue.isEmpty()  &&  (Character.isLetterOrDigit(c)  ||  c.equals('-')  ||  c.equals('_')))  {  accum.append(queue.removeFirst());  c  =  queue.peek();  }  [BUGGY]  return  accum.append  ()  ;  }        [CLASS]  TokenQueue    [METHOD]  consumeCssIdentifier  [RETURN_TYPE]  String      [VARIABLES]  boolean    StringBuilder    accum    Character    c    LinkedList    queue    
return  accum.toString  (  )  ;	[BUGGY]  return  accum  .append(  c)  ;  [CONTEXT]  public  String  consumeCssIdentifier()  {  StringBuilder  accum  =  new  StringBuilder();  Character  c  =  queue.peek();  while  (!queue.isEmpty()  &&  (Character.isLetterOrDigit(c)  ||  c.equals('-')  ||  c.equals('_')))  {  accum.append(queue.removeFirst());  c  =  queue.peek();  }  [BUGGY]  return  accum  .append  (  c  );  }        [CLASS]  TokenQueue    [METHOD]  consumeCssIdentifier  [RETURN_TYPE]  String      [VARIABLES]  boolean    StringBuilder    accum    Character    c    LinkedList    queue    
return  accum.toString  (  )  ;	[BUGGY]    [CONTEXT]  public  String  consumeCssIdentifier()  {  StringBuilder  accum  =  new  StringBuilder();  Character  c  =  queue.peek();  while  (!queue.isEmpty()  &&  (Character.isLetterOrDigit(c)  ||  c.equals('-')  ||  c.equals('_')))  {  accum.append(queue.removeFirst());  c  =  queue.peek();  }  [BUGGY]  return  accum.toString();          [CLASS]  TokenQueue    [METHOD]  consumeCssIdentifier  [RETURN_TYPE]  String      [VARIABLES]  boolean    StringBuilder    accum    Character    c    LinkedList    queue    
while  (  !queue.isEmpty  (  )  &&  (  Character.isLetterOrDigit  (  queue.peek  (  )  )  ||  matchesAny  (   "- ",   "_ ",   ": "  )  )  )  {	[BUGGY]  while  (  !queue.isEmpty(  )  ||  (  Character.isLetterOrDigit(  queue.peek(  ))  ||  matchesAny(   "- ",   "_ ",   ": ")))  {  [CONTEXT]  public  String  consumeAttributeKey()  {  StringBuilder  accum  =  new  StringBuilder();  [BUGGY]  while(  !queue.isEmpty  ()||(  Character.isLetterOrDigit  (  queue.peek  ())||  matchesAny  (   "- ",   "_ ",   ": "  ))){  accum.append(queue.removeFirst());  }  return  accum.toString();  }        [CLASS]  TokenQueue    [METHOD]  consumeAttributeKey  [RETURN_TYPE]  String      [VARIABLES]  StringBuilder    accum    LinkedList    queue    boolean    
while  (  !queue.isEmpty  (  )  &&  (  Character.isLetterOrDigit  (  queue.peek  (  )  )  ||  matchesAny  (   "- ",   "_ ",   ": "  )  )  )  {	[BUGGY]  while  (  !queue.isEmpty(  )  &&  (  Character.isLetterOrDigit(  queue.peek(  ))  &&  matchesAny(   "- ",   "_ ",   ": ")))  {  [CONTEXT]  public  String  consumeAttributeKey()  {  StringBuilder  accum  =  new  StringBuilder();  [BUGGY]  while(  !queue.isEmpty  ()&&(  Character.isLetterOrDigit  (  queue.peek  ())&&  matchesAny  (   "- ",   "_ ",   ": "  ))){  accum.append(queue.removeFirst());  }  return  accum.toString();  }        [CLASS]  TokenQueue    [METHOD]  consumeAttributeKey  [RETURN_TYPE]  String      [VARIABLES]  StringBuilder    accum    LinkedList    queue    boolean    
while  (  !queue.isEmpty  (  )  &&  (  Character.isLetterOrDigit  (  queue.peek  (  )  )  ||  matchesAny  (   "- ",   "_ ",   ": "  )  )  )  {	[BUGGY]  while  (  !queue.isEmpty(  )  &&  (  Character.isLetterOrDigit(  queue.peek(  ))  ||  matchesAny(   " ",   "_ ",   ": ")))  {  [CONTEXT]  public  String  consumeAttributeKey()  {  StringBuilder  accum  =  new  StringBuilder();  [BUGGY]  while(  !queue.isEmpty  ()&&(  Character.isLetterOrDigit  (  queue.peek  ())||  matchesAny  (   " ",   "_ ",   ": "  ))){  accum.append(queue.removeFirst());  }  return  accum.toString();  }        [CLASS]  TokenQueue    [METHOD]  consumeAttributeKey  [RETURN_TYPE]  String      [VARIABLES]  StringBuilder    accum    LinkedList    queue    boolean    
while  (  !queue.isEmpty  (  )  &&  (  Character.isLetterOrDigit  (  queue.peek  (  )  )  ||  matchesAny  (   "- ",   "_ ",   ": "  )  )  )  {	[BUGGY]  while  (  !queue.isEmpty(  )  &&  (  Character.isLetterOrDigit(  queue.peek(  ))  ||  matchesAny(   "- ",   " ",   ": ")))  {  [CONTEXT]  public  String  consumeAttributeKey()  {  StringBuilder  accum  =  new  StringBuilder();  [BUGGY]  while(  !queue.isEmpty  ()&&(  Character.isLetterOrDigit  (  queue.peek  ())||  matchesAny  (   "- ",   " ",   ": "  ))){  accum.append(queue.removeFirst());  }  return  accum.toString();  }        [CLASS]  TokenQueue    [METHOD]  consumeAttributeKey  [RETURN_TYPE]  String      [VARIABLES]  StringBuilder    accum    LinkedList    queue    boolean    
while  (  !queue.isEmpty  (  )  &&  (  Character.isLetterOrDigit  (  queue.peek  (  )  )  ||  matchesAny  (   "- ",   "_ ",   ": "  )  )  )  {	[BUGGY]  while  (  !queue.isEmpty(  )  &&  (  Character.isLetterOrDigit(  this.peek(  ))  ||  matchesAny(   "- ",   "_ ",   ": ")))  {  [CONTEXT]  public  String  consumeAttributeKey()  {  StringBuilder  accum  =  new  StringBuilder();  [BUGGY]  while(  !queue.isEmpty  ()&&(  Character.isLetterOrDigit  (  this.peek  ())||  matchesAny  (   "- ",   "_ ",   ": "  ))){  accum.append(queue.removeFirst());  }  return  accum.toString();  }        [CLASS]  TokenQueue    [METHOD]  consumeAttributeKey  [RETURN_TYPE]  String      [VARIABLES]  StringBuilder    accum    LinkedList    queue    boolean    
while  (  !queue.isEmpty  (  )  &&  (  Character.isLetterOrDigit  (  queue.peek  (  )  )  ||  matchesAny  (   "- ",   "_ ",   ": "  )  )  )  {	[BUGGY]  while  (  !queue.peek(  )  &&  (  Character.isLetterOrDigit(  queue.peek(  ))  ||  matchesAny(   "- ",   "_ ",   ": ")))  {  [CONTEXT]  public  String  consumeAttributeKey()  {  StringBuilder  accum  =  new  StringBuilder();  [BUGGY]  while(  !queue.peek  ()&&(  Character.isLetterOrDigit  (  queue.peek  ())||  matchesAny  (   "- ",   "_ ",   ": "  ))){  accum.append(queue.removeFirst());  }  return  accum.toString();  }        [CLASS]  TokenQueue    [METHOD]  consumeAttributeKey  [RETURN_TYPE]  String      [VARIABLES]  StringBuilder    accum    LinkedList    queue    boolean    
while  (  !queue.isEmpty  (  )  &&  (  Character.isLetterOrDigit  (  queue.peek  (  )  )  ||  matchesAny  (   "- ",   "_ ",   ": "  )  )  )  {	[BUGGY]  while  (  !queue.isEmpty(  )  &&  (  Character.isWhitespace(  queue.peek(  ))  ||  matchesAny(   "- ",   "_ ",   ": ")))  {  [CONTEXT]  public  String  consumeAttributeKey()  {  StringBuilder  accum  =  new  StringBuilder();  [BUGGY]  while(  !queue.isEmpty  ()&&(  Character.isWhitespace  (  queue.peek  ())||  matchesAny  (   "- ",   "_ ",   ": "  ))){  accum.append(queue.removeFirst());  }  return  accum.toString();  }        [CLASS]  TokenQueue    [METHOD]  consumeAttributeKey  [RETURN_TYPE]  String      [VARIABLES]  StringBuilder    accum    LinkedList    queue    boolean    
while  (  !queue.isEmpty  (  )  &&  (  Character.isLetterOrDigit  (  queue.peek  (  )  )  ||  matchesAny  (   "- ",   "_ ",   ": "  )  )  )  {	[BUGGY]  while  (  !queue.isEmpty(  )  &&  (  Character  .isLetterOrDigit(  )    ||  matchesAny(   "- ",   "_ ",   ": ")))  {  [CONTEXT]  public  String  consumeAttributeKey()  {  StringBuilder  accum  =  new  StringBuilder();  [BUGGY]  while(  !queue.isEmpty  ()&&(  Character  .isLetterOrDigit  ()  ||  matchesAny  (   "- ",   "_ ",   ": "  ))){  accum.append(queue.removeFirst());  }  return  accum.toString();  }        [CLASS]  TokenQueue    [METHOD]  consumeAttributeKey  [RETURN_TYPE]  String      [VARIABLES]  StringBuilder    accum    LinkedList    queue    boolean    
while  (  !queue.isEmpty  (  )  &&  (  Character.isLetterOrDigit  (  queue.peek  (  )  )  ||  matchesAny  (   "- ",   "_ ",   ": "  )  )  )  {	[BUGGY]  while  (  !queue.isEmpty(  )  &&  (  Character.isLetterOrDigit(  queue.size(  ))  ||  matchesAny(   "- ",   "_ ",   ": ")))  {  [CONTEXT]  public  String  consumeAttributeKey()  {  StringBuilder  accum  =  new  StringBuilder();  [BUGGY]  while(  !queue.isEmpty  ()&&(  Character.isLetterOrDigit  (  queue.size  ())||  matchesAny  (   "- ",   "_ ",   ": "  ))){  accum.append(queue.removeFirst());  }  return  accum.toString();  }        [CLASS]  TokenQueue    [METHOD]  consumeAttributeKey  [RETURN_TYPE]  String      [VARIABLES]  StringBuilder    accum    LinkedList    queue    boolean    
while  (  !queue.isEmpty  (  )  &&  (  Character.isLetterOrDigit  (  queue.peek  (  )  )  ||  matchesAny  (   "- ",   "_ ",   ": "  )  )  )  {	[BUGGY]  while  (  !queue.isEmpty(  )  &&  (  Character.isLetterOrDigit(  queue  .removeFirst(  )  )  ||  matchesAny(   "- ",   "_ ",   ": ")))  {  [CONTEXT]  public  String  consumeAttributeKey()  {  StringBuilder  accum  =  new  StringBuilder();  [BUGGY]  while(  !queue.isEmpty  ()&&(  Character.isLetterOrDigit  (  queue  .removeFirst  ()  )||  matchesAny  (   "- ",   "_ ",   ": "  ))){  accum.append(queue.removeFirst());  }  return  accum.toString();  }        [CLASS]  TokenQueue    [METHOD]  consumeAttributeKey  [RETURN_TYPE]  String      [VARIABLES]  StringBuilder    accum    LinkedList    queue    boolean    
accum.append  (  queue.removeFirst  (  )  )  ;	[BUGGY]  accum.append(  queue.peek(  ));  [CONTEXT]  public  String  consumeAttributeKey()  {  StringBuilder  accum  =  new  StringBuilder();  while  (!queue.isEmpty()  &&  (Character.isLetterOrDigit(queue.peek())  ||  matchesAny( "- ",   "_ ",   ": ")))  {  [BUGGY]  accum.append  (  queue.peek  ())  ;  }  return  accum.toString();  }        [CLASS]  TokenQueue    [METHOD]  consumeAttributeKey  [RETURN_TYPE]  String      [VARIABLES]  StringBuilder    accum    LinkedList    queue    boolean    
accum.append  (  queue.removeFirst  (  )  )  ;	[BUGGY]  accum  .toString(  )  ;  [CONTEXT]  public  String  consumeAttributeKey()  {  StringBuilder  accum  =  new  StringBuilder();  while  (!queue.isEmpty()  &&  (Character.isLetterOrDigit(queue.peek())  ||  matchesAny( "- ",   "_ ",   ": ")))  {  [BUGGY]  accum  .toString  ();  }  return  accum.toString();  }        [CLASS]  TokenQueue    [METHOD]  consumeAttributeKey  [RETURN_TYPE]  String      [VARIABLES]  StringBuilder    accum    LinkedList    queue    boolean    
accum.append  (  queue.removeFirst  (  )  )  ;	[BUGGY]    [CONTEXT]  public  String  consumeAttributeKey()  {  StringBuilder  accum  =  new  StringBuilder();  while  (!queue.isEmpty()  &&  (Character.isLetterOrDigit(queue.peek())  ||  matchesAny( "- ",   "_ ",   ": ")))  {  [BUGGY]  accum.append(queue.removeFirst());    }  return  accum.toString();        [CLASS]  TokenQueue    [METHOD]  consumeAttributeKey  [RETURN_TYPE]  String      [VARIABLES]  StringBuilder    accum    LinkedList    queue    boolean    
accum.append  (  queue.removeFirst  (  )  )  ;	[BUGGY]  accum.append(  3.removeFirst(  ));  [CONTEXT]  public  String  consumeAttributeKey()  {  StringBuilder  accum  =  new  StringBuilder();  while  (!queue.isEmpty()  &&  (Character.isLetterOrDigit(queue.peek())  ||  matchesAny( "- ",   "_ ",   ": ")))  {  [BUGGY]  accum.append  (  3.removeFirst  ())  ;  }  return  accum.toString();  }        [CLASS]  TokenQueue    [METHOD]  consumeAttributeKey  [RETURN_TYPE]  String      [VARIABLES]  StringBuilder    accum    LinkedList    queue    boolean    
while  (  !queue.isEmpty  (  )  &&  (  Character.isLetterOrDigit  (  queue.peek  (  )  )  ||  matchesAny  (   "- ",   "_ ",   ": "  )  )  )  {  accum.append  (  queue.removeFirst  (  )  )  ;	[BUGGY]    [CONTEXT]  public  String  consumeAttributeKey()  {  StringBuilder  accum  =  new  StringBuilder();  [BUGGY]  while  (!queue.isEmpty()  &&  (Character.isLetterOrDigit(queue.peek())  ||  matchesAny( "- ",   "_ ",   ": ")))  {      }  return  accum.toString();        [CLASS]  TokenQueue    [METHOD]  consumeAttributeKey  [RETURN_TYPE]  String      [VARIABLES]  StringBuilder    accum    LinkedList    queue    boolean    
while  (  !queue.isEmpty  (  )  &&  (  Character.isLetterOrDigit  (  queue.peek  (  )  )  ||  matchesAny  (   "- ",   "_ ",   ": "  )  )  )  {	[BUGGY]  while  (  !queue.isEmpty(  )  &&  Character.isWhitespace(  queue.peek(  )))  {  consume(  );while  (  !queue.isEmpty(  )  &&  (  Character.isLetterOrDigit(  queue.peek(  ))  ||  matchesAny(   "- ",   "_ ",   ": ")))  {  [CONTEXT]        [CLASS]  TokenQueue    [METHOD]  consumeAttributeKey  [RETURN_TYPE]  String      [VARIABLES]  StringBuilder    accum    LinkedList    queue    boolean    
while  (  !queue.isEmpty  (  )  &&  (  Character.isLetterOrDigit  (  queue.peek  (  )  )  ||  matchesAny  (   "- ",   "_ ",   ": "  )  )  )  {	[BUGGY]  while  (  !queue.isEmpty(  )  &&  Character.isLetterOrDigit(  queue.peek(  )))  {  wordAccum.append(  queue.removeFirst(  ));while  (  !queue.isEmpty(  )  &&  (  Character.isLetterOrDigit(  queue.peek(  ))  ||  matchesAny(   "- ",   "_ ",   ": ")))  {  [CONTEXT]        [CLASS]  TokenQueue    [METHOD]  consumeAttributeKey  [RETURN_TYPE]  String      [VARIABLES]  StringBuilder    accum    LinkedList    queue    boolean    
while  (  !queue.isEmpty  (  )  &&  (  Character.isLetterOrDigit  (  queue.peek  (  )  )  ||  matchesAny  (   "- ",   "_ ",   ": "  )  )  )  {	[BUGGY]  return  !queue.isEmpty(  )  &&  Character.isLetterOrDigit(  queue.peek(  ));while  (  !queue.isEmpty(  )  &&  (  Character.isLetterOrDigit(  queue.peek(  ))  ||  matchesAny(   "- ",   "_ ",   ": ")))  {  [CONTEXT]        [CLASS]  TokenQueue    [METHOD]  consumeAttributeKey  [RETURN_TYPE]  String      [VARIABLES]  StringBuilder    accum    LinkedList    queue    boolean    
while  (  !queue.isEmpty  (  )  &&  (  Character.isLetterOrDigit  (  queue.peek  (  )  )  ||  matchesAny  (   "- ",   "_ ",   ": "  )  )  )  {	[BUGGY]  while  (  !queue.isEmpty(  )  &&  (  Character.isLetterOrDigit(  c)  ||  c.equals(  '-')  ||  c.equals(  '_')))  {  accum.append(  queue.removeFirst(  ));while  (  !queue.isEmpty(  )  &&  (  Character.isLetterOrDigit(  queue.peek(  ))  ||  matchesAny(   "- ",   "_ ",   ": ")))  {  [CONTEXT]        [CLASS]  TokenQueue    [METHOD]  consumeAttributeKey  [RETURN_TYPE]  String      [VARIABLES]  StringBuilder    accum    LinkedList    queue    boolean    
while  (  !queue.isEmpty  (  )  &&  (  Character.isLetterOrDigit  (  queue.peek  (  )  )  ||  matchesAny  (   "- ",   "_ ",   ": "  )  )  )  {	[BUGGY]  while  (  !queue.isEmpty(  )  &&  (  Character.isLetterOrDigit(  queue.peek(  ))  ||  matchesAny(   "- ",   "_ ",   ": ")))  {  accum.append(  queue.removeFirst(  ));while  (  !queue.isEmpty(  )  &&  (  Character.isLetterOrDigit(  queue.peek(  ))  ||  matchesAny(   "- ",   "_ ",   ": ")))  {  [CONTEXT]        [CLASS]  TokenQueue    [METHOD]  consumeAttributeKey  [RETURN_TYPE]  String      [VARIABLES]  StringBuilder    accum    LinkedList    queue    boolean    
while  (  !queue.isEmpty  (  )  &&  (  Character.isLetterOrDigit  (  queue.peek  (  )  )  ||  matchesAny  (   "- ",   "_ ",   ": "  )  )  )  {	[BUGGY]  while  (  !queue.isEmpty(  )  &&  (  Character.isLetterOrDigit(  2.peek(  ))  ||  matchesAny(   "- ",   "_ ",   ": ")))  {  [CONTEXT]  public  String  consumeAttributeKey()  {  StringBuilder  accum  =  new  StringBuilder();  [BUGGY]  while(  !queue.isEmpty  ()&&(  Character.isLetterOrDigit  (  2.peek  ())||  matchesAny  (   "- ",   "_ ",   ": "  ))){  accum.append(queue.removeFirst());  }  return  accum.toString();  }        [CLASS]  TokenQueue    [METHOD]  consumeAttributeKey  [RETURN_TYPE]  String      [VARIABLES]  StringBuilder    accum    LinkedList    queue    boolean    
while  (  !queue.isEmpty  (  )  &&  (  Character.isLetterOrDigit  (  queue.peek  (  )  )  ||  matchesAny  (   "- ",   "_ ",   ": "  )  )  )  {	[BUGGY]  while  (  !queue.isEmpty(  )  &&  (  Character.isLetterOrDigit(  queue.peek(  ))  ||  matchesAny(   "- ",   "_ ",   " ")))  {  [CONTEXT]  public  String  consumeAttributeKey()  {  StringBuilder  accum  =  new  StringBuilder();  [BUGGY]  while(  !queue.isEmpty  ()&&(  Character.isLetterOrDigit  (  queue.peek  ())||  matchesAny  (   "- ",   "_ ",   " "  ))){  accum.append(queue.removeFirst());  }  return  accum.toString();  }        [CLASS]  TokenQueue    [METHOD]  consumeAttributeKey  [RETURN_TYPE]  String      [VARIABLES]  StringBuilder    accum    LinkedList    queue    boolean    
accum.append  (  queue.removeFirst  (  )  )  ;	[BUGGY]  accum.append(  0.removeFirst(  ));  [CONTEXT]  public  String  consumeAttributeKey()  {  StringBuilder  accum  =  new  StringBuilder();  while  (!queue.isEmpty()  &&  (Character.isLetterOrDigit(queue.peek())  ||  matchesAny( "- ",   "_ ",   ": ")))  {  [BUGGY]  accum.append  (  0.removeFirst  ())  ;  }  return  accum.toString();  }        [CLASS]  TokenQueue    [METHOD]  consumeAttributeKey  [RETURN_TYPE]  String      [VARIABLES]  StringBuilder    accum    LinkedList    queue    boolean    
accum.append  (  queue.removeFirst  (  )  )  ;	[BUGGY]  accum.append(  3.peek(  ));  [CONTEXT]  public  String  consumeAttributeKey()  {  StringBuilder  accum  =  new  StringBuilder();  while  (!queue.isEmpty()  &&  (Character.isLetterOrDigit(queue.peek())  ||  matchesAny( "- ",   "_ ",   ": ")))  {  [BUGGY]  accum.append  (  3.peek  ())  ;  }  return  accum.toString();  }        [CLASS]  TokenQueue    [METHOD]  consumeAttributeKey  [RETURN_TYPE]  String      [VARIABLES]  StringBuilder    accum    LinkedList    queue    boolean    
return  accum.toString  (  )  ;	[BUGGY]  return  accum.append(  );  [CONTEXT]  public  String  consumeAttributeKey()  {  StringBuilder  accum  =  new  StringBuilder();  while  (!queue.isEmpty()  &&  (Character.isLetterOrDigit(queue.peek())  ||  matchesAny( "- ",   "_ ",   ": ")))  {  accum.append(queue.removeFirst());  }  [BUGGY]  return  accum.append  ()  ;  }        [CLASS]  TokenQueue    [METHOD]  consumeAttributeKey  [RETURN_TYPE]  String      [VARIABLES]  StringBuilder    accum    LinkedList    queue    boolean    
return  accum.toString  (  )  ;	[BUGGY]    [CONTEXT]  public  String  consumeAttributeKey()  {  StringBuilder  accum  =  new  StringBuilder();  while  (!queue.isEmpty()  &&  (Character.isLetterOrDigit(queue.peek())  ||  matchesAny( "- ",   "_ ",   ": ")))  {  accum.append(queue.removeFirst());  }  [BUGGY]  return  accum.toString();          [CLASS]  TokenQueue    [METHOD]  consumeAttributeKey  [RETURN_TYPE]  String      [VARIABLES]  StringBuilder    accum    LinkedList    queue    boolean    
while  (  !queue.isEmpty  (  )  )  {	[BUGGY]  while  (  !queue.peek(  ))  {  [CONTEXT]  public  String  remainder()  {  StringBuilder  accum  =  new  StringBuilder();  [BUGGY]  while(  !queue.peek  ()){  accum.append(consume());  }  return  accum.toString();  }        [CLASS]  TokenQueue    [METHOD]  remainder  [RETURN_TYPE]  String      [VARIABLES]  StringBuilder    accum    LinkedList    queue    boolean    
accum.append  (  consume  (  )  )  ;	[BUGGY]  accum  .toString(  )  ;  [CONTEXT]  public  String  remainder()  {  StringBuilder  accum  =  new  StringBuilder();  while  (!queue.isEmpty())  {  [BUGGY]  accum  .toString  ();  }  return  accum.toString();  }        [CLASS]  TokenQueue    [METHOD]  remainder  [RETURN_TYPE]  String      [VARIABLES]  StringBuilder    accum    LinkedList    queue    boolean    
accum.append  (  consume  (  )  )  ;	[BUGGY]    [CONTEXT]  public  String  remainder()  {  StringBuilder  accum  =  new  StringBuilder();  while  (!queue.isEmpty())  {  [BUGGY]  accum.append(consume());    }  return  accum.toString();        [CLASS]  TokenQueue    [METHOD]  remainder  [RETURN_TYPE]  String      [VARIABLES]  StringBuilder    accum    LinkedList    queue    boolean    
while  (  !queue.isEmpty  (  )  )  {  accum.append  (  consume  (  )  )  ;	[BUGGY]    [CONTEXT]  public  String  remainder()  {  StringBuilder  accum  =  new  StringBuilder();  [BUGGY]  while  (!queue.isEmpty())  {      }  return  accum.toString();        [CLASS]  TokenQueue    [METHOD]  remainder  [RETURN_TYPE]  String      [VARIABLES]  StringBuilder    accum    LinkedList    queue    boolean    
while  (  !queue.isEmpty  (  )  )  {	[BUGGY]  return  queue.isEmpty(  );while  (  !queue.isEmpty(  ))  {  [CONTEXT]        [CLASS]  TokenQueue    [METHOD]  remainder  [RETURN_TYPE]  String      [VARIABLES]  StringBuilder    accum    LinkedList    queue    boolean    
while  (  !queue.isEmpty  (  )  )  {	[BUGGY]  while  (  !queue.isEmpty(  ))  {  accum.append(  consume(  ));while  (  !queue.isEmpty(  ))  {  [CONTEXT]        [CLASS]  TokenQueue    [METHOD]  remainder  [RETURN_TYPE]  String      [VARIABLES]  StringBuilder    accum    LinkedList    queue    boolean    
return  accum.toString  (  )  ;	[BUGGY]  return  accum.append(  );  [CONTEXT]  public  String  remainder()  {  StringBuilder  accum  =  new  StringBuilder();  while  (!queue.isEmpty())  {  accum.append(consume());  }  [BUGGY]  return  accum.append  ()  ;  }        [CLASS]  TokenQueue    [METHOD]  remainder  [RETURN_TYPE]  String      [VARIABLES]  StringBuilder    accum    LinkedList    queue    boolean    
return  accum.toString  (  )  ;	[BUGGY]  return  accum  .append(  null)  ;  [CONTEXT]  public  String  remainder()  {  StringBuilder  accum  =  new  StringBuilder();  while  (!queue.isEmpty())  {  accum.append(consume());  }  [BUGGY]  return  accum  .append  (  null  );  }        [CLASS]  TokenQueue    [METHOD]  remainder  [RETURN_TYPE]  String      [VARIABLES]  StringBuilder    accum    LinkedList    queue    boolean    
return  accum.toString  (  )  ;	[BUGGY]    [CONTEXT]  public  String  remainder()  {  StringBuilder  accum  =  new  StringBuilder();  while  (!queue.isEmpty())  {  accum.append(consume());  }  [BUGGY]  return  accum.toString();          [CLASS]  TokenQueue    [METHOD]  remainder  [RETURN_TYPE]  String      [VARIABLES]  StringBuilder    accum    LinkedList    queue    boolean    
return  queue.toString  (  )  ;	[BUGGY]  return  queue.size(  );  [CONTEXT]  public  String  toString()  {  [BUGGY]  return  queue.size  ()  ;  }        [CLASS]  TokenQueue    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  LinkedList    queue    boolean    
return  queue.toString  (  )  ;	[BUGGY]    [CONTEXT]  public  String  toString()  {  [BUGGY]  return  queue.toString();          [CLASS]  TokenQueue    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  LinkedList    queue    boolean    
private  static  final  Map<String,  Tag>  tags  =  new  HashMap<String,  Tag>  (  )  ;	[BUGGY]  private    final  Map<String,  Tag>  tags  =  new  HashMap<String,  Tag>(  );  [CONTEXT]  HTML  Tag  specifications.  This  is  a  very  simplistic  model  without  the  full  expressiveness  as  the  DTD,  but  it  should  capture  most  of  what  we  need  to  know  to  intelligently  parse  a  doc.    @author  Jonathan  Hedley,  jonathan@hedley.net  */  public  class  Tag  {  [BUGGY]  privatefinal  Map<String,  Tag>  tags  =  new  HashMap<String,  Tag>  ()  ;  private  static  final  Tag  defaultAncestor;  static  {  defaultAncestor  =  new  Tag( "BODY ");  tags.put(defaultAncestor.tagName,  defaultAncestor);  }        [CLASS]  Tag      [VARIABLES]  
private  static  final  Tag  defaultAncestor;	[BUGGY]  private  static    Tag  defaultAncestor;  [CONTEXT]  but  it  should  capture  most  of  what  we  need  to  know  to  intelligently  parse  a  doc.    @author  Jonathan  Hedley,  jonathan@hedley.net  */  public  class  Tag  {  private  static  final  Map<String,  Tag>  tags  =  new  HashMap<String,  Tag>();  [BUGGY]  private  staticTag  defaultAncestor;  static  {  defaultAncestor  =  new  Tag( "BODY ");  tags.put(defaultAncestor.tagName,  defaultAncestor);  }          [CLASS]  Tag      [VARIABLES]  
private  String  tagName;	[BUGGY]  private  char  tagName;  [CONTEXT]  static  {  defaultAncestor  =  new  Tag( "BODY ");  tags.put(defaultAncestor.tagName,  defaultAncestor);  }    [BUGGY]  private  char  tagName;  private  boolean  isBlock  =  true;  //  block  or  inline  private  boolean  canContainBlock  =  true;  //  Can  this  tag  hold  block  level  tags?  private  boolean  canContainInline  =  true;  //  only  pcdata  if  not  private  boolean  optionalClosing  =  false;  //  If  tag  is  open,  and  another  seen,  close  previous  tag  private  boolean  empty  =  false;  //  can  hold  nothing;  e.g.  img        [CLASS]  Tag      [VARIABLES]  
private  boolean  isBlock  =  true;	[BUGGY]  private  boolean  isBlock  =  false;  [CONTEXT]  defaultAncestor  =  new  Tag( "BODY ");  tags.put(defaultAncestor.tagName,  defaultAncestor);  }    private  String  tagName;  [BUGGY]  private  boolean  isBlock  =  false;  private  boolean  canContainBlock  =  true;  //  Can  this  tag  hold  block  level  tags?  private  boolean  canContainInline  =  true;  //  only  pcdata  if  not  private  boolean  optionalClosing  =  false;  //  If  tag  is  open,  and  another  seen,  close  previous  tag  private  boolean  empty  =  false;  //  can  hold  nothing;  e.g.  img  private  boolean  preserveWhitespace  =  false;  //  for  pre,  textarea,  script  etc        [CLASS]  Tag      [VARIABLES]  
private  boolean  canContainBlock  =  true;	[BUGGY]  private  boolean  canContainBlock  =  false;  [CONTEXT]  tags.put(defaultAncestor.tagName,  defaultAncestor);  }    private  String  tagName;  private  boolean  isBlock  =  true;  //  block  or  inline  [BUGGY]  private  boolean  canContainBlock  =  false;  private  boolean  canContainInline  =  true;  //  only  pcdata  if  not  private  boolean  optionalClosing  =  false;  //  If  tag  is  open,  and  another  seen,  close  previous  tag  private  boolean  empty  =  false;  //  can  hold  nothing;  e.g.  img  private  boolean  preserveWhitespace  =  false;  //  for  pre,  textarea,  script  etc  private  List<Tag>  ancestors;        [CLASS]  Tag      [VARIABLES]  
private  boolean  canContainInline  =  true;	[BUGGY]  private  boolean  canContainInline  =  false;  [CONTEXT]  }    private  String  tagName;  private  boolean  isBlock  =  true;  //  block  or  inline  private  boolean  canContainBlock  =  true;  //  Can  this  tag  hold  block  level  tags?  [BUGGY]  private  boolean  canContainInline  =  false;  private  boolean  optionalClosing  =  false;  //  If  tag  is  open,  and  another  seen,  close  previous  tag  private  boolean  empty  =  false;  //  can  hold  nothing;  e.g.  img  private  boolean  preserveWhitespace  =  false;  //  for  pre,  textarea,  script  etc  private  List<Tag>  ancestors;          [CLASS]  Tag      [VARIABLES]  
private  boolean  optionalClosing  =  false;	[BUGGY]  private  boolean  optionalClosing  =  true;  [CONTEXT]    private  String  tagName;  private  boolean  isBlock  =  true;  //  block  or  inline  private  boolean  canContainBlock  =  true;  //  Can  this  tag  hold  block  level  tags?  private  boolean  canContainInline  =  true;  //  only  pcdata  if  not  [BUGGY]  private  boolean  optionalClosing  =  true;  private  boolean  empty  =  false;  //  can  hold  nothing;  e.g.  img  private  boolean  preserveWhitespace  =  false;  //  for  pre,  textarea,  script  etc  private  List<Tag>  ancestors;    private  Tag(String  tagName)  {        [CLASS]  Tag      [VARIABLES]  
private  boolean  optionalClosing  =  false;	[BUGGY]  private  boolean  optionalClosing  ;  [CONTEXT]    private  String  tagName;  private  boolean  isBlock  =  true;  //  block  or  inline  private  boolean  canContainBlock  =  true;  //  Can  this  tag  hold  block  level  tags?  private  boolean  canContainInline  =  true;  //  only  pcdata  if  not  [BUGGY]  private  boolean  optionalClosing  ;  private  boolean  empty  =  false;  //  can  hold  nothing;  e.g.  img  private  boolean  preserveWhitespace  =  false;  //  for  pre,  textarea,  script  etc  private  List<Tag>  ancestors;    private  Tag(String  tagName)  {        [CLASS]  Tag      [VARIABLES]  
private  boolean  empty  =  false;	[BUGGY]  private  boolean  empty  =  true;  [CONTEXT]  private  String  tagName;  private  boolean  isBlock  =  true;  //  block  or  inline  private  boolean  canContainBlock  =  true;  //  Can  this  tag  hold  block  level  tags?  private  boolean  canContainInline  =  true;  //  only  pcdata  if  not  private  boolean  optionalClosing  =  false;  //  If  tag  is  open,  and  another  seen,  close  previous  tag  [BUGGY]  private  boolean  empty  =  true;  private  boolean  preserveWhitespace  =  false;  //  for  pre,  textarea,  script  etc  private  List<Tag>  ancestors;    private  Tag(String  tagName)  {  this.tagName  =  tagName.toLowerCase();        [CLASS]  Tag      [VARIABLES]  
private  boolean  preserveWhitespace  =  false;	[BUGGY]  private  boolean  preserveWhitespace  =  true;  [CONTEXT]  private  boolean  isBlock  =  true;  //  block  or  inline  private  boolean  canContainBlock  =  true;  //  Can  this  tag  hold  block  level  tags?  private  boolean  canContainInline  =  true;  //  only  pcdata  if  not  private  boolean  optionalClosing  =  false;  //  If  tag  is  open,  and  another  seen,  close  previous  tag  private  boolean  empty  =  false;  //  can  hold  nothing;  e.g.  img  [BUGGY]  private  boolean  preserveWhitespace  =  true;  private  List<Tag>  ancestors;    private  Tag(String  tagName)  {  this.tagName  =  tagName.toLowerCase();  }        [CLASS]  Tag      [VARIABLES]  
this.tagName  =  tagName.toLowerCase  (  )  ;	[BUGGY]  this.tagName  =  tagName.equals(  );  [CONTEXT]  private  Tag(String  tagName)  {  [BUGGY]  this.tagName  =  tagName.equals  ()  ;  }        [CLASS]  Tag    [METHOD]  <init>  [RETURN_TYPE]  String)      String  tagName  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    defaultAncestor    String    tagName    Map    tags    
this.tagName  =  tagName.toLowerCase  (  )  ;	[BUGGY]  this.tagName  =    null.toLowerCase(  );  [CONTEXT]  private  Tag(String  tagName)  {  [BUGGY]  this.tagName  =null.toLowerCase  ()  ;  }        [CLASS]  Tag    [METHOD]  <init>  [RETURN_TYPE]  String)      String  tagName  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    defaultAncestor    String    tagName    Map    tags    
this.tagName  =  tagName.toLowerCase  (  )  ;	[BUGGY]    [CONTEXT]  private  Tag(String  tagName)  {  [BUGGY]  this.tagName  =  tagName.toLowerCase();          [CLASS]  Tag    [METHOD]  <init>  [RETURN_TYPE]  String)      String  tagName  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    defaultAncestor    String    tagName    Map    tags    
Validate.notNull  (  tagName  )  ;	[BUGGY]    [CONTEXT]  public  static  Tag  valueOf(String  tagName)  {  [BUGGY]  Validate.notNull(tagName);    tagName  =  tagName.trim().toLowerCase();  Validate.notEmpty(tagName);    synchronized  (tags)  {  Tag  tag  =  tags.get(tagName);  if  (tag  ==  null)  {      tag  =  new  Tag(tagName);  tag.setAncestor(defaultAncestor.tagName);  tag.isBlock  =  false;  tag.canContainBlock  =  true;  }  return  tag;  }        [CLASS]  Tag    [METHOD]  valueOf  [RETURN_TYPE]  Tag      String  tagName  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    defaultAncestor    tag    String    tagName    Map    tags    
Validate.notNull  (  tagName  )  ;  tagName  =  tagName.trim  (  )  .toLowerCase  (  )  ;	[BUGGY]  tagName  =  tagName.trim(  ).toLowerCase(  );  Validate.notNull(  tagName);  [CONTEXT]        [CLASS]  Tag    [METHOD]  valueOf  [RETURN_TYPE]  Tag      String  tagName  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    defaultAncestor    tag    String    tagName    Map    tags    
Validate.notNull  (  tagName  )  ;  tagName  =  tagName.trim  (  )  .toLowerCase  (  )  ;	[BUGGY]  tagName  =  tagName.trim(  ).toLowerCase(  );Validate.notNull(  tagName);  tagName  =  tagName.trim(  ).toLowerCase(  );  [CONTEXT]        [CLASS]  Tag    [METHOD]  valueOf  [RETURN_TYPE]  Tag      String  tagName  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    defaultAncestor    tag    String    tagName    Map    tags    
tagName  =  tagName.trim  (  )  .toLowerCase  (  )  ;	[BUGGY]  tagName  =  tagName.trim(  ).setAncestor(  );  [CONTEXT]  public  static  Tag  valueOf(String  tagName)  {  Validate.notNull(tagName);  [BUGGY]  tagName  =  tagName.trim  ()  .setAncestor  ()  ;  Validate.notEmpty(tagName);    synchronized  (tags)  {  Tag  tag  =  tags.get(tagName);  if  (tag  ==  null)  {      tag  =  new  Tag(tagName);  tag.setAncestor(defaultAncestor.tagName);  tag.isBlock  =  false;  tag.canContainBlock  =  true;  }  return  tag;  }  }        [CLASS]  Tag    [METHOD]  valueOf  [RETURN_TYPE]  Tag      String  tagName  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    defaultAncestor    tag    String    tagName    Map    tags    
tagName  =  tagName.trim  (  )  .toLowerCase  (  )  ;	[BUGGY]  tagName  =  tagName.trim(  )  .trim(  )  ;  [CONTEXT]  public  static  Tag  valueOf(String  tagName)  {  Validate.notNull(tagName);  [BUGGY]  tagName  =  tagName.trim  ().trim  ();  Validate.notEmpty(tagName);    synchronized  (tags)  {  Tag  tag  =  tags.get(tagName);  if  (tag  ==  null)  {      tag  =  new  Tag(tagName);  tag.setAncestor(defaultAncestor.tagName);  tag.isBlock  =  false;  tag.canContainBlock  =  true;  }  return  tag;  }  }        [CLASS]  Tag    [METHOD]  valueOf  [RETURN_TYPE]  Tag      String  tagName  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    defaultAncestor    tag    String    tagName    Map    tags    
tagName  =  tagName.trim  (  )  .toLowerCase  (  )  ;	[BUGGY]  tagName  =  tagName.equals(  ).toLowerCase(  );  [CONTEXT]  public  static  Tag  valueOf(String  tagName)  {  Validate.notNull(tagName);  [BUGGY]  tagName  =  tagName.equals  ()  .toLowerCase  ()  ;  Validate.notEmpty(tagName);    synchronized  (tags)  {  Tag  tag  =  tags.get(tagName);  if  (tag  ==  null)  {      tag  =  new  Tag(tagName);  tag.setAncestor(defaultAncestor.tagName);  tag.isBlock  =  false;  tag.canContainBlock  =  true;  }  return  tag;  }  }        [CLASS]  Tag    [METHOD]  valueOf  [RETURN_TYPE]  Tag      String  tagName  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    defaultAncestor    tag    String    tagName    Map    tags    
tagName  =  tagName.trim  (  )  .toLowerCase  (  )  ;	[BUGGY]  tagName  =    null.trim(  ).toLowerCase(  );  [CONTEXT]  public  static  Tag  valueOf(String  tagName)  {  Validate.notNull(tagName);  [BUGGY]  tagName  =null.trim  ()  .toLowerCase  ()  ;  Validate.notEmpty(tagName);    synchronized  (tags)  {  Tag  tag  =  tags.get(tagName);  if  (tag  ==  null)  {      tag  =  new  Tag(tagName);  tag.setAncestor(defaultAncestor.tagName);  tag.isBlock  =  false;  tag.canContainBlock  =  true;  }  return  tag;  }  }        [CLASS]  Tag    [METHOD]  valueOf  [RETURN_TYPE]  Tag      String  tagName  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    defaultAncestor    tag    String    tagName    Map    tags    
tagName  =  tagName.trim  (  )  .toLowerCase  (  )  ;  Validate.notEmpty  (  tagName  )  ;	[BUGGY]  Validate.notEmpty(  tagName);  tagName  =  tagName.trim(  ).toLowerCase(  );  [CONTEXT]        [CLASS]  Tag    [METHOD]  valueOf  [RETURN_TYPE]  Tag      String  tagName  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    defaultAncestor    tag    String    tagName    Map    tags    
tagName  =  tagName.trim  (  )  .toLowerCase  (  )  ;  Validate.notEmpty  (  tagName  )  ;	[BUGGY]  tagName  =  tagName.trim(  ).toLowerCase(  );tagName  =  tagName.trim(  ).toLowerCase(  );  Validate.notEmpty(  tagName);  [CONTEXT]        [CLASS]  Tag    [METHOD]  valueOf  [RETURN_TYPE]  Tag      String  tagName  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    defaultAncestor    tag    String    tagName    Map    tags    
tagName  =  tagName.trim  (  )  .toLowerCase  (  )  ;	[BUGGY]  tagName  =  tagName  .toLowerCase(  )  .toLowerCase(  );  [CONTEXT]  public  static  Tag  valueOf(String  tagName)  {  Validate.notNull(tagName);  [BUGGY]  tagName  =  tagName  .toLowerCase  ().toLowerCase  ()  ;  Validate.notEmpty(tagName);    synchronized  (tags)  {  Tag  tag  =  tags.get(tagName);  if  (tag  ==  null)  {      tag  =  new  Tag(tagName);  tag.setAncestor(defaultAncestor.tagName);  tag.isBlock  =  false;  tag.canContainBlock  =  true;  }  return  tag;  }  }        [CLASS]  Tag    [METHOD]  valueOf  [RETURN_TYPE]  Tag      String  tagName  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    defaultAncestor    tag    String    tagName    Map    tags    
tagName  =  tagName.trim  (  )  .toLowerCase  (  )  ;  Validate.notEmpty  (  tagName  )  ;	[BUGGY]    [CONTEXT]  public  static  Tag  valueOf(String  tagName)  {  Validate.notNull(tagName);  [BUGGY]  tagName  =  tagName.trim().toLowerCase();        synchronized  (tags)  {  Tag  tag  =  tags.get(tagName);  if  (tag  ==  null)  {      tag  =  new  Tag(tagName);  tag.setAncestor(defaultAncestor.tagName);  tag.isBlock  =  false;  tag.canContainBlock  =  true;  }  return  tag;  }        [CLASS]  Tag    [METHOD]  valueOf  [RETURN_TYPE]  Tag      String  tagName  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    defaultAncestor    tag    String    tagName    Map    tags    
tagName  =  tagName.trim  (  )  .toLowerCase  (  )  ;	[BUGGY]  Validate.notEmpty(  tagName);  tagName  =  tagName.trim(  ).toLowerCase(  );  [CONTEXT]        [CLASS]  Tag    [METHOD]  valueOf  [RETURN_TYPE]  Tag      String  tagName  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    defaultAncestor    tag    String    tagName    Map    tags    
tagName  =  tagName.trim  (  )  .toLowerCase  (  )  ;	[BUGGY]  this.tagName  =  tagName.toLowerCase(  );tagName  =  tagName.trim(  ).toLowerCase(  );  [CONTEXT]        [CLASS]  Tag    [METHOD]  valueOf  [RETURN_TYPE]  Tag      String  tagName  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    defaultAncestor    tag    String    tagName    Map    tags    
tagName  =  tagName.trim  (  )  .toLowerCase  (  )  ;	[BUGGY]    [CONTEXT]  public  static  Tag  valueOf(String  tagName)  {  Validate.notNull(tagName);  [BUGGY]  tagName  =  tagName.trim().toLowerCase();    Validate.notEmpty(tagName);    synchronized  (tags)  {  Tag  tag  =  tags.get(tagName);  if  (tag  ==  null)  {      tag  =  new  Tag(tagName);  tag.setAncestor(defaultAncestor.tagName);  tag.isBlock  =  false;  tag.canContainBlock  =  true;  }  return  tag;  }        [CLASS]  Tag    [METHOD]  valueOf  [RETURN_TYPE]  Tag      String  tagName  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    defaultAncestor    tag    String    tagName    Map    tags    
Validate.notEmpty  (  tagName  )  ;	[BUGGY]  Validate.notNull(  tagName);  [CONTEXT]  public  static  Tag  valueOf(String  tagName)  {  Validate.notNull(tagName);  tagName  =  tagName.trim().toLowerCase();  [BUGGY]  Validate.notNull  (  tagName  )  ;    synchronized  (tags)  {  Tag  tag  =  tags.get(tagName);  if  (tag  ==  null)  {      tag  =  new  Tag(tagName);  tag.setAncestor(defaultAncestor.tagName);  tag.isBlock  =  false;  tag.canContainBlock  =  true;  }  return  tag;  }  }        [CLASS]  Tag    [METHOD]  valueOf  [RETURN_TYPE]  Tag      String  tagName  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    defaultAncestor    tag    String    tagName    Map    tags    
Validate.notEmpty  (  tagName  )  ;	[BUGGY]    [CONTEXT]  public  static  Tag  valueOf(String  tagName)  {  Validate.notNull(tagName);  tagName  =  tagName.trim().toLowerCase();  [BUGGY]  Validate.notEmpty(tagName);      synchronized  (tags)  {  Tag  tag  =  tags.get(tagName);  if  (tag  ==  null)  {      tag  =  new  Tag(tagName);  tag.setAncestor(defaultAncestor.tagName);  tag.isBlock  =  false;  tag.canContainBlock  =  true;  }  return  tag;  }        [CLASS]  Tag    [METHOD]  valueOf  [RETURN_TYPE]  Tag      String  tagName  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    defaultAncestor    tag    String    tagName    Map    tags    
if  (  tag  ==  null  )  {	[BUGGY]  if  (  tag  !=  null)  {  [CONTEXT]  public  static  Tag  valueOf(String  tagName)  {  Validate.notNull(tagName);  tagName  =  tagName.trim().toLowerCase();  Validate.notEmpty(tagName);    synchronized  (tags)  {  Tag  tag  =  tags.get(tagName);  [BUGGY]  if(  tag  !=  null  ){      tag  =  new  Tag(tagName);  tag.setAncestor(defaultAncestor.tagName);  tag.isBlock  =  false;  tag.canContainBlock  =  true;  }  return  tag;  }  }        [CLASS]  Tag    [METHOD]  valueOf  [RETURN_TYPE]  Tag      String  tagName  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    defaultAncestor    tag    String    tagName    Map    tags    
if  (  tag  ==  null  )  {	[BUGGY]  if  (  tag  ==  true)  {  [CONTEXT]  public  static  Tag  valueOf(String  tagName)  {  Validate.notNull(tagName);  tagName  =  tagName.trim().toLowerCase();  Validate.notEmpty(tagName);    synchronized  (tags)  {  Tag  tag  =  tags.get(tagName);  [BUGGY]  if(  tag  ==  true  ){      tag  =  new  Tag(tagName);  tag.setAncestor(defaultAncestor.tagName);  tag.isBlock  =  false;  tag.canContainBlock  =  true;  }  return  tag;  }  }        [CLASS]  Tag    [METHOD]  valueOf  [RETURN_TYPE]  Tag      String  tagName  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    defaultAncestor    tag    String    tagName    Map    tags    
if  (  tag  ==  null  )  {	[BUGGY]  if  (  tagNames  ==  null)  {  [CONTEXT]  public  static  Tag  valueOf(String  tagName)  {  Validate.notNull(tagName);  tagName  =  tagName.trim().toLowerCase();  Validate.notEmpty(tagName);    synchronized  (tags)  {  Tag  tag  =  tags.get(tagName);  [BUGGY]  if(  tagNames  ==  null  ){      tag  =  new  Tag(tagName);  tag.setAncestor(defaultAncestor.tagName);  tag.isBlock  =  false;  tag.canContainBlock  =  true;  }  return  tag;  }  }        [CLASS]  Tag    [METHOD]  valueOf  [RETURN_TYPE]  Tag      String  tagName  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    defaultAncestor    tag    String    tagName    Map    tags    
tag  =  new  Tag  (  tagName  )  ;	[BUGGY]  tag  =    new  Tag(  null);  [CONTEXT]  public  static  Tag  valueOf(String  tagName)  {  Validate.notNull(tagName);  tagName  =  tagName.trim().toLowerCase();  Validate.notEmpty(tagName);    synchronized  (tags)  {  Tag  tag  =  tags.get(tagName);  if  (tag  ==  null)  {      [BUGGY]  tag  =new  Tag  (  null  )  ;  tag.setAncestor(defaultAncestor.tagName);  tag.isBlock  =  false;  tag.canContainBlock  =  true;  }  return  tag;  }  }        [CLASS]  Tag    [METHOD]  valueOf  [RETURN_TYPE]  Tag      String  tagName  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    defaultAncestor    tag    String    tagName    Map    tags    
tag.isBlock  =  false;	[BUGGY]  tag.isBlock  =  true;  [CONTEXT]  public  static  Tag  valueOf(String  tagName)  {  Validate.notNull(tagName);  tagName  =  tagName.trim().toLowerCase();  Validate.notEmpty(tagName);    synchronized  (tags)  {  Tag  tag  =  tags.get(tagName);  if  (tag  ==  null)  {      tag  =  new  Tag(tagName);  tag.setAncestor(defaultAncestor.tagName);  [BUGGY]  tag.isBlock  =  true;  tag.canContainBlock  =  true;  }  return  tag;  }  }        [CLASS]  Tag    [METHOD]  valueOf  [RETURN_TYPE]  Tag      String  tagName  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    defaultAncestor    tag    String    tagName    Map    tags    
tag.isBlock  =  false;	[BUGGY]  tag.canContainBlock  =  true;  tag.isBlock  =  false;  [CONTEXT]        [CLASS]  Tag    [METHOD]  valueOf  [RETURN_TYPE]  Tag      String  tagName  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    defaultAncestor    tag    String    tagName    Map    tags    
tag.isBlock  =  false;	[BUGGY]  inline.isBlock  =  false;tag.isBlock  =  false;  [CONTEXT]        [CLASS]  Tag    [METHOD]  valueOf  [RETURN_TYPE]  Tag      String  tagName  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    defaultAncestor    tag    String    tagName    Map    tags    
tag.isBlock  =  false;	[BUGGY]  inline.canContainBlock  =  false;tag.isBlock  =  false;  [CONTEXT]        [CLASS]  Tag    [METHOD]  valueOf  [RETURN_TYPE]  Tag      String  tagName  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    defaultAncestor    tag    String    tagName    Map    tags    
tag.isBlock  =  false;	[BUGGY]  canContainBlock  =  false;tag.isBlock  =  false;  [CONTEXT]        [CLASS]  Tag    [METHOD]  valueOf  [RETURN_TYPE]  Tag      String  tagName  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    defaultAncestor    tag    String    tagName    Map    tags    
tag.canContainBlock  =  true;	[BUGGY]  tag.canContainBlock  =  false;  [CONTEXT]  public  static  Tag  valueOf(String  tagName)  {  Validate.notNull(tagName);  tagName  =  tagName.trim().toLowerCase();  Validate.notEmpty(tagName);    synchronized  (tags)  {  Tag  tag  =  tags.get(tagName);  if  (tag  ==  null)  {      tag  =  new  Tag(tagName);  tag.setAncestor(defaultAncestor.tagName);  tag.isBlock  =  false;  [BUGGY]  tag.canContainBlock  =  false;  }  return  tag;  }  }        [CLASS]  Tag    [METHOD]  valueOf  [RETURN_TYPE]  Tag      String  tagName  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    defaultAncestor    tag    String    tagName    Map    tags    
tag.setAncestor  (  defaultAncestor.tagName  )  ;	[BUGGY]  tag.valueOf(  defaultAncestor.tagName);  [CONTEXT]  public  static  Tag  valueOf(String  tagName)  {  Validate.notNull(tagName);  tagName  =  tagName.trim().toLowerCase();  Validate.notEmpty(tagName);    synchronized  (tags)  {  Tag  tag  =  tags.get(tagName);  if  (tag  ==  null)  {      tag  =  new  Tag(tagName);  [BUGGY]  tag.valueOf  (  defaultAncestor.tagName  )  ;  tag.isBlock  =  false;  tag.canContainBlock  =  true;  }  return  tag;  }  }        [CLASS]  Tag    [METHOD]  valueOf  [RETURN_TYPE]  Tag      String  tagName  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    defaultAncestor    tag    String    tagName    Map    tags    
tag.setAncestor  (  defaultAncestor.tagName  )  ;	[BUGGY]  tag  .setAncestor(  tagName  ,  tagName)  ;  [CONTEXT]  public  static  Tag  valueOf(String  tagName)  {  Validate.notNull(tagName);  tagName  =  tagName.trim().toLowerCase();  Validate.notEmpty(tagName);    synchronized  (tags)  {  Tag  tag  =  tags.get(tagName);  if  (tag  ==  null)  {      tag  =  new  Tag(tagName);  [BUGGY]  tag  .setAncestor  (  tagName  ,  tagName  );  tag.isBlock  =  false;  tag.canContainBlock  =  true;  }  return  tag;  }  }        [CLASS]  Tag    [METHOD]  valueOf  [RETURN_TYPE]  Tag      String  tagName  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    defaultAncestor    tag    String    tagName    Map    tags    
tag.setAncestor  (  defaultAncestor.tagName  )  ;  tag.isBlock  =  false;	[BUGGY]    [CONTEXT]  public  static  Tag  valueOf(String  tagName)  {  Validate.notNull(tagName);  tagName  =  tagName.trim().toLowerCase();  Validate.notEmpty(tagName);    synchronized  (tags)  {  Tag  tag  =  tags.get(tagName);  if  (tag  ==  null)  {      tag  =  new  Tag(tagName);  [BUGGY]  tag.setAncestor(defaultAncestor.tagName);      tag.canContainBlock  =  true;  }  return  tag;  }        [CLASS]  Tag    [METHOD]  valueOf  [RETURN_TYPE]  Tag      String  tagName  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    defaultAncestor    tag    String    tagName    Map    tags    
tag.isBlock  =  false;  tag.canContainBlock  =  true;	[BUGGY]  tag.canContainBlock  =  true;  tag.isBlock  =  false;  [CONTEXT]        [CLASS]  Tag    [METHOD]  valueOf  [RETURN_TYPE]  Tag      String  tagName  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    defaultAncestor    tag    String    tagName    Map    tags    
tag.isBlock  =  false;  tag.canContainBlock  =  true;	[BUGGY]  tag.canContainBlock  =  true;tag.isBlock  =  false;  tag.canContainBlock  =  true;  [CONTEXT]        [CLASS]  Tag    [METHOD]  valueOf  [RETURN_TYPE]  Tag      String  tagName  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    defaultAncestor    tag    String    tagName    Map    tags    
return  tag;	[BUGGY]  return  defaultAncestor;  [CONTEXT]  public  static  Tag  valueOf(String  tagName)  {  Validate.notNull(tagName);  tagName  =  tagName.trim().toLowerCase();  Validate.notEmpty(tagName);    synchronized  (tags)  {  Tag  tag  =  tags.get(tagName);  if  (tag  ==  null)  {      tag  =  new  Tag(tagName);  tag.setAncestor(defaultAncestor.tagName);  tag.isBlock  =  false;  tag.canContainBlock  =  true;  }  [BUGGY]  return  defaultAncestor;  }  }        [CLASS]  Tag    [METHOD]  valueOf  [RETURN_TYPE]  Tag      String  tagName  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    defaultAncestor    tag    String    tagName    Map    tags    
Tag  tag  =  tags.get  (  tagName  )  ;	[BUGGY]  Tag  tag  =  tagName.get(  tags);  [CONTEXT]  public  static  Tag  valueOf(String  tagName)  {  Validate.notNull(tagName);  tagName  =  tagName.trim().toLowerCase();  Validate.notEmpty(tagName);    synchronized  (tags)  {  [BUGGY]  Tag  tag  =  tagName.get  (  tags  )  ;  if  (tag  ==  null)  {      tag  =  new  Tag(tagName);  tag.setAncestor(defaultAncestor.tagName);  tag.isBlock  =  false;  tag.canContainBlock  =  true;  }  return  tag;  }  }        [CLASS]  Tag    [METHOD]  valueOf  [RETURN_TYPE]  Tag      String  tagName  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    defaultAncestor    tag    String    tagName    Map    tags    
Tag  tag  =  tags.get  (  tagName  )  ;	[BUGGY]  Tag  tag  =  tags  .put(  tagName  ,  tag)  ;  [CONTEXT]  public  static  Tag  valueOf(String  tagName)  {  Validate.notNull(tagName);  tagName  =  tagName.trim().toLowerCase();  Validate.notEmpty(tagName);    synchronized  (tags)  {  [BUGGY]  Tag  tag  =  tags  .put  (  tagName  ,  tag  );  if  (tag  ==  null)  {      tag  =  new  Tag(tagName);  tag.setAncestor(defaultAncestor.tagName);  tag.isBlock  =  false;  tag.canContainBlock  =  true;  }  return  tag;  }  }        [CLASS]  Tag    [METHOD]  valueOf  [RETURN_TYPE]  Tag      String  tagName  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    defaultAncestor    tag    String    tagName    Map    tags    
Tag  tag  =  tags.get  (  tagName  )  ;	[BUGGY]  Tag  tag  =  tags  .put(  tagName  ,  defaultAncestor)  ;  [CONTEXT]  public  static  Tag  valueOf(String  tagName)  {  Validate.notNull(tagName);  tagName  =  tagName.trim().toLowerCase();  Validate.notEmpty(tagName);    synchronized  (tags)  {  [BUGGY]  Tag  tag  =  tags  .put  (  tagName  ,  defaultAncestor  );  if  (tag  ==  null)  {      tag  =  new  Tag(tagName);  tag.setAncestor(defaultAncestor.tagName);  tag.isBlock  =  false;  tag.canContainBlock  =  true;  }  return  tag;  }  }        [CLASS]  Tag    [METHOD]  valueOf  [RETURN_TYPE]  Tag      String  tagName  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    defaultAncestor    tag    String    tagName    Map    tags    
Tag  tag  =  tags.get  (  tagName  )  ;	[BUGGY]    [CONTEXT]  public  static  Tag  valueOf(String  tagName)  {  Validate.notNull(tagName);  tagName  =  tagName.trim().toLowerCase();  Validate.notEmpty(tagName);    synchronized  (tags)  {  [BUGGY]  Tag  tag  =  tags.get(tagName);    if  (tag  ==  null)  {      tag  =  new  Tag(tagName);  tag.setAncestor(defaultAncestor.tagName);  tag.isBlock  =  false;  tag.canContainBlock  =  true;  }  return  tag;  }        [CLASS]  Tag    [METHOD]  valueOf  [RETURN_TYPE]  Tag      String  tagName  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    defaultAncestor    tag    String    tagName    Map    tags    
tag.setAncestor  (  defaultAncestor.tagName  )  ;	[BUGGY]    [CONTEXT]  public  static  Tag  valueOf(String  tagName)  {  Validate.notNull(tagName);  tagName  =  tagName.trim().toLowerCase();  Validate.notEmpty(tagName);    synchronized  (tags)  {  Tag  tag  =  tags.get(tagName);  if  (tag  ==  null)  {      tag  =  new  Tag(tagName);  [BUGGY]  tag.setAncestor(defaultAncestor.tagName);    tag.isBlock  =  false;  tag.canContainBlock  =  true;  }  return  tag;  }        [CLASS]  Tag    [METHOD]  valueOf  [RETURN_TYPE]  Tag      String  tagName  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    defaultAncestor    tag    String    tagName    Map    tags    
Validate.notNull  (  child  )  ;	[BUGGY]  Validate.notNull(  tag);  [CONTEXT]  tag  =  new  Tag(tagName);  tag.setAncestor(defaultAncestor.tagName);  tag.isBlock  =  false;  tag.canContainBlock  =  true;  }  return  tag;  }  }        Test  if  this  tag,  the  prospective  parent,  can  accept  the  proposed  child.  @param  child  potential  child  tag.  @return  true  if  this  can  contain  child.      boolean  canContain(Tag  child)  {  [BUGGY]  Validate.notNull  (  tag  )  ;    if  (child.isBlock  &&  !this.canContainBlock)  return  false;    if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    if  (this.optionalClosing  &&  this.equals(child))  return  false;    if  (this.empty  ||  this.isData())  return  false;                  [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
Validate.notNull  (  child  )  ;	[BUGGY]    [CONTEXT]  tag  =  new  Tag(tagName);  tag.setAncestor(defaultAncestor.tagName);  tag.isBlock  =  false;  tag.canContainBlock  =  true;  }  return  tag;  }  }        Test  if  this  tag,  the  prospective  parent,  can  accept  the  proposed  child.  @param  child  potential  child  tag.  @return  true  if  this  can  contain  child.      boolean  canContain(Tag  child)  {  [BUGGY]  Validate.notNull(child);      if  (child.isBlock  &&  !this.canContainBlock)  return  false;    if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    if  (this.optionalClosing  &&  this.equals(child))  return  false;    if  (this.empty  ||  this.isData())  return  false;              [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  child.isBlock  &&  !this.canContainBlock  )  return  false;	[BUGGY]  if  (  child.isBlock  ||  !this.canContainBlock)return  false;  [CONTEXT]  tag.isBlock  =  false;  tag.canContainBlock  =  true;  }  return  tag;  }  }        Test  if  this  tag,  the  prospective  parent,  can  accept  the  proposed  child.  @param  child  potential  child  tag.  @return  true  if  this  can  contain  child.      boolean  canContain(Tag  child)  {  Validate.notNull(child);    [BUGGY]  if(  child.isBlock  ||  !this.canContainBlock  )  return  false;      if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    if  (this.optionalClosing  &&  this.equals(child))  return  false;    if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  if  (child.tagName.equals( "base ")  ||  child.tagName.equals( "script ")  ||  child.tagName.equals( "noscript ")  ||  child.tagName.equals( "link ")  ||        [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  child.isBlock  &&  !this.canContainBlock  )  return  false;	[BUGGY]  if  (  child.isBlock  &&  !this.canContainBlock)return  true;  [CONTEXT]  tag.isBlock  =  false;  tag.canContainBlock  =  true;  }  return  tag;  }  }        Test  if  this  tag,  the  prospective  parent,  can  accept  the  proposed  child.  @param  child  potential  child  tag.  @return  true  if  this  can  contain  child.      boolean  canContain(Tag  child)  {  Validate.notNull(child);    [BUGGY]  if(  child.isBlock  &&  !this.canContainBlock  )  return  true;      if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    if  (this.optionalClosing  &&  this.equals(child))  return  false;    if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  if  (child.tagName.equals( "base ")  ||  child.tagName.equals( "script ")  ||  child.tagName.equals( "noscript ")  ||  child.tagName.equals( "link ")  ||        [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  child.isBlock  &&  !this.canContainBlock  )  return  false;	[BUGGY]  if  (  tag.isBlock  &&  !this.canContainBlock)return  false;  [CONTEXT]  tag.isBlock  =  false;  tag.canContainBlock  =  true;  }  return  tag;  }  }        Test  if  this  tag,  the  prospective  parent,  can  accept  the  proposed  child.  @param  child  potential  child  tag.  @return  true  if  this  can  contain  child.      boolean  canContain(Tag  child)  {  Validate.notNull(child);    [BUGGY]  if(  tag.isBlock  &&  !this.canContainBlock  )  return  false;      if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    if  (this.optionalClosing  &&  this.equals(child))  return  false;    if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  if  (child.tagName.equals( "base ")  ||  child.tagName.equals( "script ")  ||  child.tagName.equals( "noscript ")  ||  child.tagName.equals( "link ")  ||        [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  child.isBlock  &&  !this.canContainBlock  )  return  false;	[BUGGY]  if  (  preserveWhitespace  &&  !this.canContainBlock)return  false;  [CONTEXT]  tag.isBlock  =  false;  tag.canContainBlock  =  true;  }  return  tag;  }  }        Test  if  this  tag,  the  prospective  parent,  can  accept  the  proposed  child.  @param  child  potential  child  tag.  @return  true  if  this  can  contain  child.      boolean  canContain(Tag  child)  {  Validate.notNull(child);    [BUGGY]  if(  preserveWhitespace  &&  !this.canContainBlock  )  return  false;      if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    if  (this.optionalClosing  &&  this.equals(child))  return  false;    if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  if  (child.tagName.equals( "base ")  ||  child.tagName.equals( "script ")  ||  child.tagName.equals( "noscript ")  ||  child.tagName.equals( "link ")  ||        [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  child.isBlock  &&  !this.canContainBlock  )  return  false;	[BUGGY]  if  (  child.isBlock  &&  !preserveWhitespace)return  false;  [CONTEXT]  tag.isBlock  =  false;  tag.canContainBlock  =  true;  }  return  tag;  }  }        Test  if  this  tag,  the  prospective  parent,  can  accept  the  proposed  child.  @param  child  potential  child  tag.  @return  true  if  this  can  contain  child.      boolean  canContain(Tag  child)  {  Validate.notNull(child);    [BUGGY]  if(  child.isBlock  &&  !preserveWhitespace  )  return  false;      if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    if  (this.optionalClosing  &&  this.equals(child))  return  false;    if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  if  (child.tagName.equals( "base ")  ||  child.tagName.equals( "script ")  ||  child.tagName.equals( "noscript ")  ||  child.tagName.equals( "link ")  ||        [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  child.isBlock  &&  !this.canContainBlock  )  return  false;	[BUGGY]  if  (  child.isBlock.isBlock  &&  !this.canContainBlock)return  false;  [CONTEXT]  tag.isBlock  =  false;  tag.canContainBlock  =  true;  }  return  tag;  }  }        Test  if  this  tag,  the  prospective  parent,  can  accept  the  proposed  child.  @param  child  potential  child  tag.  @return  true  if  this  can  contain  child.      boolean  canContain(Tag  child)  {  Validate.notNull(child);    [BUGGY]  if(  child.isBlock.isBlock  &&  !this.canContainBlock  )  return  false;      if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    if  (this.optionalClosing  &&  this.equals(child))  return  false;    if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  if  (child.tagName.equals( "base ")  ||  child.tagName.equals( "script ")  ||  child.tagName.equals( "noscript ")  ||  child.tagName.equals( "link ")  ||        [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  child.isBlock  &&  !this.canContainBlock  )  return  false;	[BUGGY]  if  (  tag.isBlock  &&  !this.canContainBlock)return  true;  [CONTEXT]  tag.isBlock  =  false;  tag.canContainBlock  =  true;  }  return  tag;  }  }        Test  if  this  tag,  the  prospective  parent,  can  accept  the  proposed  child.  @param  child  potential  child  tag.  @return  true  if  this  can  contain  child.      boolean  canContain(Tag  child)  {  Validate.notNull(child);    [BUGGY]  if(  tag.isBlock  &&  !this.canContainBlock  )  return  true;      if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    if  (this.optionalClosing  &&  this.equals(child))  return  false;    if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  if  (child.tagName.equals( "base ")  ||  child.tagName.equals( "script ")  ||  child.tagName.equals( "noscript ")  ||  child.tagName.equals( "link ")  ||        [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
return  false;	[BUGGY]  return  true;  [CONTEXT]  tag.canContainBlock  =  true;  }  return  tag;  }  }        Test  if  this  tag,  the  prospective  parent,  can  accept  the  proposed  child.  @param  child  potential  child  tag.  @return  true  if  this  can  contain  child.      boolean  canContain(Tag  child)  {  Validate.notNull(child);    if  (child.isBlock  &&  !this.canContainBlock)  [BUGGY]  return  true;    if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    if  (this.optionalClosing  &&  this.equals(child))  return  false;    if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  if  (child.tagName.equals( "base ")  ||  child.tagName.equals( "script ")  ||  child.tagName.equals( "noscript ")  ||  child.tagName.equals( "link ")  ||  child.tagName.equals( "meta ")  ||  child.tagName.equals( "title ")  ||  child.tagName.equals( "style ")  ||  child.tagName.equals( "object "))  {        [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  !child.isBlock  &&  !this.canContainInline  )  return  false;	[BUGGY]  if  (  !child.isBlock  ||  !this.canContainInline)return  false;  [CONTEXT]  return  tag;  }  }        Test  if  this  tag,  the  prospective  parent,  can  accept  the  proposed  child.  @param  child  potential  child  tag.  @return  true  if  this  can  contain  child.      boolean  canContain(Tag  child)  {  Validate.notNull(child);    if  (child.isBlock  &&  !this.canContainBlock)  return  false;    [BUGGY]  if(  !child.isBlock  ||  !this.canContainInline  )  return  false;      if  (this.optionalClosing  &&  this.equals(child))  return  false;    if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  if  (child.tagName.equals( "base ")  ||  child.tagName.equals( "script ")  ||  child.tagName.equals( "noscript ")  ||  child.tagName.equals( "link ")  ||  child.tagName.equals( "meta ")  ||  child.tagName.equals( "title ")  ||  child.tagName.equals( "style ")  ||  child.tagName.equals( "object "))  {  return  true;  }        [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  !child.isBlock  &&  !this.canContainInline  )  return  false;	[BUGGY]  if  (  !child.isBlock  &&  !this.canContainInline)return  true;  [CONTEXT]  return  tag;  }  }        Test  if  this  tag,  the  prospective  parent,  can  accept  the  proposed  child.  @param  child  potential  child  tag.  @return  true  if  this  can  contain  child.      boolean  canContain(Tag  child)  {  Validate.notNull(child);    if  (child.isBlock  &&  !this.canContainBlock)  return  false;    [BUGGY]  if(  !child.isBlock  &&  !this.canContainInline  )  return  true;      if  (this.optionalClosing  &&  this.equals(child))  return  false;    if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  if  (child.tagName.equals( "base ")  ||  child.tagName.equals( "script ")  ||  child.tagName.equals( "noscript ")  ||  child.tagName.equals( "link ")  ||  child.tagName.equals( "meta ")  ||  child.tagName.equals( "title ")  ||  child.tagName.equals( "style ")  ||  child.tagName.equals( "object "))  {  return  true;  }        [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  !child.isBlock  &&  !this.canContainInline  )  return  false;	[BUGGY]  if  (  !isBlock  &&  !this.canContainInline)return  false;  [CONTEXT]  return  tag;  }  }        Test  if  this  tag,  the  prospective  parent,  can  accept  the  proposed  child.  @param  child  potential  child  tag.  @return  true  if  this  can  contain  child.      boolean  canContain(Tag  child)  {  Validate.notNull(child);    if  (child.isBlock  &&  !this.canContainBlock)  return  false;    [BUGGY]  if(  !isBlock  &&  !this.canContainInline  )  return  false;      if  (this.optionalClosing  &&  this.equals(child))  return  false;    if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  if  (child.tagName.equals( "base ")  ||  child.tagName.equals( "script ")  ||  child.tagName.equals( "noscript ")  ||  child.tagName.equals( "link ")  ||  child.tagName.equals( "meta ")  ||  child.tagName.equals( "title ")  ||  child.tagName.equals( "style ")  ||  child.tagName.equals( "object "))  {  return  true;  }        [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
return  false;	[BUGGY]  return  true;  [CONTEXT]  }  }        Test  if  this  tag,  the  prospective  parent,  can  accept  the  proposed  child.  @param  child  potential  child  tag.  @return  true  if  this  can  contain  child.      boolean  canContain(Tag  child)  {  Validate.notNull(child);    if  (child.isBlock  &&  !this.canContainBlock)  return  false;    if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  [BUGGY]  return  true;    if  (this.optionalClosing  &&  this.equals(child))  return  false;    if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  if  (child.tagName.equals( "base ")  ||  child.tagName.equals( "script ")  ||  child.tagName.equals( "noscript ")  ||  child.tagName.equals( "link ")  ||  child.tagName.equals( "meta ")  ||  child.tagName.equals( "title ")  ||  child.tagName.equals( "style ")  ||  child.tagName.equals( "object "))  {  return  true;  }  return  false;        [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  this.optionalClosing  &&  this.equals  (  child  )  )  return  false;	[BUGGY]  if  (  this.optionalClosing  ||  this.equals(  child))return  false;  [CONTEXT]        Test  if  this  tag,  the  prospective  parent,  can  accept  the  proposed  child.  @param  child  potential  child  tag.  @return  true  if  this  can  contain  child.      boolean  canContain(Tag  child)  {  Validate.notNull(child);    if  (child.isBlock  &&  !this.canContainBlock)  return  false;    if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    [BUGGY]  if(  this.optionalClosing  ||  this.equals  (  child  ))  return  false;      if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  if  (child.tagName.equals( "base ")  ||  child.tagName.equals( "script ")  ||  child.tagName.equals( "noscript ")  ||  child.tagName.equals( "link ")  ||  child.tagName.equals( "meta ")  ||  child.tagName.equals( "title ")  ||  child.tagName.equals( "style ")  ||  child.tagName.equals( "object "))  {  return  true;  }  return  false;  }          [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  this.optionalClosing  &&  this.equals  (  child  )  )  return  false;	[BUGGY]  if  (  this.optionalClosing  &&  this.equals(  child))return  true;  [CONTEXT]        Test  if  this  tag,  the  prospective  parent,  can  accept  the  proposed  child.  @param  child  potential  child  tag.  @return  true  if  this  can  contain  child.      boolean  canContain(Tag  child)  {  Validate.notNull(child);    if  (child.isBlock  &&  !this.canContainBlock)  return  false;    if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    [BUGGY]  if(  this.optionalClosing  &&  this.equals  (  child  ))  return  true;      if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  if  (child.tagName.equals( "base ")  ||  child.tagName.equals( "script ")  ||  child.tagName.equals( "noscript ")  ||  child.tagName.equals( "link ")  ||  child.tagName.equals( "meta ")  ||  child.tagName.equals( "title ")  ||  child.tagName.equals( "style ")  ||  child.tagName.equals( "object "))  {  return  true;  }  return  false;  }          [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  this.optionalClosing  &&  this.equals  (  child  )  )  return  false;	[BUGGY]  if  (  this.optionalClosing  &&  this.equals(  tag))return  false;  [CONTEXT]        Test  if  this  tag,  the  prospective  parent,  can  accept  the  proposed  child.  @param  child  potential  child  tag.  @return  true  if  this  can  contain  child.      boolean  canContain(Tag  child)  {  Validate.notNull(child);    if  (child.isBlock  &&  !this.canContainBlock)  return  false;    if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    [BUGGY]  if(  this.optionalClosing  &&  this.equals  (  tag  ))  return  false;      if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  if  (child.tagName.equals( "base ")  ||  child.tagName.equals( "script ")  ||  child.tagName.equals( "noscript ")  ||  child.tagName.equals( "link ")  ||  child.tagName.equals( "meta ")  ||  child.tagName.equals( "title ")  ||  child.tagName.equals( "style ")  ||  child.tagName.equals( "object "))  {  return  true;  }  return  false;  }          [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  this.optionalClosing  &&  this.equals  (  child  )  )  return  false;	[BUGGY]  if  (  preserveWhitespace  &&  this.equals(  child))return  false;  [CONTEXT]        Test  if  this  tag,  the  prospective  parent,  can  accept  the  proposed  child.  @param  child  potential  child  tag.  @return  true  if  this  can  contain  child.      boolean  canContain(Tag  child)  {  Validate.notNull(child);    if  (child.isBlock  &&  !this.canContainBlock)  return  false;    if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    [BUGGY]  if(  preserveWhitespace  &&  this.equals  (  child  ))  return  false;      if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  if  (child.tagName.equals( "base ")  ||  child.tagName.equals( "script ")  ||  child.tagName.equals( "noscript ")  ||  child.tagName.equals( "link ")  ||  child.tagName.equals( "meta ")  ||  child.tagName.equals( "title ")  ||  child.tagName.equals( "style ")  ||  child.tagName.equals( "object "))  {  return  true;  }  return  false;  }          [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  this.optionalClosing  &&  this.equals  (  child  )  )  return  false;	[BUGGY]  if  (  child  &&  this.equals(  this.optionalClosing))return  false;  [CONTEXT]        Test  if  this  tag,  the  prospective  parent,  can  accept  the  proposed  child.  @param  child  potential  child  tag.  @return  true  if  this  can  contain  child.      boolean  canContain(Tag  child)  {  Validate.notNull(child);    if  (child.isBlock  &&  !this.canContainBlock)  return  false;    if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    [BUGGY]  if(  child  &&  this.equals  (  this.optionalClosing  ))  return  false;      if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  if  (child.tagName.equals( "base ")  ||  child.tagName.equals( "script ")  ||  child.tagName.equals( "noscript ")  ||  child.tagName.equals( "link ")  ||  child.tagName.equals( "meta ")  ||  child.tagName.equals( "title ")  ||  child.tagName.equals( "style ")  ||  child.tagName.equals( "object "))  {  return  true;  }  return  false;  }          [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  this.optionalClosing  &&  this.equals  (  child  )  )  return  false;	[BUGGY]  if  (  this.optionalClosing  &&  this.isValidParent(  child))return  false;  [CONTEXT]        Test  if  this  tag,  the  prospective  parent,  can  accept  the  proposed  child.  @param  child  potential  child  tag.  @return  true  if  this  can  contain  child.      boolean  canContain(Tag  child)  {  Validate.notNull(child);    if  (child.isBlock  &&  !this.canContainBlock)  return  false;    if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    [BUGGY]  if(  this.optionalClosing  &&  this.isValidParent  (  child  ))  return  false;      if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  if  (child.tagName.equals( "base ")  ||  child.tagName.equals( "script ")  ||  child.tagName.equals( "noscript ")  ||  child.tagName.equals( "link ")  ||  child.tagName.equals( "meta ")  ||  child.tagName.equals( "title ")  ||  child.tagName.equals( "style ")  ||  child.tagName.equals( "object "))  {  return  true;  }  return  false;  }          [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  this.optionalClosing  &&  this.equals  (  child  )  )  return  false;	[BUGGY]  if  (  this.optionalClosing  &&  this.isValidParent(  tag))return  true;  [CONTEXT]        Test  if  this  tag,  the  prospective  parent,  can  accept  the  proposed  child.  @param  child  potential  child  tag.  @return  true  if  this  can  contain  child.      boolean  canContain(Tag  child)  {  Validate.notNull(child);    if  (child.isBlock  &&  !this.canContainBlock)  return  false;    if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    [BUGGY]  if(  this.optionalClosing  &&  this.isValidParent  (  tag  ))  return  true;      if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  if  (child.tagName.equals( "base ")  ||  child.tagName.equals( "script ")  ||  child.tagName.equals( "noscript ")  ||  child.tagName.equals( "link ")  ||  child.tagName.equals( "meta ")  ||  child.tagName.equals( "title ")  ||  child.tagName.equals( "style ")  ||  child.tagName.equals( "object "))  {  return  true;  }  return  false;  }          [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
return  false;	[BUGGY]  return  true;  [CONTEXT]      Test  if  this  tag,  the  prospective  parent,  can  accept  the  proposed  child.  @param  child  potential  child  tag.  @return  true  if  this  can  contain  child.      boolean  canContain(Tag  child)  {  Validate.notNull(child);    if  (child.isBlock  &&  !this.canContainBlock)  return  false;    if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    if  (this.optionalClosing  &&  this.equals(child))  [BUGGY]  return  true;    if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  if  (child.tagName.equals( "base ")  ||  child.tagName.equals( "script ")  ||  child.tagName.equals( "noscript ")  ||  child.tagName.equals( "link ")  ||  child.tagName.equals( "meta ")  ||  child.tagName.equals( "title ")  ||  child.tagName.equals( "style ")  ||  child.tagName.equals( "object "))  {  return  true;  }  return  false;  }              [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  this.empty  ||  this.isData  (  )  )  return  false;	[BUGGY]  if  (  this.empty  &&  this.isData(  ))return  false;  [CONTEXT]  @param  child  potential  child  tag.  @return  true  if  this  can  contain  child.      boolean  canContain(Tag  child)  {  Validate.notNull(child);    if  (child.isBlock  &&  !this.canContainBlock)  return  false;    if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    if  (this.optionalClosing  &&  this.equals(child))  return  false;    [BUGGY]  if(  this.empty  &&  this.isData  ())  return  false;              if  (this.tagName.equals( "head "))  {  if  (child.tagName.equals( "base ")  ||  child.tagName.equals( "script ")  ||  child.tagName.equals( "noscript ")  ||  child.tagName.equals( "link ")  ||  child.tagName.equals( "meta ")  ||  child.tagName.equals( "title ")  ||  child.tagName.equals( "style ")  ||  child.tagName.equals( "object "))  {  return  true;  }  return  false;  }        if  (this.tagName.equals( "dt ")  &&  child.tagName.equals( "dd "))  return  false;        [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  this.empty  ||  this.isData  (  )  )  return  false;	[BUGGY]  if  (  this.empty  ||  this.isData(  ))return  true;  [CONTEXT]  @param  child  potential  child  tag.  @return  true  if  this  can  contain  child.      boolean  canContain(Tag  child)  {  Validate.notNull(child);    if  (child.isBlock  &&  !this.canContainBlock)  return  false;    if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    if  (this.optionalClosing  &&  this.equals(child))  return  false;    [BUGGY]  if(  this.empty  ||  this.isData  ())  return  true;              if  (this.tagName.equals( "head "))  {  if  (child.tagName.equals( "base ")  ||  child.tagName.equals( "script ")  ||  child.tagName.equals( "noscript ")  ||  child.tagName.equals( "link ")  ||  child.tagName.equals( "meta ")  ||  child.tagName.equals( "title ")  ||  child.tagName.equals( "style ")  ||  child.tagName.equals( "object "))  {  return  true;  }  return  false;  }        if  (this.tagName.equals( "dt ")  &&  child.tagName.equals( "dd "))  return  false;        [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  this.empty  ||  this.isData  (  )  )  return  false;	[BUGGY]  if  (  optionalClosing  ||  this.isData(  ))return  false;  [CONTEXT]  @param  child  potential  child  tag.  @return  true  if  this  can  contain  child.      boolean  canContain(Tag  child)  {  Validate.notNull(child);    if  (child.isBlock  &&  !this.canContainBlock)  return  false;    if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    if  (this.optionalClosing  &&  this.equals(child))  return  false;    [BUGGY]  if(  optionalClosing  ||  this.isData  ())  return  false;              if  (this.tagName.equals( "head "))  {  if  (child.tagName.equals( "base ")  ||  child.tagName.equals( "script ")  ||  child.tagName.equals( "noscript ")  ||  child.tagName.equals( "link ")  ||  child.tagName.equals( "meta ")  ||  child.tagName.equals( "title ")  ||  child.tagName.equals( "style ")  ||  child.tagName.equals( "object "))  {  return  true;  }  return  false;  }        if  (this.tagName.equals( "dt ")  &&  child.tagName.equals( "dd "))  return  false;        [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  this.empty  ||  this.isData  (  )  )  return  false;	[BUGGY]  if  (  this.empty  ||  this.isEmpty(  ))return  false;  [CONTEXT]  @param  child  potential  child  tag.  @return  true  if  this  can  contain  child.      boolean  canContain(Tag  child)  {  Validate.notNull(child);    if  (child.isBlock  &&  !this.canContainBlock)  return  false;    if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    if  (this.optionalClosing  &&  this.equals(child))  return  false;    [BUGGY]  if(  this.empty  ||  this.isEmpty  ())  return  false;              if  (this.tagName.equals( "head "))  {  if  (child.tagName.equals( "base ")  ||  child.tagName.equals( "script ")  ||  child.tagName.equals( "noscript ")  ||  child.tagName.equals( "link ")  ||  child.tagName.equals( "meta ")  ||  child.tagName.equals( "title ")  ||  child.tagName.equals( "style ")  ||  child.tagName.equals( "object "))  {  return  true;  }  return  false;  }        if  (this.tagName.equals( "dt ")  &&  child.tagName.equals( "dd "))  return  false;        [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
return  false;	[BUGGY]  return  true;  [CONTEXT]  @return  true  if  this  can  contain  child.      boolean  canContain(Tag  child)  {  Validate.notNull(child);    if  (child.isBlock  &&  !this.canContainBlock)  return  false;    if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    if  (this.optionalClosing  &&  this.equals(child))  return  false;    if  (this.empty  ||  this.isData())  [BUGGY]  return  true;            if  (this.tagName.equals( "head "))  {  if  (child.tagName.equals( "base ")  ||  child.tagName.equals( "script ")  ||  child.tagName.equals( "noscript ")  ||  child.tagName.equals( "link ")  ||  child.tagName.equals( "meta ")  ||  child.tagName.equals( "title ")  ||  child.tagName.equals( "style ")  ||  child.tagName.equals( "object "))  {  return  true;  }  return  false;  }        if  (this.tagName.equals( "dt ")  &&  child.tagName.equals( "dd "))  return  false;  if  (this.tagName.equals( "dd ")  &&  child.tagName.equals( "dt "))        [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  this.tagName.equals  (   "head "  )  )  {	[BUGGY]  if  (  this.tagName.equals(   "heade "))  {  [CONTEXT]    if  (child.isBlock  &&  !this.canContainBlock)  return  false;    if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    if  (this.optionalClosing  &&  this.equals(child))  return  false;    if  (this.empty  ||  this.isData())  return  false;            [BUGGY]  if(  this.tagName.equals  (   "heade "  )){  if  (child.tagName.equals( "base ")  ||  child.tagName.equals( "script ")  ||  child.tagName.equals( "noscript ")  ||  child.tagName.equals( "link ")  ||  child.tagName.equals( "meta ")  ||  child.tagName.equals( "title ")  ||  child.tagName.equals( "style ")  ||  child.tagName.equals( "object "))  {  return  true;  }  return  false;  }        if  (this.tagName.equals( "dt ")  &&  child.tagName.equals( "dd "))  return  false;  if  (this.tagName.equals( "dd ")  &&  child.tagName.equals( "dt "))  return  false;    return  true;  }        [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  this.tagName.equals  (   "head "  )  )  {	[BUGGY]  if  (  tagName.equals(   "head "))  {  [CONTEXT]    if  (child.isBlock  &&  !this.canContainBlock)  return  false;    if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    if  (this.optionalClosing  &&  this.equals(child))  return  false;    if  (this.empty  ||  this.isData())  return  false;            [BUGGY]  if(  tagName.equals  (   "head "  )){  if  (child.tagName.equals( "base ")  ||  child.tagName.equals( "script ")  ||  child.tagName.equals( "noscript ")  ||  child.tagName.equals( "link ")  ||  child.tagName.equals( "meta ")  ||  child.tagName.equals( "title ")  ||  child.tagName.equals( "style ")  ||  child.tagName.equals( "object "))  {  return  true;  }  return  false;  }        if  (this.tagName.equals( "dt ")  &&  child.tagName.equals( "dd "))  return  false;  if  (this.tagName.equals( "dd ")  &&  child.tagName.equals( "dt "))  return  false;    return  true;  }        [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  this.tagName.equals  (   "head "  )  )  {	[BUGGY]  if  (  equals( "base ")  ||  equals( "script "))  ||  equals( "noscript "))  ||  equals( "link "))  ||  equals( "meta "))  ||  equals( "title ")  ||  equals( "style ")))  {  [CONTEXT]    if  (child.isBlock  &&  !this.canContainBlock)  return  false;    if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    if  (this.optionalClosing  &&  this.equals(child))  return  false;    if  (this.empty  ||  this.isData())  return  false;            [BUGGY]  if(  equals( "base ")  ||  equals( "script "))  ||  equals( "noscript "))  ||  equals( "link "))  ||  equals( "meta "))  ||  equals( "title ")  ||  equals( "style "))  ){  if  (child.tagName.equals( "base ")  ||  child.tagName.equals( "script ")  ||  child.tagName.equals( "noscript ")  ||  child.tagName.equals( "link ")  ||  child.tagName.equals( "meta ")  ||  child.tagName.equals( "title ")  ||  child.tagName.equals( "style ")  ||  child.tagName.equals( "object "))  {  return  true;  }  return  false;  }        if  (this.tagName.equals( "dt ")  &&  child.tagName.equals( "dd "))  return  false;  if  (this.tagName.equals( "dd ")  &&  child.tagName.equals( "dt "))  return  false;    return  true;  }        [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  this.tagName.equals  (   "head "  )  )  {	[BUGGY]  if  (  equals( "base ")  ||  equals( "script "))  ||  equals( "noscript "))  ||  equals( "link "))  ||  equals( "meta ")  ||  equals( "title ")))  {  [CONTEXT]    if  (child.isBlock  &&  !this.canContainBlock)  return  false;    if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    if  (this.optionalClosing  &&  this.equals(child))  return  false;    if  (this.empty  ||  this.isData())  return  false;            [BUGGY]  if(  equals( "base ")  ||  equals( "script "))  ||  equals( "noscript "))  ||  equals( "link "))  ||  equals( "meta ")  ||  equals( "title "))  ){  if  (child.tagName.equals( "base ")  ||  child.tagName.equals( "script ")  ||  child.tagName.equals( "noscript ")  ||  child.tagName.equals( "link ")  ||  child.tagName.equals( "meta ")  ||  child.tagName.equals( "title ")  ||  child.tagName.equals( "style ")  ||  child.tagName.equals( "object "))  {  return  true;  }  return  false;  }        if  (this.tagName.equals( "dt ")  &&  child.tagName.equals( "dd "))  return  false;  if  (this.tagName.equals( "dd ")  &&  child.tagName.equals( "dt "))  return  false;    return  true;  }        [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  this.tagName.equals  (   "head "  )  )  {	[BUGGY]  if  (  equals( "base ")  ||  equals( "script "))  ||  equals( "noscript "))  ||  equals( "link ")  ||  equals( "meta ")))  {  [CONTEXT]    if  (child.isBlock  &&  !this.canContainBlock)  return  false;    if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    if  (this.optionalClosing  &&  this.equals(child))  return  false;    if  (this.empty  ||  this.isData())  return  false;            [BUGGY]  if(  equals( "base ")  ||  equals( "script "))  ||  equals( "noscript "))  ||  equals( "link ")  ||  equals( "meta "))  ){  if  (child.tagName.equals( "base ")  ||  child.tagName.equals( "script ")  ||  child.tagName.equals( "noscript ")  ||  child.tagName.equals( "link ")  ||  child.tagName.equals( "meta ")  ||  child.tagName.equals( "title ")  ||  child.tagName.equals( "style ")  ||  child.tagName.equals( "object "))  {  return  true;  }  return  false;  }        if  (this.tagName.equals( "dt ")  &&  child.tagName.equals( "dd "))  return  false;  if  (this.tagName.equals( "dd ")  &&  child.tagName.equals( "dt "))  return  false;    return  true;  }        [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  this.tagName.equals  (   "head "  )  )  {	[BUGGY]  if  (  equals( "base ")  ||  equals( "script "))  ||  equals( "noscript ")  ||  equals( "link ")))  {  [CONTEXT]    if  (child.isBlock  &&  !this.canContainBlock)  return  false;    if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    if  (this.optionalClosing  &&  this.equals(child))  return  false;    if  (this.empty  ||  this.isData())  return  false;            [BUGGY]  if(  equals( "base ")  ||  equals( "script "))  ||  equals( "noscript ")  ||  equals( "link "))  ){  if  (child.tagName.equals( "base ")  ||  child.tagName.equals( "script ")  ||  child.tagName.equals( "noscript ")  ||  child.tagName.equals( "link ")  ||  child.tagName.equals( "meta ")  ||  child.tagName.equals( "title ")  ||  child.tagName.equals( "style ")  ||  child.tagName.equals( "object "))  {  return  true;  }  return  false;  }        if  (this.tagName.equals( "dt ")  &&  child.tagName.equals( "dd "))  return  false;  if  (this.tagName.equals( "dd ")  &&  child.tagName.equals( "dt "))  return  false;    return  true;  }        [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  this.tagName.equals  (   "head "  )  )  {	[BUGGY]  if  (  equals( "base ")  ||  equals( "script ")  ||  equals( "noscript ")))  {  [CONTEXT]    if  (child.isBlock  &&  !this.canContainBlock)  return  false;    if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    if  (this.optionalClosing  &&  this.equals(child))  return  false;    if  (this.empty  ||  this.isData())  return  false;            [BUGGY]  if(  equals( "base ")  ||  equals( "script ")  ||  equals( "noscript "))  ){  if  (child.tagName.equals( "base ")  ||  child.tagName.equals( "script ")  ||  child.tagName.equals( "noscript ")  ||  child.tagName.equals( "link ")  ||  child.tagName.equals( "meta ")  ||  child.tagName.equals( "title ")  ||  child.tagName.equals( "style ")  ||  child.tagName.equals( "object "))  {  return  true;  }  return  false;  }        if  (this.tagName.equals( "dt ")  &&  child.tagName.equals( "dd "))  return  false;  if  (this.tagName.equals( "dd ")  &&  child.tagName.equals( "dt "))  return  false;    return  true;  }        [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  this.tagName.equals  (   "head "  )  )  {	[BUGGY]  if  (  equals( "base "  ||  equals( "script ")))  {  [CONTEXT]    if  (child.isBlock  &&  !this.canContainBlock)  return  false;    if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    if  (this.optionalClosing  &&  this.equals(child))  return  false;    if  (this.empty  ||  this.isData())  return  false;            [BUGGY]  if(  equals( "base "  ||  equals( "script "))  ){  if  (child.tagName.equals( "base ")  ||  child.tagName.equals( "script ")  ||  child.tagName.equals( "noscript ")  ||  child.tagName.equals( "link ")  ||  child.tagName.equals( "meta ")  ||  child.tagName.equals( "title ")  ||  child.tagName.equals( "style ")  ||  child.tagName.equals( "object "))  {  return  true;  }  return  false;  }        if  (this.tagName.equals( "dt ")  &&  child.tagName.equals( "dd "))  return  false;  if  (this.tagName.equals( "dd ")  &&  child.tagName.equals( "dt "))  return  false;    return  true;  }        [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  this.tagName.equals  (   "head "  )  )  {  if  (  child.tagName.equals  (   "base "  )  ||  child.tagName.equals  (   "script "  )  ||  child.tagName.equals  (   "noscript "  )  ||  child.tagName.equals  (   "link "  )  ||  child.tagName.equals  (   "meta "  )  ||  child.tagName.equals  (   "title "  )  ||  child.tagName.equals  (   "style "  )  ||  child.tagName.equals  (   "object "  )  )  {  return  true;  }	[BUGGY]  if((((((((child.tagName.equals( "base "))  ||(child.tagName.equals( "script ")))  ||(child.tagName.equals( "noscript ")))  ||(child.tagName.equals( "link ")))  ||(child.tagName.equals( "meta ")))  ||(child.tagName.equals( "title ")))  ||(child.tagName.equals( "style ")))  ||(child.tagName.equals( "object ")))  {        return  true;};  return  false;  [CONTEXT]    if  (child.isBlock  &&  !this.canContainBlock)  return  false;    if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    if  (this.optionalClosing  &&  this.equals(child))  return  false;    if  (this.empty  ||  this.isData())  return  false;            [BUGGY]  if  (this.tagName.equals( "head "))  {    if  ((((((((child.tagName.equals( "base "))  ||  (child.tagName.equals( "script ")))  ||  (child.tagName.equals( "noscript ")))  ||  (child.tagName.equals( "link ")))  ||  (child.tagName.equals( "meta ")))  ||  (child.tagName.equals( "title ")))  ||  (child.tagName.equals( "style ")))  ||  (child.tagName.equals( "object ")))  {return  true;};  return  false;        return  false;  }        if  (this.tagName.equals( "dt ")  &&  child.tagName.equals( "dd "))  return  false;  if  (this.tagName.equals( "dd ")  &&  child.tagName.equals( "dt "))  return  false;    return  true;        [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  this.tagName.equals  (   "head "  )  )  {  if  (  child.tagName.equals  (   "base "  )  ||  child.tagName.equals  (   "script "  )  ||  child.tagName.equals  (   "noscript "  )  ||  child.tagName.equals  (   "link "  )  ||  child.tagName.equals  (   "meta "  )  ||  child.tagName.equals  (   "title "  )  ||  child.tagName.equals  (   "style "  )  ||  child.tagName.equals  (   "object "  )  )  {  return  true;  }	[BUGGY]    [CONTEXT]    if  (child.isBlock  &&  !this.canContainBlock)  return  false;    if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    if  (this.optionalClosing  &&  this.equals(child))  return  false;    if  (this.empty  ||  this.isData())  return  false;            [BUGGY]  if  (this.tagName.equals( "head "))  {            return  false;  }        if  (this.tagName.equals( "dt ")  &&  child.tagName.equals( "dd "))  return  false;  if  (this.tagName.equals( "dd ")  &&  child.tagName.equals( "dt "))  return  false;    return  true;        [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  child.tagName.equals  (   "base "  )  ||  child.tagName.equals  (   "script "  )  ||  child.tagName.equals  (   "noscript "  )  ||  child.tagName.equals  (   "link "  )  ||  child.tagName.equals  (   "meta "  )  ||  child.tagName.equals  (   "title "  )  ||  child.tagName.equals  (   "style "  )  ||  child.tagName.equals  (   "object "  )  )  {	[BUGGY]  if  (  child.tagName.equals(   "base ")  &&  child.tagName.equals(   "script ")  ||  child.tagName.equals(   "noscript ")  ||  child.tagName.equals(   "link ")  ||  child.tagName.equals(   "meta ")  ||  child.tagName.equals(   "title ")  ||  child.tagName.equals(   "style ")  ||  child.tagName.equals(   "object "))  {  [CONTEXT]  if  (child.isBlock  &&  !this.canContainBlock)  return  false;    if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    if  (this.optionalClosing  &&  this.equals(child))  return  false;    if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  [BUGGY]  if(  child.tagName.equals  (   "base "  )&&  child.tagName.equals  (   "script "  )||  child.tagName.equals  (   "noscript "  )||  child.tagName.equals  (   "link "  )||  child.tagName.equals  (   "meta "  )||  child.tagName.equals  (   "title "  )||  child.tagName.equals  (   "style "  )||  child.tagName.equals  (   "object "  )){    return  true;  }  return  false;  }        if  (this.tagName.equals( "dt ")  &&  child.tagName.equals( "dd "))  return  false;  if  (this.tagName.equals( "dd ")  &&  child.tagName.equals( "dt "))  return  false;    return  true;  }          [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  child.tagName.equals  (   "base "  )  ||  child.tagName.equals  (   "script "  )  ||  child.tagName.equals  (   "noscript "  )  ||  child.tagName.equals  (   "link "  )  ||  child.tagName.equals  (   "meta "  )  ||  child.tagName.equals  (   "title "  )  ||  child.tagName.equals  (   "style "  )  ||  child.tagName.equals  (   "object "  )  )  {	[BUGGY]  if  (  child.tagName.equals(   "b ")  ||  child.tagName.equals(   "script ")  ||  child.tagName.equals(   "noscript ")  ||  child.tagName.equals(   "link ")  ||  child.tagName.equals(   "meta ")  ||  child.tagName.equals(   "title ")  ||  child.tagName.equals(   "style ")  ||  child.tagName.equals(   "object "))  {  [CONTEXT]  if  (child.isBlock  &&  !this.canContainBlock)  return  false;    if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    if  (this.optionalClosing  &&  this.equals(child))  return  false;    if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  [BUGGY]  if(  child.tagName.equals  (   "b "  )||  child.tagName.equals  (   "script "  )||  child.tagName.equals  (   "noscript "  )||  child.tagName.equals  (   "link "  )||  child.tagName.equals  (   "meta "  )||  child.tagName.equals  (   "title "  )||  child.tagName.equals  (   "style "  )||  child.tagName.equals  (   "object "  )){    return  true;  }  return  false;  }        if  (this.tagName.equals( "dt ")  &&  child.tagName.equals( "dd "))  return  false;  if  (this.tagName.equals( "dd ")  &&  child.tagName.equals( "dt "))  return  false;    return  true;  }          [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  child.tagName.equals  (   "base "  )  ||  child.tagName.equals  (   "script "  )  ||  child.tagName.equals  (   "noscript "  )  ||  child.tagName.equals  (   "link "  )  ||  child.tagName.equals  (   "meta "  )  ||  child.tagName.equals  (   "title "  )  ||  child.tagName.equals  (   "style "  )  ||  child.tagName.equals  (   "object "  )  )  {	[BUGGY]  if  (  child.tagName.equals(   "base ")  ||  child.tagName.equals(   "rcript ")  ||  child.tagName.equals(   "noscript ")  ||  child.tagName.equals(   "link ")  ||  child.tagName.equals(   "meta ")  ||  child.tagName.equals(   "title ")  ||  child.tagName.equals(   "style ")  ||  child.tagName.equals(   "object "))  {  [CONTEXT]  if  (child.isBlock  &&  !this.canContainBlock)  return  false;    if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    if  (this.optionalClosing  &&  this.equals(child))  return  false;    if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  [BUGGY]  if(  child.tagName.equals  (   "base "  )||  child.tagName.equals  (   "rcript "  )||  child.tagName.equals  (   "noscript "  )||  child.tagName.equals  (   "link "  )||  child.tagName.equals  (   "meta "  )||  child.tagName.equals  (   "title "  )||  child.tagName.equals  (   "style "  )||  child.tagName.equals  (   "object "  )){    return  true;  }  return  false;  }        if  (this.tagName.equals( "dt ")  &&  child.tagName.equals( "dd "))  return  false;  if  (this.tagName.equals( "dd ")  &&  child.tagName.equals( "dt "))  return  false;    return  true;  }          [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  child.tagName.equals  (   "base "  )  ||  child.tagName.equals  (   "script "  )  ||  child.tagName.equals  (   "noscript "  )  ||  child.tagName.equals  (   "link "  )  ||  child.tagName.equals  (   "meta "  )  ||  child.tagName.equals  (   "title "  )  ||  child.tagName.equals  (   "style "  )  ||  child.tagName.equals  (   "object "  )  )  {	[BUGGY]  if  (  child.tagName.equals(   "base ")  ||  child.tagName.equals(   "script ")  ||  child.tagName.equals(   "noscriptnosc ")  ||  child.tagName.equals(   "link ")  ||  child.tagName.equals(   "meta ")  ||  child.tagName.equals(   "title ")  ||  child.tagName.equals(   "style ")  ||  child.tagName.equals(   "object "))  {  [CONTEXT]  if  (child.isBlock  &&  !this.canContainBlock)  return  false;    if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    if  (this.optionalClosing  &&  this.equals(child))  return  false;    if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  [BUGGY]  if(  child.tagName.equals  (   "base "  )||  child.tagName.equals  (   "script "  )||  child.tagName.equals  (   "noscriptnosc "  )||  child.tagName.equals  (   "link "  )||  child.tagName.equals  (   "meta "  )||  child.tagName.equals  (   "title "  )||  child.tagName.equals  (   "style "  )||  child.tagName.equals  (   "object "  )){    return  true;  }  return  false;  }        if  (this.tagName.equals( "dt ")  &&  child.tagName.equals( "dd "))  return  false;  if  (this.tagName.equals( "dd ")  &&  child.tagName.equals( "dt "))  return  false;    return  true;  }          [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  child.tagName.equals  (   "base "  )  ||  child.tagName.equals  (   "script "  )  ||  child.tagName.equals  (   "noscript "  )  ||  child.tagName.equals  (   "link "  )  ||  child.tagName.equals  (   "meta "  )  ||  child.tagName.equals  (   "title "  )  ||  child.tagName.equals  (   "style "  )  ||  child.tagName.equals  (   "object "  )  )  {	[BUGGY]  if  (  child.tagName.equals(   "base ")  ||  child.tagName.equals(   "script ")  ||  child.tagName.equals(   "noscript ")  ||  child.tagName.equals(   " ")  ||  child.tagName.equals(   "meta ")  ||  child.tagName.equals(   "title ")  ||  child.tagName.equals(   "style ")  ||  child.tagName.equals(   "object "))  {  [CONTEXT]  if  (child.isBlock  &&  !this.canContainBlock)  return  false;    if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    if  (this.optionalClosing  &&  this.equals(child))  return  false;    if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  [BUGGY]  if(  child.tagName.equals  (   "base "  )||  child.tagName.equals  (   "script "  )||  child.tagName.equals  (   "noscript "  )||  child.tagName.equals  (   " "  )||  child.tagName.equals  (   "meta "  )||  child.tagName.equals  (   "title "  )||  child.tagName.equals  (   "style "  )||  child.tagName.equals  (   "object "  )){    return  true;  }  return  false;  }        if  (this.tagName.equals( "dt ")  &&  child.tagName.equals( "dd "))  return  false;  if  (this.tagName.equals( "dd ")  &&  child.tagName.equals( "dt "))  return  false;    return  true;  }          [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  child.tagName.equals  (   "base "  )  ||  child.tagName.equals  (   "script "  )  ||  child.tagName.equals  (   "noscript "  )  ||  child.tagName.equals  (   "link "  )  ||  child.tagName.equals  (   "meta "  )  ||  child.tagName.equals  (   "title "  )  ||  child.tagName.equals  (   "style "  )  ||  child.tagName.equals  (   "object "  )  )  {	[BUGGY]  if  (  child.tagName.equals(   "base ")  ||  child.tagName.equals(   "script ")  ||  child.tagName.equals(   "noscript ")  ||  child.tagName.equals(   "link ")  ||  child.tagName.equals(   "meteta ")  ||  child.tagName.equals(   "title ")  ||  child.tagName.equals(   "style ")  ||  child.tagName.equals(   "object "))  {  [CONTEXT]  if  (child.isBlock  &&  !this.canContainBlock)  return  false;    if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    if  (this.optionalClosing  &&  this.equals(child))  return  false;    if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  [BUGGY]  if(  child.tagName.equals  (   "base "  )||  child.tagName.equals  (   "script "  )||  child.tagName.equals  (   "noscript "  )||  child.tagName.equals  (   "link "  )||  child.tagName.equals  (   "meteta "  )||  child.tagName.equals  (   "title "  )||  child.tagName.equals  (   "style "  )||  child.tagName.equals  (   "object "  )){    return  true;  }  return  false;  }        if  (this.tagName.equals( "dt ")  &&  child.tagName.equals( "dd "))  return  false;  if  (this.tagName.equals( "dd ")  &&  child.tagName.equals( "dt "))  return  false;    return  true;  }          [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  child.tagName.equals  (   "base "  )  ||  child.tagName.equals  (   "script "  )  ||  child.tagName.equals  (   "noscript "  )  ||  child.tagName.equals  (   "link "  )  ||  child.tagName.equals  (   "meta "  )  ||  child.tagName.equals  (   "title "  )  ||  child.tagName.equals  (   "style "  )  ||  child.tagName.equals  (   "object "  )  )  {	[BUGGY]  if  (  child.tagName.equals(   "base ")  ||  child.tagName.equals(   "script ")  ||  child.tagName.equals(   "noscript ")  ||  child.tagName.equals(   "link ")  ||  child.tagName.equals(   "meta ")  ||  child.tagName.equals(   " ")  ||  child.tagName.equals(   "style ")  ||  child.tagName.equals(   "object "))  {  [CONTEXT]  if  (child.isBlock  &&  !this.canContainBlock)  return  false;    if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    if  (this.optionalClosing  &&  this.equals(child))  return  false;    if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  [BUGGY]  if(  child.tagName.equals  (   "base "  )||  child.tagName.equals  (   "script "  )||  child.tagName.equals  (   "noscript "  )||  child.tagName.equals  (   "link "  )||  child.tagName.equals  (   "meta "  )||  child.tagName.equals  (   " "  )||  child.tagName.equals  (   "style "  )||  child.tagName.equals  (   "object "  )){    return  true;  }  return  false;  }        if  (this.tagName.equals( "dt ")  &&  child.tagName.equals( "dd "))  return  false;  if  (this.tagName.equals( "dd ")  &&  child.tagName.equals( "dt "))  return  false;    return  true;  }          [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  child.tagName.equals  (   "base "  )  ||  child.tagName.equals  (   "script "  )  ||  child.tagName.equals  (   "noscript "  )  ||  child.tagName.equals  (   "link "  )  ||  child.tagName.equals  (   "meta "  )  ||  child.tagName.equals  (   "title "  )  ||  child.tagName.equals  (   "style "  )  ||  child.tagName.equals  (   "object "  )  )  {	[BUGGY]  if  (  child.tagName.equals(   "base ")  ||  child.tagName.equals(   "script ")  ||  child.tagName.equals(   "noscript ")  ||  child.tagName.equals(   "link ")  ||  child.tagName.equals(   "meta ")  ||  child.tagName.equals(   "title ")  ||  child.tagName.equals(   "ytyle ")  ||  child.tagName.equals(   "object "))  {  [CONTEXT]  if  (child.isBlock  &&  !this.canContainBlock)  return  false;    if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    if  (this.optionalClosing  &&  this.equals(child))  return  false;    if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  [BUGGY]  if(  child.tagName.equals  (   "base "  )||  child.tagName.equals  (   "script "  )||  child.tagName.equals  (   "noscript "  )||  child.tagName.equals  (   "link "  )||  child.tagName.equals  (   "meta "  )||  child.tagName.equals  (   "title "  )||  child.tagName.equals  (   "ytyle "  )||  child.tagName.equals  (   "object "  )){    return  true;  }  return  false;  }        if  (this.tagName.equals( "dt ")  &&  child.tagName.equals( "dd "))  return  false;  if  (this.tagName.equals( "dd ")  &&  child.tagName.equals( "dt "))  return  false;    return  true;  }          [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  child.tagName.equals  (   "base "  )  ||  child.tagName.equals  (   "script "  )  ||  child.tagName.equals  (   "noscript "  )  ||  child.tagName.equals  (   "link "  )  ||  child.tagName.equals  (   "meta "  )  ||  child.tagName.equals  (   "title "  )  ||  child.tagName.equals  (   "style "  )  ||  child.tagName.equals  (   "object "  )  )  {	[BUGGY]  if  (  child.tagName.equals(   "base ")  ||  child.tagName.equals(   "script ")  ||  child.tagName.equals(   "noscript ")  ||  child.tagName.equals(   "link ")  ||  child.tagName.equals(   "meta ")  ||  child.tagName.equals(   "title ")  ||  child.tagName.equals(   "style ")  ||  child.tagName.equals(   "ob "))  {  [CONTEXT]  if  (child.isBlock  &&  !this.canContainBlock)  return  false;    if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    if  (this.optionalClosing  &&  this.equals(child))  return  false;    if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  [BUGGY]  if(  child.tagName.equals  (   "base "  )||  child.tagName.equals  (   "script "  )||  child.tagName.equals  (   "noscript "  )||  child.tagName.equals  (   "link "  )||  child.tagName.equals  (   "meta "  )||  child.tagName.equals  (   "title "  )||  child.tagName.equals  (   "style "  )||  child.tagName.equals  (   "ob "  )){    return  true;  }  return  false;  }        if  (this.tagName.equals( "dt ")  &&  child.tagName.equals( "dd "))  return  false;  if  (this.tagName.equals( "dd ")  &&  child.tagName.equals( "dt "))  return  false;    return  true;  }          [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  child.tagName.equals  (   "base "  )  ||  child.tagName.equals  (   "script "  )  ||  child.tagName.equals  (   "noscript "  )  ||  child.tagName.equals  (   "link "  )  ||  child.tagName.equals  (   "meta "  )  ||  child.tagName.equals  (   "title "  )  ||  child.tagName.equals  (   "style "  )  ||  child.tagName.equals  (   "object "  )  )  {	[BUGGY]  if  (  tag.tagName.equals(   "base ")  ||  child.tagName.equals(   "script ")  ||  child.tagName.equals(   "noscript ")  ||  child.tagName.equals(   "link ")  ||  child.tagName.equals(   "meta ")  ||  child.tagName.equals(   "title ")  ||  child.tagName.equals(   "style ")  ||  child.tagName.equals(   "object "))  {  [CONTEXT]  if  (child.isBlock  &&  !this.canContainBlock)  return  false;    if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    if  (this.optionalClosing  &&  this.equals(child))  return  false;    if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  [BUGGY]  if(  tag.tagName.equals  (   "base "  )||  child.tagName.equals  (   "script "  )||  child.tagName.equals  (   "noscript "  )||  child.tagName.equals  (   "link "  )||  child.tagName.equals  (   "meta "  )||  child.tagName.equals  (   "title "  )||  child.tagName.equals  (   "style "  )||  child.tagName.equals  (   "object "  )){    return  true;  }  return  false;  }        if  (this.tagName.equals( "dt ")  &&  child.tagName.equals( "dd "))  return  false;  if  (this.tagName.equals( "dd ")  &&  child.tagName.equals( "dt "))  return  false;    return  true;  }          [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  child.tagName.equals  (   "base "  )  ||  child.tagName.equals  (   "script "  )  ||  child.tagName.equals  (   "noscript "  )  ||  child.tagName.equals  (   "link "  )  ||  child.tagName.equals  (   "meta "  )  ||  child.tagName.equals  (   "title "  )  ||  child.tagName.equals  (   "style "  )  ||  child.tagName.equals  (   "object "  )  )  {	[BUGGY]  if  (  child.tagName.tagName.equals(   "base ")  ||  child.equals(   "script ")  ||  child.tagName.equals(   "noscript ")  ||  child.tagName.equals(   "link ")  ||  child.tagName.equals(   "meta ")  ||  child.tagName.equals(   "title ")  ||  child.tagName.equals(   "style ")  ||  child.tagName.equals(   "object "))  {  [CONTEXT]  if  (child.isBlock  &&  !this.canContainBlock)  return  false;    if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    if  (this.optionalClosing  &&  this.equals(child))  return  false;    if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  [BUGGY]  if(  child.tagName.tagName.equals  (   "base "  )||  child.equals  (   "script "  )||  child.tagName.equals  (   "noscript "  )||  child.tagName.equals  (   "link "  )||  child.tagName.equals  (   "meta "  )||  child.tagName.equals  (   "title "  )||  child.tagName.equals  (   "style "  )||  child.tagName.equals  (   "object "  )){    return  true;  }  return  false;  }        if  (this.tagName.equals( "dt ")  &&  child.tagName.equals( "dd "))  return  false;  if  (this.tagName.equals( "dd ")  &&  child.tagName.equals( "dt "))  return  false;    return  true;  }          [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  child.tagName.equals  (   "base "  )  ||  child.tagName.equals  (   "script "  )  ||  child.tagName.equals  (   "noscript "  )  ||  child.tagName.equals  (   "link "  )  ||  child.tagName.equals  (   "meta "  )  ||  child.tagName.equals  (   "title "  )  ||  child.tagName.equals  (   "style "  )  ||  child.tagName.equals  (   "object "  )  )  {	[BUGGY]  if  (  child.equals(   "base ")  ||  child.tagName.tagName.equals(   "script ")  ||  child.tagName.equals(   "noscript ")  ||  child.tagName.equals(   "link ")  ||  child.tagName.equals(   "meta ")  ||  child.tagName.equals(   "title ")  ||  child.tagName.equals(   "style ")  ||  child.tagName.equals(   "object "))  {  [CONTEXT]  if  (child.isBlock  &&  !this.canContainBlock)  return  false;    if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    if  (this.optionalClosing  &&  this.equals(child))  return  false;    if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  [BUGGY]  if(  child.equals  (   "base "  )||  child.tagName.tagName.equals  (   "script "  )||  child.tagName.equals  (   "noscript "  )||  child.tagName.equals  (   "link "  )||  child.tagName.equals  (   "meta "  )||  child.tagName.equals  (   "title "  )||  child.tagName.equals  (   "style "  )||  child.tagName.equals  (   "object "  )){    return  true;  }  return  false;  }        if  (this.tagName.equals( "dt ")  &&  child.tagName.equals( "dd "))  return  false;  if  (this.tagName.equals( "dd ")  &&  child.tagName.equals( "dt "))  return  false;    return  true;  }          [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  child.tagName.equals  (   "base "  )  ||  child.tagName.equals  (   "script "  )  ||  child.tagName.equals  (   "noscript "  )  ||  child.tagName.equals  (   "link "  )  ||  child.tagName.equals  (   "meta "  )  ||  child.tagName.equals  (   "title "  )  ||  child.tagName.equals  (   "style "  )  ||  child.tagName.equals  (   "object "  )  )  {	[BUGGY]  if  (  child.tagName.equals(   "base ")){  [CONTEXT]  if  (child.isBlock  &&  !this.canContainBlock)  return  false;    if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    if  (this.optionalClosing  &&  this.equals(child))  return  false;    if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  [BUGGY]  if(  child.tagName.equals  (   "base "  ))  {    return  true;  }  return  false;  }        if  (this.tagName.equals( "dt ")  &&  child.tagName.equals( "dd "))  return  false;  if  (this.tagName.equals( "dd ")  &&  child.tagName.equals( "dt "))  return  false;    return  true;  }          [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  child.tagName.equals  (   "base "  )  ||  child.tagName.equals  (   "script "  )  ||  child.tagName.equals  (   "noscript "  )  ||  child.tagName.equals  (   "link "  )  ||  child.tagName.equals  (   "meta "  )  ||  child.tagName.equals  (   "title "  )  ||  child.tagName.equals  (   "style "  )  ||  child.tagName.equals  (   "object "  )  )  {	[BUGGY]  if  (    child.tagName.equals(   "script ")  ||  child.tagName.equals(   "noscript ")  ||  child.tagName.equals(   "link ")  ||  child.tagName.equals(   "meta ")  ||  child.tagName.equals(   "title ")  ||  child.tagName.equals(   "style ")  ||  child.tagName.equals(   "object "))  {  [CONTEXT]  if  (child.isBlock  &&  !this.canContainBlock)  return  false;    if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    if  (this.optionalClosing  &&  this.equals(child))  return  false;    if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  [BUGGY]  if(child.tagName.equals  (   "script "  )||  child.tagName.equals  (   "noscript "  )||  child.tagName.equals  (   "link "  )||  child.tagName.equals  (   "meta "  )||  child.tagName.equals  (   "title "  )||  child.tagName.equals  (   "style "  )||  child.tagName.equals  (   "object "  )){    return  true;  }  return  false;  }        if  (this.tagName.equals( "dt ")  &&  child.tagName.equals( "dd "))  return  false;  if  (this.tagName.equals( "dd ")  &&  child.tagName.equals( "dt "))  return  false;    return  true;  }          [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  child.tagName.equals  (   "base "  )  ||  child.tagName.equals  (   "script "  )  ||  child.tagName.equals  (   "noscript "  )  ||  child.tagName.equals  (   "link "  )  ||  child.tagName.equals  (   "meta "  )  ||  child.tagName.equals  (   "title "  )  ||  child.tagName.equals  (   "style "  )  ||  child.tagName.equals  (   "object "  )  )  {	[BUGGY]  if  (  equals( "base ")  ||  equals( "script "))  ||  equals( "noscript "))  ||  equals( "link "))  ||  equals( "meta "))  ||  equals( "title ")  ||  equals( "style ")))  {  [CONTEXT]  if  (child.isBlock  &&  !this.canContainBlock)  return  false;    if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    if  (this.optionalClosing  &&  this.equals(child))  return  false;    if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  [BUGGY]  if(  equals( "base ")  ||  equals( "script "))  ||  equals( "noscript "))  ||  equals( "link "))  ||  equals( "meta "))  ||  equals( "title ")  ||  equals( "style "))  ){    return  true;  }  return  false;  }        if  (this.tagName.equals( "dt ")  &&  child.tagName.equals( "dd "))  return  false;  if  (this.tagName.equals( "dd ")  &&  child.tagName.equals( "dt "))  return  false;    return  true;  }          [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  child.tagName.equals  (   "base "  )  ||  child.tagName.equals  (   "script "  )  ||  child.tagName.equals  (   "noscript "  )  ||  child.tagName.equals  (   "link "  )  ||  child.tagName.equals  (   "meta "  )  ||  child.tagName.equals  (   "title "  )  ||  child.tagName.equals  (   "style "  )  ||  child.tagName.equals  (   "object "  )  )  {	[BUGGY]  if  (  equals( "base ")  ||  equals( "script "))  ||  equals( "noscript "))  ||  equals( "link "))  ||  equals( "meta ")  ||  equals( "title ")))  {  [CONTEXT]  if  (child.isBlock  &&  !this.canContainBlock)  return  false;    if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    if  (this.optionalClosing  &&  this.equals(child))  return  false;    if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  [BUGGY]  if(  equals( "base ")  ||  equals( "script "))  ||  equals( "noscript "))  ||  equals( "link "))  ||  equals( "meta ")  ||  equals( "title "))  ){    return  true;  }  return  false;  }        if  (this.tagName.equals( "dt ")  &&  child.tagName.equals( "dd "))  return  false;  if  (this.tagName.equals( "dd ")  &&  child.tagName.equals( "dt "))  return  false;    return  true;  }          [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  child.tagName.equals  (   "base "  )  ||  child.tagName.equals  (   "script "  )  ||  child.tagName.equals  (   "noscript "  )  ||  child.tagName.equals  (   "link "  )  ||  child.tagName.equals  (   "meta "  )  ||  child.tagName.equals  (   "title "  )  ||  child.tagName.equals  (   "style "  )  ||  child.tagName.equals  (   "object "  )  )  {	[BUGGY]  if  (  equals( "base ")  ||  equals( "script "))  ||  equals( "noscript "))  ||  equals( "link ")  ||  equals( "meta ")))  {  [CONTEXT]  if  (child.isBlock  &&  !this.canContainBlock)  return  false;    if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    if  (this.optionalClosing  &&  this.equals(child))  return  false;    if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  [BUGGY]  if(  equals( "base ")  ||  equals( "script "))  ||  equals( "noscript "))  ||  equals( "link ")  ||  equals( "meta "))  ){    return  true;  }  return  false;  }        if  (this.tagName.equals( "dt ")  &&  child.tagName.equals( "dd "))  return  false;  if  (this.tagName.equals( "dd ")  &&  child.tagName.equals( "dt "))  return  false;    return  true;  }          [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  child.tagName.equals  (   "base "  )  ||  child.tagName.equals  (   "script "  )  ||  child.tagName.equals  (   "noscript "  )  ||  child.tagName.equals  (   "link "  )  ||  child.tagName.equals  (   "meta "  )  ||  child.tagName.equals  (   "title "  )  ||  child.tagName.equals  (   "style "  )  ||  child.tagName.equals  (   "object "  )  )  {	[BUGGY]  if  (  equals( "base ")  ||  equals( "script "))  ||  equals( "noscript ")  ||  equals( "link ")))  {  [CONTEXT]  if  (child.isBlock  &&  !this.canContainBlock)  return  false;    if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    if  (this.optionalClosing  &&  this.equals(child))  return  false;    if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  [BUGGY]  if(  equals( "base ")  ||  equals( "script "))  ||  equals( "noscript ")  ||  equals( "link "))  ){    return  true;  }  return  false;  }        if  (this.tagName.equals( "dt ")  &&  child.tagName.equals( "dd "))  return  false;  if  (this.tagName.equals( "dd ")  &&  child.tagName.equals( "dt "))  return  false;    return  true;  }          [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  child.tagName.equals  (   "base "  )  ||  child.tagName.equals  (   "script "  )  ||  child.tagName.equals  (   "noscript "  )  ||  child.tagName.equals  (   "link "  )  ||  child.tagName.equals  (   "meta "  )  ||  child.tagName.equals  (   "title "  )  ||  child.tagName.equals  (   "style "  )  ||  child.tagName.equals  (   "object "  )  )  {	[BUGGY]  if  (  equals( "base ")  ||  equals( "script ")  ||  equals( "noscript ")))  {  [CONTEXT]  if  (child.isBlock  &&  !this.canContainBlock)  return  false;    if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    if  (this.optionalClosing  &&  this.equals(child))  return  false;    if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  [BUGGY]  if(  equals( "base ")  ||  equals( "script ")  ||  equals( "noscript "))  ){    return  true;  }  return  false;  }        if  (this.tagName.equals( "dt ")  &&  child.tagName.equals( "dd "))  return  false;  if  (this.tagName.equals( "dd ")  &&  child.tagName.equals( "dt "))  return  false;    return  true;  }          [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  child.tagName.equals  (   "base "  )  ||  child.tagName.equals  (   "script "  )  ||  child.tagName.equals  (   "noscript "  )  ||  child.tagName.equals  (   "link "  )  ||  child.tagName.equals  (   "meta "  )  ||  child.tagName.equals  (   "title "  )  ||  child.tagName.equals  (   "style "  )  ||  child.tagName.equals  (   "object "  )  )  {	[BUGGY]  if  (  equals( "base "  ||  equals( "script ")))  {  [CONTEXT]  if  (child.isBlock  &&  !this.canContainBlock)  return  false;    if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    if  (this.optionalClosing  &&  this.equals(child))  return  false;    if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  [BUGGY]  if(  equals( "base "  ||  equals( "script "))  ){    return  true;  }  return  false;  }        if  (this.tagName.equals( "dt ")  &&  child.tagName.equals( "dd "))  return  false;  if  (this.tagName.equals( "dd ")  &&  child.tagName.equals( "dt "))  return  false;    return  true;  }          [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  child.tagName.equals  (   "base "  )  ||  child.tagName.equals  (   "script "  )  ||  child.tagName.equals  (   "noscript "  )  ||  child.tagName.equals  (   "link "  )  ||  child.tagName.equals  (   "meta "  )  ||  child.tagName.equals  (   "title "  )  ||  child.tagName.equals  (   "style "  )  ||  child.tagName.equals  (   "object "  )  )  {	[BUGGY]  if  (  child.tagName  .equals(  3)    ||  child.tagName  [CONTEXT]  if  (child.isBlock  &&  !this.canContainBlock)  return  false;    if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    if  (this.optionalClosing  &&  this.equals(child))  return  false;    if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  [BUGGY]  if(  child.tagName  .equals  (  3  )  ||  child.tagName    return  true;  }  return  false;  }        if  (this.tagName.equals( "dt ")  &&  child.tagName.equals( "dd "))  return  false;  if  (this.tagName.equals( "dd ")  &&  child.tagName.equals( "dt "))  return  false;    return  true;  }          [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  child.tagName.equals  (   "base "  )  ||  child.tagName.equals  (   "script "  )  ||  child.tagName.equals  (   "noscript "  )  ||  child.tagName.equals  (   "link "  )  ||  child.tagName.equals  (   "meta "  )  ||  child.tagName.equals  (   "title "  )  ||  child.tagName.equals  (   "style "  )  ||  child.tagName.equals  (   "object "  )  )  {  return  true;  }	[BUGGY]  return  true;  [CONTEXT]  if  (child.isBlock  &&  !this.canContainBlock)  return  false;    if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    if  (this.optionalClosing  &&  this.equals(child))  return  false;    if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  [BUGGY]  if  (child.tagName.equals( "base ")  ||  child.tagName.equals( "script ")  ||  child.tagName.equals( "noscript ")  ||  child.tagName.equals( "link ")  ||    return  true;      return  false;  }        if  (this.tagName.equals( "dt ")  &&  child.tagName.equals( "dd "))  return  false;  if  (this.tagName.equals( "dd ")  &&  child.tagName.equals( "dt "))  return  false;    return  true;  }        [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  child.tagName.equals  (   "base "  )  ||  child.tagName.equals  (   "script "  )  ||  child.tagName.equals  (   "noscript "  )  ||  child.tagName.equals  (   "link "  )  ||  child.tagName.equals  (   "meta "  )  ||  child.tagName.equals  (   "title "  )  ||  child.tagName.equals  (   "style "  )  ||  child.tagName.equals  (   "object "  )  )  {  return  true;  }	[BUGGY]    [CONTEXT]  if  (child.isBlock  &&  !this.canContainBlock)  return  false;    if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    if  (this.optionalClosing  &&  this.equals(child))  return  false;    if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  [BUGGY]  if  (child.tagName.equals( "base ")  ||  child.tagName.equals( "script ")  ||  child.tagName.equals( "noscript ")  ||  child.tagName.equals( "link ")  ||          return  false;  }        if  (this.tagName.equals( "dt ")  &&  child.tagName.equals( "dd "))  return  false;  if  (this.tagName.equals( "dd ")  &&  child.tagName.equals( "dt "))  return  false;    return  true;  }        [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
[Delete]	[BUGGY]  if  (  equals(   "head "))  {          if  (  (  (  (  (  (  (  (  equals(   "base "))  ||  (  equals(   "script ")))  ||  (  equals(   "noscript ")))  ||  (  equals(   "link ")))  ||  (  equals(   "meta ")))  ||  (  equals(   "title ")))  ||  (  equals(   "style ")))  ||  (  equals(   "object ")))  {                  return  true;          }          return  false;  }  [CONTEXT]        [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
return  true;	[BUGGY]  return  false;  [CONTEXT]  if  (child.tagName.equals( "base ")  ||  child.tagName.equals( "script ")  ||  child.tagName.equals( "noscript ")  ||  child.tagName.equals( "link ")  ||  child.tagName.equals( "meta ")  ||  child.tagName.equals( "title ")  ||  child.tagName.equals( "style ")  ||  child.tagName.equals( "object "))  {  [BUGGY]  return  false;  }        [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
return  true;	[BUGGY]  return  false;  [CONTEXT]    if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    if  (this.optionalClosing  &&  this.equals(child))  return  false;    if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  if  (child.tagName.equals( "base ")  ||  child.tagName.equals( "script ")  ||  child.tagName.equals( "noscript ")  ||  child.tagName.equals( "link ")  ||  child.tagName.equals( "meta ")  ||  child.tagName.equals( "title ")  ||  child.tagName.equals( "style ")  ||  child.tagName.equals( "object "))  {  [BUGGY]  return  false;  }  return  false;  }        if  (this.tagName.equals( "dt ")  &&  child.tagName.equals( "dd "))  return  false;  if  (this.tagName.equals( "dd ")  &&  child.tagName.equals( "dt "))  return  false;    return  true;  }        Gets  if  this  is  a  block  tag.        [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
return  false;	[BUGGY]  return  true;  [CONTEXT]  return  false;    if  (this.optionalClosing  &&  this.equals(child))  return  false;    if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  if  (child.tagName.equals( "base ")  ||  child.tagName.equals( "script ")  ||  child.tagName.equals( "noscript ")  ||  child.tagName.equals( "link ")  ||  child.tagName.equals( "meta ")  ||  child.tagName.equals( "title ")  ||  child.tagName.equals( "style ")  ||  child.tagName.equals( "object "))  {  return  true;  }  [BUGGY]  return  true;  }        if  (this.tagName.equals( "dt ")  &&  child.tagName.equals( "dd "))  return  false;  if  (this.tagName.equals( "dd ")  &&  child.tagName.equals( "dt "))  return  false;    return  true;  }        Gets  if  this  is  a  block  tag.  @return  if  block  tag            [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  child.tagName.equals  (   "base "  )  ||  child.tagName.equals  (   "script "  )  ||  child.tagName.equals  (   "noscript "  )  ||  child.tagName.equals  (   "link "  )  ||  child.tagName.equals  (   "meta "  )  ||  child.tagName.equals  (   "title "  )  ||  child.tagName.equals  (   "style "  )  ||  child.tagName.equals  (   "object "  )  )  {	[BUGGY]  if  (  child.tagName.equals(   "a ")  ||  child.tagName.equals(   "script ")  ||  child.tagName.equals(   "noscript ")  ||  child.tagName.equals(   "link ")  ||  child.tagName.equals(   "meta ")  ||  child.tagName.equals(   "title ")  ||  child.tagName.equals(   "style ")  ||  child.tagName.equals(   "object "))  {  [CONTEXT]  if  (child.isBlock  &&  !this.canContainBlock)  return  false;    if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    if  (this.optionalClosing  &&  this.equals(child))  return  false;    if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  [BUGGY]  if(  child.tagName.equals  (   "a "  )||  child.tagName.equals  (   "script "  )||  child.tagName.equals  (   "noscript "  )||  child.tagName.equals  (   "link "  )||  child.tagName.equals  (   "meta "  )||  child.tagName.equals  (   "title "  )||  child.tagName.equals  (   "style "  )||  child.tagName.equals  (   "object "  )){    return  true;  }  return  false;  }        if  (this.tagName.equals( "dt ")  &&  child.tagName.equals( "dd "))  return  false;  if  (this.tagName.equals( "dd ")  &&  child.tagName.equals( "dt "))  return  false;    return  true;  }          [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  child.tagName.equals  (   "base "  )  ||  child.tagName.equals  (   "script "  )  ||  child.tagName.equals  (   "noscript "  )  ||  child.tagName.equals  (   "link "  )  ||  child.tagName.equals  (   "meta "  )  ||  child.tagName.equals  (   "title "  )  ||  child.tagName.equals  (   "style "  )  ||  child.tagName.equals  (   "object "  )  )  {	[BUGGY]  if  (  tagName.equals(   "base ")  ||  child.tagName.equals(   "script ")  ||  child.tagName.equals(   "noscript ")  ||  child.tagName.equals(   "link ")  ||  child.tagName.equals(   "meta ")  ||  child.tagName.equals(   "title ")  ||  child.tagName.equals(   "style ")  ||  child.tagName.equals(   "object "))  {  [CONTEXT]  if  (child.isBlock  &&  !this.canContainBlock)  return  false;    if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    if  (this.optionalClosing  &&  this.equals(child))  return  false;    if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  [BUGGY]  if(  tagName.equals  (   "base "  )||  child.tagName.equals  (   "script "  )||  child.tagName.equals  (   "noscript "  )||  child.tagName.equals  (   "link "  )||  child.tagName.equals  (   "meta "  )||  child.tagName.equals  (   "title "  )||  child.tagName.equals  (   "style "  )||  child.tagName.equals  (   "object "  )){    return  true;  }  return  false;  }        if  (this.tagName.equals( "dt ")  &&  child.tagName.equals( "dd "))  return  false;  if  (this.tagName.equals( "dd ")  &&  child.tagName.equals( "dt "))  return  false;    return  true;  }          [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  child.tagName.equals  (   "base "  )  ||  child.tagName.equals  (   "script "  )  ||  child.tagName.equals  (   "noscript "  )  ||  child.tagName.equals  (   "link "  )  ||  child.tagName.equals  (   "meta "  )  ||  child.tagName.equals  (   "title "  )  ||  child.tagName.equals  (   "style "  )  ||  child.tagName.equals  (   "object "  )  )  {	[BUGGY]  if  (  child.tagName.equals(   "base ")  ||  child.tagName.equals(   "scriptsc ")  ||  child.tagName.equals(   "noscript ")  ||  child.tagName.equals(   "link ")  ||  child.tagName.equals(   "meta ")  ||  child.tagName.equals(   "title ")  ||  child.tagName.equals(   "style ")  ||  child.tagName.equals(   "object "))  {  [CONTEXT]  if  (child.isBlock  &&  !this.canContainBlock)  return  false;    if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    if  (this.optionalClosing  &&  this.equals(child))  return  false;    if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  [BUGGY]  if(  child.tagName.equals  (   "base "  )||  child.tagName.equals  (   "scriptsc "  )||  child.tagName.equals  (   "noscript "  )||  child.tagName.equals  (   "link "  )||  child.tagName.equals  (   "meta "  )||  child.tagName.equals  (   "title "  )||  child.tagName.equals  (   "style "  )||  child.tagName.equals  (   "object "  )){    return  true;  }  return  false;  }        if  (this.tagName.equals( "dt ")  &&  child.tagName.equals( "dd "))  return  false;  if  (this.tagName.equals( "dd ")  &&  child.tagName.equals( "dt "))  return  false;    return  true;  }          [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  child.tagName.equals  (   "base "  )  ||  child.tagName.equals  (   "script "  )  ||  child.tagName.equals  (   "noscript "  )  ||  child.tagName.equals  (   "link "  )  ||  child.tagName.equals  (   "meta "  )  ||  child.tagName.equals  (   "title "  )  ||  child.tagName.equals  (   "style "  )  ||  child.tagName.equals  (   "object "  )  )  {	[BUGGY]  if  (  child.tagName.equals(   "base ")  ||  child.tagName.equals(   "script ")  ||  child.tagName.equals(   "nooscript ")  ||  child.tagName.equals(   "link ")  ||  child.tagName.equals(   "meta ")  ||  child.tagName.equals(   "title ")  ||  child.tagName.equals(   "style ")  ||  child.tagName.equals(   "object "))  {  [CONTEXT]  if  (child.isBlock  &&  !this.canContainBlock)  return  false;    if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    if  (this.optionalClosing  &&  this.equals(child))  return  false;    if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  [BUGGY]  if(  child.tagName.equals  (   "base "  )||  child.tagName.equals  (   "script "  )||  child.tagName.equals  (   "nooscript "  )||  child.tagName.equals  (   "link "  )||  child.tagName.equals  (   "meta "  )||  child.tagName.equals  (   "title "  )||  child.tagName.equals  (   "style "  )||  child.tagName.equals  (   "object "  )){    return  true;  }  return  false;  }        if  (this.tagName.equals( "dt ")  &&  child.tagName.equals( "dd "))  return  false;  if  (this.tagName.equals( "dd ")  &&  child.tagName.equals( "dt "))  return  false;    return  true;  }          [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  child.tagName.equals  (   "base "  )  ||  child.tagName.equals  (   "script "  )  ||  child.tagName.equals  (   "noscript "  )  ||  child.tagName.equals  (   "link "  )  ||  child.tagName.equals  (   "meta "  )  ||  child.tagName.equals  (   "title "  )  ||  child.tagName.equals  (   "style "  )  ||  child.tagName.equals  (   "object "  )  )  {	[BUGGY]  if  (  child.tagName.equals(   "base ")  ||  child.tagName.equals(   "script ")  ||  child.tagName.equals(   "noscript ")  ||  child.tagName.equals(   "nink ")  ||  child.tagName.equals(   "meta ")  ||  child.tagName.equals(   "title ")  ||  child.tagName.equals(   "style ")  ||  child.tagName.equals(   "object "))  {  [CONTEXT]  if  (child.isBlock  &&  !this.canContainBlock)  return  false;    if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    if  (this.optionalClosing  &&  this.equals(child))  return  false;    if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  [BUGGY]  if(  child.tagName.equals  (   "base "  )||  child.tagName.equals  (   "script "  )||  child.tagName.equals  (   "noscript "  )||  child.tagName.equals  (   "nink "  )||  child.tagName.equals  (   "meta "  )||  child.tagName.equals  (   "title "  )||  child.tagName.equals  (   "style "  )||  child.tagName.equals  (   "object "  )){    return  true;  }  return  false;  }        if  (this.tagName.equals( "dt ")  &&  child.tagName.equals( "dd "))  return  false;  if  (this.tagName.equals( "dd ")  &&  child.tagName.equals( "dt "))  return  false;    return  true;  }          [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
child.tagName.equals  (   "meta "  )  ||  child.tagName.equals  (   "title "  )  ||  child.tagName.equals  (   "style "  )  ||  child.tagName.equals  (   "object "  )  )  {	[BUGGY]  child.tagName.equals(   "m ")  ||  child.tagName.equals(   "title ")  ||  child.tagName.equals(   "style ")  ||  child.tagName.equals(   "object "))  {  [CONTEXT]  return  false;    if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    if  (this.optionalClosing  &&  this.equals(child))  return  false;    if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  if  (child.tagName.equals( "base ")  ||  child.tagName.equals( "script ")  ||  child.tagName.equals( "noscript ")  ||  child.tagName.equals( "link ")  ||  [BUGGY]  child.tagName.equals  (   "m "  )||  child.tagName.equals  (   "title "  )||  child.tagName.equals  (   "style "  )||  child.tagName.equals  (   "object "  )){  return  true;  }  return  false;  }        if  (this.tagName.equals( "dt ")  &&  child.tagName.equals( "dd "))  return  false;  if  (this.tagName.equals( "dd ")  &&  child.tagName.equals( "dt "))  return  false;    return  true;  }              [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
child.tagName.equals  (   "meta "  )  ||  child.tagName.equals  (   "title "  )  ||  child.tagName.equals  (   "style "  )  ||  child.tagName.equals  (   "object "  )  )  {	[BUGGY]  child.tagName.equals(   "meta ")  ||  tag.tagName.equals(   "title ")  ||  child.tagName.equals(   "style ")  ||  child.tagName.equals(   "object "))  {  [CONTEXT]  return  false;    if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    if  (this.optionalClosing  &&  this.equals(child))  return  false;    if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  if  (child.tagName.equals( "base ")  ||  child.tagName.equals( "script ")  ||  child.tagName.equals( "noscript ")  ||  child.tagName.equals( "link ")  ||  [BUGGY]  child.tagName.equals  (   "meta "  )||  tag.tagName.equals  (   "title "  )||  child.tagName.equals  (   "style "  )||  child.tagName.equals  (   "object "  )){  return  true;  }  return  false;  }        if  (this.tagName.equals( "dt ")  &&  child.tagName.equals( "dd "))  return  false;  if  (this.tagName.equals( "dd ")  &&  child.tagName.equals( "dt "))  return  false;    return  true;  }              [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
child.tagName.equals  (   "meta "  )  ||  child.tagName.equals  (   "title "  )  ||  child.tagName.equals  (   "style "  )  ||  child.tagName.equals  (   "object "  )  )  {	[BUGGY]  child.tagName.equals(   "meta ")  ||  child.tagName.tagName.equals(   "title ")  ||  child.equals(   "style ")  ||  child.tagName.equals(   "object "))  {  [CONTEXT]  return  false;    if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    if  (this.optionalClosing  &&  this.equals(child))  return  false;    if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  if  (child.tagName.equals( "base ")  ||  child.tagName.equals( "script ")  ||  child.tagName.equals( "noscript ")  ||  child.tagName.equals( "link ")  ||  [BUGGY]  child.tagName.equals  (   "meta "  )||  child.tagName.tagName.equals  (   "title "  )||  child.equals  (   "style "  )||  child.tagName.equals  (   "object "  )){  return  true;  }  return  false;  }        if  (this.tagName.equals( "dt ")  &&  child.tagName.equals( "dd "))  return  false;  if  (this.tagName.equals( "dd ")  &&  child.tagName.equals( "dt "))  return  false;    return  true;  }              [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
child.tagName.equals  (   "meta "  )  ||  child.tagName.equals  (   "title "  )  ||  child.tagName.equals  (   "style "  )  ||  child.tagName.equals  (   "object "  )  )  {	[BUGGY]  child.tagName.equals(   "meta ")  ||  child.equals(   "title ")  ||  child.tagName.tagName.equals(   "style ")  ||  child.tagName.equals(   "object "))  {  [CONTEXT]  return  false;    if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    if  (this.optionalClosing  &&  this.equals(child))  return  false;    if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  if  (child.tagName.equals( "base ")  ||  child.tagName.equals( "script ")  ||  child.tagName.equals( "noscript ")  ||  child.tagName.equals( "link ")  ||  [BUGGY]  child.tagName.equals  (   "meta "  )||  child.equals  (   "title "  )||  child.tagName.tagName.equals  (   "style "  )||  child.tagName.equals  (   "object "  )){  return  true;  }  return  false;  }        if  (this.tagName.equals( "dt ")  &&  child.tagName.equals( "dd "))  return  false;  if  (this.tagName.equals( "dd ")  &&  child.tagName.equals( "dt "))  return  false;    return  true;  }              [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
child.tagName.equals  (   "meta "  )  ||  child.tagName.equals  (   "title "  )  ||  child.tagName.equals  (   "style "  )  ||  child.tagName.equals  (   "object "  )  )  {	[BUGGY]  child.tagName.equals(   "meta ")  ||  tagName.equals(   "title ")  ||  child.tagName.equals(   "style ")  ||  child.tagName.equals(   "object "))  {  [CONTEXT]  return  false;    if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    if  (this.optionalClosing  &&  this.equals(child))  return  false;    if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  if  (child.tagName.equals( "base ")  ||  child.tagName.equals( "script ")  ||  child.tagName.equals( "noscript ")  ||  child.tagName.equals( "link ")  ||  [BUGGY]  child.tagName.equals  (   "meta "  )||  tagName.equals  (   "title "  )||  child.tagName.equals  (   "style "  )||  child.tagName.equals  (   "object "  )){  return  true;  }  return  false;  }        if  (this.tagName.equals( "dt ")  &&  child.tagName.equals( "dd "))  return  false;  if  (this.tagName.equals( "dd ")  &&  child.tagName.equals( "dt "))  return  false;    return  true;  }              [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
child.tagName.equals  (   "meta "  )  ||  child.tagName.equals  (   "title "  )  ||  child.tagName.equals  (   "style "  )  ||  child.tagName.equals  (   "object "  )  )  {  return  true;	[BUGGY]    [CONTEXT]  return  false;    if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    if  (this.optionalClosing  &&  this.equals(child))  return  false;    if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  if  (child.tagName.equals( "base ")  ||  child.tagName.equals( "script ")  ||  child.tagName.equals( "noscript ")  ||  child.tagName.equals( "link ")  ||  [BUGGY]  child.tagName.equals( "meta ")  ||  child.tagName.equals( "title ")  ||  child.tagName.equals( "style ")  ||  child.tagName.equals( "object "))  {      }  return  false;  }        if  (this.tagName.equals( "dt ")  &&  child.tagName.equals( "dd "))  return  false;  if  (this.tagName.equals( "dd ")  &&  child.tagName.equals( "dt "))  return  false;    return  true;  }          [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
child.tagName.equals  (   "meta "  )  ||  child.tagName.equals  (   "title "  )  ||  child.tagName.equals  (   "style "  )  ||  child.tagName.equals  (   "object "  )  )  {	[BUGGY]  child.tagName.equals(   "meta ")  ||  child.tagName.equals(   "itle ")  ||  child.tagName.equals(   "style ")  ||  child.tagName.equals(   "object "))  {  [CONTEXT]  return  false;    if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    if  (this.optionalClosing  &&  this.equals(child))  return  false;    if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  if  (child.tagName.equals( "base ")  ||  child.tagName.equals( "script ")  ||  child.tagName.equals( "noscript ")  ||  child.tagName.equals( "link ")  ||  [BUGGY]  child.tagName.equals  (   "meta "  )||  child.tagName.equals  (   "itle "  )||  child.tagName.equals  (   "style "  )||  child.tagName.equals  (   "object "  )){  return  true;  }  return  false;  }        if  (this.tagName.equals( "dt ")  &&  child.tagName.equals( "dd "))  return  false;  if  (this.tagName.equals( "dd ")  &&  child.tagName.equals( "dt "))  return  false;    return  true;  }              [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
child.tagName.equals  (   "meta "  )  ||  child.tagName.equals  (   "title "  )  ||  child.tagName.equals  (   "style "  )  ||  child.tagName.equals  (   "object "  )  )  {	[BUGGY]  child.tagName.equals(   "meta ")  ||  child.tagName.equals(   "title ")  ||  child.tagName.equals(   "stytyle ")  ||  child.tagName.equals(   "object "))  {  [CONTEXT]  return  false;    if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    if  (this.optionalClosing  &&  this.equals(child))  return  false;    if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  if  (child.tagName.equals( "base ")  ||  child.tagName.equals( "script ")  ||  child.tagName.equals( "noscript ")  ||  child.tagName.equals( "link ")  ||  [BUGGY]  child.tagName.equals  (   "meta "  )||  child.tagName.equals  (   "title "  )||  child.tagName.equals  (   "stytyle "  )||  child.tagName.equals  (   "object "  )){  return  true;  }  return  false;  }        if  (this.tagName.equals( "dt ")  &&  child.tagName.equals( "dd "))  return  false;  if  (this.tagName.equals( "dd ")  &&  child.tagName.equals( "dt "))  return  false;    return  true;  }              [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
child.tagName.equals  (   "meta "  )  ||  child.tagName.equals  (   "title "  )  ||  child.tagName.equals  (   "style "  )  ||  child.tagName.equals  (   "object "  )  )  {	[BUGGY]  child.tagName.equals(   "meta ")  ||  child.tagName.equals(   "title ")  ||  child.tagName.equals(   "style ")  ||  child.tagName.equals(   "bject "))  {  [CONTEXT]  return  false;    if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    if  (this.optionalClosing  &&  this.equals(child))  return  false;    if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  if  (child.tagName.equals( "base ")  ||  child.tagName.equals( "script ")  ||  child.tagName.equals( "noscript ")  ||  child.tagName.equals( "link ")  ||  [BUGGY]  child.tagName.equals  (   "meta "  )||  child.tagName.equals  (   "title "  )||  child.tagName.equals  (   "style "  )||  child.tagName.equals  (   "bject "  )){  return  true;  }  return  false;  }        if  (this.tagName.equals( "dt ")  &&  child.tagName.equals( "dd "))  return  false;  if  (this.tagName.equals( "dd ")  &&  child.tagName.equals( "dt "))  return  false;    return  true;  }              [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  child.tagName.equals  (   "base "  )  ||  child.tagName.equals  (   "script "  )  ||  child.tagName.equals  (   "noscript "  )  ||  child.tagName.equals  (   "link "  )  ||  child.tagName.equals  (   "meta "  )  ||  child.tagName.equals  (   "title "  )  ||  child.tagName.equals  (   "style "  )  ||  child.tagName.equals  (   "object "  )  )  {	[BUGGY]  if  (  child.tagName.equals(   "baseb ")  ||  child.tagName.equals(   "script ")  ||  child.tagName.equals(   "noscript ")  ||  child.tagName.equals(   "link ")  ||  child.tagName.equals(   "meta ")  ||  child.tagName.equals(   "title ")  ||  child.tagName.equals(   "style ")  ||  child.tagName.equals(   "object "))  {  [CONTEXT]  if  (child.isBlock  &&  !this.canContainBlock)  return  false;    if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    if  (this.optionalClosing  &&  this.equals(child))  return  false;    if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  [BUGGY]  if(  child.tagName.equals  (   "baseb "  )||  child.tagName.equals  (   "script "  )||  child.tagName.equals  (   "noscript "  )||  child.tagName.equals  (   "link "  )||  child.tagName.equals  (   "meta "  )||  child.tagName.equals  (   "title "  )||  child.tagName.equals  (   "style "  )||  child.tagName.equals  (   "object "  )){    return  true;  }  return  false;  }        if  (this.tagName.equals( "dt ")  &&  child.tagName.equals( "dd "))  return  false;  if  (this.tagName.equals( "dd ")  &&  child.tagName.equals( "dt "))  return  false;    return  true;  }          [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  child.tagName.equals  (   "base "  )  ||  child.tagName.equals  (   "script "  )  ||  child.tagName.equals  (   "noscript "  )  ||  child.tagName.equals  (   "link "  )  ||  child.tagName.equals  (   "meta "  )  ||  child.tagName.equals  (   "title "  )  ||  child.tagName.equals  (   "style "  )  ||  child.tagName.equals  (   "object "  )  )  {	[BUGGY]  if  (  child.tagName.equals(   "base ")  ||  child.tagName.equals(   "scriptip ")  ||  child.tagName.equals(   "noscript ")  ||  child.tagName.equals(   "link ")  ||  child.tagName.equals(   "meta ")  ||  child.tagName.equals(   "title ")  ||  child.tagName.equals(   "style ")  ||  child.tagName.equals(   "object "))  {  [CONTEXT]  if  (child.isBlock  &&  !this.canContainBlock)  return  false;    if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    if  (this.optionalClosing  &&  this.equals(child))  return  false;    if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  [BUGGY]  if(  child.tagName.equals  (   "base "  )||  child.tagName.equals  (   "scriptip "  )||  child.tagName.equals  (   "noscript "  )||  child.tagName.equals  (   "link "  )||  child.tagName.equals  (   "meta "  )||  child.tagName.equals  (   "title "  )||  child.tagName.equals  (   "style "  )||  child.tagName.equals  (   "object "  )){    return  true;  }  return  false;  }        if  (this.tagName.equals( "dt ")  &&  child.tagName.equals( "dd "))  return  false;  if  (this.tagName.equals( "dd ")  &&  child.tagName.equals( "dt "))  return  false;    return  true;  }          [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  child.tagName.equals  (   "base "  )  ||  child.tagName.equals  (   "script "  )  ||  child.tagName.equals  (   "noscript "  )  ||  child.tagName.equals  (   "link "  )  ||  child.tagName.equals  (   "meta "  )  ||  child.tagName.equals  (   "title "  )  ||  child.tagName.equals  (   "style "  )  ||  child.tagName.equals  (   "object "  )  )  {	[BUGGY]  if  (  child.tagName.equals(   "base ")  ||  child.tagName.equals(   "script ")  ||  child.tagName.equals(   "noscriptnoscrip ")  ||  child.tagName.equals(   "link ")  ||  child.tagName.equals(   "meta ")  ||  child.tagName.equals(   "title ")  ||  child.tagName.equals(   "style ")  ||  child.tagName.equals(   "object "))  {  [CONTEXT]  if  (child.isBlock  &&  !this.canContainBlock)  return  false;    if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    if  (this.optionalClosing  &&  this.equals(child))  return  false;    if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  [BUGGY]  if(  child.tagName.equals  (   "base "  )||  child.tagName.equals  (   "script "  )||  child.tagName.equals  (   "noscriptnoscrip "  )||  child.tagName.equals  (   "link "  )||  child.tagName.equals  (   "meta "  )||  child.tagName.equals  (   "title "  )||  child.tagName.equals  (   "style "  )||  child.tagName.equals  (   "object "  )){    return  true;  }  return  false;  }        if  (this.tagName.equals( "dt ")  &&  child.tagName.equals( "dd "))  return  false;  if  (this.tagName.equals( "dd ")  &&  child.tagName.equals( "dt "))  return  false;    return  true;  }          [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  child.tagName.equals  (   "base "  )  ||  child.tagName.equals  (   "script "  )  ||  child.tagName.equals  (   "noscript "  )  ||  child.tagName.equals  (   "link "  )  ||  child.tagName.equals  (   "meta "  )  ||  child.tagName.equals  (   "title "  )  ||  child.tagName.equals  (   "style "  )  ||  child.tagName.equals  (   "object "  )  )  {	[BUGGY]  if  (  child.tagName.equals(   "base ")  ||  child.tagName.equals(   "script ")  ||  child.tagName.equals(   "noscript ")  ||  child.tagName.equals(   "linink ")  ||  child.tagName.equals(   "meta ")  ||  child.tagName.equals(   "title ")  ||  child.tagName.equals(   "style ")  ||  child.tagName.equals(   "object "))  {  [CONTEXT]  if  (child.isBlock  &&  !this.canContainBlock)  return  false;    if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    if  (this.optionalClosing  &&  this.equals(child))  return  false;    if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  [BUGGY]  if(  child.tagName.equals  (   "base "  )||  child.tagName.equals  (   "script "  )||  child.tagName.equals  (   "noscript "  )||  child.tagName.equals  (   "linink "  )||  child.tagName.equals  (   "meta "  )||  child.tagName.equals  (   "title "  )||  child.tagName.equals  (   "style "  )||  child.tagName.equals  (   "object "  )){    return  true;  }  return  false;  }        if  (this.tagName.equals( "dt ")  &&  child.tagName.equals( "dd "))  return  false;  if  (this.tagName.equals( "dd ")  &&  child.tagName.equals( "dt "))  return  false;    return  true;  }          [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  child.tagName.equals  (   "base "  )  ||  child.tagName.equals  (   "script "  )  ||  child.tagName.equals  (   "noscript "  )  ||  child.tagName.equals  (   "link "  )  ||  child.tagName.equals  (   "meta "  )  ||  child.tagName.equals  (   "title "  )  ||  child.tagName.equals  (   "style "  )  ||  child.tagName.equals  (   "object "  )  )  {	[BUGGY]  if  (  child.tagName.equals(   "base ")  ||  child.tagName.equals(   "script ")  ||  child.tagName.equals(   "noscript ")  ||  child.tagName.equals(   "link ")  ||  child.tagName.equals(   "t ")  ||  child.tagName.equals(   "title ")  ||  child.tagName.equals(   "style ")  ||  child.tagName.equals(   "object "))  {  [CONTEXT]  if  (child.isBlock  &&  !this.canContainBlock)  return  false;    if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    if  (this.optionalClosing  &&  this.equals(child))  return  false;    if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  [BUGGY]  if(  child.tagName.equals  (   "base "  )||  child.tagName.equals  (   "script "  )||  child.tagName.equals  (   "noscript "  )||  child.tagName.equals  (   "link "  )||  child.tagName.equals  (   "t "  )||  child.tagName.equals  (   "title "  )||  child.tagName.equals  (   "style "  )||  child.tagName.equals  (   "object "  )){    return  true;  }  return  false;  }        if  (this.tagName.equals( "dt ")  &&  child.tagName.equals( "dd "))  return  false;  if  (this.tagName.equals( "dd ")  &&  child.tagName.equals( "dt "))  return  false;    return  true;  }          [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  child.tagName.equals  (   "base "  )  ||  child.tagName.equals  (   "script "  )  ||  child.tagName.equals  (   "noscript "  )  ||  child.tagName.equals  (   "link "  )  ||  child.tagName.equals  (   "meta "  )  ||  child.tagName.equals  (   "title "  )  ||  child.tagName.equals  (   "style "  )  ||  child.tagName.equals  (   "object "  )  )  {	[BUGGY]  if  (  child.tagName.equals(   "base ")  ||  child.tagName.equals(   "script ")  ||  child.tagName.equals(   "noscript ")  ||  child.tagName.equals(   "link ")  ||  child.tagName.equals(   "meta ")  ||  child.tagName.equals(   "title ")  ||  child.tagName.equals(   "stylest ")  ||  child.tagName.equals(   "object "))  {  [CONTEXT]  if  (child.isBlock  &&  !this.canContainBlock)  return  false;    if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    if  (this.optionalClosing  &&  this.equals(child))  return  false;    if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  [BUGGY]  if(  child.tagName.equals  (   "base "  )||  child.tagName.equals  (   "script "  )||  child.tagName.equals  (   "noscript "  )||  child.tagName.equals  (   "link "  )||  child.tagName.equals  (   "meta "  )||  child.tagName.equals  (   "title "  )||  child.tagName.equals  (   "stylest "  )||  child.tagName.equals  (   "object "  )){    return  true;  }  return  false;  }        if  (this.tagName.equals( "dt ")  &&  child.tagName.equals( "dd "))  return  false;  if  (this.tagName.equals( "dd ")  &&  child.tagName.equals( "dt "))  return  false;    return  true;  }          [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  child.tagName.equals  (   "base "  )  ||  child.tagName.equals  (   "script "  )  ||  child.tagName.equals  (   "noscript "  )  ||  child.tagName.equals  (   "link "  )  ||  child.tagName.equals  (   "meta "  )  ||  child.tagName.equals  (   "title "  )  ||  child.tagName.equals  (   "style "  )  ||  child.tagName.equals  (   "object "  )  )  {	[BUGGY]  if  (  child.tagName.equals(   "base ")  ||  child.tagName.equals(   "script ")  ||  child.tagName.equals(   "noscript ")  ||  child.tagName.equals(   "link ")  ||  child.tagName.equals(   "meta ")  ||  child.tagName.equals(   "title ")  ||  child.tagName.equals(   "style ")  ||  child.tagName.equals(   "objectobj "))  {  [CONTEXT]  if  (child.isBlock  &&  !this.canContainBlock)  return  false;    if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    if  (this.optionalClosing  &&  this.equals(child))  return  false;    if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  [BUGGY]  if(  child.tagName.equals  (   "base "  )||  child.tagName.equals  (   "script "  )||  child.tagName.equals  (   "noscript "  )||  child.tagName.equals  (   "link "  )||  child.tagName.equals  (   "meta "  )||  child.tagName.equals  (   "title "  )||  child.tagName.equals  (   "style "  )||  child.tagName.equals  (   "objectobj "  )){    return  true;  }  return  false;  }        if  (this.tagName.equals( "dt ")  &&  child.tagName.equals( "dd "))  return  false;  if  (this.tagName.equals( "dd ")  &&  child.tagName.equals( "dt "))  return  false;    return  true;  }          [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  child.tagName.equals  (   "base "  )  ||  child.tagName.equals  (   "script "  )  ||  child.tagName.equals  (   "noscript "  )  ||  child.tagName.equals  (   "link "  )  ||  child.tagName.equals  (   "meta "  )  ||  child.tagName.equals  (   "title "  )  ||  child.tagName.equals  (   "style "  )  ||  child.tagName.equals  (   "object "  )  )  {	[BUGGY]  if  (  tagName.equals(   "base ")){  [CONTEXT]  if  (child.isBlock  &&  !this.canContainBlock)  return  false;    if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    if  (this.optionalClosing  &&  this.equals(child))  return  false;    if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  [BUGGY]  if(  tagName.equals  (   "base "  ))  {    return  true;  }  return  false;  }        if  (this.tagName.equals( "dt ")  &&  child.tagName.equals( "dd "))  return  false;  if  (this.tagName.equals( "dd ")  &&  child.tagName.equals( "dt "))  return  false;    return  true;  }          [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  this.tagName.equals  (   "head "  )  )  {	[BUGGY]  if  (  this.tagName.equals(   "aead "))  {  [CONTEXT]    if  (child.isBlock  &&  !this.canContainBlock)  return  false;    if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    if  (this.optionalClosing  &&  this.equals(child))  return  false;    if  (this.empty  ||  this.isData())  return  false;            [BUGGY]  if(  this.tagName.equals  (   "aead "  )){  if  (child.tagName.equals( "base ")  ||  child.tagName.equals( "script ")  ||  child.tagName.equals( "noscript ")  ||  child.tagName.equals( "link ")  ||  child.tagName.equals( "meta ")  ||  child.tagName.equals( "title ")  ||  child.tagName.equals( "style ")  ||  child.tagName.equals( "object "))  {  return  true;  }  return  false;  }        if  (this.tagName.equals( "dt ")  &&  child.tagName.equals( "dd "))  return  false;  if  (this.tagName.equals( "dd ")  &&  child.tagName.equals( "dt "))  return  false;    return  true;  }        [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  child.tagName.equals  (   "base "  )  ||  child.tagName.equals  (   "script "  )  ||  child.tagName.equals  (   "noscript "  )  ||  child.tagName.equals  (   "link "  )  ||  child.tagName.equals  (   "meta "  )  ||  child.tagName.equals  (   "title "  )  ||  child.tagName.equals  (   "style "  )  ||  child.tagName.equals  (   "object "  )  )  {	[BUGGY]  if  (  child.tagName.equals(   "sase ")  ||  child.tagName.equals(   "script ")  ||  child.tagName.equals(   "noscript ")  ||  child.tagName.equals(   "link ")  ||  child.tagName.equals(   "meta ")  ||  child.tagName.equals(   "title ")  ||  child.tagName.equals(   "style ")  ||  child.tagName.equals(   "object "))  {  [CONTEXT]  if  (child.isBlock  &&  !this.canContainBlock)  return  false;    if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    if  (this.optionalClosing  &&  this.equals(child))  return  false;    if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  [BUGGY]  if(  child.tagName.equals  (   "sase "  )||  child.tagName.equals  (   "script "  )||  child.tagName.equals  (   "noscript "  )||  child.tagName.equals  (   "link "  )||  child.tagName.equals  (   "meta "  )||  child.tagName.equals  (   "title "  )||  child.tagName.equals  (   "style "  )||  child.tagName.equals  (   "object "  )){    return  true;  }  return  false;  }        if  (this.tagName.equals( "dt ")  &&  child.tagName.equals( "dd "))  return  false;  if  (this.tagName.equals( "dd ")  &&  child.tagName.equals( "dt "))  return  false;    return  true;  }          [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  child.tagName.equals  (   "base "  )  ||  child.tagName.equals  (   "script "  )  ||  child.tagName.equals  (   "noscript "  )  ||  child.tagName.equals  (   "link "  )  ||  child.tagName.equals  (   "meta "  )  ||  child.tagName.equals  (   "title "  )  ||  child.tagName.equals  (   "style "  )  ||  child.tagName.equals  (   "object "  )  )  {	[BUGGY]  if  (  child.tagName.equals(   "base ")  ||  child.tagName.equals(   "r ")  ||  child.tagName.equals(   "noscript ")  ||  child.tagName.equals(   "link ")  ||  child.tagName.equals(   "meta ")  ||  child.tagName.equals(   "title ")  ||  child.tagName.equals(   "style ")  ||  child.tagName.equals(   "object "))  {  [CONTEXT]  if  (child.isBlock  &&  !this.canContainBlock)  return  false;    if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    if  (this.optionalClosing  &&  this.equals(child))  return  false;    if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  [BUGGY]  if(  child.tagName.equals  (   "base "  )||  child.tagName.equals  (   "r "  )||  child.tagName.equals  (   "noscript "  )||  child.tagName.equals  (   "link "  )||  child.tagName.equals  (   "meta "  )||  child.tagName.equals  (   "title "  )||  child.tagName.equals  (   "style "  )||  child.tagName.equals  (   "object "  )){    return  true;  }  return  false;  }        if  (this.tagName.equals( "dt ")  &&  child.tagName.equals( "dd "))  return  false;  if  (this.tagName.equals( "dd ")  &&  child.tagName.equals( "dt "))  return  false;    return  true;  }          [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  child.tagName.equals  (   "base "  )  ||  child.tagName.equals  (   "script "  )  ||  child.tagName.equals  (   "noscript "  )  ||  child.tagName.equals  (   "link "  )  ||  child.tagName.equals  (   "meta "  )  ||  child.tagName.equals  (   "title "  )  ||  child.tagName.equals  (   "style "  )  ||  child.tagName.equals  (   "object "  )  )  {	[BUGGY]  if  (  child.tagName.equals(   "base ")  ||  child.tagName.equals(   "script ")  ||  child.tagName.equals(   "o ")  ||  child.tagName.equals(   "link ")  ||  child.tagName.equals(   "meta ")  ||  child.tagName.equals(   "title ")  ||  child.tagName.equals(   "style ")  ||  child.tagName.equals(   "object "))  {  [CONTEXT]  if  (child.isBlock  &&  !this.canContainBlock)  return  false;    if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    if  (this.optionalClosing  &&  this.equals(child))  return  false;    if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  [BUGGY]  if(  child.tagName.equals  (   "base "  )||  child.tagName.equals  (   "script "  )||  child.tagName.equals  (   "o "  )||  child.tagName.equals  (   "link "  )||  child.tagName.equals  (   "meta "  )||  child.tagName.equals  (   "title "  )||  child.tagName.equals  (   "style "  )||  child.tagName.equals  (   "object "  )){    return  true;  }  return  false;  }        if  (this.tagName.equals( "dt ")  &&  child.tagName.equals( "dd "))  return  false;  if  (this.tagName.equals( "dd ")  &&  child.tagName.equals( "dt "))  return  false;    return  true;  }          [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  child.tagName.equals  (   "base "  )  ||  child.tagName.equals  (   "script "  )  ||  child.tagName.equals  (   "noscript "  )  ||  child.tagName.equals  (   "link "  )  ||  child.tagName.equals  (   "meta "  )  ||  child.tagName.equals  (   "title "  )  ||  child.tagName.equals  (   "style "  )  ||  child.tagName.equals  (   "object "  )  )  {	[BUGGY]  if  (  child.tagName.equals(   "base ")  ||  child.tagName.equals(   "script ")  ||  child.tagName.equals(   "noscript ")  ||  child.tagName.equals(   "lin ")  ||  child.tagName.equals(   "meta ")  ||  child.tagName.equals(   "title ")  ||  child.tagName.equals(   "style ")  ||  child.tagName.equals(   "object "))  {  [CONTEXT]  if  (child.isBlock  &&  !this.canContainBlock)  return  false;    if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    if  (this.optionalClosing  &&  this.equals(child))  return  false;    if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  [BUGGY]  if(  child.tagName.equals  (   "base "  )||  child.tagName.equals  (   "script "  )||  child.tagName.equals  (   "noscript "  )||  child.tagName.equals  (   "lin "  )||  child.tagName.equals  (   "meta "  )||  child.tagName.equals  (   "title "  )||  child.tagName.equals  (   "style "  )||  child.tagName.equals  (   "object "  )){    return  true;  }  return  false;  }        if  (this.tagName.equals( "dt ")  &&  child.tagName.equals( "dd "))  return  false;  if  (this.tagName.equals( "dd ")  &&  child.tagName.equals( "dt "))  return  false;    return  true;  }          [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
child.tagName.equals  (   "meta "  )  ||  child.tagName.equals  (   "title "  )  ||  child.tagName.equals  (   "style "  )  ||  child.tagName.equals  (   "object "  )  )  {	[BUGGY]  child.tagName.equals(   "metame ")  ||  child.tagName.equals(   "title ")  ||  child.tagName.equals(   "style ")  ||  child.tagName.equals(   "object "))  {  [CONTEXT]  return  false;    if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    if  (this.optionalClosing  &&  this.equals(child))  return  false;    if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  if  (child.tagName.equals( "base ")  ||  child.tagName.equals( "script ")  ||  child.tagName.equals( "noscript ")  ||  child.tagName.equals( "link ")  ||  [BUGGY]  child.tagName.equals  (   "metame "  )||  child.tagName.equals  (   "title "  )||  child.tagName.equals  (   "style "  )||  child.tagName.equals  (   "object "  )){  return  true;  }  return  false;  }        if  (this.tagName.equals( "dt ")  &&  child.tagName.equals( "dd "))  return  false;  if  (this.tagName.equals( "dd ")  &&  child.tagName.equals( "dt "))  return  false;    return  true;  }              [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
child.tagName.equals  (   "meta "  )  ||  child.tagName.equals  (   "title "  )  ||  child.tagName.equals  (   "style "  )  ||  child.tagName.equals  (   "object "  )  )  {	[BUGGY]  child.tagName.equals(   "meta ")  ||  child.tagName.equals(   "title ")  ||  child.tagName.equals(   "tyle ")  ||  child.tagName.equals(   "object "))  {  [CONTEXT]  return  false;    if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    if  (this.optionalClosing  &&  this.equals(child))  return  false;    if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  if  (child.tagName.equals( "base ")  ||  child.tagName.equals( "script ")  ||  child.tagName.equals( "noscript ")  ||  child.tagName.equals( "link ")  ||  [BUGGY]  child.tagName.equals  (   "meta "  )||  child.tagName.equals  (   "title "  )||  child.tagName.equals  (   "tyle "  )||  child.tagName.equals  (   "object "  )){  return  true;  }  return  false;  }        if  (this.tagName.equals( "dt ")  &&  child.tagName.equals( "dd "))  return  false;  if  (this.tagName.equals( "dd ")  &&  child.tagName.equals( "dt "))  return  false;    return  true;  }              [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
child.tagName.equals  (   "meta "  )  ||  child.tagName.equals  (   "title "  )  ||  child.tagName.equals  (   "style "  )  ||  child.tagName.equals  (   "object "  )  )  {	[BUGGY]  child.tagName  .equals(  null)    ||  child.tagName  [CONTEXT]  return  false;    if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    if  (this.optionalClosing  &&  this.equals(child))  return  false;    if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  if  (child.tagName.equals( "base ")  ||  child.tagName.equals( "script ")  ||  child.tagName.equals( "noscript ")  ||  child.tagName.equals( "link ")  ||  [BUGGY]  child.tagName  .equals  (  null  )  ||  child.tagName  return  true;  }  return  false;  }        if  (this.tagName.equals( "dt ")  &&  child.tagName.equals( "dd "))  return  false;  if  (this.tagName.equals( "dd ")  &&  child.tagName.equals( "dt "))  return  false;    return  true;  }              [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
child.tagName.equals  (   "meta "  )  ||  child.tagName.equals  (   "title "  )  ||  child.tagName.equals  (   "style "  )  ||  child.tagName.equals  (   "object "  )  )  {	[BUGGY]  child.tagName.equals(   "meta ")  ||  child.tagName.equals(   "title ")  ||  child.tagName.equals(   "style ")  ||  child.tagName.equals(   "objec "))  {  [CONTEXT]  return  false;    if  (!child.isBlock  &&  !this.canContainInline)  //  not  block  ==  inline  return  false;    if  (this.optionalClosing  &&  this.equals(child))  return  false;    if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  if  (child.tagName.equals( "base ")  ||  child.tagName.equals( "script ")  ||  child.tagName.equals( "noscript ")  ||  child.tagName.equals( "link ")  ||  [BUGGY]  child.tagName.equals  (   "meta "  )||  child.tagName.equals  (   "title "  )||  child.tagName.equals  (   "style "  )||  child.tagName.equals  (   "objec "  )){  return  true;  }  return  false;  }        if  (this.tagName.equals( "dt ")  &&  child.tagName.equals( "dd "))  return  false;  if  (this.tagName.equals( "dd ")  &&  child.tagName.equals( "dt "))  return  false;    return  true;  }              [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  this.tagName.equals  (   "dt "  )  &&  child.tagName.equals  (   "dd "  )  )  return  false;	[BUGGY]  if  (  this.tagName.equals(   "dt ")  ||  child.tagName.equals(   "dd "))return  false;  [CONTEXT]    if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  if  (child.tagName.equals( "base ")  ||  child.tagName.equals( "script ")  ||  child.tagName.equals( "noscript ")  ||  child.tagName.equals( "link ")  ||  child.tagName.equals( "meta ")  ||  child.tagName.equals( "title ")  ||  child.tagName.equals( "style ")  ||  child.tagName.equals( "object "))  {  return  true;  }  return  false;  }        [BUGGY]  if(  this.tagName.equals  (   "dt "  )||  child.tagName.equals  (   "dd "  ))  return  false;    if  (this.tagName.equals( "dd ")  &&  child.tagName.equals( "dt "))  return  false;    return  true;  }        Gets  if  this  is  a  block  tag.  @return  if  block  tag      public  boolean  isBlock()  {  return  isBlock;  }          [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  this.tagName.equals  (   "dt "  )  &&  child.tagName.equals  (   "dd "  )  )  return  false;	[BUGGY]  if  (  this.tagName.equals(   "dtd ")  &&  child.tagName.equals(   "dd "))return  false;  [CONTEXT]    if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  if  (child.tagName.equals( "base ")  ||  child.tagName.equals( "script ")  ||  child.tagName.equals( "noscript ")  ||  child.tagName.equals( "link ")  ||  child.tagName.equals( "meta ")  ||  child.tagName.equals( "title ")  ||  child.tagName.equals( "style ")  ||  child.tagName.equals( "object "))  {  return  true;  }  return  false;  }        [BUGGY]  if(  this.tagName.equals  (   "dtd "  )&&  child.tagName.equals  (   "dd "  ))  return  false;    if  (this.tagName.equals( "dd ")  &&  child.tagName.equals( "dt "))  return  false;    return  true;  }        Gets  if  this  is  a  block  tag.  @return  if  block  tag      public  boolean  isBlock()  {  return  isBlock;  }          [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  this.tagName.equals  (   "dt "  )  &&  child.tagName.equals  (   "dd "  )  )  return  false;	[BUGGY]  if  (  this.tagName.equals(   "dt ")  &&  child.tagName.equals(   "dd "))return  true;  [CONTEXT]    if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  if  (child.tagName.equals( "base ")  ||  child.tagName.equals( "script ")  ||  child.tagName.equals( "noscript ")  ||  child.tagName.equals( "link ")  ||  child.tagName.equals( "meta ")  ||  child.tagName.equals( "title ")  ||  child.tagName.equals( "style ")  ||  child.tagName.equals( "object "))  {  return  true;  }  return  false;  }        [BUGGY]  if(  this.tagName.equals  (   "dt "  )&&  child.tagName.equals  (   "dd "  ))  return  true;    if  (this.tagName.equals( "dd ")  &&  child.tagName.equals( "dt "))  return  false;    return  true;  }        Gets  if  this  is  a  block  tag.  @return  if  block  tag      public  boolean  isBlock()  {  return  isBlock;  }          [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  this.tagName.equals  (   "dt "  )  &&  child.tagName.equals  (   "dd "  )  )  return  false;	[BUGGY]  if  (  this.tagName.equals(   "dt ")  &&  tag.tagName.equals(   "dd "))return  false;  [CONTEXT]    if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  if  (child.tagName.equals( "base ")  ||  child.tagName.equals( "script ")  ||  child.tagName.equals( "noscript ")  ||  child.tagName.equals( "link ")  ||  child.tagName.equals( "meta ")  ||  child.tagName.equals( "title ")  ||  child.tagName.equals( "style ")  ||  child.tagName.equals( "object "))  {  return  true;  }  return  false;  }        [BUGGY]  if(  this.tagName.equals  (   "dt "  )&&  tag.tagName.equals  (   "dd "  ))  return  false;    if  (this.tagName.equals( "dd ")  &&  child.tagName.equals( "dt "))  return  false;    return  true;  }        Gets  if  this  is  a  block  tag.  @return  if  block  tag      public  boolean  isBlock()  {  return  isBlock;  }          [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  this.tagName.equals  (   "dt "  )  &&  child.tagName.equals  (   "dd "  )  )  return  false;	[BUGGY]  if  (  tagName.equals(   "dt ")  &&  child.tagName.equals(   "dd "))return  false;  [CONTEXT]    if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  if  (child.tagName.equals( "base ")  ||  child.tagName.equals( "script ")  ||  child.tagName.equals( "noscript ")  ||  child.tagName.equals( "link ")  ||  child.tagName.equals( "meta ")  ||  child.tagName.equals( "title ")  ||  child.tagName.equals( "style ")  ||  child.tagName.equals( "object "))  {  return  true;  }  return  false;  }        [BUGGY]  if(  tagName.equals  (   "dt "  )&&  child.tagName.equals  (   "dd "  ))  return  false;    if  (this.tagName.equals( "dd ")  &&  child.tagName.equals( "dt "))  return  false;    return  true;  }        Gets  if  this  is  a  block  tag.  @return  if  block  tag      public  boolean  isBlock()  {  return  isBlock;  }          [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  this.tagName.equals  (   "dt "  )  &&  child.tagName.equals  (   "dd "  )  )  return  false;	[BUGGY]  if  (  this.tagName.equals(   "dt ")  &&  child.tagName.tagName.equals(   "dd "))return  false;  [CONTEXT]    if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  if  (child.tagName.equals( "base ")  ||  child.tagName.equals( "script ")  ||  child.tagName.equals( "noscript ")  ||  child.tagName.equals( "link ")  ||  child.tagName.equals( "meta ")  ||  child.tagName.equals( "title ")  ||  child.tagName.equals( "style ")  ||  child.tagName.equals( "object "))  {  return  true;  }  return  false;  }        [BUGGY]  if(  this.tagName.equals  (   "dt "  )&&  child.tagName.tagName.equals  (   "dd "  ))  return  false;    if  (this.tagName.equals( "dd ")  &&  child.tagName.equals( "dt "))  return  false;    return  true;  }        Gets  if  this  is  a  block  tag.  @return  if  block  tag      public  boolean  isBlock()  {  return  isBlock;  }          [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  this.tagName.equals  (   "dt "  )  &&  child.tagName.equals  (   "dd "  )  )  return  false;	[BUGGY]  if  (  child.tagName.equals(   "dt ")  &&  this.tagName.equals(   "dd "))return  false;  [CONTEXT]    if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  if  (child.tagName.equals( "base ")  ||  child.tagName.equals( "script ")  ||  child.tagName.equals( "noscript ")  ||  child.tagName.equals( "link ")  ||  child.tagName.equals( "meta ")  ||  child.tagName.equals( "title ")  ||  child.tagName.equals( "style ")  ||  child.tagName.equals( "object "))  {  return  true;  }  return  false;  }        [BUGGY]  if(  child.tagName.equals  (   "dt "  )&&  this.tagName.equals  (   "dd "  ))  return  false;    if  (this.tagName.equals( "dd ")  &&  child.tagName.equals( "dt "))  return  false;    return  true;  }        Gets  if  this  is  a  block  tag.  @return  if  block  tag      public  boolean  isBlock()  {  return  isBlock;  }          [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  this.tagName.equals  (   "dt "  )  &&  child.tagName.equals  (   "dd "  )  )  return  false;	[BUGGY]  if  (  this.tagName.equals(   "dt ")  &&  child.equals(   "dd "))return  false;  [CONTEXT]    if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  if  (child.tagName.equals( "base ")  ||  child.tagName.equals( "script ")  ||  child.tagName.equals( "noscript ")  ||  child.tagName.equals( "link ")  ||  child.tagName.equals( "meta ")  ||  child.tagName.equals( "title ")  ||  child.tagName.equals( "style ")  ||  child.tagName.equals( "object "))  {  return  true;  }  return  false;  }        [BUGGY]  if(  this.tagName.equals  (   "dt "  )&&  child.equals  (   "dd "  ))  return  false;    if  (this.tagName.equals( "dd ")  &&  child.tagName.equals( "dt "))  return  false;    return  true;  }        Gets  if  this  is  a  block  tag.  @return  if  block  tag      public  boolean  isBlock()  {  return  isBlock;  }          [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
return  false;	[BUGGY]  return  true;  [CONTEXT]  if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  if  (child.tagName.equals( "base ")  ||  child.tagName.equals( "script ")  ||  child.tagName.equals( "noscript ")  ||  child.tagName.equals( "link ")  ||  child.tagName.equals( "meta ")  ||  child.tagName.equals( "title ")  ||  child.tagName.equals( "style ")  ||  child.tagName.equals( "object "))  {  return  true;  }  return  false;  }        if  (this.tagName.equals( "dt ")  &&  child.tagName.equals( "dd "))  [BUGGY]  return  true;  if  (this.tagName.equals( "dd ")  &&  child.tagName.equals( "dt "))  return  false;    return  true;  }        Gets  if  this  is  a  block  tag.  @return  if  block  tag      public  boolean  isBlock()  {  return  isBlock;  }              [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  this.tagName.equals  (   "dt "  )  &&  child.tagName.equals  (   "dd "  )  )  return  false;	[BUGGY]  if  (  this.tagName.equals(   "d ")  &&  child.tagName.equals(   "dd "))return  false;  [CONTEXT]    if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  if  (child.tagName.equals( "base ")  ||  child.tagName.equals( "script ")  ||  child.tagName.equals( "noscript ")  ||  child.tagName.equals( "link ")  ||  child.tagName.equals( "meta ")  ||  child.tagName.equals( "title ")  ||  child.tagName.equals( "style ")  ||  child.tagName.equals( "object "))  {  return  true;  }  return  false;  }        [BUGGY]  if(  this.tagName.equals  (   "d "  )&&  child.tagName.equals  (   "dd "  ))  return  false;    if  (this.tagName.equals( "dd ")  &&  child.tagName.equals( "dt "))  return  false;    return  true;  }        Gets  if  this  is  a  block  tag.  @return  if  block  tag      public  boolean  isBlock()  {  return  isBlock;  }          [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  this.tagName.equals  (   "dt "  )  &&  child.tagName.equals  (   "dd "  )  )  return  false;	[BUGGY]  if  (  this.tagName.equals(   "dt ")  &&  child.tagName.equals(   "d "))return  false;  [CONTEXT]    if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  if  (child.tagName.equals( "base ")  ||  child.tagName.equals( "script ")  ||  child.tagName.equals( "noscript ")  ||  child.tagName.equals( "link ")  ||  child.tagName.equals( "meta ")  ||  child.tagName.equals( "title ")  ||  child.tagName.equals( "style ")  ||  child.tagName.equals( "object "))  {  return  true;  }  return  false;  }        [BUGGY]  if(  this.tagName.equals  (   "dt "  )&&  child.tagName.equals  (   "d "  ))  return  false;    if  (this.tagName.equals( "dd ")  &&  child.tagName.equals( "dt "))  return  false;    return  true;  }        Gets  if  this  is  a  block  tag.  @return  if  block  tag      public  boolean  isBlock()  {  return  isBlock;  }          [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  this.tagName.equals  (   "dt "  )  &&  child.tagName.equals  (   "dd "  )  )  return  false;	[BUGGY]  if  (  this.tagName.equals(   "dt ")  &&  tagName.equals(   "dd "))return  false;  [CONTEXT]    if  (this.empty  ||  this.isData())  return  false;            if  (this.tagName.equals( "head "))  {  if  (child.tagName.equals( "base ")  ||  child.tagName.equals( "script ")  ||  child.tagName.equals( "noscript ")  ||  child.tagName.equals( "link ")  ||  child.tagName.equals( "meta ")  ||  child.tagName.equals( "title ")  ||  child.tagName.equals( "style ")  ||  child.tagName.equals( "object "))  {  return  true;  }  return  false;  }        [BUGGY]  if(  this.tagName.equals  (   "dt "  )&&  tagName.equals  (   "dd "  ))  return  false;    if  (this.tagName.equals( "dd ")  &&  child.tagName.equals( "dt "))  return  false;    return  true;  }        Gets  if  this  is  a  block  tag.  @return  if  block  tag      public  boolean  isBlock()  {  return  isBlock;  }          [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  this.tagName.equals  (   "dd "  )  &&  child.tagName.equals  (   "dt "  )  )  return  false;	[BUGGY]  if  (  this.tagName.equals(   "dd ")  ||  child.tagName.equals(   "dt "))return  false;  [CONTEXT]  return  false;            if  (this.tagName.equals( "head "))  {  if  (child.tagName.equals( "base ")  ||  child.tagName.equals( "script ")  ||  child.tagName.equals( "noscript ")  ||  child.tagName.equals( "link ")  ||  child.tagName.equals( "meta ")  ||  child.tagName.equals( "title ")  ||  child.tagName.equals( "style ")  ||  child.tagName.equals( "object "))  {  return  true;  }  return  false;  }        if  (this.tagName.equals( "dt ")  &&  child.tagName.equals( "dd "))  return  false;  [BUGGY]  if(  this.tagName.equals  (   "dd "  )||  child.tagName.equals  (   "dt "  ))  return  false;      return  true;  }        Gets  if  this  is  a  block  tag.  @return  if  block  tag      public  boolean  isBlock()  {  return  isBlock;  }        Gets  if  this  tag  can  contain  block  tags.        [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  this.tagName.equals  (   "dd "  )  &&  child.tagName.equals  (   "dt "  )  )  return  false;	[BUGGY]  if  (  this.tagName.equals(   "ddd ")  &&  child.tagName.equals(   "dt "))return  false;  [CONTEXT]  return  false;            if  (this.tagName.equals( "head "))  {  if  (child.tagName.equals( "base ")  ||  child.tagName.equals( "script ")  ||  child.tagName.equals( "noscript ")  ||  child.tagName.equals( "link ")  ||  child.tagName.equals( "meta ")  ||  child.tagName.equals( "title ")  ||  child.tagName.equals( "style ")  ||  child.tagName.equals( "object "))  {  return  true;  }  return  false;  }        if  (this.tagName.equals( "dt ")  &&  child.tagName.equals( "dd "))  return  false;  [BUGGY]  if(  this.tagName.equals  (   "ddd "  )&&  child.tagName.equals  (   "dt "  ))  return  false;      return  true;  }        Gets  if  this  is  a  block  tag.  @return  if  block  tag      public  boolean  isBlock()  {  return  isBlock;  }        Gets  if  this  tag  can  contain  block  tags.        [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  this.tagName.equals  (   "dd "  )  &&  child.tagName.equals  (   "dt "  )  )  return  false;	[BUGGY]  if  (  this.tagName.equals(   "dd ")  &&  child.tagName.equals(   "dtd "))return  false;  [CONTEXT]  return  false;            if  (this.tagName.equals( "head "))  {  if  (child.tagName.equals( "base ")  ||  child.tagName.equals( "script ")  ||  child.tagName.equals( "noscript ")  ||  child.tagName.equals( "link ")  ||  child.tagName.equals( "meta ")  ||  child.tagName.equals( "title ")  ||  child.tagName.equals( "style ")  ||  child.tagName.equals( "object "))  {  return  true;  }  return  false;  }        if  (this.tagName.equals( "dt ")  &&  child.tagName.equals( "dd "))  return  false;  [BUGGY]  if(  this.tagName.equals  (   "dd "  )&&  child.tagName.equals  (   "dtd "  ))  return  false;      return  true;  }        Gets  if  this  is  a  block  tag.  @return  if  block  tag      public  boolean  isBlock()  {  return  isBlock;  }        Gets  if  this  tag  can  contain  block  tags.        [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  this.tagName.equals  (   "dd "  )  &&  child.tagName.equals  (   "dt "  )  )  return  false;	[BUGGY]  if  (  this.tagName.equals(   "dd ")  &&  child.tagName.equals(   "dt "))return  true;  [CONTEXT]  return  false;            if  (this.tagName.equals( "head "))  {  if  (child.tagName.equals( "base ")  ||  child.tagName.equals( "script ")  ||  child.tagName.equals( "noscript ")  ||  child.tagName.equals( "link ")  ||  child.tagName.equals( "meta ")  ||  child.tagName.equals( "title ")  ||  child.tagName.equals( "style ")  ||  child.tagName.equals( "object "))  {  return  true;  }  return  false;  }        if  (this.tagName.equals( "dt ")  &&  child.tagName.equals( "dd "))  return  false;  [BUGGY]  if(  this.tagName.equals  (   "dd "  )&&  child.tagName.equals  (   "dt "  ))  return  true;      return  true;  }        Gets  if  this  is  a  block  tag.  @return  if  block  tag      public  boolean  isBlock()  {  return  isBlock;  }        Gets  if  this  tag  can  contain  block  tags.        [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  this.tagName.equals  (   "dd "  )  &&  child.tagName.equals  (   "dt "  )  )  return  false;	[BUGGY]  if  (  this.tagName.equals(   "dd ")  &&  tag.tagName.equals(   "dt "))return  false;  [CONTEXT]  return  false;            if  (this.tagName.equals( "head "))  {  if  (child.tagName.equals( "base ")  ||  child.tagName.equals( "script ")  ||  child.tagName.equals( "noscript ")  ||  child.tagName.equals( "link ")  ||  child.tagName.equals( "meta ")  ||  child.tagName.equals( "title ")  ||  child.tagName.equals( "style ")  ||  child.tagName.equals( "object "))  {  return  true;  }  return  false;  }        if  (this.tagName.equals( "dt ")  &&  child.tagName.equals( "dd "))  return  false;  [BUGGY]  if(  this.tagName.equals  (   "dd "  )&&  tag.tagName.equals  (   "dt "  ))  return  false;      return  true;  }        Gets  if  this  is  a  block  tag.  @return  if  block  tag      public  boolean  isBlock()  {  return  isBlock;  }        Gets  if  this  tag  can  contain  block  tags.        [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  this.tagName.equals  (   "dd "  )  &&  child.tagName.equals  (   "dt "  )  )  return  false;	[BUGGY]  if  (  tagName.equals(   "dd ")  &&  child.tagName.equals(   "dt "))return  false;  [CONTEXT]  return  false;            if  (this.tagName.equals( "head "))  {  if  (child.tagName.equals( "base ")  ||  child.tagName.equals( "script ")  ||  child.tagName.equals( "noscript ")  ||  child.tagName.equals( "link ")  ||  child.tagName.equals( "meta ")  ||  child.tagName.equals( "title ")  ||  child.tagName.equals( "style ")  ||  child.tagName.equals( "object "))  {  return  true;  }  return  false;  }        if  (this.tagName.equals( "dt ")  &&  child.tagName.equals( "dd "))  return  false;  [BUGGY]  if(  tagName.equals  (   "dd "  )&&  child.tagName.equals  (   "dt "  ))  return  false;      return  true;  }        Gets  if  this  is  a  block  tag.  @return  if  block  tag      public  boolean  isBlock()  {  return  isBlock;  }        Gets  if  this  tag  can  contain  block  tags.        [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  this.tagName.equals  (   "dd "  )  &&  child.tagName.equals  (   "dt "  )  )  return  false;	[BUGGY]  if  (  this.tagName.equals(   "dd ")  &&  tagName.equals(   "dt "))return  false;  [CONTEXT]  return  false;            if  (this.tagName.equals( "head "))  {  if  (child.tagName.equals( "base ")  ||  child.tagName.equals( "script ")  ||  child.tagName.equals( "noscript ")  ||  child.tagName.equals( "link ")  ||  child.tagName.equals( "meta ")  ||  child.tagName.equals( "title ")  ||  child.tagName.equals( "style ")  ||  child.tagName.equals( "object "))  {  return  true;  }  return  false;  }        if  (this.tagName.equals( "dt ")  &&  child.tagName.equals( "dd "))  return  false;  [BUGGY]  if(  this.tagName.equals  (   "dd "  )&&  tagName.equals  (   "dt "  ))  return  false;      return  true;  }        Gets  if  this  is  a  block  tag.  @return  if  block  tag      public  boolean  isBlock()  {  return  isBlock;  }        Gets  if  this  tag  can  contain  block  tags.        [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  this.tagName.equals  (   "dd "  )  &&  child.tagName.equals  (   "dt "  )  )  return  false;	[BUGGY]  if  (  this.tagName.equals(   "dd ")  &&  child.tagName.tagName.equals(   "dt "))return  false;  [CONTEXT]  return  false;            if  (this.tagName.equals( "head "))  {  if  (child.tagName.equals( "base ")  ||  child.tagName.equals( "script ")  ||  child.tagName.equals( "noscript ")  ||  child.tagName.equals( "link ")  ||  child.tagName.equals( "meta ")  ||  child.tagName.equals( "title ")  ||  child.tagName.equals( "style ")  ||  child.tagName.equals( "object "))  {  return  true;  }  return  false;  }        if  (this.tagName.equals( "dt ")  &&  child.tagName.equals( "dd "))  return  false;  [BUGGY]  if(  this.tagName.equals  (   "dd "  )&&  child.tagName.tagName.equals  (   "dt "  ))  return  false;      return  true;  }        Gets  if  this  is  a  block  tag.  @return  if  block  tag      public  boolean  isBlock()  {  return  isBlock;  }        Gets  if  this  tag  can  contain  block  tags.        [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  this.tagName.equals  (   "dd "  )  &&  child.tagName.equals  (   "dt "  )  )  return  false;	[BUGGY]  if  (  child.equals(   "dd ")  &&  this.tagName.tagName.equals(   "dt "))return  false;  [CONTEXT]  return  false;            if  (this.tagName.equals( "head "))  {  if  (child.tagName.equals( "base ")  ||  child.tagName.equals( "script ")  ||  child.tagName.equals( "noscript ")  ||  child.tagName.equals( "link ")  ||  child.tagName.equals( "meta ")  ||  child.tagName.equals( "title ")  ||  child.tagName.equals( "style ")  ||  child.tagName.equals( "object "))  {  return  true;  }  return  false;  }        if  (this.tagName.equals( "dt ")  &&  child.tagName.equals( "dd "))  return  false;  [BUGGY]  if(  child.equals  (   "dd "  )&&  this.tagName.tagName.equals  (   "dt "  ))  return  false;      return  true;  }        Gets  if  this  is  a  block  tag.  @return  if  block  tag      public  boolean  isBlock()  {  return  isBlock;  }        Gets  if  this  tag  can  contain  block  tags.        [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  this.tagName.equals  (   "dd "  )  &&  child.tagName.equals  (   "dt "  )  )  return  false;	[BUGGY]  if  (  this.tagName.equals(   "dd ")  &&  child.equals(   "dt "))return  false;  [CONTEXT]  return  false;            if  (this.tagName.equals( "head "))  {  if  (child.tagName.equals( "base ")  ||  child.tagName.equals( "script ")  ||  child.tagName.equals( "noscript ")  ||  child.tagName.equals( "link ")  ||  child.tagName.equals( "meta ")  ||  child.tagName.equals( "title ")  ||  child.tagName.equals( "style ")  ||  child.tagName.equals( "object "))  {  return  true;  }  return  false;  }        if  (this.tagName.equals( "dt ")  &&  child.tagName.equals( "dd "))  return  false;  [BUGGY]  if(  this.tagName.equals  (   "dd "  )&&  child.equals  (   "dt "  ))  return  false;      return  true;  }        Gets  if  this  is  a  block  tag.  @return  if  block  tag      public  boolean  isBlock()  {  return  isBlock;  }        Gets  if  this  tag  can  contain  block  tags.        [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  this.tagName.equals  (   "dd "  )  &&  child.tagName.equals  (   "dt "  )  )  return  false;  return  true;  }	[BUGGY]  return  false;  [CONTEXT]  return  false;            if  (this.tagName.equals( "head "))  {  if  (child.tagName.equals( "base ")  ||  child.tagName.equals( "script ")  ||  child.tagName.equals( "noscript ")  ||  child.tagName.equals( "link ")  ||  child.tagName.equals( "meta ")  ||  child.tagName.equals( "title ")  ||  child.tagName.equals( "style ")  ||  child.tagName.equals( "object "))  {  return  true;  }  return  false;  }        if  (this.tagName.equals( "dt ")  &&  child.tagName.equals( "dd "))  return  false;  [BUGGY]  if  (this.tagName.equals( "dd ")  &&  child.tagName.equals( "dt "))    return  false;              Gets  if  this  is  a  block  tag.  @return  if  block  tag      public  boolean  isBlock()  {  return  isBlock;  }              [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  this.tagName.equals  (   "dd "  )  &&  child.tagName.equals  (   "dt "  )  )  return  false;  return  true;  }	[BUGGY]    [CONTEXT]  return  false;            if  (this.tagName.equals( "head "))  {  if  (child.tagName.equals( "base ")  ||  child.tagName.equals( "script ")  ||  child.tagName.equals( "noscript ")  ||  child.tagName.equals( "link ")  ||  child.tagName.equals( "meta ")  ||  child.tagName.equals( "title ")  ||  child.tagName.equals( "style ")  ||  child.tagName.equals( "object "))  {  return  true;  }  return  false;  }        if  (this.tagName.equals( "dt ")  &&  child.tagName.equals( "dd "))  return  false;  [BUGGY]  if  (this.tagName.equals( "dd ")  &&  child.tagName.equals( "dt "))                  Gets  if  this  is  a  block  tag.  @return  if  block  tag      public  boolean  isBlock()  {  return  isBlock;  }              [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
return  false;	[BUGGY]  return  true;  [CONTEXT]            if  (this.tagName.equals( "head "))  {  if  (child.tagName.equals( "base ")  ||  child.tagName.equals( "script ")  ||  child.tagName.equals( "noscript ")  ||  child.tagName.equals( "link ")  ||  child.tagName.equals( "meta ")  ||  child.tagName.equals( "title ")  ||  child.tagName.equals( "style ")  ||  child.tagName.equals( "object "))  {  return  true;  }  return  false;  }        if  (this.tagName.equals( "dt ")  &&  child.tagName.equals( "dd "))  return  false;  if  (this.tagName.equals( "dd ")  &&  child.tagName.equals( "dt "))  [BUGGY]  return  true;    return  true;  }        Gets  if  this  is  a  block  tag.  @return  if  block  tag      public  boolean  isBlock()  {  return  isBlock;  }        Gets  if  this  tag  can  contain  block  tags.  @return  if  tag  can  contain  block  tags        [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
return  true;	[BUGGY]  return  false;  [CONTEXT]      if  (this.tagName.equals( "head "))  {  if  (child.tagName.equals( "base ")  ||  child.tagName.equals( "script ")  ||  child.tagName.equals( "noscript ")  ||  child.tagName.equals( "link ")  ||  child.tagName.equals( "meta ")  ||  child.tagName.equals( "title ")  ||  child.tagName.equals( "style ")  ||  child.tagName.equals( "object "))  {  return  true;  }  return  false;  }        if  (this.tagName.equals( "dt ")  &&  child.tagName.equals( "dd "))  return  false;  if  (this.tagName.equals( "dd ")  &&  child.tagName.equals( "dt "))  return  false;    [BUGGY]  return  false;  }        Gets  if  this  is  a  block  tag.  @return  if  block  tag      public  boolean  isBlock()  {  return  isBlock;  }        Gets  if  this  tag  can  contain  block  tags.  @return  if  tag  can  contain  block  tags      public  boolean  canContainBlock()  {        [CLASS]  Tag    [METHOD]  canContain  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
return  isBlock;	[BUGGY]  return  optionalClosing;  [CONTEXT]  public  boolean  isBlock()  {  [BUGGY]  return  optionalClosing;  }        [CLASS]  Tag    [METHOD]  isBlock  [RETURN_TYPE]  boolean      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
return  canContainBlock;	[BUGGY]  return  preserveWhitespace;  [CONTEXT]  public  boolean  canContainBlock()  {  [BUGGY]  return  preserveWhitespace;  }        [CLASS]  Tag    [METHOD]  canContainBlock  [RETURN_TYPE]  boolean      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
return  !canContainInline  &&  !isEmpty  (  )  ;	[BUGGY]  return  !canContainInline  ||  !isEmpty(  );  [CONTEXT]  public  boolean  isData()  {  [BUGGY]  return  !canContainInline  ||  !isEmpty  ()  ;  }        [CLASS]  Tag    [METHOD]  isData  [RETURN_TYPE]  boolean      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
return  !canContainInline  &&  !isEmpty  (  )  ;	[BUGGY]  return  !preserveWhitespace  &&  !isEmpty(  );  [CONTEXT]  public  boolean  isData()  {  [BUGGY]  return  !preserveWhitespace  &&  !isEmpty  ()  ;  }        [CLASS]  Tag    [METHOD]  isData  [RETURN_TYPE]  boolean      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
return  !canContainInline  &&  !isEmpty  (  )  ;	[BUGGY]  return  !canContainInline  &&  !isData(  );  [CONTEXT]  public  boolean  isData()  {  [BUGGY]  return  !canContainInline  &&  !isData  ()  ;  }        [CLASS]  Tag    [METHOD]  isData  [RETURN_TYPE]  boolean      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
return  !canContainInline  &&  !isEmpty  (  )  ;	[BUGGY]    [CONTEXT]  public  boolean  isData()  {  [BUGGY]  return  !canContainInline  &&  !isEmpty();          [CLASS]  Tag    [METHOD]  isData  [RETURN_TYPE]  boolean      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
return  empty;	[BUGGY]  return  preserveWhitespace;  [CONTEXT]  public  boolean  isEmpty()  {  [BUGGY]  return  preserveWhitespace;  }        [CLASS]  Tag    [METHOD]  isEmpty  [RETURN_TYPE]  boolean      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
return  preserveWhitespace;	[BUGGY]  return  optionalClosing;  [CONTEXT]  public  boolean  preserveWhitespace()  {  [BUGGY]  return  optionalClosing;  }        [CLASS]  Tag    [METHOD]  preserveWhitespace  [RETURN_TYPE]  boolean      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
return  (  !ancestors.isEmpty  (  )  )  ?  ancestors.get  (  0  )  :  null;	[BUGGY]  return  (  !ancestors.isEmpty(  ))  ?  ancestors.get(  1)  :  null;  [CONTEXT]  Tag  getImplicitParent()  {  [BUGGY]  return(  !ancestors.isEmpty  ())?  ancestors.get  (  1  ):  null;  }        [CLASS]  Tag    [METHOD]  getImplicitParent  [RETURN_TYPE]  Tag      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
return  (  !ancestors.isEmpty  (  )  )  ?  ancestors.get  (  0  )  :  null;	[BUGGY]  return  (  !ancestors.add(  ))  ?  ancestors.get(  0)  :  null;  [CONTEXT]  Tag  getImplicitParent()  {  [BUGGY]  return(  !ancestors.add  ())?  ancestors.get  (  0  ):  null;  }        [CLASS]  Tag    [METHOD]  getImplicitParent  [RETURN_TYPE]  Tag      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
return  (  !ancestors.isEmpty  (  )  )  ?  ancestors.get  (  0  )  :  null;	[BUGGY]  return  (  !ancestors.add(  ))  ?  ancestors.get(  4)  :  null;  [CONTEXT]  Tag  getImplicitParent()  {  [BUGGY]  return(  !ancestors.add  ())?  ancestors.get  (  4  ):  null;  }        [CLASS]  Tag    [METHOD]  getImplicitParent  [RETURN_TYPE]  Tag      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
return  (  !ancestors.isEmpty  (  )  )  ?  ancestors.get  (  0  )  :  null;	[BUGGY]    [CONTEXT]  Tag  getImplicitParent()  {  [BUGGY]  return  (!ancestors.isEmpty())  ?  ancestors.get(0)  :  null;          [CLASS]  Tag    [METHOD]  getImplicitParent  [RETURN_TYPE]  Tag      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
return  (  !ancestors.isEmpty  (  )  )  ?  ancestors.get  (  0  )  :  null;	[BUGGY]  return  (  !ancestors.isEmpty(  ))  ?  ancestors.get(  4)  :  null;  [CONTEXT]  Tag  getImplicitParent()  {  [BUGGY]  return(  !ancestors.isEmpty  ())?  ancestors.get  (  4  ):  null;  }        [CLASS]  Tag    [METHOD]  getImplicitParent  [RETURN_TYPE]  Tag      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
return  (  !ancestors.isEmpty  (  )  )  ?  ancestors.get  (  0  )  :  null;	[BUGGY]  return  (  !ancestors.isEmpty(  ))  ?  ancestors  .put(  tagName  ,  defaultAncestor)    :  null;  [CONTEXT]  Tag  getImplicitParent()  {  [BUGGY]  return(  !ancestors.isEmpty  ())?  ancestors  .put  (  tagName  ,  defaultAncestor  )  :  null;  }        [CLASS]  Tag    [METHOD]  getImplicitParent  [RETURN_TYPE]  Tag      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  child.ancestors.isEmpty  (  )  )  return  true;	[BUGGY]  if  (  child.ancestors.isEmpty(  ))return  false;  [CONTEXT]  boolean  isValidParent(Tag  child)  {  [BUGGY]  if(  child.ancestors.isEmpty  ())  return  false;      for  (Tag  tag  :  child.ancestors)  {  if  (this.equals(tag))  return  true;  }  return  false;  }        [CLASS]  Tag    [METHOD]  isValidParent  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  child.ancestors.isEmpty  (  )  )  return  true;	[BUGGY]  if  (  tag.ancestors.isEmpty(  ))return  true;  [CONTEXT]  boolean  isValidParent(Tag  child)  {  [BUGGY]  if(  tag.ancestors.isEmpty  ())  return  true;      for  (Tag  tag  :  child.ancestors)  {  if  (this.equals(tag))  return  true;  }  return  false;  }        [CLASS]  Tag    [METHOD]  isValidParent  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  child.ancestors.isEmpty  (  )  )  return  true;	[BUGGY]  if  (  child.ancestors.ancestors.isEmpty(  ))return  true;  [CONTEXT]  boolean  isValidParent(Tag  child)  {  [BUGGY]  if(  child.ancestors.ancestors.isEmpty  ())  return  true;      for  (Tag  tag  :  child.ancestors)  {  if  (this.equals(tag))  return  true;  }  return  false;  }        [CLASS]  Tag    [METHOD]  isValidParent  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  child.ancestors.isEmpty  (  )  )  return  true;	[BUGGY]  if  (  child.isEmpty(  ))return  true;  [CONTEXT]  boolean  isValidParent(Tag  child)  {  [BUGGY]  if(  child.isEmpty  ())  return  true;      for  (Tag  tag  :  child.ancestors)  {  if  (this.equals(tag))  return  true;  }  return  false;  }        [CLASS]  Tag    [METHOD]  isValidParent  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  child.ancestors.isEmpty  (  )  )  return  true;	[BUGGY]  if  (  child.ancestors.get(  ))return  true;  [CONTEXT]  boolean  isValidParent(Tag  child)  {  [BUGGY]  if(  child.ancestors.get  ())  return  true;      for  (Tag  tag  :  child.ancestors)  {  if  (this.equals(tag))  return  true;  }  return  false;  }        [CLASS]  Tag    [METHOD]  isValidParent  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  child.ancestors.isEmpty  (  )  )  return  true;	[BUGGY]  if  (  child.ancestors  .isData(  )  )return  true;  [CONTEXT]  boolean  isValidParent(Tag  child)  {  [BUGGY]  if(  child.ancestors  .isData  ()  )  return  true;      for  (Tag  tag  :  child.ancestors)  {  if  (this.equals(tag))  return  true;  }  return  false;  }        [CLASS]  Tag    [METHOD]  isValidParent  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  child.ancestors.isEmpty  (  )  )  return  true;	[BUGGY]  if  (  child.ancestors.get(  ))return  false;  [CONTEXT]  boolean  isValidParent(Tag  child)  {  [BUGGY]  if(  child.ancestors.get  ())  return  false;      for  (Tag  tag  :  child.ancestors)  {  if  (this.equals(tag))  return  true;  }  return  false;  }        [CLASS]  Tag    [METHOD]  isValidParent  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
return  true;	[BUGGY]  return  false;  [CONTEXT]  boolean  isValidParent(Tag  child)  {  if  (child.ancestors.isEmpty())  [BUGGY]  return  false;    for  (Tag  tag  :  child.ancestors)  {  if  (this.equals(tag))  return  true;  }  return  false;  }        [CLASS]  Tag    [METHOD]  isValidParent  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  this.equals  (  tag  )  )  return  true;	[BUGGY]  if  (  this.equals(  tag))return  false;  [CONTEXT]  boolean  isValidParent(Tag  child)  {  if  (child.ancestors.isEmpty())  return  true;  //  HTML  tag    for  (Tag  tag  :  child.ancestors)  {  [BUGGY]  if(  this.equals  (  tag  ))  return  false;    }  return  false;  }        [CLASS]  Tag    [METHOD]  isValidParent  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  this.equals  (  tag  )  )  return  true;	[BUGGY]  if  (  this.equals(  defaultAncestor))return  true;  [CONTEXT]  boolean  isValidParent(Tag  child)  {  if  (child.ancestors.isEmpty())  return  true;  //  HTML  tag    for  (Tag  tag  :  child.ancestors)  {  [BUGGY]  if(  this.equals  (  defaultAncestor  ))  return  true;    }  return  false;  }        [CLASS]  Tag    [METHOD]  isValidParent  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  this.equals  (  tag  )  )  return  true;	[BUGGY]  if  (  this.isValidParent(  tag))return  true;  [CONTEXT]  boolean  isValidParent(Tag  child)  {  if  (child.ancestors.isEmpty())  return  true;  //  HTML  tag    for  (Tag  tag  :  child.ancestors)  {  [BUGGY]  if(  this.isValidParent  (  tag  ))  return  true;    }  return  false;  }        [CLASS]  Tag    [METHOD]  isValidParent  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  this.equals  (  tag  )  )  return  true;  }	[BUGGY]  return  true;  [CONTEXT]  boolean  isValidParent(Tag  child)  {  if  (child.ancestors.isEmpty())  return  true;  //  HTML  tag    for  (Tag  tag  :  child.ancestors)  {  [BUGGY]  if  (this.equals(tag))    return  true;    return  false;        [CLASS]  Tag    [METHOD]  isValidParent  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  this.equals  (  tag  )  )  return  true;  }	[BUGGY]    [CONTEXT]  boolean  isValidParent(Tag  child)  {  if  (child.ancestors.isEmpty())  return  true;  //  HTML  tag    for  (Tag  tag  :  child.ancestors)  {  [BUGGY]  if  (this.equals(tag))        return  false;        [CLASS]  Tag    [METHOD]  isValidParent  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
return  true;	[BUGGY]  return  false;  [CONTEXT]  boolean  isValidParent(Tag  child)  {  if  (child.ancestors.isEmpty())  return  true;  //  HTML  tag    for  (Tag  tag  :  child.ancestors)  {  if  (this.equals(tag))  [BUGGY]  return  false;  }  return  false;  }        [CLASS]  Tag    [METHOD]  isValidParent  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
return  false;	[BUGGY]  return  true;  [CONTEXT]  boolean  isValidParent(Tag  child)  {  if  (child.ancestors.isEmpty())  return  true;  //  HTML  tag    for  (Tag  tag  :  child.ancestors)  {  if  (this.equals(tag))  return  true;  }  [BUGGY]  return  true;  }        [CLASS]  Tag    [METHOD]  isValidParent  [RETURN_TYPE]  boolean      Tag  child  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  this  ==  o  )  return  true;	[BUGGY]  if  (  this  !=  o)  return  true;  [CONTEXT]  public  boolean  equals(Object  o)  {  [BUGGY]  if(  this  !=  o  )return  true;  if  (o  ==  null  ||  getClass()  !=  o.getClass())  return  false;    Tag  tag  =  (Tag)  o;    if  (canContainBlock  !=  tag.canContainBlock)  return  false;  if  (canContainInline  !=  tag.canContainInline)  return  false;  if  (empty  !=  tag.empty)  return  false;  if  (isBlock  !=  tag.isBlock)  return  false;  if  (optionalClosing  !=  tag.optionalClosing)  return  false;  if  (tagName  !=  null  ?  !tagName.equals(tag.tagName)  :  tag.tagName  !=  null)  return  false;    return  true;  }        [CLASS]  Tag    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  List    ancestors    Object    o    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  this  ==  o  )  return  true;	[BUGGY]  if  (  this  ==  o)  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  [BUGGY]  if(  this  ==  o  )return  false;  if  (o  ==  null  ||  getClass()  !=  o.getClass())  return  false;    Tag  tag  =  (Tag)  o;    if  (canContainBlock  !=  tag.canContainBlock)  return  false;  if  (canContainInline  !=  tag.canContainInline)  return  false;  if  (empty  !=  tag.empty)  return  false;  if  (isBlock  !=  tag.isBlock)  return  false;  if  (optionalClosing  !=  tag.optionalClosing)  return  false;  if  (tagName  !=  null  ?  !tagName.equals(tag.tagName)  :  tag.tagName  !=  null)  return  false;    return  true;  }        [CLASS]  Tag    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  List    ancestors    Object    o    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  o  ==  null  ||  getClass  (  )  !=  o.getClass  (  )  )  return  false;	[BUGGY]  if  (  o  ==  null  &&  getClass(  )  !=  o.getClass(  ))  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  [BUGGY]  if(  o  ==  null  &&  getClass  ()!=  o.getClass  ())return  false;    Tag  tag  =  (Tag)  o;    if  (canContainBlock  !=  tag.canContainBlock)  return  false;  if  (canContainInline  !=  tag.canContainInline)  return  false;  if  (empty  !=  tag.empty)  return  false;  if  (isBlock  !=  tag.isBlock)  return  false;  if  (optionalClosing  !=  tag.optionalClosing)  return  false;  if  (tagName  !=  null  ?  !tagName.equals(tag.tagName)  :  tag.tagName  !=  null)  return  false;    return  true;  }        [CLASS]  Tag    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  List    ancestors    Object    o    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  o  ==  null  ||  getClass  (  )  !=  o.getClass  (  )  )  return  false;	[BUGGY]  if  (  o  !=  null  ||  getClass(  )  !=  o.getClass(  ))  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  [BUGGY]  if(  o  !=  null  ||  getClass  ()!=  o.getClass  ())return  false;    Tag  tag  =  (Tag)  o;    if  (canContainBlock  !=  tag.canContainBlock)  return  false;  if  (canContainInline  !=  tag.canContainInline)  return  false;  if  (empty  !=  tag.empty)  return  false;  if  (isBlock  !=  tag.isBlock)  return  false;  if  (optionalClosing  !=  tag.optionalClosing)  return  false;  if  (tagName  !=  null  ?  !tagName.equals(tag.tagName)  :  tag.tagName  !=  null)  return  false;    return  true;  }        [CLASS]  Tag    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  List    ancestors    Object    o    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  o  ==  null  ||  getClass  (  )  !=  o.getClass  (  )  )  return  false;	[BUGGY]  if  (  o  ==  null  ||  getClass(  )  ==  o.getClass(  ))  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  [BUGGY]  if(  o  ==  null  ||  getClass  ()==  o.getClass  ())return  false;    Tag  tag  =  (Tag)  o;    if  (canContainBlock  !=  tag.canContainBlock)  return  false;  if  (canContainInline  !=  tag.canContainInline)  return  false;  if  (empty  !=  tag.empty)  return  false;  if  (isBlock  !=  tag.isBlock)  return  false;  if  (optionalClosing  !=  tag.optionalClosing)  return  false;  if  (tagName  !=  null  ?  !tagName.equals(tag.tagName)  :  tag.tagName  !=  null)  return  false;    return  true;  }        [CLASS]  Tag    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  List    ancestors    Object    o    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  o  ==  null  ||  getClass  (  )  !=  o.getClass  (  )  )  return  false;	[BUGGY]  if  (  o  ==  null  ||  getClass(  )  !=  o.getClass(  ))  return  true;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  [BUGGY]  if(  o  ==  null  ||  getClass  ()!=  o.getClass  ())return  true;    Tag  tag  =  (Tag)  o;    if  (canContainBlock  !=  tag.canContainBlock)  return  false;  if  (canContainInline  !=  tag.canContainInline)  return  false;  if  (empty  !=  tag.empty)  return  false;  if  (isBlock  !=  tag.isBlock)  return  false;  if  (optionalClosing  !=  tag.optionalClosing)  return  false;  if  (tagName  !=  null  ?  !tagName.equals(tag.tagName)  :  tag.tagName  !=  null)  return  false;    return  true;  }        [CLASS]  Tag    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  List    ancestors    Object    o    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  o  ==  null  ||  getClass  (  )  !=  o.getClass  (  )  )  return  false;	[BUGGY]  if  (  o  ==  null)  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  [BUGGY]  if(  o  ==  null  )return  false;    Tag  tag  =  (Tag)  o;    if  (canContainBlock  !=  tag.canContainBlock)  return  false;  if  (canContainInline  !=  tag.canContainInline)  return  false;  if  (empty  !=  tag.empty)  return  false;  if  (isBlock  !=  tag.isBlock)  return  false;  if  (optionalClosing  !=  tag.optionalClosing)  return  false;  if  (tagName  !=  null  ?  !tagName.equals(tag.tagName)  :  tag.tagName  !=  null)  return  false;    return  true;  }        [CLASS]  Tag    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  List    ancestors    Object    o    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  o  ==  null  ||  getClass  (  )  !=  o.getClass  (  )  )  return  false;	[BUGGY]  if  (  getClass(  )  !=  o.getClass(  ))    return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  [BUGGY]  if(  getClass  ()!=  o.getClass  ()  )return  false;    Tag  tag  =  (Tag)  o;    if  (canContainBlock  !=  tag.canContainBlock)  return  false;  if  (canContainInline  !=  tag.canContainInline)  return  false;  if  (empty  !=  tag.empty)  return  false;  if  (isBlock  !=  tag.isBlock)  return  false;  if  (optionalClosing  !=  tag.optionalClosing)  return  false;  if  (tagName  !=  null  ?  !tagName.equals(tag.tagName)  :  tag.tagName  !=  null)  return  false;    return  true;  }        [CLASS]  Tag    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  List    ancestors    Object    o    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  o  ==  null  ||  getClass  (  )  !=  o.getClass  (  )  )  return  false;	[BUGGY]  if  (  o  ==  null  ||  getClass(  )  !=  o.setEmpty(  ))  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  [BUGGY]  if(  o  ==  null  ||  getClass  ()!=  o.setEmpty  ())return  false;    Tag  tag  =  (Tag)  o;    if  (canContainBlock  !=  tag.canContainBlock)  return  false;  if  (canContainInline  !=  tag.canContainInline)  return  false;  if  (empty  !=  tag.empty)  return  false;  if  (isBlock  !=  tag.isBlock)  return  false;  if  (optionalClosing  !=  tag.optionalClosing)  return  false;  if  (tagName  !=  null  ?  !tagName.equals(tag.tagName)  :  tag.tagName  !=  null)  return  false;    return  true;  }        [CLASS]  Tag    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  List    ancestors    Object    o    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  o  ==  null  ||  getClass  (  )  !=  o.getClass  (  )  )  return  false;	[BUGGY]  if  (  o  ==  true  ||  getClass(  )  !=  o.getClass(  ))  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  [BUGGY]  if(  o  ==  true  ||  getClass  ()!=  o.getClass  ())return  false;    Tag  tag  =  (Tag)  o;    if  (canContainBlock  !=  tag.canContainBlock)  return  false;  if  (canContainInline  !=  tag.canContainInline)  return  false;  if  (empty  !=  tag.empty)  return  false;  if  (isBlock  !=  tag.isBlock)  return  false;  if  (optionalClosing  !=  tag.optionalClosing)  return  false;  if  (tagName  !=  null  ?  !tagName.equals(tag.tagName)  :  tag.tagName  !=  null)  return  false;    return  true;  }        [CLASS]  Tag    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  List    ancestors    Object    o    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  o  ==  null  ||  getClass  (  )  !=  o.getClass  (  )  )  return  false;	[BUGGY]  if  (  o  ==  null  ||  getClass(  )  !=  o  .setOptionalClosing(  )  )  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  [BUGGY]  if(  o  ==  null  ||  getClass  ()!=  o  .setOptionalClosing  ()  )return  false;    Tag  tag  =  (Tag)  o;    if  (canContainBlock  !=  tag.canContainBlock)  return  false;  if  (canContainInline  !=  tag.canContainInline)  return  false;  if  (empty  !=  tag.empty)  return  false;  if  (isBlock  !=  tag.isBlock)  return  false;  if  (optionalClosing  !=  tag.optionalClosing)  return  false;  if  (tagName  !=  null  ?  !tagName.equals(tag.tagName)  :  tag.tagName  !=  null)  return  false;    return  true;  }        [CLASS]  Tag    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  List    ancestors    Object    o    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  canContainBlock  !=  tag.canContainBlock  )  return  false;	[BUGGY]  if  (  canContainBlock  >  tag.canContainBlock)  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (o  ==  null  ||  getClass()  !=  o.getClass())  return  false;    Tag  tag  =  (Tag)  o;    [BUGGY]  if(  canContainBlock  >  tag.canContainBlock  )return  false;  if  (canContainInline  !=  tag.canContainInline)  return  false;  if  (empty  !=  tag.empty)  return  false;  if  (isBlock  !=  tag.isBlock)  return  false;  if  (optionalClosing  !=  tag.optionalClosing)  return  false;  if  (tagName  !=  null  ?  !tagName.equals(tag.tagName)  :  tag.tagName  !=  null)  return  false;    return  true;  }        [CLASS]  Tag    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  List    ancestors    Object    o    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  canContainBlock  !=  tag.canContainBlock  )  return  false;	[BUGGY]  if  (  canContainBlock  !=  tag.canContainBlock)  return  true;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (o  ==  null  ||  getClass()  !=  o.getClass())  return  false;    Tag  tag  =  (Tag)  o;    [BUGGY]  if(  canContainBlock  !=  tag.canContainBlock  )return  true;  if  (canContainInline  !=  tag.canContainInline)  return  false;  if  (empty  !=  tag.empty)  return  false;  if  (isBlock  !=  tag.isBlock)  return  false;  if  (optionalClosing  !=  tag.optionalClosing)  return  false;  if  (tagName  !=  null  ?  !tagName.equals(tag.tagName)  :  tag.tagName  !=  null)  return  false;    return  true;  }        [CLASS]  Tag    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  List    ancestors    Object    o    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  canContainBlock  !=  tag.canContainBlock  )  return  false;	[BUGGY]  if  (  canContainBlock  !=  defaultAncestor.canContainBlock)  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (o  ==  null  ||  getClass()  !=  o.getClass())  return  false;    Tag  tag  =  (Tag)  o;    [BUGGY]  if(  canContainBlock  !=  defaultAncestor.canContainBlock  )return  false;  if  (canContainInline  !=  tag.canContainInline)  return  false;  if  (empty  !=  tag.empty)  return  false;  if  (isBlock  !=  tag.isBlock)  return  false;  if  (optionalClosing  !=  tag.optionalClosing)  return  false;  if  (tagName  !=  null  ?  !tagName.equals(tag.tagName)  :  tag.tagName  !=  null)  return  false;    return  true;  }        [CLASS]  Tag    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  List    ancestors    Object    o    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  canContainBlock  !=  tag.canContainBlock  )  return  false;	[BUGGY]  if  (  preserveWhitespace  !=  tag.canContainBlock)  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (o  ==  null  ||  getClass()  !=  o.getClass())  return  false;    Tag  tag  =  (Tag)  o;    [BUGGY]  if(  preserveWhitespace  !=  tag.canContainBlock  )return  false;  if  (canContainInline  !=  tag.canContainInline)  return  false;  if  (empty  !=  tag.empty)  return  false;  if  (isBlock  !=  tag.isBlock)  return  false;  if  (optionalClosing  !=  tag.optionalClosing)  return  false;  if  (tagName  !=  null  ?  !tagName.equals(tag.tagName)  :  tag.tagName  !=  null)  return  false;    return  true;  }        [CLASS]  Tag    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  List    ancestors    Object    o    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  canContainBlock  !=  tag.canContainBlock  )  return  false;	[BUGGY]  if  (  canContainBlock  !=  optionalClosing)  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (o  ==  null  ||  getClass()  !=  o.getClass())  return  false;    Tag  tag  =  (Tag)  o;    [BUGGY]  if(  canContainBlock  !=  optionalClosing  )return  false;  if  (canContainInline  !=  tag.canContainInline)  return  false;  if  (empty  !=  tag.empty)  return  false;  if  (isBlock  !=  tag.isBlock)  return  false;  if  (optionalClosing  !=  tag.optionalClosing)  return  false;  if  (tagName  !=  null  ?  !tagName.equals(tag.tagName)  :  tag.tagName  !=  null)  return  false;    return  true;  }        [CLASS]  Tag    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  List    ancestors    Object    o    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  canContainBlock  !=  tag.canContainBlock  )  return  false;	[BUGGY]  if  (  tag  !=  canContainBlock.canContainBlock)  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (o  ==  null  ||  getClass()  !=  o.getClass())  return  false;    Tag  tag  =  (Tag)  o;    [BUGGY]  if(  tag  !=  canContainBlock.canContainBlock  )return  false;  if  (canContainInline  !=  tag.canContainInline)  return  false;  if  (empty  !=  tag.empty)  return  false;  if  (isBlock  !=  tag.isBlock)  return  false;  if  (optionalClosing  !=  tag.optionalClosing)  return  false;  if  (tagName  !=  null  ?  !tagName.equals(tag.tagName)  :  tag.tagName  !=  null)  return  false;    return  true;  }        [CLASS]  Tag    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  List    ancestors    Object    o    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  canContainBlock  !=  tag.canContainBlock  )  return  false;	[BUGGY]  if  (  canContainBlock  !=  tag)  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (o  ==  null  ||  getClass()  !=  o.getClass())  return  false;    Tag  tag  =  (Tag)  o;    [BUGGY]  if(  canContainBlock  !=  tag  )return  false;  if  (canContainInline  !=  tag.canContainInline)  return  false;  if  (empty  !=  tag.empty)  return  false;  if  (isBlock  !=  tag.isBlock)  return  false;  if  (optionalClosing  !=  tag.optionalClosing)  return  false;  if  (tagName  !=  null  ?  !tagName.equals(tag.tagName)  :  tag.tagName  !=  null)  return  false;    return  true;  }        [CLASS]  Tag    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  List    ancestors    Object    o    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  canContainInline  !=  tag.canContainInline  )  return  false;	[BUGGY]  if  (  canContainInline  <  tag.canContainInline)  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (o  ==  null  ||  getClass()  !=  o.getClass())  return  false;    Tag  tag  =  (Tag)  o;    if  (canContainBlock  !=  tag.canContainBlock)  return  false;  [BUGGY]  if(  canContainInline  <  tag.canContainInline  )return  false;  if  (empty  !=  tag.empty)  return  false;  if  (isBlock  !=  tag.isBlock)  return  false;  if  (optionalClosing  !=  tag.optionalClosing)  return  false;  if  (tagName  !=  null  ?  !tagName.equals(tag.tagName)  :  tag.tagName  !=  null)  return  false;    return  true;  }        [CLASS]  Tag    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  List    ancestors    Object    o    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  canContainInline  !=  tag.canContainInline  )  return  false;	[BUGGY]  if  (  canContainInline  !=  tag.canContainInline)  return  true;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (o  ==  null  ||  getClass()  !=  o.getClass())  return  false;    Tag  tag  =  (Tag)  o;    if  (canContainBlock  !=  tag.canContainBlock)  return  false;  [BUGGY]  if(  canContainInline  !=  tag.canContainInline  )return  true;  if  (empty  !=  tag.empty)  return  false;  if  (isBlock  !=  tag.isBlock)  return  false;  if  (optionalClosing  !=  tag.optionalClosing)  return  false;  if  (tagName  !=  null  ?  !tagName.equals(tag.tagName)  :  tag.tagName  !=  null)  return  false;    return  true;  }        [CLASS]  Tag    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  List    ancestors    Object    o    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  canContainInline  !=  tag.canContainInline  )  return  false;	[BUGGY]  if  (  canContainInline  !=  defaultAncestor.canContainInline)  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (o  ==  null  ||  getClass()  !=  o.getClass())  return  false;    Tag  tag  =  (Tag)  o;    if  (canContainBlock  !=  tag.canContainBlock)  return  false;  [BUGGY]  if(  canContainInline  !=  defaultAncestor.canContainInline  )return  false;  if  (empty  !=  tag.empty)  return  false;  if  (isBlock  !=  tag.isBlock)  return  false;  if  (optionalClosing  !=  tag.optionalClosing)  return  false;  if  (tagName  !=  null  ?  !tagName.equals(tag.tagName)  :  tag.tagName  !=  null)  return  false;    return  true;  }        [CLASS]  Tag    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  List    ancestors    Object    o    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  canContainInline  !=  tag.canContainInline  )  return  false;	[BUGGY]  if  (  optionalClosing  !=  tag.canContainInline)  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (o  ==  null  ||  getClass()  !=  o.getClass())  return  false;    Tag  tag  =  (Tag)  o;    if  (canContainBlock  !=  tag.canContainBlock)  return  false;  [BUGGY]  if(  optionalClosing  !=  tag.canContainInline  )return  false;  if  (empty  !=  tag.empty)  return  false;  if  (isBlock  !=  tag.isBlock)  return  false;  if  (optionalClosing  !=  tag.optionalClosing)  return  false;  if  (tagName  !=  null  ?  !tagName.equals(tag.tagName)  :  tag.tagName  !=  null)  return  false;    return  true;  }        [CLASS]  Tag    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  List    ancestors    Object    o    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  canContainInline  !=  tag.canContainInline  )  return  false;	[BUGGY]  if  (  canContainInline  !=  preserveWhitespace)  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (o  ==  null  ||  getClass()  !=  o.getClass())  return  false;    Tag  tag  =  (Tag)  o;    if  (canContainBlock  !=  tag.canContainBlock)  return  false;  [BUGGY]  if(  canContainInline  !=  preserveWhitespace  )return  false;  if  (empty  !=  tag.empty)  return  false;  if  (isBlock  !=  tag.isBlock)  return  false;  if  (optionalClosing  !=  tag.optionalClosing)  return  false;  if  (tagName  !=  null  ?  !tagName.equals(tag.tagName)  :  tag.tagName  !=  null)  return  false;    return  true;  }        [CLASS]  Tag    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  List    ancestors    Object    o    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  canContainInline  !=  tag.canContainInline  )  return  false;	[BUGGY]  if  (  tag  !=  canContainInline.canContainInline)  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (o  ==  null  ||  getClass()  !=  o.getClass())  return  false;    Tag  tag  =  (Tag)  o;    if  (canContainBlock  !=  tag.canContainBlock)  return  false;  [BUGGY]  if(  tag  !=  canContainInline.canContainInline  )return  false;  if  (empty  !=  tag.empty)  return  false;  if  (isBlock  !=  tag.isBlock)  return  false;  if  (optionalClosing  !=  tag.optionalClosing)  return  false;  if  (tagName  !=  null  ?  !tagName.equals(tag.tagName)  :  tag.tagName  !=  null)  return  false;    return  true;  }        [CLASS]  Tag    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  List    ancestors    Object    o    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  canContainInline  !=  tag.canContainInline  )  return  false;	[BUGGY]  if  (  tag.canContainInline  !=  canContainInline)  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (o  ==  null  ||  getClass()  !=  o.getClass())  return  false;    Tag  tag  =  (Tag)  o;    if  (canContainBlock  !=  tag.canContainBlock)  return  false;  [BUGGY]  if(  tag.canContainInline  !=  canContainInline  )return  false;  if  (empty  !=  tag.empty)  return  false;  if  (isBlock  !=  tag.isBlock)  return  false;  if  (optionalClosing  !=  tag.optionalClosing)  return  false;  if  (tagName  !=  null  ?  !tagName.equals(tag.tagName)  :  tag.tagName  !=  null)  return  false;    return  true;  }        [CLASS]  Tag    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  List    ancestors    Object    o    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  empty  !=  tag.empty  )  return  false;	[BUGGY]  if  (  empty  ==  tag.empty)  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (o  ==  null  ||  getClass()  !=  o.getClass())  return  false;    Tag  tag  =  (Tag)  o;    if  (canContainBlock  !=  tag.canContainBlock)  return  false;  if  (canContainInline  !=  tag.canContainInline)  return  false;  [BUGGY]  if(  empty  ==  tag.empty  )return  false;  if  (isBlock  !=  tag.isBlock)  return  false;  if  (optionalClosing  !=  tag.optionalClosing)  return  false;  if  (tagName  !=  null  ?  !tagName.equals(tag.tagName)  :  tag.tagName  !=  null)  return  false;    return  true;  }        [CLASS]  Tag    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  List    ancestors    Object    o    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  empty  !=  tag.empty  )  return  false;	[BUGGY]  if  (  empty  !=  tag.empty)  return  true;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (o  ==  null  ||  getClass()  !=  o.getClass())  return  false;    Tag  tag  =  (Tag)  o;    if  (canContainBlock  !=  tag.canContainBlock)  return  false;  if  (canContainInline  !=  tag.canContainInline)  return  false;  [BUGGY]  if(  empty  !=  tag.empty  )return  true;  if  (isBlock  !=  tag.isBlock)  return  false;  if  (optionalClosing  !=  tag.optionalClosing)  return  false;  if  (tagName  !=  null  ?  !tagName.equals(tag.tagName)  :  tag.tagName  !=  null)  return  false;    return  true;  }        [CLASS]  Tag    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  List    ancestors    Object    o    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  empty  !=  tag.empty  )  return  false;	[BUGGY]  if  (  empty  !=  defaultAncestor.empty)  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (o  ==  null  ||  getClass()  !=  o.getClass())  return  false;    Tag  tag  =  (Tag)  o;    if  (canContainBlock  !=  tag.canContainBlock)  return  false;  if  (canContainInline  !=  tag.canContainInline)  return  false;  [BUGGY]  if(  empty  !=  defaultAncestor.empty  )return  false;  if  (isBlock  !=  tag.isBlock)  return  false;  if  (optionalClosing  !=  tag.optionalClosing)  return  false;  if  (tagName  !=  null  ?  !tagName.equals(tag.tagName)  :  tag.tagName  !=  null)  return  false;    return  true;  }        [CLASS]  Tag    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  List    ancestors    Object    o    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  empty  !=  tag.empty  )  return  false;	[BUGGY]  if  (  empty  !=  preserveWhitespace)  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (o  ==  null  ||  getClass()  !=  o.getClass())  return  false;    Tag  tag  =  (Tag)  o;    if  (canContainBlock  !=  tag.canContainBlock)  return  false;  if  (canContainInline  !=  tag.canContainInline)  return  false;  [BUGGY]  if(  empty  !=  preserveWhitespace  )return  false;  if  (isBlock  !=  tag.isBlock)  return  false;  if  (optionalClosing  !=  tag.optionalClosing)  return  false;  if  (tagName  !=  null  ?  !tagName.equals(tag.tagName)  :  tag.tagName  !=  null)  return  false;    return  true;  }        [CLASS]  Tag    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  List    ancestors    Object    o    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  empty  !=  tag.empty  )  return  false;	[BUGGY]  if  (  empty  !=  tag.empty.empty)  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (o  ==  null  ||  getClass()  !=  o.getClass())  return  false;    Tag  tag  =  (Tag)  o;    if  (canContainBlock  !=  tag.canContainBlock)  return  false;  if  (canContainInline  !=  tag.canContainInline)  return  false;  [BUGGY]  if(  empty  !=  tag.empty.empty  )return  false;  if  (isBlock  !=  tag.isBlock)  return  false;  if  (optionalClosing  !=  tag.optionalClosing)  return  false;  if  (tagName  !=  null  ?  !tagName.equals(tag.tagName)  :  tag.tagName  !=  null)  return  false;    return  true;  }        [CLASS]  Tag    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  List    ancestors    Object    o    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  empty  !=  tag.empty  )  return  false;	[BUGGY]  if  (  tag  !=  empty.empty)  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (o  ==  null  ||  getClass()  !=  o.getClass())  return  false;    Tag  tag  =  (Tag)  o;    if  (canContainBlock  !=  tag.canContainBlock)  return  false;  if  (canContainInline  !=  tag.canContainInline)  return  false;  [BUGGY]  if(  tag  !=  empty.empty  )return  false;  if  (isBlock  !=  tag.isBlock)  return  false;  if  (optionalClosing  !=  tag.optionalClosing)  return  false;  if  (tagName  !=  null  ?  !tagName.equals(tag.tagName)  :  tag.tagName  !=  null)  return  false;    return  true;  }        [CLASS]  Tag    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  List    ancestors    Object    o    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  empty  !=  tag.empty  )  return  false;	[BUGGY]  if  (  tag.empty  !=  empty)  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (o  ==  null  ||  getClass()  !=  o.getClass())  return  false;    Tag  tag  =  (Tag)  o;    if  (canContainBlock  !=  tag.canContainBlock)  return  false;  if  (canContainInline  !=  tag.canContainInline)  return  false;  [BUGGY]  if(  tag.empty  !=  empty  )return  false;  if  (isBlock  !=  tag.isBlock)  return  false;  if  (optionalClosing  !=  tag.optionalClosing)  return  false;  if  (tagName  !=  null  ?  !tagName.equals(tag.tagName)  :  tag.tagName  !=  null)  return  false;    return  true;  }        [CLASS]  Tag    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  List    ancestors    Object    o    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  empty  !=  tag.empty  )  return  false;	[BUGGY]  if  (  empty  !=  preserveWhitespace)  return  true;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (o  ==  null  ||  getClass()  !=  o.getClass())  return  false;    Tag  tag  =  (Tag)  o;    if  (canContainBlock  !=  tag.canContainBlock)  return  false;  if  (canContainInline  !=  tag.canContainInline)  return  false;  [BUGGY]  if(  empty  !=  preserveWhitespace  )return  true;  if  (isBlock  !=  tag.isBlock)  return  false;  if  (optionalClosing  !=  tag.optionalClosing)  return  false;  if  (tagName  !=  null  ?  !tagName.equals(tag.tagName)  :  tag.tagName  !=  null)  return  false;    return  true;  }        [CLASS]  Tag    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  List    ancestors    Object    o    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  isBlock  !=  tag.isBlock  )  return  false;	[BUGGY]  if  (  isBlock  ==  tag.isBlock)  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (o  ==  null  ||  getClass()  !=  o.getClass())  return  false;    Tag  tag  =  (Tag)  o;    if  (canContainBlock  !=  tag.canContainBlock)  return  false;  if  (canContainInline  !=  tag.canContainInline)  return  false;  if  (empty  !=  tag.empty)  return  false;  [BUGGY]  if(  isBlock  ==  tag.isBlock  )return  false;  if  (optionalClosing  !=  tag.optionalClosing)  return  false;  if  (tagName  !=  null  ?  !tagName.equals(tag.tagName)  :  tag.tagName  !=  null)  return  false;    return  true;  }        [CLASS]  Tag    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  List    ancestors    Object    o    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  isBlock  !=  tag.isBlock  )  return  false;	[BUGGY]  if  (  isBlock  !=  tag.isBlock)  return  true;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (o  ==  null  ||  getClass()  !=  o.getClass())  return  false;    Tag  tag  =  (Tag)  o;    if  (canContainBlock  !=  tag.canContainBlock)  return  false;  if  (canContainInline  !=  tag.canContainInline)  return  false;  if  (empty  !=  tag.empty)  return  false;  [BUGGY]  if(  isBlock  !=  tag.isBlock  )return  true;  if  (optionalClosing  !=  tag.optionalClosing)  return  false;  if  (tagName  !=  null  ?  !tagName.equals(tag.tagName)  :  tag.tagName  !=  null)  return  false;    return  true;  }        [CLASS]  Tag    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  List    ancestors    Object    o    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  isBlock  !=  tag.isBlock  )  return  false;	[BUGGY]  if  (  isBlock  !=  defaultAncestor.isBlock)  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (o  ==  null  ||  getClass()  !=  o.getClass())  return  false;    Tag  tag  =  (Tag)  o;    if  (canContainBlock  !=  tag.canContainBlock)  return  false;  if  (canContainInline  !=  tag.canContainInline)  return  false;  if  (empty  !=  tag.empty)  return  false;  [BUGGY]  if(  isBlock  !=  defaultAncestor.isBlock  )return  false;  if  (optionalClosing  !=  tag.optionalClosing)  return  false;  if  (tagName  !=  null  ?  !tagName.equals(tag.tagName)  :  tag.tagName  !=  null)  return  false;    return  true;  }        [CLASS]  Tag    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  List    ancestors    Object    o    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  isBlock  !=  tag.isBlock  )  return  false;	[BUGGY]  if  (  optionalClosing  !=  tag.isBlock)  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (o  ==  null  ||  getClass()  !=  o.getClass())  return  false;    Tag  tag  =  (Tag)  o;    if  (canContainBlock  !=  tag.canContainBlock)  return  false;  if  (canContainInline  !=  tag.canContainInline)  return  false;  if  (empty  !=  tag.empty)  return  false;  [BUGGY]  if(  optionalClosing  !=  tag.isBlock  )return  false;  if  (optionalClosing  !=  tag.optionalClosing)  return  false;  if  (tagName  !=  null  ?  !tagName.equals(tag.tagName)  :  tag.tagName  !=  null)  return  false;    return  true;  }        [CLASS]  Tag    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  List    ancestors    Object    o    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  isBlock  !=  tag.isBlock  )  return  false;	[BUGGY]  if  (  isBlock  !=  isBlock)  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (o  ==  null  ||  getClass()  !=  o.getClass())  return  false;    Tag  tag  =  (Tag)  o;    if  (canContainBlock  !=  tag.canContainBlock)  return  false;  if  (canContainInline  !=  tag.canContainInline)  return  false;  if  (empty  !=  tag.empty)  return  false;  [BUGGY]  if(  isBlock  !=  isBlock  )return  false;  if  (optionalClosing  !=  tag.optionalClosing)  return  false;  if  (tagName  !=  null  ?  !tagName.equals(tag.tagName)  :  tag.tagName  !=  null)  return  false;    return  true;  }        [CLASS]  Tag    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  List    ancestors    Object    o    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  isBlock  !=  tag.isBlock  )  return  false;	[BUGGY]  if  (  tag  !=  isBlock.isBlock)  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (o  ==  null  ||  getClass()  !=  o.getClass())  return  false;    Tag  tag  =  (Tag)  o;    if  (canContainBlock  !=  tag.canContainBlock)  return  false;  if  (canContainInline  !=  tag.canContainInline)  return  false;  if  (empty  !=  tag.empty)  return  false;  [BUGGY]  if(  tag  !=  isBlock.isBlock  )return  false;  if  (optionalClosing  !=  tag.optionalClosing)  return  false;  if  (tagName  !=  null  ?  !tagName.equals(tag.tagName)  :  tag.tagName  !=  null)  return  false;    return  true;  }        [CLASS]  Tag    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  List    ancestors    Object    o    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  isBlock  !=  tag.isBlock  )  return  false;	[BUGGY]  if  (  tag.isBlock  !=  isBlock)  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (o  ==  null  ||  getClass()  !=  o.getClass())  return  false;    Tag  tag  =  (Tag)  o;    if  (canContainBlock  !=  tag.canContainBlock)  return  false;  if  (canContainInline  !=  tag.canContainInline)  return  false;  if  (empty  !=  tag.empty)  return  false;  [BUGGY]  if(  tag.isBlock  !=  isBlock  )return  false;  if  (optionalClosing  !=  tag.optionalClosing)  return  false;  if  (tagName  !=  null  ?  !tagName.equals(tag.tagName)  :  tag.tagName  !=  null)  return  false;    return  true;  }        [CLASS]  Tag    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  List    ancestors    Object    o    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  isBlock  !=  tag.isBlock  )  return  false;  if  (  optionalClosing  !=  tag.optionalClosing  )  return  false;  if  (  tagName  !=  null  ?  !tagName.equals  (  tag.tagName  )  :  tag.tagName  !=  null  )  return  false;  return  true;  }	[BUGGY]  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (o  ==  null  ||  getClass()  !=  o.getClass())  return  false;    Tag  tag  =  (Tag)  o;    if  (canContainBlock  !=  tag.canContainBlock)  return  false;  if  (canContainInline  !=  tag.canContainInline)  return  false;  if  (empty  !=  tag.empty)  return  false;  [BUGGY]  if  (isBlock  !=  tag.isBlock)  return  false;    return  false;              [CLASS]  Tag    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  List    ancestors    Object    o    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  isBlock  !=  tag.isBlock  )  return  false;  if  (  optionalClosing  !=  tag.optionalClosing  )  return  false;  if  (  tagName  !=  null  ?  !tagName.equals  (  tag.tagName  )  :  tag.tagName  !=  null  )  return  false;  return  true;  }	[BUGGY]    [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (o  ==  null  ||  getClass()  !=  o.getClass())  return  false;    Tag  tag  =  (Tag)  o;    if  (canContainBlock  !=  tag.canContainBlock)  return  false;  if  (canContainInline  !=  tag.canContainInline)  return  false;  if  (empty  !=  tag.empty)  return  false;  [BUGGY]  if  (isBlock  !=  tag.isBlock)  return  false;                  [CLASS]  Tag    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  List    ancestors    Object    o    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  optionalClosing  !=  tag.optionalClosing  )  return  false;	[BUGGY]  if  (  optionalClosing  ==  tag.optionalClosing)  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (o  ==  null  ||  getClass()  !=  o.getClass())  return  false;    Tag  tag  =  (Tag)  o;    if  (canContainBlock  !=  tag.canContainBlock)  return  false;  if  (canContainInline  !=  tag.canContainInline)  return  false;  if  (empty  !=  tag.empty)  return  false;  if  (isBlock  !=  tag.isBlock)  return  false;  [BUGGY]  if(  optionalClosing  ==  tag.optionalClosing  )return  false;  if  (tagName  !=  null  ?  !tagName.equals(tag.tagName)  :  tag.tagName  !=  null)  return  false;    return  true;  }        [CLASS]  Tag    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  List    ancestors    Object    o    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  optionalClosing  !=  tag.optionalClosing  )  return  false;	[BUGGY]  if  (  optionalClosing  !=  tag.optionalClosing)  return  true;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (o  ==  null  ||  getClass()  !=  o.getClass())  return  false;    Tag  tag  =  (Tag)  o;    if  (canContainBlock  !=  tag.canContainBlock)  return  false;  if  (canContainInline  !=  tag.canContainInline)  return  false;  if  (empty  !=  tag.empty)  return  false;  if  (isBlock  !=  tag.isBlock)  return  false;  [BUGGY]  if(  optionalClosing  !=  tag.optionalClosing  )return  true;  if  (tagName  !=  null  ?  !tagName.equals(tag.tagName)  :  tag.tagName  !=  null)  return  false;    return  true;  }        [CLASS]  Tag    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  List    ancestors    Object    o    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  optionalClosing  !=  tag.optionalClosing  )  return  false;	[BUGGY]  if  (  preserveWhitespace  !=  tag.optionalClosing)  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (o  ==  null  ||  getClass()  !=  o.getClass())  return  false;    Tag  tag  =  (Tag)  o;    if  (canContainBlock  !=  tag.canContainBlock)  return  false;  if  (canContainInline  !=  tag.canContainInline)  return  false;  if  (empty  !=  tag.empty)  return  false;  if  (isBlock  !=  tag.isBlock)  return  false;  [BUGGY]  if(  preserveWhitespace  !=  tag.optionalClosing  )return  false;  if  (tagName  !=  null  ?  !tagName.equals(tag.tagName)  :  tag.tagName  !=  null)  return  false;    return  true;  }        [CLASS]  Tag    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  List    ancestors    Object    o    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  optionalClosing  !=  tag.optionalClosing  )  return  false;	[BUGGY]  if  (  optionalClosing  !=  isBlock)  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (o  ==  null  ||  getClass()  !=  o.getClass())  return  false;    Tag  tag  =  (Tag)  o;    if  (canContainBlock  !=  tag.canContainBlock)  return  false;  if  (canContainInline  !=  tag.canContainInline)  return  false;  if  (empty  !=  tag.empty)  return  false;  if  (isBlock  !=  tag.isBlock)  return  false;  [BUGGY]  if(  optionalClosing  !=  isBlock  )return  false;  if  (tagName  !=  null  ?  !tagName.equals(tag.tagName)  :  tag.tagName  !=  null)  return  false;    return  true;  }        [CLASS]  Tag    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  List    ancestors    Object    o    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  optionalClosing  !=  tag.optionalClosing  )  return  false;	[BUGGY]  if  (  tag  !=  optionalClosing.optionalClosing)  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (o  ==  null  ||  getClass()  !=  o.getClass())  return  false;    Tag  tag  =  (Tag)  o;    if  (canContainBlock  !=  tag.canContainBlock)  return  false;  if  (canContainInline  !=  tag.canContainInline)  return  false;  if  (empty  !=  tag.empty)  return  false;  if  (isBlock  !=  tag.isBlock)  return  false;  [BUGGY]  if(  tag  !=  optionalClosing.optionalClosing  )return  false;  if  (tagName  !=  null  ?  !tagName.equals(tag.tagName)  :  tag.tagName  !=  null)  return  false;    return  true;  }        [CLASS]  Tag    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  List    ancestors    Object    o    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  optionalClosing  !=  tag.optionalClosing  )  return  false;	[BUGGY]  if  (  tag.optionalClosing  !=  optionalClosing)  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (o  ==  null  ||  getClass()  !=  o.getClass())  return  false;    Tag  tag  =  (Tag)  o;    if  (canContainBlock  !=  tag.canContainBlock)  return  false;  if  (canContainInline  !=  tag.canContainInline)  return  false;  if  (empty  !=  tag.empty)  return  false;  if  (isBlock  !=  tag.isBlock)  return  false;  [BUGGY]  if(  tag.optionalClosing  !=  optionalClosing  )return  false;  if  (tagName  !=  null  ?  !tagName.equals(tag.tagName)  :  tag.tagName  !=  null)  return  false;    return  true;  }        [CLASS]  Tag    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  List    ancestors    Object    o    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  optionalClosing  !=  tag.optionalClosing  )  return  false;  if  (  tagName  !=  null  ?  !tagName.equals  (  tag.tagName  )  :  tag.tagName  !=  null  )  return  false;  return  true;  }	[BUGGY]  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (o  ==  null  ||  getClass()  !=  o.getClass())  return  false;    Tag  tag  =  (Tag)  o;    if  (canContainBlock  !=  tag.canContainBlock)  return  false;  if  (canContainInline  !=  tag.canContainInline)  return  false;  if  (empty  !=  tag.empty)  return  false;  if  (isBlock  !=  tag.isBlock)  return  false;  [BUGGY]  if  (optionalClosing  !=  tag.optionalClosing)  return  false;    return  false;            [CLASS]  Tag    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  List    ancestors    Object    o    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  optionalClosing  !=  tag.optionalClosing  )  return  false;  if  (  tagName  !=  null  ?  !tagName.equals  (  tag.tagName  )  :  tag.tagName  !=  null  )  return  false;  return  true;  }	[BUGGY]    [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (o  ==  null  ||  getClass()  !=  o.getClass())  return  false;    Tag  tag  =  (Tag)  o;    if  (canContainBlock  !=  tag.canContainBlock)  return  false;  if  (canContainInline  !=  tag.canContainInline)  return  false;  if  (empty  !=  tag.empty)  return  false;  if  (isBlock  !=  tag.isBlock)  return  false;  [BUGGY]  if  (optionalClosing  !=  tag.optionalClosing)  return  false;                [CLASS]  Tag    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  List    ancestors    Object    o    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  tagName  !=  null  ?  !tagName.equals  (  tag.tagName  )  :  tag.tagName  !=  null  )  return  false;	[BUGGY]  if  (  tagName  ==  null  ?  !tagName.equals(  tag.tagName)  :  tag.tagName  ==  null)  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (o  ==  null  ||  getClass()  !=  o.getClass())  return  false;    Tag  tag  =  (Tag)  o;    if  (canContainBlock  !=  tag.canContainBlock)  return  false;  if  (canContainInline  !=  tag.canContainInline)  return  false;  if  (empty  !=  tag.empty)  return  false;  if  (isBlock  !=  tag.isBlock)  return  false;  if  (optionalClosing  !=  tag.optionalClosing)  return  false;  [BUGGY]  if(  tagName  ==  null  ?  !tagName.equals  (  tag.tagName  ):  tag.tagName  ==  null  )return  false;    return  true;  }        [CLASS]  Tag    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  List    ancestors    Object    o    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  tagName  !=  null  ?  !tagName.equals  (  tag.tagName  )  :  tag.tagName  !=  null  )  return  false;	[BUGGY]  if  (  tagName  !=  null  ?  !tagName.equals(  tag.tagName)  :  tag.tagName  ==  null)  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (o  ==  null  ||  getClass()  !=  o.getClass())  return  false;    Tag  tag  =  (Tag)  o;    if  (canContainBlock  !=  tag.canContainBlock)  return  false;  if  (canContainInline  !=  tag.canContainInline)  return  false;  if  (empty  !=  tag.empty)  return  false;  if  (isBlock  !=  tag.isBlock)  return  false;  if  (optionalClosing  !=  tag.optionalClosing)  return  false;  [BUGGY]  if(  tagName  !=  null  ?  !tagName.equals  (  tag.tagName  ):  tag.tagName  ==  null  )return  false;    return  true;  }        [CLASS]  Tag    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  List    ancestors    Object    o    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  tagName  !=  null  ?  !tagName.equals  (  tag.tagName  )  :  tag.tagName  !=  null  )  return  false;	[BUGGY]  if  (  tagName  !=  null  ?  !tagName.equals(  tag.tagName)  :  tag.tagName  !=  null)  return  true;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (o  ==  null  ||  getClass()  !=  o.getClass())  return  false;    Tag  tag  =  (Tag)  o;    if  (canContainBlock  !=  tag.canContainBlock)  return  false;  if  (canContainInline  !=  tag.canContainInline)  return  false;  if  (empty  !=  tag.empty)  return  false;  if  (isBlock  !=  tag.isBlock)  return  false;  if  (optionalClosing  !=  tag.optionalClosing)  return  false;  [BUGGY]  if(  tagName  !=  null  ?  !tagName.equals  (  tag.tagName  ):  tag.tagName  !=  null  )return  true;    return  true;  }        [CLASS]  Tag    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  List    ancestors    Object    o    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  tagName  !=  null  ?  !tagName.equals  (  tag.tagName  )  :  tag.tagName  !=  null  )  return  false;	[BUGGY]  if  (  defaultAncestorName  !=  null  ?  !tagName.equals(  tag.tagName)  :  tag.tagName  !=  null)  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (o  ==  null  ||  getClass()  !=  o.getClass())  return  false;    Tag  tag  =  (Tag)  o;    if  (canContainBlock  !=  tag.canContainBlock)  return  false;  if  (canContainInline  !=  tag.canContainInline)  return  false;  if  (empty  !=  tag.empty)  return  false;  if  (isBlock  !=  tag.isBlock)  return  false;  if  (optionalClosing  !=  tag.optionalClosing)  return  false;  [BUGGY]  if(  defaultAncestorName  !=  null  ?  !tagName.equals  (  tag.tagName  ):  tag.tagName  !=  null  )return  false;    return  true;  }        [CLASS]  Tag    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  List    ancestors    Object    o    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  tagName  !=  null  ?  !tagName.equals  (  tag.tagName  )  :  tag.tagName  !=  null  )  return  false;	[BUGGY]  if  (  tag.tagNameName  !=  null  ?  !tagName.equals(  tag)  :  tag.tagName  !=  null)  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (o  ==  null  ||  getClass()  !=  o.getClass())  return  false;    Tag  tag  =  (Tag)  o;    if  (canContainBlock  !=  tag.canContainBlock)  return  false;  if  (canContainInline  !=  tag.canContainInline)  return  false;  if  (empty  !=  tag.empty)  return  false;  if  (isBlock  !=  tag.isBlock)  return  false;  if  (optionalClosing  !=  tag.optionalClosing)  return  false;  [BUGGY]  if(  tag.tagNameName  !=  null  ?  !tagName.equals  (  tag  ):  tag.tagName  !=  null  )return  false;    return  true;  }        [CLASS]  Tag    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  List    ancestors    Object    o    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  tagName  !=  null  ?  !tagName.equals  (  tag.tagName  )  :  tag.tagName  !=  null  )  return  false;	[BUGGY]  if  (  tag.tagName  !=  null  ?  !tagName.equals(  tagName)  :  tag.tagName  !=  null)  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (o  ==  null  ||  getClass()  !=  o.getClass())  return  false;    Tag  tag  =  (Tag)  o;    if  (canContainBlock  !=  tag.canContainBlock)  return  false;  if  (canContainInline  !=  tag.canContainInline)  return  false;  if  (empty  !=  tag.empty)  return  false;  if  (isBlock  !=  tag.isBlock)  return  false;  if  (optionalClosing  !=  tag.optionalClosing)  return  false;  [BUGGY]  if(  tag.tagName  !=  null  ?  !tagName.equals  (  tagName  ):  tag.tagName  !=  null  )return  false;    return  true;  }        [CLASS]  Tag    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  List    ancestors    Object    o    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  tagName  !=  null  ?  !tagName.equals  (  tag.tagName  )  :  tag.tagName  !=  null  )  return  false;	[BUGGY]  if  (  tag.tagName  !=  null)  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (o  ==  null  ||  getClass()  !=  o.getClass())  return  false;    Tag  tag  =  (Tag)  o;    if  (canContainBlock  !=  tag.canContainBlock)  return  false;  if  (canContainInline  !=  tag.canContainInline)  return  false;  if  (empty  !=  tag.empty)  return  false;  if  (isBlock  !=  tag.isBlock)  return  false;  if  (optionalClosing  !=  tag.optionalClosing)  return  false;  [BUGGY]  if(  tag.tagName  !=  null  )return  false;    return  true;  }        [CLASS]  Tag    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  List    ancestors    Object    o    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  tagName  !=  null  ?  !tagName.equals  (  tag.tagName  )  :  tag.tagName  !=  null  )  return  false;	[BUGGY]  if  (  tagName  !=  this  ?  !tagName.equals(  tag.tagName)  :  tag.tagName  !=  this)  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (o  ==  null  ||  getClass()  !=  o.getClass())  return  false;    Tag  tag  =  (Tag)  o;    if  (canContainBlock  !=  tag.canContainBlock)  return  false;  if  (canContainInline  !=  tag.canContainInline)  return  false;  if  (empty  !=  tag.empty)  return  false;  if  (isBlock  !=  tag.isBlock)  return  false;  if  (optionalClosing  !=  tag.optionalClosing)  return  false;  [BUGGY]  if(  tagName  !=  this  ?  !tagName.equals  (  tag.tagName  ):  tag.tagName  !=  this  )return  false;    return  true;  }        [CLASS]  Tag    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  List    ancestors    Object    o    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  tagName  !=  null  ?  !tagName.equals  (  tag.tagName  )  :  tag.tagName  !=  null  )  return  false;  return  true;  }	[BUGGY]  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (o  ==  null  ||  getClass()  !=  o.getClass())  return  false;    Tag  tag  =  (Tag)  o;    if  (canContainBlock  !=  tag.canContainBlock)  return  false;  if  (canContainInline  !=  tag.canContainInline)  return  false;  if  (empty  !=  tag.empty)  return  false;  if  (isBlock  !=  tag.isBlock)  return  false;  if  (optionalClosing  !=  tag.optionalClosing)  return  false;  [BUGGY]  if  (tagName  !=  null  ?  !tagName.equals(tag.tagName)  :  tag.tagName  !=  null)  return  false;    return  false;          [CLASS]  Tag    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  List    ancestors    Object    o    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  tagName  !=  null  ?  !tagName.equals  (  tag.tagName  )  :  tag.tagName  !=  null  )  return  false;  return  true;  }	[BUGGY]    [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (o  ==  null  ||  getClass()  !=  o.getClass())  return  false;    Tag  tag  =  (Tag)  o;    if  (canContainBlock  !=  tag.canContainBlock)  return  false;  if  (canContainInline  !=  tag.canContainInline)  return  false;  if  (empty  !=  tag.empty)  return  false;  if  (isBlock  !=  tag.isBlock)  return  false;  if  (optionalClosing  !=  tag.optionalClosing)  return  false;  [BUGGY]  if  (tagName  !=  null  ?  !tagName.equals(tag.tagName)  :  tag.tagName  !=  null)  return  false;              [CLASS]  Tag    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  List    ancestors    Object    o    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  tagName  !=  null  ?  !tagName.equals  (  tag.tagName  )  :  tag.tagName  !=  null  )  return  false;	[BUGGY]  if  (  tagName  !  =    tag.tagName  !=  null)  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (o  ==  null  ||  getClass()  !=  o.getClass())  return  false;    Tag  tag  =  (Tag)  o;    if  (canContainBlock  !=  tag.canContainBlock)  return  false;  if  (canContainInline  !=  tag.canContainInline)  return  false;  if  (empty  !=  tag.empty)  return  false;  if  (isBlock  !=  tag.isBlock)  return  false;  if  (optionalClosing  !=  tag.optionalClosing)  return  false;  [BUGGY]  if(  tagName  !  =tag.tagName  !=  null  )return  false;    return  true;  }        [CLASS]  Tag    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  List    ancestors    Object    o    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  tagName  !=  null  ?  !tagName.equals  (  tag.tagName  )  :  tag.tagName  !=  null  )  return  false;	[BUGGY]  if  (  tagName  !  =    !tagName.equals(  tag.tagName)  ;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (o  ==  null  ||  getClass()  !=  o.getClass())  return  false;    Tag  tag  =  (Tag)  o;    if  (canContainBlock  !=  tag.canContainBlock)  return  false;  if  (canContainInline  !=  tag.canContainInline)  return  false;  if  (empty  !=  tag.empty)  return  false;  if  (isBlock  !=  tag.isBlock)  return  false;  if  (optionalClosing  !=  tag.optionalClosing)  return  false;  [BUGGY]  if(  tagName  !  =!tagName.equals  (  tag.tagName  );    return  true;  }        [CLASS]  Tag    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  List    ancestors    Object    o    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
if  (  tagName  !=  null  ?  !tagName.equals  (  tag.tagName  )  :  tag.tagName  !=  null  )  return  false;	[BUGGY]  if  (  tagNameName  !=  null  ?  !tagName.equals(  tag.tagName)  :  tag.tagName  !=  null)  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (o  ==  null  ||  getClass()  !=  o.getClass())  return  false;    Tag  tag  =  (Tag)  o;    if  (canContainBlock  !=  tag.canContainBlock)  return  false;  if  (canContainInline  !=  tag.canContainInline)  return  false;  if  (empty  !=  tag.empty)  return  false;  if  (isBlock  !=  tag.isBlock)  return  false;  if  (optionalClosing  !=  tag.optionalClosing)  return  false;  [BUGGY]  if(  tagNameName  !=  null  ?  !tagName.equals  (  tag.tagName  ):  tag.tagName  !=  null  )return  false;    return  true;  }        [CLASS]  Tag    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  List    ancestors    Object    o    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
return  true;	[BUGGY]  return  false;  [CONTEXT]  public  boolean  equals(Object  o)  {  if  (this  ==  o)  return  true;  if  (o  ==  null  ||  getClass()  !=  o.getClass())  return  false;    Tag  tag  =  (Tag)  o;    if  (canContainBlock  !=  tag.canContainBlock)  return  false;  if  (canContainInline  !=  tag.canContainInline)  return  false;  if  (empty  !=  tag.empty)  return  false;  if  (isBlock  !=  tag.isBlock)  return  false;  if  (optionalClosing  !=  tag.optionalClosing)  return  false;  if  (tagName  !=  null  ?  !tagName.equals(tag.tagName)  :  tag.tagName  !=  null)  return  false;    [BUGGY]  return  false;  }        [CLASS]  Tag    [METHOD]  equals  [RETURN_TYPE]  boolean      Object  o  [VARIABLES]  List    ancestors    Object    o    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
int  result  =  tagName  !=  null  ?  tagName.hashCode  (  )  :  0;	[BUGGY]  long    result  =  tagName  !=  null  ?  tagName.hashCode(  )  :  0;  [CONTEXT]  public  int  hashCode()  {  [BUGGY]  longresult  =  tagName  !=  null  ?  tagName.hashCode  ():  0;  result  =  31  *  result  +  (isBlock  ?  1  :  0);  result  =  31  *  result  +  (canContainBlock  ?  1  :  0);  result  =  31  *  result  +  (canContainInline  ?  1  :  0);  result  =  31  *  result  +  (optionalClosing  ?  1  :  0);  result  =  31  *  result  +  (empty  ?  1  :  0);  return  result;  }        [CLASS]  Tag    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    int    result    
int  result  =  tagName  !=  null  ?  tagName.hashCode  (  )  :  0;	[BUGGY]  int  result  =  tagName  ==  null  ?  tagName.hashCode(  )  :  0;  [CONTEXT]  public  int  hashCode()  {  [BUGGY]  int  result  =  tagName  ==  null  ?  tagName.hashCode  ():  0;  result  =  31  *  result  +  (isBlock  ?  1  :  0);  result  =  31  *  result  +  (canContainBlock  ?  1  :  0);  result  =  31  *  result  +  (canContainInline  ?  1  :  0);  result  =  31  *  result  +  (optionalClosing  ?  1  :  0);  result  =  31  *  result  +  (empty  ?  1  :  0);  return  result;  }        [CLASS]  Tag    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    int    result    
int  result  =  tagName  !=  null  ?  tagName.hashCode  (  )  :  0;	[BUGGY]  int  result  =  tagName  !=  null  ?  tagName.hashCode(  )  :  -2;  [CONTEXT]  public  int  hashCode()  {  [BUGGY]  int  result  =  tagName  !=  null  ?  tagName.hashCode  ():  -2;  result  =  31  *  result  +  (isBlock  ?  1  :  0);  result  =  31  *  result  +  (canContainBlock  ?  1  :  0);  result  =  31  *  result  +  (canContainInline  ?  1  :  0);  result  =  31  *  result  +  (optionalClosing  ?  1  :  0);  result  =  31  *  result  +  (empty  ?  1  :  0);  return  result;  }        [CLASS]  Tag    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    int    result    
int  result  =  tagName  !=  null  ?  tagName.hashCode  (  )  :  0;	[BUGGY]  int  result    =    0;  [CONTEXT]  public  int  hashCode()  {  [BUGGY]  int  result=0;  result  =  31  *  result  +  (isBlock  ?  1  :  0);  result  =  31  *  result  +  (canContainBlock  ?  1  :  0);  result  =  31  *  result  +  (canContainInline  ?  1  :  0);  result  =  31  *  result  +  (optionalClosing  ?  1  :  0);  result  =  31  *  result  +  (empty  ?  1  :  0);  return  result;  }        [CLASS]  Tag    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    int    result    
int  result  =  tagName  !=  null  ?  tagName.hashCode  (  )  :  0;	[BUGGY]  int  result    =    tagName.hashCode(  )  ;  [CONTEXT]  public  int  hashCode()  {  [BUGGY]  int  result=tagName.hashCode  ();  result  =  31  *  result  +  (isBlock  ?  1  :  0);  result  =  31  *  result  +  (canContainBlock  ?  1  :  0);  result  =  31  *  result  +  (canContainInline  ?  1  :  0);  result  =  31  *  result  +  (optionalClosing  ?  1  :  0);  result  =  31  *  result  +  (empty  ?  1  :  0);  return  result;  }        [CLASS]  Tag    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    int    result    
int  result  =  tagName  !=  null  ?  tagName.hashCode  (  )  :  0;	[BUGGY]  int  result  =  tagName  !=  null  ?  tagName.trim(  )  :  0;  [CONTEXT]  public  int  hashCode()  {  [BUGGY]  int  result  =  tagName  !=  null  ?  tagName.trim  ():  0;  result  =  31  *  result  +  (isBlock  ?  1  :  0);  result  =  31  *  result  +  (canContainBlock  ?  1  :  0);  result  =  31  *  result  +  (canContainInline  ?  1  :  0);  result  =  31  *  result  +  (optionalClosing  ?  1  :  0);  result  =  31  *  result  +  (empty  ?  1  :  0);  return  result;  }        [CLASS]  Tag    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    int    result    
int  result  =  tagName  !=  null  ?  tagName.hashCode  (  )  :  0;	[BUGGY]  int  result  =  tagName  !=  null  ?  tagName  .toLowerCase(  )    :  0;  [CONTEXT]  public  int  hashCode()  {  [BUGGY]  int  result  =  tagName  !=  null  ?  tagName  .toLowerCase  ()  :  0;  result  =  31  *  result  +  (isBlock  ?  1  :  0);  result  =  31  *  result  +  (canContainBlock  ?  1  :  0);  result  =  31  *  result  +  (canContainInline  ?  1  :  0);  result  =  31  *  result  +  (optionalClosing  ?  1  :  0);  result  =  31  *  result  +  (empty  ?  1  :  0);  return  result;  }        [CLASS]  Tag    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    int    result    
int  result  =  tagName  !=  null  ?  tagName.hashCode  (  )  :  0;  result  =  31  *  result  +  (  isBlock  ?  1  :  0  )  ;	[BUGGY]    [CONTEXT]  public  int  hashCode()  {  [BUGGY]  int  result  =  tagName  !=  null  ?  tagName.hashCode()  :  0;      result  =  31  *  result  +  (canContainBlock  ?  1  :  0);  result  =  31  *  result  +  (canContainInline  ?  1  :  0);  result  =  31  *  result  +  (optionalClosing  ?  1  :  0);  result  =  31  *  result  +  (empty  ?  1  :  0);  return  result;        [CLASS]  Tag    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    int    result    
result  =  31  *  result  +  (  isBlock  ?  1  :  0  )  ;	[BUGGY]  result  =  31  -  result  +  (  isBlock  ?  1  :  0);  [CONTEXT]  public  int  hashCode()  {  int  result  =  tagName  !=  null  ?  tagName.hashCode()  :  0;  [BUGGY]  result  =  31  -  result  +(  isBlock  ?  1  :  0  )  ;  result  =  31  *  result  +  (canContainBlock  ?  1  :  0);  result  =  31  *  result  +  (canContainInline  ?  1  :  0);  result  =  31  *  result  +  (optionalClosing  ?  1  :  0);  result  =  31  *  result  +  (empty  ?  1  :  0);  return  result;  }        [CLASS]  Tag    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    int    result    
result  =  31  *  result  +  (  isBlock  ?  1  :  0  )  ;	[BUGGY]  result  =  33  *  result  +  (  isBlock  ?  1  :  0);  [CONTEXT]  public  int  hashCode()  {  int  result  =  tagName  !=  null  ?  tagName.hashCode()  :  0;  [BUGGY]  result  =  33  *  result  +(  isBlock  ?  1  :  0  )  ;  result  =  31  *  result  +  (canContainBlock  ?  1  :  0);  result  =  31  *  result  +  (canContainInline  ?  1  :  0);  result  =  31  *  result  +  (optionalClosing  ?  1  :  0);  result  =  31  *  result  +  (empty  ?  1  :  0);  return  result;  }        [CLASS]  Tag    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    int    result    
result  =  31  *  result  +  (  isBlock  ?  1  :  0  )  ;	[BUGGY]  result  =  31  *  result  +  (  isBlock  ?  1  :  -3);  [CONTEXT]  public  int  hashCode()  {  int  result  =  tagName  !=  null  ?  tagName.hashCode()  :  0;  [BUGGY]  result  =  31  *  result  +(  isBlock  ?  1  :  -3  )  ;  result  =  31  *  result  +  (canContainBlock  ?  1  :  0);  result  =  31  *  result  +  (canContainInline  ?  1  :  0);  result  =  31  *  result  +  (optionalClosing  ?  1  :  0);  result  =  31  *  result  +  (empty  ?  1  :  0);  return  result;  }        [CLASS]  Tag    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    int    result    
result  =  31  *  result  +  (  isBlock  ?  1  :  0  )  ;	[BUGGY]  result  =  31  *  result  +  (  optionalClosing  ?  1  :  0);  [CONTEXT]  public  int  hashCode()  {  int  result  =  tagName  !=  null  ?  tagName.hashCode()  :  0;  [BUGGY]  result  =  31  *  result  +(  optionalClosing  ?  1  :  0  )  ;  result  =  31  *  result  +  (canContainBlock  ?  1  :  0);  result  =  31  *  result  +  (canContainInline  ?  1  :  0);  result  =  31  *  result  +  (optionalClosing  ?  1  :  0);  result  =  31  *  result  +  (empty  ?  1  :  0);  return  result;  }        [CLASS]  Tag    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    int    result    
result  =  31  *  result  +  (  isBlock  ?  1  :  0  )  ;	[BUGGY]  result  =  31  *  isBlock  +  (  result  ?  1  :  0);  [CONTEXT]  public  int  hashCode()  {  int  result  =  tagName  !=  null  ?  tagName.hashCode()  :  0;  [BUGGY]  result  =  31  *  isBlock  +(  result  ?  1  :  0  )  ;  result  =  31  *  result  +  (canContainBlock  ?  1  :  0);  result  =  31  *  result  +  (canContainInline  ?  1  :  0);  result  =  31  *  result  +  (optionalClosing  ?  1  :  0);  result  =  31  *  result  +  (empty  ?  1  :  0);  return  result;  }        [CLASS]  Tag    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    int    result    
result  =  31  *  result  +  (  isBlock  ?  1  :  0  )  ;	[BUGGY]  result    =    0);  [CONTEXT]  public  int  hashCode()  {  int  result  =  tagName  !=  null  ?  tagName.hashCode()  :  0;  [BUGGY]  result=0  )  ;  result  =  31  *  result  +  (canContainBlock  ?  1  :  0);  result  =  31  *  result  +  (canContainInline  ?  1  :  0);  result  =  31  *  result  +  (optionalClosing  ?  1  :  0);  result  =  31  *  result  +  (empty  ?  1  :  0);  return  result;  }        [CLASS]  Tag    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    int    result    
result  =  31  *  result  +  (  isBlock  ?  1  :  0  )  ;	[BUGGY]  result    =    1  ;  [CONTEXT]  public  int  hashCode()  {  int  result  =  tagName  !=  null  ?  tagName.hashCode()  :  0;  [BUGGY]  result=1  ;  result  =  31  *  result  +  (canContainBlock  ?  1  :  0);  result  =  31  *  result  +  (canContainInline  ?  1  :  0);  result  =  31  *  result  +  (optionalClosing  ?  1  :  0);  result  =  31  *  result  +  (empty  ?  1  :  0);  return  result;  }        [CLASS]  Tag    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    int    result    
result  =  31  *  result  +  (  isBlock  ?  1  :  0  )  ;	[BUGGY]  result  =  31  +  0  *  result  +  (  isBlock  ?  1  :  0);  [CONTEXT]  public  int  hashCode()  {  int  result  =  tagName  !=  null  ?  tagName.hashCode()  :  0;  [BUGGY]  result  =  31  +  0  *  result  +(  isBlock  ?  1  :  0  )  ;  result  =  31  *  result  +  (canContainBlock  ?  1  :  0);  result  =  31  *  result  +  (canContainInline  ?  1  :  0);  result  =  31  *  result  +  (optionalClosing  ?  1  :  0);  result  =  31  *  result  +  (empty  ?  1  :  0);  return  result;  }        [CLASS]  Tag    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    int    result    
result  =  31  *  result  +  (  isBlock  ?  1  :  0  )  ;	[BUGGY]  result  =  31  *  result  +  (  canContainBlock  ?  1  :  0);result  =  31  *  result  +  (  isBlock  ?  1  :  0);  [CONTEXT]        [CLASS]  Tag    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    int    result    
result  =  31  *  result  +  (  isBlock  ?  1  :  0  )  ;	[BUGGY]  result  =  31  *  result  +  (  canContainInline  ?  1  :  0);result  =  31  *  result  +  (  isBlock  ?  1  :  0);  [CONTEXT]        [CLASS]  Tag    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    int    result    
result  =  31  *  result  +  (  isBlock  ?  1  :  0  )  ;	[BUGGY]  result  =  31  *  result  +  (  optionalClosing  ?  1  :  0);result  =  31  *  result  +  (  isBlock  ?  1  :  0);  [CONTEXT]        [CLASS]  Tag    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    int    result    
result  =  31  *  result  +  (  isBlock  ?  1  :  0  )  ;	[BUGGY]  result  =  31  *  result  +  (  empty  ?  1  :  0);result  =  31  *  result  +  (  isBlock  ?  1  :  0);  [CONTEXT]        [CLASS]  Tag    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    int    result    
result  =  31  *  result  +  (  canContainBlock  ?  1  :  0  )  ;	[BUGGY]  result  =  31  *  result  +    <<  (  canContainBlock  ?  1  :  0);  [CONTEXT]  public  int  hashCode()  {  int  result  =  tagName  !=  null  ?  tagName.hashCode()  :  0;  result  =  31  *  result  +  (isBlock  ?  1  :  0);  [BUGGY]  result  =  31  *  result  +<<(  canContainBlock  ?  1  :  0  )  ;  result  =  31  *  result  +  (canContainInline  ?  1  :  0);  result  =  31  *  result  +  (optionalClosing  ?  1  :  0);  result  =  31  *  result  +  (empty  ?  1  :  0);  return  result;  }        [CLASS]  Tag    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    int    result    
result  =  31  *  result  +  (  canContainBlock  ?  1  :  0  )  ;	[BUGGY]  result  =  31  -  result  +  (  canContainBlock  ?  1  :  0);  [CONTEXT]  public  int  hashCode()  {  int  result  =  tagName  !=  null  ?  tagName.hashCode()  :  0;  result  =  31  *  result  +  (isBlock  ?  1  :  0);  [BUGGY]  result  =  31  -  result  +(  canContainBlock  ?  1  :  0  )  ;  result  =  31  *  result  +  (canContainInline  ?  1  :  0);  result  =  31  *  result  +  (optionalClosing  ?  1  :  0);  result  =  31  *  result  +  (empty  ?  1  :  0);  return  result;  }        [CLASS]  Tag    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    int    result    
result  =  31  *  result  +  (  canContainBlock  ?  1  :  0  )  ;	[BUGGY]  result  =  result  *  result  +  (  canContainBlock  ?  1  :  0);  [CONTEXT]  public  int  hashCode()  {  int  result  =  tagName  !=  null  ?  tagName.hashCode()  :  0;  result  =  31  *  result  +  (isBlock  ?  1  :  0);  [BUGGY]  result  =  result  *  result  +(  canContainBlock  ?  1  :  0  )  ;  result  =  31  *  result  +  (canContainInline  ?  1  :  0);  result  =  31  *  result  +  (optionalClosing  ?  1  :  0);  result  =  31  *  result  +  (empty  ?  1  :  0);  return  result;  }        [CLASS]  Tag    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    int    result    
result  =  31  *  result  +  (  canContainBlock  ?  1  :  0  )  ;	[BUGGY]  result  =  3result  *  result  +  (  canContainBlock  ?  result  :  0);  [CONTEXT]  public  int  hashCode()  {  int  result  =  tagName  !=  null  ?  tagName.hashCode()  :  0;  result  =  31  *  result  +  (isBlock  ?  1  :  0);  [BUGGY]  result  =  3result  *  result  +(  canContainBlock  ?  result  :  0  )  ;  result  =  31  *  result  +  (canContainInline  ?  1  :  0);  result  =  31  *  result  +  (optionalClosing  ?  1  :  0);  result  =  31  *  result  +  (empty  ?  1  :  0);  return  result;  }        [CLASS]  Tag    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    int    result    
result  =  31  *  result  +  (  canContainBlock  ?  1  :  0  )  ;	[BUGGY]  result  =  31  *  result  +  (  canContainBlock  ?  1  :  6);  [CONTEXT]  public  int  hashCode()  {  int  result  =  tagName  !=  null  ?  tagName.hashCode()  :  0;  result  =  31  *  result  +  (isBlock  ?  1  :  0);  [BUGGY]  result  =  31  *  result  +(  canContainBlock  ?  1  :  6  )  ;  result  =  31  *  result  +  (canContainInline  ?  1  :  0);  result  =  31  *  result  +  (optionalClosing  ?  1  :  0);  result  =  31  *  result  +  (empty  ?  1  :  0);  return  result;  }        [CLASS]  Tag    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    int    result    
result  =  31  *  result  +  (  canContainBlock  ?  1  :  0  )  ;	[BUGGY]  result  =  31  *  result  +  (  preserveWhitespace  ?  1  :  0);  [CONTEXT]  public  int  hashCode()  {  int  result  =  tagName  !=  null  ?  tagName.hashCode()  :  0;  result  =  31  *  result  +  (isBlock  ?  1  :  0);  [BUGGY]  result  =  31  *  result  +(  preserveWhitespace  ?  1  :  0  )  ;  result  =  31  *  result  +  (canContainInline  ?  1  :  0);  result  =  31  *  result  +  (optionalClosing  ?  1  :  0);  result  =  31  *  result  +  (empty  ?  1  :  0);  return  result;  }        [CLASS]  Tag    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    int    result    
result  =  31  *  result  +  (  canContainBlock  ?  1  :  0  )  ;	[BUGGY]  result  =  31  *  canContainBlock  +  (  result  ?  1  :  0);  [CONTEXT]  public  int  hashCode()  {  int  result  =  tagName  !=  null  ?  tagName.hashCode()  :  0;  result  =  31  *  result  +  (isBlock  ?  1  :  0);  [BUGGY]  result  =  31  *  canContainBlock  +(  result  ?  1  :  0  )  ;  result  =  31  *  result  +  (canContainInline  ?  1  :  0);  result  =  31  *  result  +  (optionalClosing  ?  1  :  0);  result  =  31  *  result  +  (empty  ?  1  :  0);  return  result;  }        [CLASS]  Tag    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    int    result    
result  =  31  *  result  +  (  canContainBlock  ?  1  :  0  )  ;	[BUGGY]  result    =    0);  [CONTEXT]  public  int  hashCode()  {  int  result  =  tagName  !=  null  ?  tagName.hashCode()  :  0;  result  =  31  *  result  +  (isBlock  ?  1  :  0);  [BUGGY]  result=0  )  ;  result  =  31  *  result  +  (canContainInline  ?  1  :  0);  result  =  31  *  result  +  (optionalClosing  ?  1  :  0);  result  =  31  *  result  +  (empty  ?  1  :  0);  return  result;  }        [CLASS]  Tag    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    int    result    
result  =  31  *  result  +  (  canContainBlock  ?  1  :  0  )  ;	[BUGGY]  result    =    1  ;  [CONTEXT]  public  int  hashCode()  {  int  result  =  tagName  !=  null  ?  tagName.hashCode()  :  0;  result  =  31  *  result  +  (isBlock  ?  1  :  0);  [BUGGY]  result=1  ;  result  =  31  *  result  +  (canContainInline  ?  1  :  0);  result  =  31  *  result  +  (optionalClosing  ?  1  :  0);  result  =  31  *  result  +  (empty  ?  1  :  0);  return  result;  }        [CLASS]  Tag    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    int    result    
result  =  31  *  result  +  (  canContainBlock  ?  1  :  0  )  ;	[BUGGY]  result  =  31  *  3  *  result  +  (  canContainBlock  ?  1  :  0);  [CONTEXT]  public  int  hashCode()  {  int  result  =  tagName  !=  null  ?  tagName.hashCode()  :  0;  result  =  31  *  result  +  (isBlock  ?  1  :  0);  [BUGGY]  result  =  31  *  3  *  result  +(  canContainBlock  ?  1  :  0  )  ;  result  =  31  *  result  +  (canContainInline  ?  1  :  0);  result  =  31  *  result  +  (optionalClosing  ?  1  :  0);  result  =  31  *  result  +  (empty  ?  1  :  0);  return  result;  }        [CLASS]  Tag    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    int    result    
result  =  31  *  result  +  (  canContainBlock  ?  1  :  0  )  ;	[BUGGY]  result  =  31  *  result  +  (  isBlock  ?  1  :  0);result  =  31  *  result  +  (  canContainBlock  ?  1  :  0);  [CONTEXT]        [CLASS]  Tag    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    int    result    
result  =  31  *  result  +  (  canContainBlock  ?  1  :  0  )  ;	[BUGGY]  result  =  31  *  result  +  (  canContainInline  ?  1  :  0);result  =  31  *  result  +  (  canContainBlock  ?  1  :  0);  [CONTEXT]        [CLASS]  Tag    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    int    result    
result  =  31  *  result  +  (  canContainBlock  ?  1  :  0  )  ;	[BUGGY]  result  =  31  *  result  +  (  optionalClosing  ?  1  :  0);result  =  31  *  result  +  (  canContainBlock  ?  1  :  0);  [CONTEXT]        [CLASS]  Tag    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    int    result    
result  =  31  *  result  +  (  canContainBlock  ?  1  :  0  )  ;	[BUGGY]  result  =  31  *  result  +  (  empty  ?  1  :  0);result  =  31  *  result  +  (  canContainBlock  ?  1  :  0);  [CONTEXT]        [CLASS]  Tag    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    int    result    
result  =  31  *  result  +  (  canContainInline  ?  1  :  0  )  ;	[BUGGY]  result  =  31  *  result  +      instanceof    (  canContainInline  ?  1  :  0);  [CONTEXT]  public  int  hashCode()  {  int  result  =  tagName  !=  null  ?  tagName.hashCode()  :  0;  result  =  31  *  result  +  (isBlock  ?  1  :  0);  result  =  31  *  result  +  (canContainBlock  ?  1  :  0);  [BUGGY]  result  =  31  *  result  +  instanceof  (  canContainInline  ?  1  :  0  )  ;  result  =  31  *  result  +  (optionalClosing  ?  1  :  0);  result  =  31  *  result  +  (empty  ?  1  :  0);  return  result;  }        [CLASS]  Tag    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    int    result    
result  =  31  *  result  +  (  canContainInline  ?  1  :  0  )  ;	[BUGGY]  result  =  31  /  result  +  (  canContainInline  ?  1  :  0);  [CONTEXT]  public  int  hashCode()  {  int  result  =  tagName  !=  null  ?  tagName.hashCode()  :  0;  result  =  31  *  result  +  (isBlock  ?  1  :  0);  result  =  31  *  result  +  (canContainBlock  ?  1  :  0);  [BUGGY]  result  =  31  /  result  +(  canContainInline  ?  1  :  0  )  ;  result  =  31  *  result  +  (optionalClosing  ?  1  :  0);  result  =  31  *  result  +  (empty  ?  1  :  0);  return  result;  }        [CLASS]  Tag    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    int    result    
result  =  31  *  result  +  (  canContainInline  ?  1  :  0  )  ;	[BUGGY]  result  =  result  *  result  +  (  canContainInline  ?  1  :  0);  [CONTEXT]  public  int  hashCode()  {  int  result  =  tagName  !=  null  ?  tagName.hashCode()  :  0;  result  =  31  *  result  +  (isBlock  ?  1  :  0);  result  =  31  *  result  +  (canContainBlock  ?  1  :  0);  [BUGGY]  result  =  result  *  result  +(  canContainInline  ?  1  :  0  )  ;  result  =  31  *  result  +  (optionalClosing  ?  1  :  0);  result  =  31  *  result  +  (empty  ?  1  :  0);  return  result;  }        [CLASS]  Tag    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    int    result    
result  =  31  *  result  +  (  canContainInline  ?  1  :  0  )  ;	[BUGGY]  result  =  31  *  result  +  (  canContainInline  ?  1  :  -4);  [CONTEXT]  public  int  hashCode()  {  int  result  =  tagName  !=  null  ?  tagName.hashCode()  :  0;  result  =  31  *  result  +  (isBlock  ?  1  :  0);  result  =  31  *  result  +  (canContainBlock  ?  1  :  0);  [BUGGY]  result  =  31  *  result  +(  canContainInline  ?  1  :  -4  )  ;  result  =  31  *  result  +  (optionalClosing  ?  1  :  0);  result  =  31  *  result  +  (empty  ?  1  :  0);  return  result;  }        [CLASS]  Tag    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    int    result    
result  =  31  *  result  +  (  canContainInline  ?  1  :  0  )  ;	[BUGGY]  result  =  31  *  result  +  (  optionalClosing  ?  1  :  0);  [CONTEXT]  public  int  hashCode()  {  int  result  =  tagName  !=  null  ?  tagName.hashCode()  :  0;  result  =  31  *  result  +  (isBlock  ?  1  :  0);  result  =  31  *  result  +  (canContainBlock  ?  1  :  0);  [BUGGY]  result  =  31  *  result  +(  optionalClosing  ?  1  :  0  )  ;  result  =  31  *  result  +  (optionalClosing  ?  1  :  0);  result  =  31  *  result  +  (empty  ?  1  :  0);  return  result;  }        [CLASS]  Tag    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    int    result    
result  =  31  *  result  +  (  canContainInline  ?  1  :  0  )  ;	[BUGGY]  result  =  31  *  canContainInline  +  (  result  ?  1  :  0);  [CONTEXT]  public  int  hashCode()  {  int  result  =  tagName  !=  null  ?  tagName.hashCode()  :  0;  result  =  31  *  result  +  (isBlock  ?  1  :  0);  result  =  31  *  result  +  (canContainBlock  ?  1  :  0);  [BUGGY]  result  =  31  *  canContainInline  +(  result  ?  1  :  0  )  ;  result  =  31  *  result  +  (optionalClosing  ?  1  :  0);  result  =  31  *  result  +  (empty  ?  1  :  0);  return  result;  }        [CLASS]  Tag    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    int    result    
result  =  31  *  result  +  (  canContainInline  ?  1  :  0  )  ;	[BUGGY]  result    =    0);  [CONTEXT]  public  int  hashCode()  {  int  result  =  tagName  !=  null  ?  tagName.hashCode()  :  0;  result  =  31  *  result  +  (isBlock  ?  1  :  0);  result  =  31  *  result  +  (canContainBlock  ?  1  :  0);  [BUGGY]  result=0  )  ;  result  =  31  *  result  +  (optionalClosing  ?  1  :  0);  result  =  31  *  result  +  (empty  ?  1  :  0);  return  result;  }        [CLASS]  Tag    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    int    result    
result  =  31  *  result  +  (  canContainInline  ?  1  :  0  )  ;	[BUGGY]  result    =    1  ;  [CONTEXT]  public  int  hashCode()  {  int  result  =  tagName  !=  null  ?  tagName.hashCode()  :  0;  result  =  31  *  result  +  (isBlock  ?  1  :  0);  result  =  31  *  result  +  (canContainBlock  ?  1  :  0);  [BUGGY]  result=1  ;  result  =  31  *  result  +  (optionalClosing  ?  1  :  0);  result  =  31  *  result  +  (empty  ?  1  :  0);  return  result;  }        [CLASS]  Tag    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    int    result    
result  =  31  *  result  +  (  canContainInline  ?  1  :  0  )  ;	[BUGGY]  result  =  4  *  result  +  (  canContainInline  ?  1  :  0);  [CONTEXT]  public  int  hashCode()  {  int  result  =  tagName  !=  null  ?  tagName.hashCode()  :  0;  result  =  31  *  result  +  (isBlock  ?  1  :  0);  result  =  31  *  result  +  (canContainBlock  ?  1  :  0);  [BUGGY]  result  =  4  *  result  +(  canContainInline  ?  1  :  0  )  ;  result  =  31  *  result  +  (optionalClosing  ?  1  :  0);  result  =  31  *  result  +  (empty  ?  1  :  0);  return  result;  }        [CLASS]  Tag    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    int    result    
result  =  31  *  result  +  (  canContainInline  ?  1  :  0  )  ;	[BUGGY]  result  =  31  *  result  +  (  optionalClosing  ?  1  :  0);  result  =  31  *  result  +  (  canContainInline  ?  1  :  0);  [CONTEXT]        [CLASS]  Tag    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    int    result    
result  =  31  *  result  +  (  canContainInline  ?  1  :  0  )  ;	[BUGGY]  result  =  31  *  result  +  (  isBlock  ?  1  :  0);result  =  31  *  result  +  (  canContainInline  ?  1  :  0);  [CONTEXT]        [CLASS]  Tag    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    int    result    
result  =  31  *  result  +  (  canContainInline  ?  1  :  0  )  ;	[BUGGY]  result  =  31  *  result  +  (  canContainBlock  ?  1  :  0);result  =  31  *  result  +  (  canContainInline  ?  1  :  0);  [CONTEXT]        [CLASS]  Tag    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    int    result    
result  =  31  *  result  +  (  canContainInline  ?  1  :  0  )  ;	[BUGGY]  result  =  31  *  result  +  (  empty  ?  1  :  0);result  =  31  *  result  +  (  canContainInline  ?  1  :  0);  [CONTEXT]        [CLASS]  Tag    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    int    result    
result  =  31  *  result  +  (  optionalClosing  ?  1  :  0  )  ;	[BUGGY]  result  =  31  *  result  +    &&  (  optionalClosing  ?  1  :  0);  [CONTEXT]  public  int  hashCode()  {  int  result  =  tagName  !=  null  ?  tagName.hashCode()  :  0;  result  =  31  *  result  +  (isBlock  ?  1  :  0);  result  =  31  *  result  +  (canContainBlock  ?  1  :  0);  result  =  31  *  result  +  (canContainInline  ?  1  :  0);  [BUGGY]  result  =  31  *  result  +&&(  optionalClosing  ?  1  :  0  )  ;  result  =  31  *  result  +  (empty  ?  1  :  0);  return  result;  }        [CLASS]  Tag    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    int    result    
result  =  31  *  result  +  (  optionalClosing  ?  1  :  0  )  ;	[BUGGY]  result  =  31  /  result  +  (  optionalClosing  ?  1  :  0);  [CONTEXT]  public  int  hashCode()  {  int  result  =  tagName  !=  null  ?  tagName.hashCode()  :  0;  result  =  31  *  result  +  (isBlock  ?  1  :  0);  result  =  31  *  result  +  (canContainBlock  ?  1  :  0);  result  =  31  *  result  +  (canContainInline  ?  1  :  0);  [BUGGY]  result  =  31  /  result  +(  optionalClosing  ?  1  :  0  )  ;  result  =  31  *  result  +  (empty  ?  1  :  0);  return  result;  }        [CLASS]  Tag    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    int    result    
result  =  31  *  result  +  (  optionalClosing  ?  1  :  0  )  ;	[BUGGY]  result  =    *  result  +  (  optionalClosing  ?  1  :  0);  [CONTEXT]  public  int  hashCode()  {  int  result  =  tagName  !=  null  ?  tagName.hashCode()  :  0;  result  =  31  *  result  +  (isBlock  ?  1  :  0);  result  =  31  *  result  +  (canContainBlock  ?  1  :  0);  result  =  31  *  result  +  (canContainInline  ?  1  :  0);  [BUGGY]  result  =*  result  +(  optionalClosing  ?  1  :  0  )  ;  result  =  31  *  result  +  (empty  ?  1  :  0);  return  result;  }        [CLASS]  Tag    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    int    result    
result  =  31  *  result  +  (  optionalClosing  ?  1  :  0  )  ;	[BUGGY]  result  =  3result  *  result  +  (  optionalClosing  ?  result  :  0);  [CONTEXT]  public  int  hashCode()  {  int  result  =  tagName  !=  null  ?  tagName.hashCode()  :  0;  result  =  31  *  result  +  (isBlock  ?  1  :  0);  result  =  31  *  result  +  (canContainBlock  ?  1  :  0);  result  =  31  *  result  +  (canContainInline  ?  1  :  0);  [BUGGY]  result  =  3result  *  result  +(  optionalClosing  ?  result  :  0  )  ;  result  =  31  *  result  +  (empty  ?  1  :  0);  return  result;  }        [CLASS]  Tag    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    int    result    
result  =  31  *  result  +  (  optionalClosing  ?  1  :  0  )  ;	[BUGGY]  result  =  31  *  result  +  (  optionalClosing  ?  1  :  -1);  [CONTEXT]  public  int  hashCode()  {  int  result  =  tagName  !=  null  ?  tagName.hashCode()  :  0;  result  =  31  *  result  +  (isBlock  ?  1  :  0);  result  =  31  *  result  +  (canContainBlock  ?  1  :  0);  result  =  31  *  result  +  (canContainInline  ?  1  :  0);  [BUGGY]  result  =  31  *  result  +(  optionalClosing  ?  1  :  -1  )  ;  result  =  31  *  result  +  (empty  ?  1  :  0);  return  result;  }        [CLASS]  Tag    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    int    result    
result  =  31  *  result  +  (  optionalClosing  ?  1  :  0  )  ;	[BUGGY]  result  =  31  *  result  +  (  preserveWhitespace  ?  1  :  0);  [CONTEXT]  public  int  hashCode()  {  int  result  =  tagName  !=  null  ?  tagName.hashCode()  :  0;  result  =  31  *  result  +  (isBlock  ?  1  :  0);  result  =  31  *  result  +  (canContainBlock  ?  1  :  0);  result  =  31  *  result  +  (canContainInline  ?  1  :  0);  [BUGGY]  result  =  31  *  result  +(  preserveWhitespace  ?  1  :  0  )  ;  result  =  31  *  result  +  (empty  ?  1  :  0);  return  result;  }        [CLASS]  Tag    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    int    result    
result  =  31  *  result  +  (  optionalClosing  ?  1  :  0  )  ;	[BUGGY]  result  =  31  *  optionalClosing  +  (  result  ?  1  :  0);  [CONTEXT]  public  int  hashCode()  {  int  result  =  tagName  !=  null  ?  tagName.hashCode()  :  0;  result  =  31  *  result  +  (isBlock  ?  1  :  0);  result  =  31  *  result  +  (canContainBlock  ?  1  :  0);  result  =  31  *  result  +  (canContainInline  ?  1  :  0);  [BUGGY]  result  =  31  *  optionalClosing  +(  result  ?  1  :  0  )  ;  result  =  31  *  result  +  (empty  ?  1  :  0);  return  result;  }        [CLASS]  Tag    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    int    result    
result  =  31  *  result  +  (  optionalClosing  ?  1  :  0  )  ;	[BUGGY]  result    =    0);  [CONTEXT]  public  int  hashCode()  {  int  result  =  tagName  !=  null  ?  tagName.hashCode()  :  0;  result  =  31  *  result  +  (isBlock  ?  1  :  0);  result  =  31  *  result  +  (canContainBlock  ?  1  :  0);  result  =  31  *  result  +  (canContainInline  ?  1  :  0);  [BUGGY]  result=0  )  ;  result  =  31  *  result  +  (empty  ?  1  :  0);  return  result;  }        [CLASS]  Tag    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    int    result    
result  =  31  *  result  +  (  optionalClosing  ?  1  :  0  )  ;	[BUGGY]  result    =    1  ;  [CONTEXT]  public  int  hashCode()  {  int  result  =  tagName  !=  null  ?  tagName.hashCode()  :  0;  result  =  31  *  result  +  (isBlock  ?  1  :  0);  result  =  31  *  result  +  (canContainBlock  ?  1  :  0);  result  =  31  *  result  +  (canContainInline  ?  1  :  0);  [BUGGY]  result=1  ;  result  =  31  *  result  +  (empty  ?  1  :  0);  return  result;  }        [CLASS]  Tag    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    int    result    
result  =  31  *  result  +  (  optionalClosing  ?  1  :  0  )  ;	[BUGGY]  result  =  17  *  result  +  (  optionalClosing  ?  1  :  0);  [CONTEXT]  public  int  hashCode()  {  int  result  =  tagName  !=  null  ?  tagName.hashCode()  :  0;  result  =  31  *  result  +  (isBlock  ?  1  :  0);  result  =  31  *  result  +  (canContainBlock  ?  1  :  0);  result  =  31  *  result  +  (canContainInline  ?  1  :  0);  [BUGGY]  result  =  17  *  result  +(  optionalClosing  ?  1  :  0  )  ;  result  =  31  *  result  +  (empty  ?  1  :  0);  return  result;  }        [CLASS]  Tag    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    int    result    
result  =  31  *  result  +  (  optionalClosing  ?  1  :  0  )  ;	[BUGGY]  result  =  31  *  result  +  (  isBlock  ?  1  :  0);result  =  31  *  result  +  (  optionalClosing  ?  1  :  0);  [CONTEXT]        [CLASS]  Tag    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    int    result    
result  =  31  *  result  +  (  optionalClosing  ?  1  :  0  )  ;	[BUGGY]  result  =  31  *  result  +  (  canContainBlock  ?  1  :  0);result  =  31  *  result  +  (  optionalClosing  ?  1  :  0);  [CONTEXT]        [CLASS]  Tag    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    int    result    
result  =  31  *  result  +  (  optionalClosing  ?  1  :  0  )  ;	[BUGGY]  result  =  31  *  result  +  (  canContainInline  ?  1  :  0);result  =  31  *  result  +  (  optionalClosing  ?  1  :  0);  [CONTEXT]        [CLASS]  Tag    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    int    result    
result  =  31  *  result  +  (  optionalClosing  ?  1  :  0  )  ;	[BUGGY]  result  =  31  *  result  +  (  empty  ?  1  :  0);result  =  31  *  result  +  (  optionalClosing  ?  1  :  0);  [CONTEXT]        [CLASS]  Tag    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    int    result    
result  =  31  *  result  +  (  empty  ?  1  :  0  )  ;	[BUGGY]  result  =  31  *  result  +    >=  (  empty  ?  1  :  0);  [CONTEXT]  public  int  hashCode()  {  int  result  =  tagName  !=  null  ?  tagName.hashCode()  :  0;  result  =  31  *  result  +  (isBlock  ?  1  :  0);  result  =  31  *  result  +  (canContainBlock  ?  1  :  0);  result  =  31  *  result  +  (canContainInline  ?  1  :  0);  result  =  31  *  result  +  (optionalClosing  ?  1  :  0);  [BUGGY]  result  =  31  *  result  +>=(  empty  ?  1  :  0  )  ;  return  result;  }        [CLASS]  Tag    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    int    result    
result  =  31  *  result  +  (  empty  ?  1  :  0  )  ;	[BUGGY]  result  =  31  /  result  +  (  empty  ?  1  :  0);  [CONTEXT]  public  int  hashCode()  {  int  result  =  tagName  !=  null  ?  tagName.hashCode()  :  0;  result  =  31  *  result  +  (isBlock  ?  1  :  0);  result  =  31  *  result  +  (canContainBlock  ?  1  :  0);  result  =  31  *  result  +  (canContainInline  ?  1  :  0);  result  =  31  *  result  +  (optionalClosing  ?  1  :  0);  [BUGGY]  result  =  31  /  result  +(  empty  ?  1  :  0  )  ;  return  result;  }        [CLASS]  Tag    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    int    result    
result  =  31  *  result  +  (  empty  ?  1  :  0  )  ;	[BUGGY]  result  =  result  *  result  +  (  empty  ?  1  :  0);  [CONTEXT]  public  int  hashCode()  {  int  result  =  tagName  !=  null  ?  tagName.hashCode()  :  0;  result  =  31  *  result  +  (isBlock  ?  1  :  0);  result  =  31  *  result  +  (canContainBlock  ?  1  :  0);  result  =  31  *  result  +  (canContainInline  ?  1  :  0);  result  =  31  *  result  +  (optionalClosing  ?  1  :  0);  [BUGGY]  result  =  result  *  result  +(  empty  ?  1  :  0  )  ;  return  result;  }        [CLASS]  Tag    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    int    result    
result  =  31  *  result  +  (  empty  ?  1  :  0  )  ;	[BUGGY]  result  =  39  *  result  +  (  empty  ?  9  :  0);  [CONTEXT]  public  int  hashCode()  {  int  result  =  tagName  !=  null  ?  tagName.hashCode()  :  0;  result  =  31  *  result  +  (isBlock  ?  1  :  0);  result  =  31  *  result  +  (canContainBlock  ?  1  :  0);  result  =  31  *  result  +  (canContainInline  ?  1  :  0);  result  =  31  *  result  +  (optionalClosing  ?  1  :  0);  [BUGGY]  result  =  39  *  result  +(  empty  ?  9  :  0  )  ;  return  result;  }        [CLASS]  Tag    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    int    result    
result  =  31  *  result  +  (  empty  ?  1  :  0  )  ;	[BUGGY]  result  =  31  *  result  +  (  empty  ?  1  :  1);  [CONTEXT]  public  int  hashCode()  {  int  result  =  tagName  !=  null  ?  tagName.hashCode()  :  0;  result  =  31  *  result  +  (isBlock  ?  1  :  0);  result  =  31  *  result  +  (canContainBlock  ?  1  :  0);  result  =  31  *  result  +  (canContainInline  ?  1  :  0);  result  =  31  *  result  +  (optionalClosing  ?  1  :  0);  [BUGGY]  result  =  31  *  result  +(  empty  ?  1  :  1  )  ;  return  result;  }        [CLASS]  Tag    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    int    result    
result  =  31  *  result  +  (  empty  ?  1  :  0  )  ;	[BUGGY]  result  =  31  *  result  +  (  optionalClosing  ?  1  :  0);  [CONTEXT]  public  int  hashCode()  {  int  result  =  tagName  !=  null  ?  tagName.hashCode()  :  0;  result  =  31  *  result  +  (isBlock  ?  1  :  0);  result  =  31  *  result  +  (canContainBlock  ?  1  :  0);  result  =  31  *  result  +  (canContainInline  ?  1  :  0);  result  =  31  *  result  +  (optionalClosing  ?  1  :  0);  [BUGGY]  result  =  31  *  result  +(  optionalClosing  ?  1  :  0  )  ;  return  result;  }        [CLASS]  Tag    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    int    result    
result  =  31  *  result  +  (  empty  ?  1  :  0  )  ;	[BUGGY]  result  =  31  *  empty  +  (  result  ?  1  :  0);  [CONTEXT]  public  int  hashCode()  {  int  result  =  tagName  !=  null  ?  tagName.hashCode()  :  0;  result  =  31  *  result  +  (isBlock  ?  1  :  0);  result  =  31  *  result  +  (canContainBlock  ?  1  :  0);  result  =  31  *  result  +  (canContainInline  ?  1  :  0);  result  =  31  *  result  +  (optionalClosing  ?  1  :  0);  [BUGGY]  result  =  31  *  empty  +(  result  ?  1  :  0  )  ;  return  result;  }        [CLASS]  Tag    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    int    result    
result  =  31  *  result  +  (  empty  ?  1  :  0  )  ;	[BUGGY]  result    =    0);  [CONTEXT]  public  int  hashCode()  {  int  result  =  tagName  !=  null  ?  tagName.hashCode()  :  0;  result  =  31  *  result  +  (isBlock  ?  1  :  0);  result  =  31  *  result  +  (canContainBlock  ?  1  :  0);  result  =  31  *  result  +  (canContainInline  ?  1  :  0);  result  =  31  *  result  +  (optionalClosing  ?  1  :  0);  [BUGGY]  result=0  )  ;  return  result;  }        [CLASS]  Tag    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    int    result    
result  =  31  *  result  +  (  empty  ?  1  :  0  )  ;	[BUGGY]  result    =    1  ;  [CONTEXT]  public  int  hashCode()  {  int  result  =  tagName  !=  null  ?  tagName.hashCode()  :  0;  result  =  31  *  result  +  (isBlock  ?  1  :  0);  result  =  31  *  result  +  (canContainBlock  ?  1  :  0);  result  =  31  *  result  +  (canContainInline  ?  1  :  0);  result  =  31  *  result  +  (optionalClosing  ?  1  :  0);  [BUGGY]  result=1  ;  return  result;  }        [CLASS]  Tag    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    int    result    
result  =  31  *  result  +  (  empty  ?  1  :  0  )  ;	[BUGGY]  result  =  0  *  result  +  (  empty  ?  1  :  0);  [CONTEXT]  public  int  hashCode()  {  int  result  =  tagName  !=  null  ?  tagName.hashCode()  :  0;  result  =  31  *  result  +  (isBlock  ?  1  :  0);  result  =  31  *  result  +  (canContainBlock  ?  1  :  0);  result  =  31  *  result  +  (canContainInline  ?  1  :  0);  result  =  31  *  result  +  (optionalClosing  ?  1  :  0);  [BUGGY]  result  =  0  *  result  +(  empty  ?  1  :  0  )  ;  return  result;  }        [CLASS]  Tag    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    int    result    
result  =  31  *  result  +  (  empty  ?  1  :  0  )  ;	[BUGGY]    result  =  31  *  result  +  (  empty  ?  1  :  0);  [CONTEXT]        [CLASS]  Tag    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    int    result    
result  =  31  *  result  +  (  empty  ?  1  :  0  )  ;	[BUGGY]  result  =  31  *  result  +  (  isBlock  ?  1  :  0);result  =  31  *  result  +  (  empty  ?  1  :  0);  [CONTEXT]        [CLASS]  Tag    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    int    result    
result  =  31  *  result  +  (  empty  ?  1  :  0  )  ;	[BUGGY]  result  =  31  *  result  +  (  canContainBlock  ?  1  :  0);result  =  31  *  result  +  (  empty  ?  1  :  0);  [CONTEXT]        [CLASS]  Tag    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    int    result    
result  =  31  *  result  +  (  empty  ?  1  :  0  )  ;	[BUGGY]  result  =  31  *  result  +  (  canContainInline  ?  1  :  0);result  =  31  *  result  +  (  empty  ?  1  :  0);  [CONTEXT]        [CLASS]  Tag    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    int    result    
result  =  31  *  result  +  (  empty  ?  1  :  0  )  ;	[BUGGY]  result  =  31  *  result  +  (  optionalClosing  ?  1  :  0);result  =  31  *  result  +  (  empty  ?  1  :  0);  [CONTEXT]        [CLASS]  Tag    [METHOD]  hashCode  [RETURN_TYPE]  int      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    int    result    
return  register  (  new  Tag  (  tagName  )  )  ;	[BUGGY]  return  canContain(  new  Tag(  tagName));  [CONTEXT]  private  static  Tag  createBlock(String  tagName)  {  [BUGGY]  return  canContain  (  new  Tag  (  tagName  ))  ;  }        [CLASS]  Tag    [METHOD]  createBlock  [RETURN_TYPE]  Tag      String  tagName  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
return  register  (  new  Tag  (  tagName  )  )  ;	[BUGGY]    [CONTEXT]  private  static  Tag  createBlock(String  tagName)  {  [BUGGY]  return  register(new  Tag(tagName));          [CLASS]  Tag    [METHOD]  createBlock  [RETURN_TYPE]  Tag      String  tagName  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    tag    String    tagName    Map    tags    
Tag  inline  =  new  Tag  (  tagName  )  ;	[BUGGY]  Tag  tag  =  tags.get(  tagName);Tag  inline  =  new  Tag(  tagName);  [CONTEXT]        [CLASS]  Tag    [METHOD]  createInline  [RETURN_TYPE]  Tag      String  tagName  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    inline    tag    String    tagName    Map    tags    
inline.isBlock  =  false;	[BUGGY]  inline.isBlock  =  true;  [CONTEXT]  private  static  Tag  createInline(String  tagName)  {  Tag  inline  =  new  Tag(tagName);  [BUGGY]  inline.isBlock  =  true;  inline.canContainBlock  =  false;  return  register(inline);  }        [CLASS]  Tag    [METHOD]  createInline  [RETURN_TYPE]  Tag      String  tagName  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    inline    tag    String    tagName    Map    tags    
inline.isBlock  =  false;  inline.canContainBlock  =  false;	[BUGGY]  inline.canContainBlock  =  false;  inline.isBlock  =  false;  [CONTEXT]        [CLASS]  Tag    [METHOD]  createInline  [RETURN_TYPE]  Tag      String  tagName  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    inline    tag    String    tagName    Map    tags    
inline.isBlock  =  false;  inline.canContainBlock  =  false;	[BUGGY]  inline.canContainBlock  =  false;inline.isBlock  =  false;  inline.canContainBlock  =  false;  [CONTEXT]        [CLASS]  Tag    [METHOD]  createInline  [RETURN_TYPE]  Tag      String  tagName  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    inline    tag    String    tagName    Map    tags    
inline.canContainBlock  =  false;	[BUGGY]  inline.canContainBlock  =  true;  [CONTEXT]  private  static  Tag  createInline(String  tagName)  {  Tag  inline  =  new  Tag(tagName);  inline.isBlock  =  false;  [BUGGY]  inline.canContainBlock  =  true;  return  register(inline);  }        [CLASS]  Tag    [METHOD]  createInline  [RETURN_TYPE]  Tag      String  tagName  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    inline    tag    String    tagName    Map    tags    
inline.canContainBlock  =  false;	[BUGGY]  return  register(  inline);  inline.canContainBlock  =  false;  [CONTEXT]        [CLASS]  Tag    [METHOD]  createInline  [RETURN_TYPE]  Tag      String  tagName  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    inline    tag    String    tagName    Map    tags    
inline.canContainBlock  =  false;	[BUGGY]  canContainInline  =  false;inline.canContainBlock  =  false;  [CONTEXT]        [CLASS]  Tag    [METHOD]  createInline  [RETURN_TYPE]  Tag      String  tagName  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    inline    tag    String    tagName    Map    tags    
inline.canContainBlock  =  false;	[BUGGY]  inline.isBlock  =  false;inline.canContainBlock  =  false;  [CONTEXT]        [CLASS]  Tag    [METHOD]  createInline  [RETURN_TYPE]  Tag      String  tagName  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    inline    tag    String    tagName    Map    tags    
inline.canContainBlock  =  false;	[BUGGY]  tag.canContainBlock  =  true;inline.canContainBlock  =  false;  [CONTEXT]        [CLASS]  Tag    [METHOD]  createInline  [RETURN_TYPE]  Tag      String  tagName  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    inline    tag    String    tagName    Map    tags    
inline.canContainBlock  =  false;	[BUGGY]  tag.isBlock  =  false;inline.canContainBlock  =  false;  [CONTEXT]        [CLASS]  Tag    [METHOD]  createInline  [RETURN_TYPE]  Tag      String  tagName  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    inline    tag    String    tagName    Map    tags    
inline.canContainBlock  =  false;	[BUGGY]  canContainBlock  =  false;inline.canContainBlock  =  false;  [CONTEXT]        [CLASS]  Tag    [METHOD]  createInline  [RETURN_TYPE]  Tag      String  tagName  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    inline    tag    String    tagName    Map    tags    
return  register  (  inline  )  ;	[BUGGY]  return  register(  tag);  [CONTEXT]  private  static  Tag  createInline(String  tagName)  {  Tag  inline  =  new  Tag(tagName);  inline.isBlock  =  false;  inline.canContainBlock  =  false;  [BUGGY]  return  register  (  tag  )  ;  }        [CLASS]  Tag    [METHOD]  createInline  [RETURN_TYPE]  Tag      String  tagName  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    inline    tag    String    tagName    Map    tags    
return  register  (  inline  )  ;	[BUGGY]  return  canContain(  inline);  [CONTEXT]  private  static  Tag  createInline(String  tagName)  {  Tag  inline  =  new  Tag(tagName);  inline.isBlock  =  false;  inline.canContainBlock  =  false;  [BUGGY]  return  canContain  (  inline  )  ;  }        [CLASS]  Tag    [METHOD]  createInline  [RETURN_TYPE]  Tag      String  tagName  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    inline    tag    String    tagName    Map    tags    
return  register  (  inline  )  ;	[BUGGY]    [CONTEXT]  private  static  Tag  createInline(String  tagName)  {  Tag  inline  =  new  Tag(tagName);  inline.isBlock  =  false;  inline.canContainBlock  =  false;  [BUGGY]  return  register(inline);          [CLASS]  Tag    [METHOD]  createInline  [RETURN_TYPE]  Tag      String  tagName  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    inline    tag    String    tagName    Map    tags    
tag.setAncestor  (  defaultAncestor.tagName  )  ;	[BUGGY]  tag.setAncestor(  tag.tagName);  [CONTEXT]  private  static  Tag  register(Tag  tag)  {  [BUGGY]  tag.setAncestor  (  tag.tagName  )  ;  synchronized  (tags)  {  tags.put(tag.tagName,  tag);  }  return  tag;  }        [CLASS]  Tag    [METHOD]  register  [RETURN_TYPE]  Tag      Tag  tag  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    inline    tag    String    tagName    Map    tags    
tag.setAncestor  (  defaultAncestor.tagName  )  ;	[BUGGY]  tag.valueOf(  defaultAncestor.tagName);  [CONTEXT]  private  static  Tag  register(Tag  tag)  {  [BUGGY]  tag.valueOf  (  defaultAncestor.tagName  )  ;  synchronized  (tags)  {  tags.put(tag.tagName,  tag);  }  return  tag;  }        [CLASS]  Tag    [METHOD]  register  [RETURN_TYPE]  Tag      Tag  tag  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    inline    tag    String    tagName    Map    tags    
tag.setAncestor  (  defaultAncestor.tagName  )  ;	[BUGGY]  tag  .setAncestor(  tagName  ,  tagName)  ;  [CONTEXT]  private  static  Tag  register(Tag  tag)  {  [BUGGY]  tag  .setAncestor  (  tagName  ,  tagName  );  synchronized  (tags)  {  tags.put(tag.tagName,  tag);  }  return  tag;  }        [CLASS]  Tag    [METHOD]  register  [RETURN_TYPE]  Tag      Tag  tag  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    inline    tag    String    tagName    Map    tags    
tag.setAncestor  (  defaultAncestor.tagName  )  ;	[BUGGY]  tag.setAncestor(  inline.tagName);  [CONTEXT]  private  static  Tag  register(Tag  tag)  {  [BUGGY]  tag.setAncestor  (  inline.tagName  )  ;  synchronized  (tags)  {  tags.put(tag.tagName,  tag);  }  return  tag;  }        [CLASS]  Tag    [METHOD]  register  [RETURN_TYPE]  Tag      Tag  tag  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    inline    tag    String    tagName    Map    tags    
tag.setAncestor  (  defaultAncestor.tagName  )  ;	[BUGGY]    [CONTEXT]  private  static  Tag  register(Tag  tag)  {  [BUGGY]  tag.setAncestor(defaultAncestor.tagName);    synchronized  (tags)  {  tags.put(tag.tagName,  tag);  }  return  tag;        [CLASS]  Tag    [METHOD]  register  [RETURN_TYPE]  Tag      Tag  tag  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    inline    tag    String    tagName    Map    tags    
tags.put  (  tag.tagName,  tag  )  ;	[BUGGY]  tags.put(  tagName,  tag);  [CONTEXT]  private  static  Tag  register(Tag  tag)  {  tag.setAncestor(defaultAncestor.tagName);  synchronized  (tags)  {  [BUGGY]  tags.put  (  tagName,  tag  )  ;  }  return  tag;  }        [CLASS]  Tag    [METHOD]  register  [RETURN_TYPE]  Tag      Tag  tag  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    inline    tag    String    tagName    Map    tags    
tags.put  (  tag.tagName,  tag  )  ;	[BUGGY]  tags.put(  tag.tagName);  [CONTEXT]  private  static  Tag  register(Tag  tag)  {  tag.setAncestor(defaultAncestor.tagName);  synchronized  (tags)  {  [BUGGY]  tags.put  (  tag.tagName  )  ;  }  return  tag;  }        [CLASS]  Tag    [METHOD]  register  [RETURN_TYPE]  Tag      Tag  tag  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    inline    tag    String    tagName    Map    tags    
tags.put  (  tag.tagName,  tag  )  ;	[BUGGY]  tags.put(    tag);  [CONTEXT]  private  static  Tag  register(Tag  tag)  {  tag.setAncestor(defaultAncestor.tagName);  synchronized  (tags)  {  [BUGGY]  tags.put  (tag  )  ;  }  return  tag;  }        [CLASS]  Tag    [METHOD]  register  [RETURN_TYPE]  Tag      Tag  tag  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    inline    tag    String    tagName    Map    tags    
tags.put  (  tag.tagName,  tag  )  ;	[BUGGY]  tags.put(  inline.tagName,  tag);  [CONTEXT]  private  static  Tag  register(Tag  tag)  {  tag.setAncestor(defaultAncestor.tagName);  synchronized  (tags)  {  [BUGGY]  tags.put  (  inline.tagName,  tag  )  ;  }  return  tag;  }        [CLASS]  Tag    [METHOD]  register  [RETURN_TYPE]  Tag      Tag  tag  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    inline    tag    String    tagName    Map    tags    
tags.put  (  tag.tagName,  tag  )  ;	[BUGGY]    [CONTEXT]  private  static  Tag  register(Tag  tag)  {  tag.setAncestor(defaultAncestor.tagName);  synchronized  (tags)  {  [BUGGY]  tags.put(tag.tagName,  tag);    }  return  tag;        [CLASS]  Tag    [METHOD]  register  [RETURN_TYPE]  Tag      Tag  tag  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    inline    tag    String    tagName    Map    tags    
return  tag;	[BUGGY]  return  inline;  [CONTEXT]  private  static  Tag  register(Tag  tag)  {  tag.setAncestor(defaultAncestor.tagName);  synchronized  (tags)  {  tags.put(tag.tagName,  tag);  }  [BUGGY]  return  inline;  }        [CLASS]  Tag    [METHOD]  register  [RETURN_TYPE]  Tag      Tag  tag  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    inline    tag    String    tagName    Map    tags    
canContainBlock  =  false;	[BUGGY]  canContainBlock  =  true;  [CONTEXT]  private  Tag  setContainInlineOnly()  {  [BUGGY]  canContainBlock  =  true;  canContainInline  =  true;  return  this;  }        [CLASS]  Tag    [METHOD]  setContainInlineOnly  [RETURN_TYPE]  Tag      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    inline    tag    String    tagName    Map    tags    
canContainInline  =  true;	[BUGGY]  canContainInline  =  false;  [CONTEXT]  private  Tag  setContainInlineOnly()  {  canContainBlock  =  false;  [BUGGY]  canContainInline  =  false;  return  this;  }        [CLASS]  Tag    [METHOD]  setContainInlineOnly  [RETURN_TYPE]  Tag      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    inline    tag    String    tagName    Map    tags    
canContainInline  =  true;  return  this;	[BUGGY]  return  this;  canContainInline  =  true;  [CONTEXT]        [CLASS]  Tag    [METHOD]  setContainInlineOnly  [RETURN_TYPE]  Tag      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    inline    tag    String    tagName    Map    tags    
canContainInline  =  true;  return  this;	[BUGGY]  canContainInline  =  true;canContainInline  =  true;  return  this;  [CONTEXT]        [CLASS]  Tag    [METHOD]  setContainInlineOnly  [RETURN_TYPE]  Tag      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    inline    tag    String    tagName    Map    tags    
canContainInline  =  true;  return  this;	[BUGGY]  canContainInline  =  false;canContainInline  =  true;  return  this;  [CONTEXT]        [CLASS]  Tag    [METHOD]  setContainInlineOnly  [RETURN_TYPE]  Tag      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    inline    tag    String    tagName    Map    tags    
return  this;	[BUGGY]  return  null;  [CONTEXT]  private  Tag  setContainInlineOnly()  {  canContainBlock  =  false;  canContainInline  =  true;  [BUGGY]  return  null;  }        [CLASS]  Tag    [METHOD]  setContainInlineOnly  [RETURN_TYPE]  Tag      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    inline    tag    String    tagName    Map    tags    
canContainBlock  =  false;	[BUGGY]  canContainBlock  =  true;  [CONTEXT]  private  Tag  setContainDataOnly()  {  [BUGGY]  canContainBlock  =  true;  canContainInline  =  false;  preserveWhitespace  =  true;  return  this;  }        [CLASS]  Tag    [METHOD]  setContainDataOnly  [RETURN_TYPE]  Tag      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    inline    tag    String    tagName    Map    tags    
canContainBlock  =  false;	[BUGGY]  canContainInline  =  true;canContainBlock  =  false;  [CONTEXT]        [CLASS]  Tag    [METHOD]  setContainDataOnly  [RETURN_TYPE]  Tag      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    inline    tag    String    tagName    Map    tags    
canContainBlock  =  false;	[BUGGY]  canContainInline  =  false;canContainBlock  =  false;  [CONTEXT]        [CLASS]  Tag    [METHOD]  setContainDataOnly  [RETURN_TYPE]  Tag      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    inline    tag    String    tagName    Map    tags    
canContainBlock  =  false;	[BUGGY]  inline.isBlock  =  false;canContainBlock  =  false;  [CONTEXT]        [CLASS]  Tag    [METHOD]  setContainDataOnly  [RETURN_TYPE]  Tag      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    inline    tag    String    tagName    Map    tags    
canContainBlock  =  false;	[BUGGY]  tag.canContainBlock  =  true;canContainBlock  =  false;  [CONTEXT]        [CLASS]  Tag    [METHOD]  setContainDataOnly  [RETURN_TYPE]  Tag      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    inline    tag    String    tagName    Map    tags    
canContainBlock  =  false;	[BUGGY]  tag.isBlock  =  false;canContainBlock  =  false;  [CONTEXT]        [CLASS]  Tag    [METHOD]  setContainDataOnly  [RETURN_TYPE]  Tag      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    inline    tag    String    tagName    Map    tags    
canContainBlock  =  false;	[BUGGY]  inline.canContainBlock  =  false;canContainBlock  =  false;  [CONTEXT]        [CLASS]  Tag    [METHOD]  setContainDataOnly  [RETURN_TYPE]  Tag      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    inline    tag    String    tagName    Map    tags    
canContainInline  =  false;	[BUGGY]  canContainInline  =  true;  [CONTEXT]  private  Tag  setContainDataOnly()  {  canContainBlock  =  false;  [BUGGY]  canContainInline  =  true;  preserveWhitespace  =  true;  return  this;  }        [CLASS]  Tag    [METHOD]  setContainDataOnly  [RETURN_TYPE]  Tag      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    inline    tag    String    tagName    Map    tags    
canContainInline  =  false;	[BUGGY]  canContainInline  =  true;canContainInline  =  false;  [CONTEXT]        [CLASS]  Tag    [METHOD]  setContainDataOnly  [RETURN_TYPE]  Tag      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    inline    tag    String    tagName    Map    tags    
canContainInline  =  false;	[BUGGY]  inline.isBlock  =  false;canContainInline  =  false;  [CONTEXT]        [CLASS]  Tag    [METHOD]  setContainDataOnly  [RETURN_TYPE]  Tag      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    inline    tag    String    tagName    Map    tags    
canContainInline  =  false;	[BUGGY]  tag.canContainBlock  =  true;canContainInline  =  false;  [CONTEXT]        [CLASS]  Tag    [METHOD]  setContainDataOnly  [RETURN_TYPE]  Tag      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    inline    tag    String    tagName    Map    tags    
canContainInline  =  false;	[BUGGY]  inline.canContainBlock  =  false;canContainInline  =  false;  [CONTEXT]        [CLASS]  Tag    [METHOD]  setContainDataOnly  [RETURN_TYPE]  Tag      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    inline    tag    String    tagName    Map    tags    
canContainInline  =  false;	[BUGGY]  canContainBlock  =  false;canContainInline  =  false;  [CONTEXT]        [CLASS]  Tag    [METHOD]  setContainDataOnly  [RETURN_TYPE]  Tag      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    inline    tag    String    tagName    Map    tags    
preserveWhitespace  =  true;	[BUGGY]  preserveWhitespace  =  false;  [CONTEXT]  private  Tag  setContainDataOnly()  {  canContainBlock  =  false;  canContainInline  =  false;  [BUGGY]  preserveWhitespace  =  false;  return  this;  }        [CLASS]  Tag    [METHOD]  setContainDataOnly  [RETURN_TYPE]  Tag      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    inline    tag    String    tagName    Map    tags    
return  this;	[BUGGY]  return  null;  [CONTEXT]  private  Tag  setContainDataOnly()  {  canContainBlock  =  false;  canContainInline  =  false;  preserveWhitespace  =  true;  [BUGGY]  return  null;  }        [CLASS]  Tag    [METHOD]  setContainDataOnly  [RETURN_TYPE]  Tag      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    inline    tag    String    tagName    Map    tags    
canContainBlock  =  false;	[BUGGY]  canContainBlock  =  true;  [CONTEXT]  private  Tag  setEmpty()  {  [BUGGY]  canContainBlock  =  true;  canContainInline  =  false;  empty  =  true;  return  this;  }        [CLASS]  Tag    [METHOD]  setEmpty  [RETURN_TYPE]  Tag      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    inline    tag    String    tagName    Map    tags    
canContainBlock  =  false;	[BUGGY]  canContainInline  =  false;  canContainBlock  =  false;  [CONTEXT]        [CLASS]  Tag    [METHOD]  setEmpty  [RETURN_TYPE]  Tag      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    inline    tag    String    tagName    Map    tags    
canContainBlock  =  false;	[BUGGY]  canContainInline  =  true;canContainBlock  =  false;  [CONTEXT]        [CLASS]  Tag    [METHOD]  setEmpty  [RETURN_TYPE]  Tag      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    inline    tag    String    tagName    Map    tags    
canContainBlock  =  false;	[BUGGY]  inline.isBlock  =  false;canContainBlock  =  false;  [CONTEXT]        [CLASS]  Tag    [METHOD]  setEmpty  [RETURN_TYPE]  Tag      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    inline    tag    String    tagName    Map    tags    
canContainBlock  =  false;	[BUGGY]  tag.canContainBlock  =  true;canContainBlock  =  false;  [CONTEXT]        [CLASS]  Tag    [METHOD]  setEmpty  [RETURN_TYPE]  Tag      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    inline    tag    String    tagName    Map    tags    
canContainBlock  =  false;	[BUGGY]  tag.isBlock  =  false;canContainBlock  =  false;  [CONTEXT]        [CLASS]  Tag    [METHOD]  setEmpty  [RETURN_TYPE]  Tag      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    inline    tag    String    tagName    Map    tags    
canContainBlock  =  false;	[BUGGY]  inline.canContainBlock  =  false;canContainBlock  =  false;  [CONTEXT]        [CLASS]  Tag    [METHOD]  setEmpty  [RETURN_TYPE]  Tag      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    inline    tag    String    tagName    Map    tags    
canContainInline  =  false;	[BUGGY]  canContainInline  =  true;  [CONTEXT]  private  Tag  setEmpty()  {  canContainBlock  =  false;  [BUGGY]  canContainInline  =  true;  empty  =  true;  return  this;  }        [CLASS]  Tag    [METHOD]  setEmpty  [RETURN_TYPE]  Tag      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    inline    tag    String    tagName    Map    tags    
canContainInline  =  false;	[BUGGY]  canContainInline  =  true;canContainInline  =  false;  [CONTEXT]        [CLASS]  Tag    [METHOD]  setEmpty  [RETURN_TYPE]  Tag      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    inline    tag    String    tagName    Map    tags    
canContainInline  =  false;	[BUGGY]  inline.isBlock  =  false;canContainInline  =  false;  [CONTEXT]        [CLASS]  Tag    [METHOD]  setEmpty  [RETURN_TYPE]  Tag      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    inline    tag    String    tagName    Map    tags    
canContainInline  =  false;	[BUGGY]  tag.canContainBlock  =  true;canContainInline  =  false;  [CONTEXT]        [CLASS]  Tag    [METHOD]  setEmpty  [RETURN_TYPE]  Tag      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    inline    tag    String    tagName    Map    tags    
canContainInline  =  false;	[BUGGY]  inline.canContainBlock  =  false;canContainInline  =  false;  [CONTEXT]        [CLASS]  Tag    [METHOD]  setEmpty  [RETURN_TYPE]  Tag      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    inline    tag    String    tagName    Map    tags    
canContainInline  =  false;	[BUGGY]  canContainBlock  =  false;canContainInline  =  false;  [CONTEXT]        [CLASS]  Tag    [METHOD]  setEmpty  [RETURN_TYPE]  Tag      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    inline    tag    String    tagName    Map    tags    
empty  =  true;	[BUGGY]  empty  =  false;  [CONTEXT]  private  Tag  setEmpty()  {  canContainBlock  =  false;  canContainInline  =  false;  [BUGGY]  empty  =  false;  return  this;  }        [CLASS]  Tag    [METHOD]  setEmpty  [RETURN_TYPE]  Tag      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    inline    tag    String    tagName    Map    tags    
return  this;	[BUGGY]  return  null;  [CONTEXT]  private  Tag  setEmpty()  {  canContainBlock  =  false;  canContainInline  =  false;  empty  =  true;  [BUGGY]  return  null;  }        [CLASS]  Tag    [METHOD]  setEmpty  [RETURN_TYPE]  Tag      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    inline    tag    String    tagName    Map    tags    
optionalClosing  =  true;	[BUGGY]  optionalClosing  =  false;  [CONTEXT]  private  Tag  setOptionalClosing()  {  [BUGGY]  optionalClosing  =  false;  return  this;  }        [CLASS]  Tag    [METHOD]  setOptionalClosing  [RETURN_TYPE]  Tag      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    inline    tag    String    tagName    Map    tags    
optionalClosing  =  true;	[BUGGY]    optionalClosing  =  true;  [CONTEXT]        [CLASS]  Tag    [METHOD]  setOptionalClosing  [RETURN_TYPE]  Tag      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    inline    tag    String    tagName    Map    tags    
optionalClosing  =  true;	[BUGGY]  canContainInline  =  true;optionalClosing  =  true;  [CONTEXT]        [CLASS]  Tag    [METHOD]  setOptionalClosing  [RETURN_TYPE]  Tag      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    inline    tag    String    tagName    Map    tags    
return  this;	[BUGGY]  return  null;  [CONTEXT]  private  Tag  setOptionalClosing()  {  optionalClosing  =  true;  [BUGGY]  return  null;  }        [CLASS]  Tag    [METHOD]  setOptionalClosing  [RETURN_TYPE]  Tag      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    inline    tag    String    tagName    Map    tags    
preserveWhitespace  =  true;	[BUGGY]  preserveWhitespace  =  false;  [CONTEXT]  private  Tag  setPreserveWhitespace()  {  [BUGGY]  preserveWhitespace  =  false;  return  this;  }        [CLASS]  Tag    [METHOD]  setPreserveWhitespace  [RETURN_TYPE]  Tag      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    inline    tag    String    tagName    Map    tags    
return  this;	[BUGGY]  return  null;  [CONTEXT]  private  Tag  setPreserveWhitespace()  {  preserveWhitespace  =  true;  [BUGGY]  return  null;  }        [CLASS]  Tag    [METHOD]  setPreserveWhitespace  [RETURN_TYPE]  Tag      [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    inline    tag    String    tagName    Map    tags    
if  (  tagNames  ==  null  )  {	[BUGGY]  if  (  tagNames  !=  null)  {  [CONTEXT]  private  Tag  setAncestor(String...  tagNames)  {  [BUGGY]  if(  tagNames  !=  null  ){  ancestors  =  Collections.emptyList();  }  else  {  ancestors  =  new  ArrayList<Tag>(tagNames.length);  for  (String  name  :  tagNames)  {  ancestors.add(Tag.valueOf(name));  }  }  return  this;  }        [CLASS]  Tag    [METHOD]  setAncestor  [RETURN_TYPE]  Tag        tagNames  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    inline    tag    String    name    tagName    String[]    tagNames    Map    tags    
if  (  tagNames  ==  null  )  {	[BUGGY]  if  (  tagNames  ==  true)  {  [CONTEXT]  private  Tag  setAncestor(String...  tagNames)  {  [BUGGY]  if(  tagNames  ==  true  ){  ancestors  =  Collections.emptyList();  }  else  {  ancestors  =  new  ArrayList<Tag>(tagNames.length);  for  (String  name  :  tagNames)  {  ancestors.add(Tag.valueOf(name));  }  }  return  this;  }        [CLASS]  Tag    [METHOD]  setAncestor  [RETURN_TYPE]  Tag        tagNames  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    inline    tag    String    name    tagName    String[]    tagNames    Map    tags    
if  (  tagNames  ==  null  )  {	[BUGGY]  if  (  tag  ==  null)  {  [CONTEXT]  private  Tag  setAncestor(String...  tagNames)  {  [BUGGY]  if(  tag  ==  null  ){  ancestors  =  Collections.emptyList();  }  else  {  ancestors  =  new  ArrayList<Tag>(tagNames.length);  for  (String  name  :  tagNames)  {  ancestors.add(Tag.valueOf(name));  }  }  return  this;  }        [CLASS]  Tag    [METHOD]  setAncestor  [RETURN_TYPE]  Tag        tagNames  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    inline    tag    String    name    tagName    String[]    tagNames    Map    tags    
ancestors  =  new  ArrayList<Tag>  (  tagNames.length  )  ;	[BUGGY]  ancestors  =    new  ArrayList<Tag>(  null.length);  [CONTEXT]  private  Tag  setAncestor(String...  tagNames)  {  if  (tagNames  ==  null)  {  ancestors  =  Collections.emptyList();  }  else  {  [BUGGY]  ancestors  =new  ArrayList<Tag>  (  null.length  )  ;  for  (String  name  :  tagNames)  {  ancestors.add(Tag.valueOf(name));  }  }  return  this;  }        [CLASS]  Tag    [METHOD]  setAncestor  [RETURN_TYPE]  Tag        tagNames  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    inline    tag    String    name    tagName    String[]    tagNames    Map    tags    
for  (  String  name  :  tagNames  )  {	[BUGGY]  for  (  char  name  :  tagNames)  {  [CONTEXT]  private  Tag  setAncestor(String...  tagNames)  {  if  (tagNames  ==  null)  {  ancestors  =  Collections.emptyList();  }  else  {  ancestors  =  new  ArrayList<Tag>(tagNames.length);  [BUGGY]  for(  char  name  :  tagNames  ){  ancestors.add(Tag.valueOf(name));  }  }  return  this;  }        [CLASS]  Tag    [METHOD]  setAncestor  [RETURN_TYPE]  Tag        tagNames  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    inline    tag    String    name    tagName    String[]    tagNames    Map    tags    
ancestors.add  (  Tag.valueOf  (  name  )  )  ;	[BUGGY]  ancestors.add(  Tag.valueOf(  tagName));  [CONTEXT]  private  Tag  setAncestor(String...  tagNames)  {  if  (tagNames  ==  null)  {  ancestors  =  Collections.emptyList();  }  else  {  ancestors  =  new  ArrayList<Tag>(tagNames.length);  for  (String  name  :  tagNames)  {  [BUGGY]  ancestors.add  (  Tag.valueOf  (  tagName  ))  ;  }  }  return  this;  }        [CLASS]  Tag    [METHOD]  setAncestor  [RETURN_TYPE]  Tag        tagNames  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    inline    tag    String    name    tagName    String[]    tagNames    Map    tags    
ancestors.add  (  Tag.valueOf  (  name  )  )  ;	[BUGGY]  ancestors.get(  Tag.valueOf(  name));  [CONTEXT]  private  Tag  setAncestor(String...  tagNames)  {  if  (tagNames  ==  null)  {  ancestors  =  Collections.emptyList();  }  else  {  ancestors  =  new  ArrayList<Tag>(tagNames.length);  for  (String  name  :  tagNames)  {  [BUGGY]  ancestors.get  (  Tag.valueOf  (  name  ))  ;  }  }  return  this;  }        [CLASS]  Tag    [METHOD]  setAncestor  [RETURN_TYPE]  Tag        tagNames  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    inline    tag    String    name    tagName    String[]    tagNames    Map    tags    
ancestors.add  (  Tag.valueOf  (  name  )  )  ;	[BUGGY]  ancestors.add(  Tag.Tag(  name));  [CONTEXT]  private  Tag  setAncestor(String...  tagNames)  {  if  (tagNames  ==  null)  {  ancestors  =  Collections.emptyList();  }  else  {  ancestors  =  new  ArrayList<Tag>(tagNames.length);  for  (String  name  :  tagNames)  {  [BUGGY]  ancestors.add  (  Tag.Tag  (  name  ))  ;  }  }  return  this;  }        [CLASS]  Tag    [METHOD]  setAncestor  [RETURN_TYPE]  Tag        tagNames  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    inline    tag    String    name    tagName    String[]    tagNames    Map    tags    
ancestors.add  (  Tag.valueOf  (  name  )  )  ;	[BUGGY]  ancestors.add(  Tag.Tag(  tagName));  [CONTEXT]  private  Tag  setAncestor(String...  tagNames)  {  if  (tagNames  ==  null)  {  ancestors  =  Collections.emptyList();  }  else  {  ancestors  =  new  ArrayList<Tag>(tagNames.length);  for  (String  name  :  tagNames)  {  [BUGGY]  ancestors.add  (  Tag.Tag  (  tagName  ))  ;  }  }  return  this;  }        [CLASS]  Tag    [METHOD]  setAncestor  [RETURN_TYPE]  Tag        tagNames  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    inline    tag    String    name    tagName    String[]    tagNames    Map    tags    
ancestors.add  (  Tag.valueOf  (  name  )  )  ;	[BUGGY]    [CONTEXT]  private  Tag  setAncestor(String...  tagNames)  {  if  (tagNames  ==  null)  {  ancestors  =  Collections.emptyList();  }  else  {  ancestors  =  new  ArrayList<Tag>(tagNames.length);  for  (String  name  :  tagNames)  {  [BUGGY]  ancestors.add(Tag.valueOf(name));    }  }  return  this;        [CLASS]  Tag    [METHOD]  setAncestor  [RETURN_TYPE]  Tag        tagNames  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    inline    tag    String    name    tagName    String[]    tagNames    Map    tags    
ancestors  =  Collections.emptyList  (  )  ;	[BUGGY]  ancestors    =    ancestors  ;  [CONTEXT]  private  Tag  setAncestor(String...  tagNames)  {  if  (tagNames  ==  null)  {  [BUGGY]  ancestors=ancestors  ;  }  else  {  ancestors  =  new  ArrayList<Tag>(tagNames.length);  for  (String  name  :  tagNames)  {  ancestors.add(Tag.valueOf(name));  }  }  return  this;  }        [CLASS]  Tag    [METHOD]  setAncestor  [RETURN_TYPE]  Tag        tagNames  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    inline    tag    String    name    tagName    String[]    tagNames    Map    tags    
ancestors  =  Collections.emptyList  (  )  ;	[BUGGY]    [CONTEXT]  private  Tag  setAncestor(String...  tagNames)  {  if  (tagNames  ==  null)  {  [BUGGY]  ancestors  =  Collections.emptyList();    }  else  {  ancestors  =  new  ArrayList<Tag>(tagNames.length);  for  (String  name  :  tagNames)  {  ancestors.add(Tag.valueOf(name));  }  }  return  this;        [CLASS]  Tag    [METHOD]  setAncestor  [RETURN_TYPE]  Tag        tagNames  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    inline    tag    String    name    tagName    String[]    tagNames    Map    tags    
ancestors  =  Collections.emptyList  (  )  ;	[BUGGY]  ancestors  ;  [CONTEXT]  private  Tag  setAncestor(String...  tagNames)  {  if  (tagNames  ==  null)  {  [BUGGY]  ancestors  ;  }  else  {  ancestors  =  new  ArrayList<Tag>(tagNames.length);  for  (String  name  :  tagNames)  {  ancestors.add(Tag.valueOf(name));  }  }  return  this;  }        [CLASS]  Tag    [METHOD]  setAncestor  [RETURN_TYPE]  Tag        tagNames  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    inline    tag    String    name    tagName    String[]    tagNames    Map    tags    
ancestors.add  (  Tag.valueOf  (  name  )  )  ;	[BUGGY]  ancestors.add(  Tag  .isValidParent(  inline)  );  [CONTEXT]  private  Tag  setAncestor(String...  tagNames)  {  if  (tagNames  ==  null)  {  ancestors  =  Collections.emptyList();  }  else  {  ancestors  =  new  ArrayList<Tag>(tagNames.length);  for  (String  name  :  tagNames)  {  [BUGGY]  ancestors.add  (  Tag  .isValidParent  (  inline  )  )  ;  }  }  return  this;  }        [CLASS]  Tag    [METHOD]  setAncestor  [RETURN_TYPE]  Tag        tagNames  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    inline    tag    String    name    tagName    String[]    tagNames    Map    tags    
return  this;	[BUGGY]  return  null;  [CONTEXT]  private  Tag  setAncestor(String...  tagNames)  {  if  (tagNames  ==  null)  {  ancestors  =  Collections.emptyList();  }  else  {  ancestors  =  new  ArrayList<Tag>(tagNames.length);  for  (String  name  :  tagNames)  {  ancestors.add(Tag.valueOf(name));  }  }  [BUGGY]  return  null;  }        [CLASS]  Tag    [METHOD]  setAncestor  [RETURN_TYPE]  Tag        tagNames  [VARIABLES]  List    ancestors    boolean    canContainBlock    canContainInline    empty    isBlock    optionalClosing    preserveWhitespace    Tag    child    defaultAncestor    inline    tag    String    name    tagName    String[]    tagNames    Map    tags    
return  Parser.parse  (  html,  baseUri  )  ;	[BUGGY]  return  Parser.parse(  baseUri,  html);  [CONTEXT]  public  static  Document  parse(String  html,  String  baseUri)  {  [BUGGY]  return  Parser.parse  (  baseUri,  html  )  ;  }        [CLASS]  Jsoup    [METHOD]  parse  [RETURN_TYPE]  Document      String  html  String  baseUri  [VARIABLES]  boolean    String    baseUri    html    
return  Parser.parse  (  html,  baseUri  )  ;	[BUGGY]  return  Parser.parse(    baseUri);  [CONTEXT]  public  static  Document  parse(String  html,  String  baseUri)  {  [BUGGY]  return  Parser.parse  (baseUri  )  ;  }        [CLASS]  Jsoup    [METHOD]  parse  [RETURN_TYPE]  Document      String  html  String  baseUri  [VARIABLES]  boolean    String    baseUri    html    
return  Parser.parse  (  html,  baseUri  )  ;	[BUGGY]  return  Parser.parse(  html);  [CONTEXT]  public  static  Document  parse(String  html,  String  baseUri)  {  [BUGGY]  return  Parser.parse  (  html  )  ;  }        [CLASS]  Jsoup    [METHOD]  parse  [RETURN_TYPE]  Document      String  html  String  baseUri  [VARIABLES]  boolean    String    baseUri    html    
return  Parser.parse  (  html,  baseUri  )  ;	[BUGGY]    [CONTEXT]  public  static  Document  parse(String  html,  String  baseUri)  {  [BUGGY]  return  Parser.parse(html,  baseUri);          [CLASS]  Jsoup    [METHOD]  parse  [RETURN_TYPE]  Document      String  html  String  baseUri  [VARIABLES]  boolean    String    baseUri    html    
return  Parser.parse  (  html,   " "  )  ;	[BUGGY]  return  Parser.parseBodyFragment(  html,   " ");  [CONTEXT]  public  static  Document  parse(String  html)  {  [BUGGY]  return  Parser.parseBodyFragment  (  html,   " "  )  ;  }        [CLASS]  Jsoup    [METHOD]  parse  [RETURN_TYPE]  Document      String  html  [VARIABLES]  boolean    String    html    
return  Parser.parse  (  html,   " "  )  ;	[BUGGY]    [CONTEXT]  public  static  Document  parse(String  html)  {  [BUGGY]  return  Parser.parse(html,   " ");          [CLASS]  Jsoup    [METHOD]  parse  [RETURN_TYPE]  Document      String  html  [VARIABLES]  boolean    String    html    
String  html  =  DataUtil.load  (  url,  timeoutMillis  )  ;	[BUGGY]  char  html  =  DataUtil.load(  url,  timeoutMillis);  [CONTEXT]  public  static  Document  parse(URL  url,  int  timeoutMillis)  throws  IOException  {  [BUGGY]  char  html  =  DataUtil.load  (  url,  timeoutMillis  )  ;  return  parse(html,  url.toExternalForm());  }        [CLASS]  Jsoup    [METHOD]  parse  [RETURN_TYPE]  Document      URL  url  int  timeoutMillis  [VARIABLES]  boolean    String    html    URL    url    int    timeoutMillis    
String  html  =  DataUtil.load  (  url,  timeoutMillis  )  ;	[BUGGY]  String  html  =  DataUtil.load(  timeoutMillis,  url);  [CONTEXT]  public  static  Document  parse(URL  url,  int  timeoutMillis)  throws  IOException  {  [BUGGY]  String  html  =  DataUtil.load  (  timeoutMillis,  url  )  ;  return  parse(html,  url.toExternalForm());  }        [CLASS]  Jsoup    [METHOD]  parse  [RETURN_TYPE]  Document      URL  url  int  timeoutMillis  [VARIABLES]  boolean    String    html    URL    url    int    timeoutMillis    
String  html  =  DataUtil.load  (  url,  timeoutMillis  )  ;	[BUGGY]  String  html  =  DataUtil.load(    timeoutMillis);  [CONTEXT]  public  static  Document  parse(URL  url,  int  timeoutMillis)  throws  IOException  {  [BUGGY]  String  html  =  DataUtil.load  (timeoutMillis  )  ;  return  parse(html,  url.toExternalForm());  }        [CLASS]  Jsoup    [METHOD]  parse  [RETURN_TYPE]  Document      URL  url  int  timeoutMillis  [VARIABLES]  boolean    String    html    URL    url    int    timeoutMillis    
String  html  =  DataUtil.load  (  url,  timeoutMillis  )  ;	[BUGGY]  String  html  =  DataUtil.load(  url);  [CONTEXT]  public  static  Document  parse(URL  url,  int  timeoutMillis)  throws  IOException  {  [BUGGY]  String  html  =  DataUtil.load  (  url  )  ;  return  parse(html,  url.toExternalForm());  }        [CLASS]  Jsoup    [METHOD]  parse  [RETURN_TYPE]  Document      URL  url  int  timeoutMillis  [VARIABLES]  boolean    String    html    URL    url    int    timeoutMillis    
String  html  =  DataUtil.load  (  url,  timeoutMillis  )  ;	[BUGGY]    String  html  =  DataUtil.load(  url,  timeoutMillis);  [CONTEXT]        [CLASS]  Jsoup    [METHOD]  parse  [RETURN_TYPE]  Document      URL  url  int  timeoutMillis  [VARIABLES]  boolean    String    html    URL    url    int    timeoutMillis    
String  html  =  DataUtil.load  (  url,  timeoutMillis  )  ;	[BUGGY]  String  html  =  DataUtil.load(  in,  charsetName);String  html  =  DataUtil.load(  url,  timeoutMillis);  [CONTEXT]        [CLASS]  Jsoup    [METHOD]  parse  [RETURN_TYPE]  Document      URL  url  int  timeoutMillis  [VARIABLES]  boolean    String    html    URL    url    int    timeoutMillis    
String  html  =  DataUtil.load  (  url,  timeoutMillis  )  ;	[BUGGY]    [CONTEXT]  public  static  Document  parse(URL  url,  int  timeoutMillis)  throws  IOException  {  [BUGGY]  String  html  =  DataUtil.load(url,  timeoutMillis);    return  parse(html,  url.toExternalForm());        [CLASS]  Jsoup    [METHOD]  parse  [RETURN_TYPE]  Document      URL  url  int  timeoutMillis  [VARIABLES]  boolean    String    html    URL    url    int    timeoutMillis    
String  html  =  DataUtil.load  (  url,  timeoutMillis  )  ;	[BUGGY]  return  parse(  html,  url.toExternalForm(  ));  String  html  =  DataUtil.load(  url,  timeoutMillis);  [CONTEXT]        [CLASS]  Jsoup    [METHOD]  parse  [RETURN_TYPE]  Document      URL  url  int  timeoutMillis  [VARIABLES]  boolean    String    html    URL    url    int    timeoutMillis    
return  parse  (  html,  url.toExternalForm  (  )  )  ;	[BUGGY]  return  parse(  url,  html.toExternalForm(  ));  [CONTEXT]  public  static  Document  parse(URL  url,  int  timeoutMillis)  throws  IOException  {  String  html  =  DataUtil.load(url,  timeoutMillis);  [BUGGY]  return  parse  (  url,  html.toExternalForm  ())  ;  }        [CLASS]  Jsoup    [METHOD]  parse  [RETURN_TYPE]  Document      URL  url  int  timeoutMillis  [VARIABLES]  boolean    String    html    URL    url    int    timeoutMillis    
return  parse  (  html,  url.toExternalForm  (  )  )  ;	[BUGGY]  return  parse(    url.toExternalForm(  ));  [CONTEXT]  public  static  Document  parse(URL  url,  int  timeoutMillis)  throws  IOException  {  String  html  =  DataUtil.load(url,  timeoutMillis);  [BUGGY]  return  parse  (url.toExternalForm  ())  ;  }        [CLASS]  Jsoup    [METHOD]  parse  [RETURN_TYPE]  Document      URL  url  int  timeoutMillis  [VARIABLES]  boolean    String    html    URL    url    int    timeoutMillis    
return  parse  (  html,  url.toExternalForm  (  )  )  ;	[BUGGY]  return  parse(  html.toExternalForm(  ));  [CONTEXT]  public  static  Document  parse(URL  url,  int  timeoutMillis)  throws  IOException  {  String  html  =  DataUtil.load(url,  timeoutMillis);  [BUGGY]  return  parse  (  html.toExternalForm  ())  ;  }        [CLASS]  Jsoup    [METHOD]  parse  [RETURN_TYPE]  Document      URL  url  int  timeoutMillis  [VARIABLES]  boolean    String    html    URL    url    int    timeoutMillis    
return  parse  (  html,  url.toExternalForm  (  )  )  ;	[BUGGY]  return  parseBodyFragment(  html,  url.toExternalForm(  ));  [CONTEXT]  public  static  Document  parse(URL  url,  int  timeoutMillis)  throws  IOException  {  String  html  =  DataUtil.load(url,  timeoutMillis);  [BUGGY]  return  parseBodyFragment  (  html,  url.toExternalForm  ())  ;  }        [CLASS]  Jsoup    [METHOD]  parse  [RETURN_TYPE]  Document      URL  url  int  timeoutMillis  [VARIABLES]  boolean    String    html    URL    url    int    timeoutMillis    
return  parse  (  html,  url.toExternalForm  (  )  )  ;	[BUGGY]    [CONTEXT]  public  static  Document  parse(URL  url,  int  timeoutMillis)  throws  IOException  {  String  html  =  DataUtil.load(url,  timeoutMillis);  [BUGGY]  return  parse(html,  url.toExternalForm());          [CLASS]  Jsoup    [METHOD]  parse  [RETURN_TYPE]  Document      URL  url  int  timeoutMillis  [VARIABLES]  boolean    String    html    URL    url    int    timeoutMillis    
String  html  =  DataUtil.load  (  in,  charsetName  )  ;	[BUGGY]  char  html  =  DataUtil.load(  in,  charsetName);  [CONTEXT]  public  static  Document  parse(File  in,  String  charsetName,  String  baseUri)  throws  IOException  {  [BUGGY]  char  html  =  DataUtil.load  (  in,  charsetName  )  ;  return  parse(html,  baseUri);  }        [CLASS]  Jsoup    [METHOD]  parse  [RETURN_TYPE]  Document      File  in  String  charsetName  String  baseUri  [VARIABLES]  boolean    String    baseUri    charsetName    html    File    in    
String  html  =  DataUtil.load  (  in,  charsetName  )  ;	[BUGGY]  String  html  =  DataUtil.load(  in,  baseUri);  [CONTEXT]  public  static  Document  parse(File  in,  String  charsetName,  String  baseUri)  throws  IOException  {  [BUGGY]  String  html  =  DataUtil.load  (  in,  baseUri  )  ;  return  parse(html,  baseUri);  }        [CLASS]  Jsoup    [METHOD]  parse  [RETURN_TYPE]  Document      File  in  String  charsetName  String  baseUri  [VARIABLES]  boolean    String    baseUri    charsetName    html    File    in    
String  html  =  DataUtil.load  (  in,  charsetName  )  ;	[BUGGY]  String  html  =  DataUtil.load(  charsetName,  in);  [CONTEXT]  public  static  Document  parse(File  in,  String  charsetName,  String  baseUri)  throws  IOException  {  [BUGGY]  String  html  =  DataUtil.load  (  charsetName,  in  )  ;  return  parse(html,  baseUri);  }        [CLASS]  Jsoup    [METHOD]  parse  [RETURN_TYPE]  Document      File  in  String  charsetName  String  baseUri  [VARIABLES]  boolean    String    baseUri    charsetName    html    File    in    
String  html  =  DataUtil.load  (  in,  charsetName  )  ;	[BUGGY]  String  html  =  DataUtil.load(    charsetName);  [CONTEXT]  public  static  Document  parse(File  in,  String  charsetName,  String  baseUri)  throws  IOException  {  [BUGGY]  String  html  =  DataUtil.load  (charsetName  )  ;  return  parse(html,  baseUri);  }        [CLASS]  Jsoup    [METHOD]  parse  [RETURN_TYPE]  Document      File  in  String  charsetName  String  baseUri  [VARIABLES]  boolean    String    baseUri    charsetName    html    File    in    
String  html  =  DataUtil.load  (  in,  charsetName  )  ;	[BUGGY]  String  html  =  DataUtil.load(  in);  [CONTEXT]  public  static  Document  parse(File  in,  String  charsetName,  String  baseUri)  throws  IOException  {  [BUGGY]  String  html  =  DataUtil.load  (  in  )  ;  return  parse(html,  baseUri);  }        [CLASS]  Jsoup    [METHOD]  parse  [RETURN_TYPE]  Document      File  in  String  charsetName  String  baseUri  [VARIABLES]  boolean    String    baseUri    charsetName    html    File    in    
String  html  =  DataUtil.load  (  in,  charsetName  )  ;	[BUGGY]  return  parse(  html,  baseUri);  String  html  =  DataUtil.load(  in,  charsetName);  [CONTEXT]        [CLASS]  Jsoup    [METHOD]  parse  [RETURN_TYPE]  Document      File  in  String  charsetName  String  baseUri  [VARIABLES]  boolean    String    baseUri    charsetName    html    File    in    
String  html  =  DataUtil.load  (  in,  charsetName  )  ;	[BUGGY]  String  html  =  DataUtil.load(  url,  timeoutMillis);String  html  =  DataUtil.load(  in,  charsetName);  [CONTEXT]        [CLASS]  Jsoup    [METHOD]  parse  [RETURN_TYPE]  Document      File  in  String  charsetName  String  baseUri  [VARIABLES]  boolean    String    baseUri    charsetName    html    File    in    
String  html  =  DataUtil.load  (  in,  charsetName  )  ;	[BUGGY]  String  html  =  DataUtil.load(  in,  html);  [CONTEXT]  public  static  Document  parse(File  in,  String  charsetName,  String  baseUri)  throws  IOException  {  [BUGGY]  String  html  =  DataUtil.load  (  in,  html  )  ;  return  parse(html,  baseUri);  }        [CLASS]  Jsoup    [METHOD]  parse  [RETURN_TYPE]  Document      File  in  String  charsetName  String  baseUri  [VARIABLES]  boolean    String    baseUri    charsetName    html    File    in    
String  html  =  DataUtil.load  (  in,  charsetName  )  ;  return  parse  (  html,  baseUri  )  ;	[BUGGY]    [CONTEXT]  public  static  Document  parse(File  in,  String  charsetName,  String  baseUri)  throws  IOException  {  [BUGGY]  String  html  =  DataUtil.load(in,  charsetName);            [CLASS]  Jsoup    [METHOD]  parse  [RETURN_TYPE]  Document      File  in  String  charsetName  String  baseUri  [VARIABLES]  boolean    String    baseUri    charsetName    html    File    in    
String  html  =  DataUtil.load  (  in,  charsetName  )  ;	[BUGGY]    String  html  =  DataUtil.load(  in,  charsetName);  [CONTEXT]        [CLASS]  Jsoup    [METHOD]  parse  [RETURN_TYPE]  Document      File  in  String  charsetName  String  baseUri  [VARIABLES]  boolean    String    baseUri    charsetName    html    File    in    
return  parse  (  html,  baseUri  )  ;	[BUGGY]  return  parse(  charsetName,  baseUri);  [CONTEXT]  public  static  Document  parse(File  in,  String  charsetName,  String  baseUri)  throws  IOException  {  String  html  =  DataUtil.load(in,  charsetName);  [BUGGY]  return  parse  (  charsetName,  baseUri  )  ;  }        [CLASS]  Jsoup    [METHOD]  parse  [RETURN_TYPE]  Document      File  in  String  charsetName  String  baseUri  [VARIABLES]  boolean    String    baseUri    charsetName    html    File    in    
return  parse  (  html,  baseUri  )  ;	[BUGGY]  return  parse(  baseUri,  html);  [CONTEXT]  public  static  Document  parse(File  in,  String  charsetName,  String  baseUri)  throws  IOException  {  String  html  =  DataUtil.load(in,  charsetName);  [BUGGY]  return  parse  (  baseUri,  html  )  ;  }        [CLASS]  Jsoup    [METHOD]  parse  [RETURN_TYPE]  Document      File  in  String  charsetName  String  baseUri  [VARIABLES]  boolean    String    baseUri    charsetName    html    File    in    
return  parse  (  html,  baseUri  )  ;	[BUGGY]  return  parse(    baseUri);  [CONTEXT]  public  static  Document  parse(File  in,  String  charsetName,  String  baseUri)  throws  IOException  {  String  html  =  DataUtil.load(in,  charsetName);  [BUGGY]  return  parse  (baseUri  )  ;  }        [CLASS]  Jsoup    [METHOD]  parse  [RETURN_TYPE]  Document      File  in  String  charsetName  String  baseUri  [VARIABLES]  boolean    String    baseUri    charsetName    html    File    in    
return  parse  (  html,  baseUri  )  ;	[BUGGY]  return  parse(  html);  [CONTEXT]  public  static  Document  parse(File  in,  String  charsetName,  String  baseUri)  throws  IOException  {  String  html  =  DataUtil.load(in,  charsetName);  [BUGGY]  return  parse  (  html  )  ;  }        [CLASS]  Jsoup    [METHOD]  parse  [RETURN_TYPE]  Document      File  in  String  charsetName  String  baseUri  [VARIABLES]  boolean    String    baseUri    charsetName    html    File    in    
return  parse  (  html,  baseUri  )  ;	[BUGGY]  return  parseBodyFragment(  html,  baseUri);  [CONTEXT]  public  static  Document  parse(File  in,  String  charsetName,  String  baseUri)  throws  IOException  {  String  html  =  DataUtil.load(in,  charsetName);  [BUGGY]  return  parseBodyFragment  (  html,  baseUri  )  ;  }        [CLASS]  Jsoup    [METHOD]  parse  [RETURN_TYPE]  Document      File  in  String  charsetName  String  baseUri  [VARIABLES]  boolean    String    baseUri    charsetName    html    File    in    
return  parse  (  html,  baseUri  )  ;	[BUGGY]  return  parse(  html,  charsetName);  [CONTEXT]  public  static  Document  parse(File  in,  String  charsetName,  String  baseUri)  throws  IOException  {  String  html  =  DataUtil.load(in,  charsetName);  [BUGGY]  return  parse  (  html,  charsetName  )  ;  }        [CLASS]  Jsoup    [METHOD]  parse  [RETURN_TYPE]  Document      File  in  String  charsetName  String  baseUri  [VARIABLES]  boolean    String    baseUri    charsetName    html    File    in    
return  parse  (  html,  baseUri  )  ;	[BUGGY]    [CONTEXT]  public  static  Document  parse(File  in,  String  charsetName,  String  baseUri)  throws  IOException  {  String  html  =  DataUtil.load(in,  charsetName);  [BUGGY]  return  parse(html,  baseUri);          [CLASS]  Jsoup    [METHOD]  parse  [RETURN_TYPE]  Document      File  in  String  charsetName  String  baseUri  [VARIABLES]  boolean    String    baseUri    charsetName    html    File    in    
String  html  =  DataUtil.load  (  in,  charsetName  )  ;	[BUGGY]  char  html  =  DataUtil.load(  in,  charsetName);  [CONTEXT]  public  static  Document  parse(File  in,  String  charsetName)  throws  IOException  {  [BUGGY]  char  html  =  DataUtil.load  (  in,  charsetName  )  ;  return  parse(html,  in.getAbsolutePath());  }        [CLASS]  Jsoup    [METHOD]  parse  [RETURN_TYPE]  Document      File  in  String  charsetName  [VARIABLES]  boolean    String    charsetName    html    File    in    
String  html  =  DataUtil.load  (  in,  charsetName  )  ;	[BUGGY]  String  html  =  DataUtil.load(  charsetName,  in);  [CONTEXT]  public  static  Document  parse(File  in,  String  charsetName)  throws  IOException  {  [BUGGY]  String  html  =  DataUtil.load  (  charsetName,  in  )  ;  return  parse(html,  in.getAbsolutePath());  }        [CLASS]  Jsoup    [METHOD]  parse  [RETURN_TYPE]  Document      File  in  String  charsetName  [VARIABLES]  boolean    String    charsetName    html    File    in    
String  html  =  DataUtil.load  (  in,  charsetName  )  ;	[BUGGY]  String  html  =  DataUtil.load(    charsetName);  [CONTEXT]  public  static  Document  parse(File  in,  String  charsetName)  throws  IOException  {  [BUGGY]  String  html  =  DataUtil.load  (charsetName  )  ;  return  parse(html,  in.getAbsolutePath());  }        [CLASS]  Jsoup    [METHOD]  parse  [RETURN_TYPE]  Document      File  in  String  charsetName  [VARIABLES]  boolean    String    charsetName    html    File    in    
String  html  =  DataUtil.load  (  in,  charsetName  )  ;	[BUGGY]  String  html  =  DataUtil.load(  in);  [CONTEXT]  public  static  Document  parse(File  in,  String  charsetName)  throws  IOException  {  [BUGGY]  String  html  =  DataUtil.load  (  in  )  ;  return  parse(html,  in.getAbsolutePath());  }        [CLASS]  Jsoup    [METHOD]  parse  [RETURN_TYPE]  Document      File  in  String  charsetName  [VARIABLES]  boolean    String    charsetName    html    File    in    
String  html  =  DataUtil.load  (  in,  charsetName  )  ;	[BUGGY]  return  parse(  html,  in.getAbsolutePath(  ));  String  html  =  DataUtil.load(  in,  charsetName);  [CONTEXT]        [CLASS]  Jsoup    [METHOD]  parse  [RETURN_TYPE]  Document      File  in  String  charsetName  [VARIABLES]  boolean    String    charsetName    html    File    in    
String  html  =  DataUtil.load  (  in,  charsetName  )  ;	[BUGGY]  String  html  =  DataUtil.load(  url,  timeoutMillis);String  html  =  DataUtil.load(  in,  charsetName);  [CONTEXT]        [CLASS]  Jsoup    [METHOD]  parse  [RETURN_TYPE]  Document      File  in  String  charsetName  [VARIABLES]  boolean    String    charsetName    html    File    in    
String  html  =  DataUtil.load  (  in,  charsetName  )  ;	[BUGGY]  String  html  =  DataUtil.load(  in,  html);  [CONTEXT]  public  static  Document  parse(File  in,  String  charsetName)  throws  IOException  {  [BUGGY]  String  html  =  DataUtil.load  (  in,  html  )  ;  return  parse(html,  in.getAbsolutePath());  }        [CLASS]  Jsoup    [METHOD]  parse  [RETURN_TYPE]  Document      File  in  String  charsetName  [VARIABLES]  boolean    String    charsetName    html    File    in    
String  html  =  DataUtil.load  (  in,  charsetName  )  ;  return  parse  (  html,  in.getAbsolutePath  (  )  )  ;	[BUGGY]    [CONTEXT]  public  static  Document  parse(File  in,  String  charsetName)  throws  IOException  {  [BUGGY]  String  html  =  DataUtil.load(in,  charsetName);            [CLASS]  Jsoup    [METHOD]  parse  [RETURN_TYPE]  Document      File  in  String  charsetName  [VARIABLES]  boolean    String    charsetName    html    File    in    
String  html  =  DataUtil.load  (  in,  charsetName  )  ;	[BUGGY]    String  html  =  DataUtil.load(  in,  charsetName);  [CONTEXT]        [CLASS]  Jsoup    [METHOD]  parse  [RETURN_TYPE]  Document      File  in  String  charsetName  [VARIABLES]  boolean    String    charsetName    html    File    in    
return  parse  (  html,  in.getAbsolutePath  (  )  )  ;	[BUGGY]  return  parse(  charsetName,  in.getAbsolutePath(  ));  [CONTEXT]  public  static  Document  parse(File  in,  String  charsetName)  throws  IOException  {  String  html  =  DataUtil.load(in,  charsetName);  [BUGGY]  return  parse  (  charsetName,  in.getAbsolutePath  ())  ;  }        [CLASS]  Jsoup    [METHOD]  parse  [RETURN_TYPE]  Document      File  in  String  charsetName  [VARIABLES]  boolean    String    charsetName    html    File    in    
return  parse  (  html,  in.getAbsolutePath  (  )  )  ;	[BUGGY]  return  parse(  in,  html.getAbsolutePath(  ));  [CONTEXT]  public  static  Document  parse(File  in,  String  charsetName)  throws  IOException  {  String  html  =  DataUtil.load(in,  charsetName);  [BUGGY]  return  parse  (  in,  html.getAbsolutePath  ())  ;  }        [CLASS]  Jsoup    [METHOD]  parse  [RETURN_TYPE]  Document      File  in  String  charsetName  [VARIABLES]  boolean    String    charsetName    html    File    in    
return  parse  (  html,  in.getAbsolutePath  (  )  )  ;	[BUGGY]  return  parse(    in.getAbsolutePath(  ));  [CONTEXT]  public  static  Document  parse(File  in,  String  charsetName)  throws  IOException  {  String  html  =  DataUtil.load(in,  charsetName);  [BUGGY]  return  parse  (in.getAbsolutePath  ())  ;  }        [CLASS]  Jsoup    [METHOD]  parse  [RETURN_TYPE]  Document      File  in  String  charsetName  [VARIABLES]  boolean    String    charsetName    html    File    in    
return  parse  (  html,  in.getAbsolutePath  (  )  )  ;	[BUGGY]  return  parse(  html.getAbsolutePath(  ));  [CONTEXT]  public  static  Document  parse(File  in,  String  charsetName)  throws  IOException  {  String  html  =  DataUtil.load(in,  charsetName);  [BUGGY]  return  parse  (  html.getAbsolutePath  ())  ;  }        [CLASS]  Jsoup    [METHOD]  parse  [RETURN_TYPE]  Document      File  in  String  charsetName  [VARIABLES]  boolean    String    charsetName    html    File    in    
return  parse  (  html,  in.getAbsolutePath  (  )  )  ;	[BUGGY]  return  parseBodyFragment(  html,  in.getAbsolutePath(  ));  [CONTEXT]  public  static  Document  parse(File  in,  String  charsetName)  throws  IOException  {  String  html  =  DataUtil.load(in,  charsetName);  [BUGGY]  return  parseBodyFragment  (  html,  in.getAbsolutePath  ())  ;  }        [CLASS]  Jsoup    [METHOD]  parse  [RETURN_TYPE]  Document      File  in  String  charsetName  [VARIABLES]  boolean    String    charsetName    html    File    in    
return  parse  (  html,  in.getAbsolutePath  (  )  )  ;	[BUGGY]  return  parseBodyFragment(  charsetName,  in.getAbsolutePath(  ));  [CONTEXT]  public  static  Document  parse(File  in,  String  charsetName)  throws  IOException  {  String  html  =  DataUtil.load(in,  charsetName);  [BUGGY]  return  parseBodyFragment  (  charsetName,  in.getAbsolutePath  ())  ;  }        [CLASS]  Jsoup    [METHOD]  parse  [RETURN_TYPE]  Document      File  in  String  charsetName  [VARIABLES]  boolean    String    charsetName    html    File    in    
return  parse  (  html,  in.getAbsolutePath  (  )  )  ;	[BUGGY]    [CONTEXT]  public  static  Document  parse(File  in,  String  charsetName)  throws  IOException  {  String  html  =  DataUtil.load(in,  charsetName);  [BUGGY]  return  parse(html,  in.getAbsolutePath());          [CLASS]  Jsoup    [METHOD]  parse  [RETURN_TYPE]  Document      File  in  String  charsetName  [VARIABLES]  boolean    String    charsetName    html    File    in    
return  Parser.parseBodyFragment  (  bodyHtml,  baseUri  )  ;	[BUGGY]  return  Parser.parseBodyFragment(  baseUri,  bodyHtml);  [CONTEXT]  public  static  Document  parseBodyFragment(String  bodyHtml,  String  baseUri)  {  [BUGGY]  return  Parser.parseBodyFragment  (  baseUri,  bodyHtml  )  ;  }        [CLASS]  Jsoup    [METHOD]  parseBodyFragment  [RETURN_TYPE]  Document      String  bodyHtml  String  baseUri  [VARIABLES]  boolean    String    baseUri    bodyHtml    
return  Parser.parseBodyFragment  (  bodyHtml,  baseUri  )  ;	[BUGGY]  return  Parser.parseBodyFragment(    baseUri);  [CONTEXT]  public  static  Document  parseBodyFragment(String  bodyHtml,  String  baseUri)  {  [BUGGY]  return  Parser.parseBodyFragment  (baseUri  )  ;  }        [CLASS]  Jsoup    [METHOD]  parseBodyFragment  [RETURN_TYPE]  Document      String  bodyHtml  String  baseUri  [VARIABLES]  boolean    String    baseUri    bodyHtml    
return  Parser.parseBodyFragment  (  bodyHtml,  baseUri  )  ;	[BUGGY]  return  Parser.parseBodyFragment(  bodyHtml);  [CONTEXT]  public  static  Document  parseBodyFragment(String  bodyHtml,  String  baseUri)  {  [BUGGY]  return  Parser.parseBodyFragment  (  bodyHtml  )  ;  }        [CLASS]  Jsoup    [METHOD]  parseBodyFragment  [RETURN_TYPE]  Document      String  bodyHtml  String  baseUri  [VARIABLES]  boolean    String    baseUri    bodyHtml    
return  Parser.parseBodyFragment  (  bodyHtml,  baseUri  )  ;	[BUGGY]    [CONTEXT]  public  static  Document  parseBodyFragment(String  bodyHtml,  String  baseUri)  {  [BUGGY]  return  Parser.parseBodyFragment(bodyHtml,  baseUri);          [CLASS]  Jsoup    [METHOD]  parseBodyFragment  [RETURN_TYPE]  Document      String  bodyHtml  String  baseUri  [VARIABLES]  boolean    String    baseUri    bodyHtml    
return  Parser.parseBodyFragment  (  bodyHtml,   " "  )  ;	[BUGGY]  return  Parser  .parseBodyFragment(  bodyHtml)  ;  [CONTEXT]  public  static  Document  parseBodyFragment(String  bodyHtml)  {  [BUGGY]  return  Parser  .parseBodyFragment  (  bodyHtml  );  }        [CLASS]  Jsoup    [METHOD]  parseBodyFragment  [RETURN_TYPE]  Document      String  bodyHtml  [VARIABLES]  boolean    String    bodyHtml    
return  Parser.parseBodyFragment  (  bodyHtml,   " "  )  ;	[BUGGY]    [CONTEXT]  public  static  Document  parseBodyFragment(String  bodyHtml)  {  [BUGGY]  return  Parser.parseBodyFragment(bodyHtml,   " ");          [CLASS]  Jsoup    [METHOD]  parseBodyFragment  [RETURN_TYPE]  Document      String  bodyHtml  [VARIABLES]  boolean    String    bodyHtml    
Document  dirty  =  parseBodyFragment  (  bodyHtml,  baseUri  )  ;	[BUGGY]  Document  dirty  =  parseBodyFragment(  bodyHtml,  bodyHtml);  [CONTEXT]  public  static  String  clean(String  bodyHtml,  String  baseUri,  Whitelist  whitelist)  {  [BUGGY]  Document  dirty  =  parseBodyFragment  (  bodyHtml,  bodyHtml  )  ;  Cleaner  cleaner  =  new  Cleaner(whitelist);  Document  clean  =  cleaner.clean(dirty);  return  clean.body().html();  }        [CLASS]  Jsoup    [METHOD]  clean  [RETURN_TYPE]  String      String  bodyHtml  String  baseUri  Whitelist  whitelist  [VARIABLES]  boolean    Whitelist    whitelist    String    baseUri    bodyHtml    Document    clean    dirty    Cleaner    cleaner    
Document  dirty  =  parseBodyFragment  (  bodyHtml,  baseUri  )  ;	[BUGGY]  Document  dirty  =  parseBodyFragment(  baseUri,  bodyHtml);  [CONTEXT]  public  static  String  clean(String  bodyHtml,  String  baseUri,  Whitelist  whitelist)  {  [BUGGY]  Document  dirty  =  parseBodyFragment  (  baseUri,  bodyHtml  )  ;  Cleaner  cleaner  =  new  Cleaner(whitelist);  Document  clean  =  cleaner.clean(dirty);  return  clean.body().html();  }        [CLASS]  Jsoup    [METHOD]  clean  [RETURN_TYPE]  String      String  bodyHtml  String  baseUri  Whitelist  whitelist  [VARIABLES]  boolean    Whitelist    whitelist    String    baseUri    bodyHtml    Document    clean    dirty    Cleaner    cleaner    
Document  dirty  =  parseBodyFragment  (  bodyHtml,  baseUri  )  ;	[BUGGY]  Document  dirty  =  parseBodyFragment(    baseUri);  [CONTEXT]  public  static  String  clean(String  bodyHtml,  String  baseUri,  Whitelist  whitelist)  {  [BUGGY]  Document  dirty  =  parseBodyFragment  (baseUri  )  ;  Cleaner  cleaner  =  new  Cleaner(whitelist);  Document  clean  =  cleaner.clean(dirty);  return  clean.body().html();  }        [CLASS]  Jsoup    [METHOD]  clean  [RETURN_TYPE]  String      String  bodyHtml  String  baseUri  Whitelist  whitelist  [VARIABLES]  boolean    Whitelist    whitelist    String    baseUri    bodyHtml    Document    clean    dirty    Cleaner    cleaner    
Document  dirty  =  parseBodyFragment  (  bodyHtml,  baseUri  )  ;	[BUGGY]  Document  dirty  =  parseBodyFragment(  bodyHtml);  [CONTEXT]  public  static  String  clean(String  bodyHtml,  String  baseUri,  Whitelist  whitelist)  {  [BUGGY]  Document  dirty  =  parseBodyFragment  (  bodyHtml  )  ;  Cleaner  cleaner  =  new  Cleaner(whitelist);  Document  clean  =  cleaner.clean(dirty);  return  clean.body().html();  }        [CLASS]  Jsoup    [METHOD]  clean  [RETURN_TYPE]  String      String  bodyHtml  String  baseUri  Whitelist  whitelist  [VARIABLES]  boolean    Whitelist    whitelist    String    baseUri    bodyHtml    Document    clean    dirty    Cleaner    cleaner    
Document  dirty  =  parseBodyFragment  (  bodyHtml,  baseUri  )  ;	[BUGGY]  Document  dirty  =  parse(  bodyHtml,  baseUri);  [CONTEXT]  public  static  String  clean(String  bodyHtml,  String  baseUri,  Whitelist  whitelist)  {  [BUGGY]  Document  dirty  =  parse  (  bodyHtml,  baseUri  )  ;  Cleaner  cleaner  =  new  Cleaner(whitelist);  Document  clean  =  cleaner.clean(dirty);  return  clean.body().html();  }        [CLASS]  Jsoup    [METHOD]  clean  [RETURN_TYPE]  String      String  bodyHtml  String  baseUri  Whitelist  whitelist  [VARIABLES]  boolean    Whitelist    whitelist    String    baseUri    bodyHtml    Document    clean    dirty    Cleaner    cleaner    
Document  dirty  =  parseBodyFragment  (  bodyHtml,  baseUri  )  ;  Cleaner  cleaner  =  new  Cleaner  (  whitelist  )  ;	[BUGGY]  Cleaner  cleaner  =  new  Cleaner(  whitelist);  Document  dirty  =  parseBodyFragment(  bodyHtml,  baseUri);  [CONTEXT]        [CLASS]  Jsoup    [METHOD]  clean  [RETURN_TYPE]  String      String  bodyHtml  String  baseUri  Whitelist  whitelist  [VARIABLES]  boolean    Whitelist    whitelist    String    baseUri    bodyHtml    Document    clean    dirty    Cleaner    cleaner    
Document  dirty  =  parseBodyFragment  (  bodyHtml,  baseUri  )  ;  Cleaner  cleaner  =  new  Cleaner  (  whitelist  )  ;	[BUGGY]  Document  dirty  =  parseBodyFragment(  bodyHtml,  baseUri);Document  dirty  =  parseBodyFragment(  bodyHtml,  baseUri);  Cleaner  cleaner  =  new  Cleaner(  whitelist);  [CONTEXT]        [CLASS]  Jsoup    [METHOD]  clean  [RETURN_TYPE]  String      String  bodyHtml  String  baseUri  Whitelist  whitelist  [VARIABLES]  boolean    Whitelist    whitelist    String    baseUri    bodyHtml    Document    clean    dirty    Cleaner    cleaner    
Document  dirty  =  parseBodyFragment  (  bodyHtml,  baseUri  )  ;  Cleaner  cleaner  =  new  Cleaner  (  whitelist  )  ;	[BUGGY]    [CONTEXT]  public  static  String  clean(String  bodyHtml,  String  baseUri,  Whitelist  whitelist)  {  [BUGGY]  Document  dirty  =  parseBodyFragment(bodyHtml,  baseUri);      Document  clean  =  cleaner.clean(dirty);  return  clean.body().html();        [CLASS]  Jsoup    [METHOD]  clean  [RETURN_TYPE]  String      String  bodyHtml  String  baseUri  Whitelist  whitelist  [VARIABLES]  boolean    Whitelist    whitelist    String    baseUri    bodyHtml    Document    clean    dirty    Cleaner    cleaner    
Document  clean  =  cleaner.clean  (  dirty  )  ;	[BUGGY]  Document  clean  =  dirty.clean(  cleaner);  [CONTEXT]  public  static  String  clean(String  bodyHtml,  String  baseUri,  Whitelist  whitelist)  {  Document  dirty  =  parseBodyFragment(bodyHtml,  baseUri);  Cleaner  cleaner  =  new  Cleaner(whitelist);  [BUGGY]  Document  clean  =  dirty.clean  (  cleaner  )  ;  return  clean.body().html();  }        [CLASS]  Jsoup    [METHOD]  clean  [RETURN_TYPE]  String      String  bodyHtml  String  baseUri  Whitelist  whitelist  [VARIABLES]  boolean    Whitelist    whitelist    String    baseUri    bodyHtml    Document    clean    dirty    Cleaner    cleaner    
Document  clean  =  cleaner.clean  (  dirty  )  ;	[BUGGY]  Document  clean  =  cleaner  .clean(  bodyHtml  ,  bodyHtml  ,  whitelist)  ;  [CONTEXT]  public  static  String  clean(String  bodyHtml,  String  baseUri,  Whitelist  whitelist)  {  Document  dirty  =  parseBodyFragment(bodyHtml,  baseUri);  Cleaner  cleaner  =  new  Cleaner(whitelist);  [BUGGY]  Document  clean  =  cleaner  .clean  (  bodyHtml  ,  bodyHtml  ,  whitelist  );  return  clean.body().html();  }        [CLASS]  Jsoup    [METHOD]  clean  [RETURN_TYPE]  String      String  bodyHtml  String  baseUri  Whitelist  whitelist  [VARIABLES]  boolean    Whitelist    whitelist    String    baseUri    bodyHtml    Document    clean    dirty    Cleaner    cleaner    
Document  clean  =  cleaner.clean  (  dirty  )  ;	[BUGGY]  Document  clean  =  cleaner.clean(  clean);  [CONTEXT]  public  static  String  clean(String  bodyHtml,  String  baseUri,  Whitelist  whitelist)  {  Document  dirty  =  parseBodyFragment(bodyHtml,  baseUri);  Cleaner  cleaner  =  new  Cleaner(whitelist);  [BUGGY]  Document  clean  =  cleaner.clean  (  clean  )  ;  return  clean.body().html();  }        [CLASS]  Jsoup    [METHOD]  clean  [RETURN_TYPE]  String      String  bodyHtml  String  baseUri  Whitelist  whitelist  [VARIABLES]  boolean    Whitelist    whitelist    String    baseUri    bodyHtml    Document    clean    dirty    Cleaner    cleaner    
Document  clean  =  cleaner.clean  (  dirty  )  ;	[BUGGY]    [CONTEXT]  public  static  String  clean(String  bodyHtml,  String  baseUri,  Whitelist  whitelist)  {  Document  dirty  =  parseBodyFragment(bodyHtml,  baseUri);  Cleaner  cleaner  =  new  Cleaner(whitelist);  [BUGGY]  Document  clean  =  cleaner.clean(dirty);    return  clean.body().html();        [CLASS]  Jsoup    [METHOD]  clean  [RETURN_TYPE]  String      String  bodyHtml  String  baseUri  Whitelist  whitelist  [VARIABLES]  boolean    Whitelist    whitelist    String    baseUri    bodyHtml    Document    clean    dirty    Cleaner    cleaner    
Document  clean  =  cleaner.clean  (  dirty  )  ;	[BUGGY]    Document  clean  =  cleaner.clean(  dirty);  [CONTEXT]        [CLASS]  Jsoup    [METHOD]  clean  [RETURN_TYPE]  String      String  bodyHtml  String  baseUri  Whitelist  whitelist  [VARIABLES]  boolean    Whitelist    whitelist    String    baseUri    bodyHtml    Document    clean    dirty    Cleaner    cleaner    
Document  clean  =  cleaner.clean  (  dirty  )  ;	[BUGGY]  return  cleaner.isValid(  dirty);Document  clean  =  cleaner.clean(  dirty);  [CONTEXT]        [CLASS]  Jsoup    [METHOD]  clean  [RETURN_TYPE]  String      String  bodyHtml  String  baseUri  Whitelist  whitelist  [VARIABLES]  boolean    Whitelist    whitelist    String    baseUri    bodyHtml    Document    clean    dirty    Cleaner    cleaner    
return  clean.body  (  )  .html  (  )  ;	[BUGGY]  return  dirty.body(  ).html(  );  [CONTEXT]  public  static  String  clean(String  bodyHtml,  String  baseUri,  Whitelist  whitelist)  {  Document  dirty  =  parseBodyFragment(bodyHtml,  baseUri);  Cleaner  cleaner  =  new  Cleaner(whitelist);  Document  clean  =  cleaner.clean(dirty);  [BUGGY]  return  dirty.body  ()  .html  ()  ;  }        [CLASS]  Jsoup    [METHOD]  clean  [RETURN_TYPE]  String      String  bodyHtml  String  baseUri  Whitelist  whitelist  [VARIABLES]  boolean    Whitelist    whitelist    String    baseUri    bodyHtml    Document    clean    dirty    Cleaner    cleaner    
return  clean.body  (  )  .html  (  )  ;	[BUGGY]    [CONTEXT]  public  static  String  clean(String  bodyHtml,  String  baseUri,  Whitelist  whitelist)  {  Document  dirty  =  parseBodyFragment(bodyHtml,  baseUri);  Cleaner  cleaner  =  new  Cleaner(whitelist);  Document  clean  =  cleaner.clean(dirty);  [BUGGY]  return  clean.body().html();          [CLASS]  Jsoup    [METHOD]  clean  [RETURN_TYPE]  String      String  bodyHtml  String  baseUri  Whitelist  whitelist  [VARIABLES]  boolean    Whitelist    whitelist    String    baseUri    bodyHtml    Document    clean    dirty    Cleaner    cleaner    
return  clean  (  bodyHtml,   " ",  whitelist  )  ;	[BUGGY]  return  clean(  whitelist,   " ",  bodyHtml);  [CONTEXT]  public  static  String  clean(String  bodyHtml,  Whitelist  whitelist)  {  [BUGGY]  return  clean  (  whitelist,   " ",  bodyHtml  )  ;  }        [CLASS]  Jsoup    [METHOD]  clean  [RETURN_TYPE]  String      String  bodyHtml  Whitelist  whitelist  [VARIABLES]  boolean    Whitelist    whitelist    String    bodyHtml    
return  clean  (  bodyHtml,   " ",  whitelist  )  ;	[BUGGY]  return  clean(     " ",  whitelist);  [CONTEXT]  public  static  String  clean(String  bodyHtml,  Whitelist  whitelist)  {  [BUGGY]  return  clean  ( " ",  whitelist  )  ;  }        [CLASS]  Jsoup    [METHOD]  clean  [RETURN_TYPE]  String      String  bodyHtml  Whitelist  whitelist  [VARIABLES]  boolean    Whitelist    whitelist    String    bodyHtml    
return  clean  (  bodyHtml,   " ",  whitelist  )  ;	[BUGGY]  return  clean(  bodyHtml,   " ");  [CONTEXT]  public  static  String  clean(String  bodyHtml,  Whitelist  whitelist)  {  [BUGGY]  return  clean  (  bodyHtml,   " "  )  ;  }        [CLASS]  Jsoup    [METHOD]  clean  [RETURN_TYPE]  String      String  bodyHtml  Whitelist  whitelist  [VARIABLES]  boolean    Whitelist    whitelist    String    bodyHtml    
return  clean  (  bodyHtml,   " ",  whitelist  )  ;	[BUGGY]  return  parse(  bodyHtml,   " ",  whitelist);  [CONTEXT]  public  static  String  clean(String  bodyHtml,  Whitelist  whitelist)  {  [BUGGY]  return  parse  (  bodyHtml,   " ",  whitelist  )  ;  }        [CLASS]  Jsoup    [METHOD]  clean  [RETURN_TYPE]  String      String  bodyHtml  Whitelist  whitelist  [VARIABLES]  boolean    Whitelist    whitelist    String    bodyHtml    
return  clean  (  bodyHtml,   " ",  whitelist  )  ;	[BUGGY]    [CONTEXT]  public  static  String  clean(String  bodyHtml,  Whitelist  whitelist)  {  [BUGGY]  return  clean(bodyHtml,   " ",  whitelist);          [CLASS]  Jsoup    [METHOD]  clean  [RETURN_TYPE]  String      String  bodyHtml  Whitelist  whitelist  [VARIABLES]  boolean    Whitelist    whitelist    String    bodyHtml    
Document  dirty  =  parseBodyFragment  (  bodyHtml,   " "  )  ;	[BUGGY]  Document  dirty  =  parse(  bodyHtml,   " ");  [CONTEXT]  public  static  boolean  isValid(String  bodyHtml,  Whitelist  whitelist)  {  [BUGGY]  Document  dirty  =  parse  (  bodyHtml,   " "  )  ;  Cleaner  cleaner  =  new  Cleaner(whitelist);  return  cleaner.isValid(dirty);  }        [CLASS]  Jsoup    [METHOD]  isValid  [RETURN_TYPE]  boolean      String  bodyHtml  Whitelist  whitelist  [VARIABLES]  boolean    Whitelist    whitelist    String    bodyHtml    Document    dirty    Cleaner    cleaner    
Document  dirty  =  parseBodyFragment  (  bodyHtml,   " "  )  ;  Cleaner  cleaner  =  new  Cleaner  (  whitelist  )  ;	[BUGGY]  Cleaner  cleaner  =  new  Cleaner(  whitelist);  Document  dirty  =  parseBodyFragment(  bodyHtml,   " ");  [CONTEXT]        [CLASS]  Jsoup    [METHOD]  isValid  [RETURN_TYPE]  boolean      String  bodyHtml  Whitelist  whitelist  [VARIABLES]  boolean    Whitelist    whitelist    String    bodyHtml    Document    dirty    Cleaner    cleaner    
Document  dirty  =  parseBodyFragment  (  bodyHtml,   " "  )  ;  Cleaner  cleaner  =  new  Cleaner  (  whitelist  )  ;	[BUGGY]  Document  dirty  =  parseBodyFragment(  bodyHtml,  baseUri);Document  dirty  =  parseBodyFragment(  bodyHtml,   " ");  Cleaner  cleaner  =  new  Cleaner(  whitelist);  [CONTEXT]        [CLASS]  Jsoup    [METHOD]  isValid  [RETURN_TYPE]  boolean      String  bodyHtml  Whitelist  whitelist  [VARIABLES]  boolean    Whitelist    whitelist    String    bodyHtml    Document    dirty    Cleaner    cleaner    
Document  dirty  =  parseBodyFragment  (  bodyHtml,   " "  )  ;  Cleaner  cleaner  =  new  Cleaner  (  whitelist  )  ;	[BUGGY]  Document  dirty  =  parseBodyFragment(  bodyHtml,   " ");Document  dirty  =  parseBodyFragment(  bodyHtml,   " ");  Cleaner  cleaner  =  new  Cleaner(  whitelist);  [CONTEXT]        [CLASS]  Jsoup    [METHOD]  isValid  [RETURN_TYPE]  boolean      String  bodyHtml  Whitelist  whitelist  [VARIABLES]  boolean    Whitelist    whitelist    String    bodyHtml    Document    dirty    Cleaner    cleaner    
Document  dirty  =  parseBodyFragment  (  bodyHtml,   " "  )  ;	[BUGGY]    [CONTEXT]  public  static  boolean  isValid(String  bodyHtml,  Whitelist  whitelist)  {  [BUGGY]  Document  dirty  =  parseBodyFragment(bodyHtml,   " ");    Cleaner  cleaner  =  new  Cleaner(whitelist);  return  cleaner.isValid(dirty);        [CLASS]  Jsoup    [METHOD]  isValid  [RETURN_TYPE]  boolean      String  bodyHtml  Whitelist  whitelist  [VARIABLES]  boolean    Whitelist    whitelist    String    bodyHtml    Document    dirty    Cleaner    cleaner    
Document  dirty  =  parseBodyFragment  (  bodyHtml,   " "  )  ;	[BUGGY]  return  Parser.parseBodyFragment(  bodyHtml,   " ");Document  dirty  =  parseBodyFragment(  bodyHtml,   " ");  [CONTEXT]        [CLASS]  Jsoup    [METHOD]  isValid  [RETURN_TYPE]  boolean      String  bodyHtml  Whitelist  whitelist  [VARIABLES]  boolean    Whitelist    whitelist    String    bodyHtml    Document    dirty    Cleaner    cleaner    
Document  dirty  =  parseBodyFragment  (  bodyHtml,   " "  )  ;	[BUGGY]  Document  dirty  =  parseBodyFragment(  bodyHtml,  baseUri);Document  dirty  =  parseBodyFragment(  bodyHtml,   " ");  [CONTEXT]        [CLASS]  Jsoup    [METHOD]  isValid  [RETURN_TYPE]  boolean      String  bodyHtml  Whitelist  whitelist  [VARIABLES]  boolean    Whitelist    whitelist    String    bodyHtml    Document    dirty    Cleaner    cleaner    
Document  dirty  =  parseBodyFragment  (  bodyHtml,   " "  )  ;	[BUGGY]  return  Parser.parseBodyFragment(  bodyHtml,  baseUri);Document  dirty  =  parseBodyFragment(  bodyHtml,   " ");  [CONTEXT]        [CLASS]  Jsoup    [METHOD]  isValid  [RETURN_TYPE]  boolean      String  bodyHtml  Whitelist  whitelist  [VARIABLES]  boolean    Whitelist    whitelist    String    bodyHtml    Document    dirty    Cleaner    cleaner    
return  cleaner.isValid  (  dirty  )  ;	[BUGGY]  return  dirty.isValid(  cleaner);  [CONTEXT]  public  static  boolean  isValid(String  bodyHtml,  Whitelist  whitelist)  {  Document  dirty  =  parseBodyFragment(bodyHtml,   " ");  Cleaner  cleaner  =  new  Cleaner(whitelist);  [BUGGY]  return  dirty.isValid  (  cleaner  )  ;  }        [CLASS]  Jsoup    [METHOD]  isValid  [RETURN_TYPE]  boolean      String  bodyHtml  Whitelist  whitelist  [VARIABLES]  boolean    Whitelist    whitelist    String    bodyHtml    Document    dirty    Cleaner    cleaner    
return  cleaner.isValid  (  dirty  )  ;	[BUGGY]  return  cleaner  .isValid(  dirty)  ;  [CONTEXT]  public  static  boolean  isValid(String  bodyHtml,  Whitelist  whitelist)  {  Document  dirty  =  parseBodyFragment(bodyHtml,   " ");  Cleaner  cleaner  =  new  Cleaner(whitelist);  [BUGGY]  return  cleaner  .isValid  (  dirty  );  }        [CLASS]  Jsoup    [METHOD]  isValid  [RETURN_TYPE]  boolean      String  bodyHtml  Whitelist  whitelist  [VARIABLES]  boolean    Whitelist    whitelist    String    bodyHtml    Document    dirty    Cleaner    cleaner    
return  cleaner.isValid  (  dirty  )  ;	[BUGGY]    [CONTEXT]  public  static  boolean  isValid(String  bodyHtml,  Whitelist  whitelist)  {  Document  dirty  =  parseBodyFragment(bodyHtml,   " ");  Cleaner  cleaner  =  new  Cleaner(whitelist);  [BUGGY]  return  cleaner.isValid(dirty);          [CLASS]  Jsoup    [METHOD]  isValid  [RETURN_TYPE]  boolean      String  bodyHtml  Whitelist  whitelist  [VARIABLES]  boolean    Whitelist    whitelist    String    bodyHtml    Document    dirty    Cleaner    cleaner    
