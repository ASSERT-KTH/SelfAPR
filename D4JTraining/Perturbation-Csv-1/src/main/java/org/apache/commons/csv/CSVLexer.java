[ADD]^^44^^^^^41^118^[ADD] int lastChar = in.readAgain (  ) ;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^int c = in .readLine (  )  ;^51^^^^^41^118^[REPLACE] int c = in.read (  ) ;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^boolean eol = isEndOfLine ( lastChar ) ;^52^^^^^41^118^[REPLACE] boolean eol = isEndOfLine ( c ) ;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^c = in.read (  )  ;^53^^^^^41^118^[REPLACE] c = in.readAgain (  ) ;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^if   (  isEscape  (  c  )    )   {  ;^56^^^^^41^118^[REPLACE] if  ( emptyLinesIgnored )  {^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[ADD]^^56^57^58^59^^41^118^[ADD] if  ( emptyLinesIgnored )  { while  ( eol &&  ( lastChar == '\n' || lastChar == '\r' || lastChar == ExtendedBufferedReader.UNDEFINED ) && !isEndOfFile ( lastChar )  )  {^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^if   (  isEscape  (  c  )    )   {  ;^66^^^^^41^118^[REPLACE] if  ( isEndOfFile ( c )  )  {^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[ADD]^^67^^^^^41^118^[ADD] tkn.type = EOF;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^return tkn;  ;^69^^^^^41^118^[REPLACE] return tkn;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^lastChar =  null;^61^^^^^41^118^[REPLACE] lastChar = c;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[ADD]^^62^63^^^^41^118^[ADD] c = in.read (  ) ; eol = isEndOfLine ( c ) ;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^eol =  isEndOfLine ( lastChar ) ;^63^^^^^41^118^[REPLACE] eol = isEndOfLine ( c ) ;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^c = in.read (  )  ;^64^^^^^41^118^[REPLACE] c = in.readAgain (  ) ;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^tkn.type = TOKEN  ;^67^^^^^41^118^[REPLACE] tkn.type = EOF;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^c = in.readAgain (  )  ;^62^^^^^41^118^[REPLACE] c = in.read (  ) ;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^if  ( isEndOfFile ( lastChar )  ||  ( isDelimiter ( lastChar )  && isEndOfFile ( c )  )  )  {^75^^^^^41^118^[REPLACE] if  ( isEndOfFile ( lastChar )  ||  ( !isDelimiter ( lastChar )  && isEndOfFile ( c )  )  )  {^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^tkn.type = TOKEN  ;^76^^^^^41^118^[REPLACE] tkn.type = EOF;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^return tkn;  ;^78^^^^^41^118^[REPLACE] return tkn;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^if   (  isEscape  (  c  )    )   {  ;^84^^^^^41^118^[REPLACE] if  ( surroundingSpacesIgnored )  {^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[ADD]^^84^85^86^87^88^41^118^[ADD] if  ( surroundingSpacesIgnored )  { while  ( isWhitespace ( c )  && !eol )  { c = in.read (  ) ; eol = isEndOfLine ( c ) ; }^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^c = in.readAgain (  )  ;^86^^^^^41^118^[REPLACE] c = in.read (  ) ;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^eol =  isEndOfLine ( lastChar ) ;^87^^^^^41^118^[REPLACE] eol = isEndOfLine ( c ) ;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^if   (  isEscape  (  c  )    )   {  ;^92^^^^^41^118^[REPLACE] if  ( isCommentStart ( c )  )  {^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^} else if   (  isEndOfFile  (  c  )    )   {  ;^96^^^^^41^118^[REPLACE] } else if  ( isDelimiter ( c )  )  {^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^}  if  ( false )  {^99^^^^^41^118^[REPLACE] } else if  ( eol )  {^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REMOVE]^if  ( isDelimiter ( c )  )  {     tkn.type = TOKEN; }else     if  ( eol )  {         tkn.type = EORECORD;     }else         if  ( isEncapsulator ( c )  )  {             encapsulatedTokenLexer ( tkn, c ) ;         }else             if  ( isEndOfFile ( c )  )  {                 tkn.type = EOF;                 tkn.isReady = true;             }else {                 simpleTokenLexer ( tkn, c ) ;             }^99^^^^^41^118^[REMOVE] ^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^}  if  ( isEncapsulator ( lastChar )  )  {^103^^^^^41^118^[REPLACE] } else if  ( isEncapsulator ( c )  )  {^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^} else if   (  isDelimiter  (  c  )    )   {  ;^106^^^^^41^118^[REPLACE] } else if  ( isEndOfFile ( c )  )  {^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[ADD]^}   tkn.type = EOF;tkn.isReady = true;^106^107^^109^110^41^118^[ADD] else if  ( isEndOfFile ( c )  )  {  tkn.type = EOF; tkn.isReady = true;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^simpleTokenLexer ( tkn, lastChar ) ;^114^^^^^106^115^[REPLACE] simpleTokenLexer ( tkn, c ) ;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REMOVE]^encapsulatedTokenLexer ( tkn, c )  ;^114^^^^^106^115^[REMOVE] ^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[ADD]^^109^^^^^41^118^[ADD] tkn.type = EOF;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^tkn.isReady = false;^110^^^^^41^118^[REPLACE] tkn.isReady = true;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^encapsulatedTokenLexer ( tkn, lastChar ) ;^105^^^^^41^118^[REPLACE] encapsulatedTokenLexer ( tkn, c ) ;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REMOVE]^isEncapsulator ( c )  ;^105^^^^^41^118^[REMOVE] ^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^encapsulatedTokenLexer ( tkn, c )  ;^114^^^^^106^115^[REPLACE] simpleTokenLexer ( tkn, c ) ;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^tkn.type = TOKEN  ;^109^^^^^41^118^[REPLACE] tkn.type = EOF;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^tkn.type  =  tkn.type ;^102^^^^^41^118^[REPLACE] tkn.type = EORECORD;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^} else if   (  isEndOfFile  (  c  )    )   {  ;^103^^^^^41^118^[REPLACE] } else if  ( isEncapsulator ( c )  )  {^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[ADD]^}   encapsulatedTokenLexer ( tkn, c ) ;^103^104^105^106^^41^118^[ADD] else if  ( isEncapsulator ( c )  )  {  encapsulatedTokenLexer ( tkn, c ) ; } else if  ( isEndOfFile ( c )  )  {^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^} else if  ( isEndOfFile ( lastChar )  )  {^106^^^^^41^118^[REPLACE] } else if  ( isEndOfFile ( c )  )  {^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[ADD]^^114^^^^^106^115^[ADD] simpleTokenLexer ( tkn, c ) ;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[ADD]^^110^^^^^41^118^[ADD] tkn.isReady = true;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^}  if  ( isEndOfFile ( lastChar )  )  {^106^^^^^41^118^[REPLACE] } else if  ( isEndOfFile ( c )  )  {^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[ADD]^^98^^^^^41^118^[ADD] tkn.type = TOKEN;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^}  else {^99^^^^^41^118^[REPLACE] } else if  ( eol )  {^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^}  if  ( isEncapsulator ( c )  )  {^103^^^^^41^118^[REPLACE] } else if  ( isEncapsulator ( c )  )  {^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^}  else {^106^^^^^41^118^[REPLACE] } else if  ( isEndOfFile ( c )  )  {^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^tkn.type ;^102^^^^^41^118^[REPLACE] tkn.type = EORECORD;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^}  else {^103^^^^^41^118^[REPLACE] } else if  ( isEncapsulator ( c )  )  {^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REMOVE]^if  ( isEncapsulator ( c )  )  {     encapsulatedTokenLexer ( tkn, c ) ; }else     if  ( isEndOfFile ( c )  )  {         tkn.type = EOF;         tkn.isReady = true;     }else {         simpleTokenLexer ( tkn, c ) ;     }^106^^^^^41^118^[REMOVE] ^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[ADD]^tkn.isReady = true;^109^110^^^^41^118^[ADD] tkn.type = EOF; tkn.isReady = true;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^simpleTokenLexer ( tkn, c )  ;^105^^^^^41^118^[REPLACE] encapsulatedTokenLexer ( tkn, c ) ;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^tkn.type = EOF  ;^98^^^^^41^118^[REPLACE] tkn.type = TOKEN;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^tkn =  nextToken ( null.reset (  )  ) ;^95^^^^^41^118^[REPLACE] tkn = nextToken ( tkn.reset (  )  ) ;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^}  else {^96^^^^^41^118^[REPLACE] } else if  ( isDelimiter ( c )  )  {^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[ADD]^^102^^^^^41^118^[ADD] tkn.type = EORECORD;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^}  if  ( isEndOfFile ( c )  )  {^106^^^^^41^118^[REPLACE] } else if  ( isEndOfFile ( c )  )  {^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^tkn.type = EOF  ;^102^^^^^41^118^[REPLACE] tkn.type = EORECORD;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[ADD]^^109^110^^^^41^118^[ADD] tkn.type = EOF; tkn.isReady = true;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^}  if  ( eol )  {^99^^^^^41^118^[REPLACE] } else if  ( eol )  {^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[ADD]^}   tkn.type = EORECORD;^99^100^^102^^41^118^[ADD] else if  ( eol )  {  tkn.type = EORECORD;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^return tkn;  ;^117^^^^^41^118^[REPLACE] return tkn;^[METHOD] nextToken [TYPE] Token [PARAMETER] Token tkn [CLASS] CSVLexer   [TYPE]  boolean eol  false  true  [TYPE]  Token tkn  [TYPE]  int c  lastChar 
[REPLACE]^if   (  isEscape  (  c  )    )   {  ;^139^^^^^137^166^[REPLACE] if  ( isEndOfLine ( c )  )  {^[METHOD] simpleTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c 
[ADD]^^139^140^141^142^^137^166^[ADD] if  ( isEndOfLine ( c )  )  {  tkn.type = EORECORD; break;^[METHOD] simpleTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c 
[REPLACE]^} else if   (  isDelimiter  (  c  )    )   {  ;^143^^^^^137^166^[REPLACE] } else if  ( isEndOfFile ( c )  )  {^[METHOD] simpleTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c 
[REPLACE]^}  if  ( isDelimiter ( c )  )  {^148^^^^^137^166^[REPLACE] } else if  ( isDelimiter ( c )  )  {^[METHOD] simpleTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c 
[REPLACE]^}  if  ( isEscape ( c )  )  {^152^^^^^137^166^[REPLACE] } else if  ( isEscape ( c )  )  {^[METHOD] simpleTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c 
[REPLACE]^append (  (  ( char )   ( readEscape ( c )  )  )  )  ;^155^^^^^152^156^[REPLACE] tkn.content.append (  ( char )  c ) ;^[METHOD] simpleTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c 
[REPLACE]^append (  (  ( char )   ( c )  )  )  ;^153^^^^^137^166^[REPLACE] tkn.content.append (  ( char )  readEscape ( c )  ) ;^[METHOD] simpleTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c 
[ADD]^^153^^^^^137^166^[ADD] tkn.content.append (  ( char )  readEscape ( c )  ) ;^[METHOD] simpleTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c 
[REPLACE]^( isEndOfFile ( lastChar )  )  ;^153^^^^^137^166^[REPLACE] tkn.content.append (  ( char )  readEscape ( c )  ) ;^[METHOD] simpleTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c 
[REPLACE]^tkn.type = EOF  ;^150^^^^^137^166^[REPLACE] tkn.type = TOKEN;^[METHOD] simpleTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c 
[REPLACE]^}  else {^152^^^^^137^166^[REPLACE] } else if  ( isEscape ( c )  )  {^[METHOD] simpleTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c 
[ADD]^}   tkn.content.append (  ( char )  c ) ;^152^153^154^155^156^137^166^[ADD] else if  ( isEscape ( c )  )  { tkn.content.append (  ( char )  readEscape ( c )  ) ; } else { tkn.content.append (  ( char )  c ) ; }^[METHOD] simpleTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c 
[ADD]^^155^^^^^152^156^[ADD] tkn.content.append (  ( char )  c ) ;^[METHOD] simpleTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c 
[REPLACE]^tkn.type = TOKEN  ;^145^^^^^137^166^[REPLACE] tkn.type = EOF;^[METHOD] simpleTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c 
[REPLACE]^tkn.isReady = false;^146^^^^^137^166^[REPLACE] tkn.isReady = true;^[METHOD] simpleTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c 
[REPLACE]^} else if   (  isEndOfFile  (  c  )    )   {  ;^148^^^^^137^166^[REPLACE] } else if  ( isDelimiter ( c )  )  {^[METHOD] simpleTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c 
[REMOVE]^if  ( isEncapsulator ( c )  )  {     encapsulatedTokenLexer ( tkn, c ) ; }else     if  ( isEndOfFile ( c )  )  {         tkn.type = EOF;         tkn.isReady = true;     }else {         simpleTokenLexer ( tkn, c ) ;     }^148^^^^^137^166^[REMOVE] ^[METHOD] simpleTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c 
[REPLACE]^if   (  isEscape  (  c  )    )   {  ;^152^^^^^137^166^[REPLACE] } else if  ( isEscape ( c )  )  {^[METHOD] simpleTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c 
[ADD]^}   tkn.content.append (  ( char )  readEscape ( c )  ) ;tkn.content.append (  ( char )  c ) ;^152^153^154^155^156^137^166^[ADD] else if  ( isEscape ( c )  )  { tkn.content.append (  ( char )  readEscape ( c )  ) ; } else { tkn.content.append (  ( char )  c ) ; }^[METHOD] simpleTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c 
[REPLACE]^tkn.type  = null ;^141^^^^^137^166^[REPLACE] tkn.type = EORECORD;^[METHOD] simpleTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c 
[REPLACE]^}  else {^148^^^^^137^166^[REPLACE] } else if  ( isDelimiter ( c )  )  {^[METHOD] simpleTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c 
[REMOVE]^(  ( char )   ( readEscape ( c )  )  )  ;^153^^^^^137^166^[REMOVE] ^[METHOD] simpleTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c 
[REMOVE]^if  ( isDelimiter ( c )  )  {     tkn.type = TOKEN;     break; }else     if  ( isEscape ( c )  )  {         append (  (  ( char )   ( readEscape ( c )  )  )  ) ;     }else {         append (  (  ( char )   ( c )  )  ) ;     }^152^^^^^137^166^[REMOVE] ^[METHOD] simpleTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c 
[ADD]^^150^^^^^137^166^[ADD] tkn.type = TOKEN;^[METHOD] simpleTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c 
[ADD]^^145^^^^^137^166^[ADD] tkn.type = EOF;^[METHOD] simpleTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c 
[REPLACE]^c = in.readAgain (  )  ;^158^^^^^137^166^[REPLACE] c = in.read (  ) ;^[METHOD] simpleTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c 
[REPLACE]^if   (  isEscape  (  c  )    )   {  ;^161^^^^^137^166^[REPLACE] if  ( surroundingSpacesIgnored )  {^[METHOD] simpleTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c 
[REPLACE]^( isEndOfFile ( lastChar )  )  ;^162^^^^^137^166^[REPLACE] trimTrailingSpaces ( tkn.content ) ;^[METHOD] simpleTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c 
[REPLACE]^return tkn;  ;^165^^^^^137^166^[REPLACE] return tkn;^[METHOD] simpleTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c 
[REPLACE]^int lastChar = in.readAgain (  )  ;^183^^^^^181^225^[REPLACE] int startLineNumber = getLineNumber (  ) ;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^if   (  isDelimiter  (  c  )    )   {  ;^189^^^^^181^225^[REPLACE] if  ( isEscape ( c )  )  {^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^}  else {^191^^^^^181^225^[REPLACE] } else if  ( isEncapsulator ( c )  )  {^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^}  if  ( isEndOfFile ( c )  )  {^217^^^^^181^225^[REPLACE] } else if  ( isEndOfFile ( c )  )  {^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^append (  (  ( char )   ( readEscape ( c )  )  )  )  ;^222^^^^^217^223^[REPLACE] tkn.content.append (  ( char )  c ) ;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^return ;^219^^^^^181^225^[REPLACE] throw new IOException  (" ")  ;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^throw new IOException (  (  ( " ( line " +  ( getLineNumber (  )  )  )  + " )  invalid char between encapsulated token and delimiter" )  )  ;^219^^^^^181^225^[REPLACE] throw new IOException  (" ")  ;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^if   (  isEscape  (  c  )    )   {  ;^192^^^^^181^225^[REPLACE] if  ( isEncapsulator ( in.lookAhead (  )  )  )  {^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^if   (  isEscape  (  c  )    )   {  ;^200^^^^^192^216^[REPLACE] if  ( isDelimiter ( c )  )  {^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^}  else {^203^^^^^192^216^[REPLACE] } else if  ( isEndOfFile ( c )  )  {^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[ADD]^}   tkn.type = EOF;tkn.isReady = true;return tkn;^203^204^205^206^^192^216^[ADD] else if  ( isEndOfFile ( c )  )  { tkn.type = EOF; tkn.isReady = true; return tkn;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^} else if   (  isDelimiter  (  c  )    )   {  ;^207^^^^^192^216^[REPLACE] } else if  ( isEndOfLine ( c )  )  {^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[ADD]^}   tkn.type = EORECORD;return tkn;^207^208^209^210^^192^216^[ADD] else if  ( isEndOfLine ( c )  )  {  tkn.type = EORECORD; return tkn;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^}  if  ( isWhitespace ( c )  )  {^211^^^^^192^216^[REPLACE] } else if  ( !isWhitespace ( c )  )  {^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^return ;^213^^^^^192^216^[REPLACE] throw new IOException  (" ")  ;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^getLineNumber (  )  ;^213^^^^^192^216^[REPLACE] throw new IOException  (" ")  ;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[ADD]^^213^^^^^192^216^[ADD] throw new IOException  (" ")  ;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^tkn.type  =  tkn.type ;^209^^^^^192^216^[REPLACE] tkn.type = EORECORD;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^return tkn;  ;^210^^^^^192^216^[REPLACE] return tkn;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^throw new IOException (  (  ( " ( startline " + startLineNumber )  + " )  EOF reached before encapsulated token finished" )  )  ;^213^^^^^192^216^[REPLACE] throw new IOException  (" ")  ;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^tkn.type = TOKEN  ;^204^^^^^192^216^[REPLACE] tkn.type = EOF;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^tkn.isReady = false;^205^^^^^192^216^[REPLACE] tkn.isReady = true;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^return tkn;  ;^206^^^^^192^216^[REPLACE] return tkn;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^}  else {^211^^^^^192^216^[REPLACE] } else if  ( !isWhitespace ( c )  )  {^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[ADD]^^209^210^^^^192^216^[ADD] tkn.type = EORECORD; return tkn;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^tkn.type ;^209^^^^^192^216^[REPLACE] tkn.type = EORECORD;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^tkn.type = EOF  ;^201^^^^^192^216^[REPLACE] tkn.type = TOKEN;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^return tkn;  ;^202^^^^^192^216^[REPLACE] return tkn;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[ADD]^}   tkn.isReady = true;return tkn;^203^204^205^206^^192^216^[ADD] else if  ( isEndOfFile ( c )  )  { tkn.type = EOF; tkn.isReady = true; return tkn;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^}  else {^207^^^^^192^216^[REPLACE] } else if  ( isEndOfLine ( c )  )  {^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REMOVE]^if  ( isDelimiter ( c )  )  {     tkn.type = TOKEN;     break; }else     if  ( isEscape ( c )  )  {         append (  (  ( char )   ( readEscape ( c )  )  )  ) ;     }else {         append (  (  ( char )   ( c )  )  ) ;     }^207^^^^^192^216^[REMOVE] ^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REMOVE]^if  ( isEndOfFile ( c )  )  {     tkn.type = EOF;     tkn.isReady = true;     return tkn; }else     if  ( isEndOfLine ( c )  )  {         tkn.type = EORECORD;         return tkn;     }else         if  ( ! ( isWhitespace ( c )  )  )  {             throw new IOException (  (  ( " ( line " +  ( getLineNumber (  )  )  )  + " )  invalid char between encapsulated token and delimiter" )  ) ;         }^211^^^^^192^216^[REMOVE] ^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^tkn.type = EOF  ;^209^^^^^192^216^[REPLACE] tkn.type = EORECORD;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REMOVE]^( isWhitespace ( c )  )  ;^213^^^^^192^216^[REMOVE] ^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[ADD]^}^211^212^213^214^^192^216^[ADD] else if  ( !isWhitespace ( c )  )  {  throw new IOException  (" ")  ; }^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^c = in.readAgain (  )  ;^199^^^^^192^216^[REPLACE] c = in.read (  ) ;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[ADD]^^201^^^^^192^216^[ADD] tkn.type = TOKEN;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[ADD]^return tkn;^209^210^^^^192^216^[ADD] tkn.type = EORECORD; return tkn;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[ADD]^^194^195^^^^181^225^[ADD] c = in.read (  ) ; tkn.content.append (  ( char )  c ) ;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^if   (  isEscape  (  c  )    )   {  ;^200^^^^^181^225^[REPLACE] if  ( isDelimiter ( c )  )  {^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^} else if   (  isDelimiter  (  c  )    )   {  ;^203^^^^^181^225^[REPLACE] } else if  ( isEndOfFile ( c )  )  {^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^}  if  ( isEndOfLine ( c )  )  {^207^^^^^181^225^[REPLACE] } else if  ( isEndOfLine ( c )  )  {^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^} else if  ( isWhitespace ( c )  )  {^211^^^^^181^225^[REPLACE] } else if  ( !isWhitespace ( c )  )  {^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[ADD]^}^211^212^213^214^^181^225^[ADD] else if  ( !isWhitespace ( c )  )  {  throw new IOException  (" ")  ; }^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^throw new IOException (  (  ( " ( startline " + startLineNumber )  + " )  EOF reached before encapsulated token finished" )  )  ;^213^^^^^181^225^[REPLACE] throw new IOException  (" ")  ;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^getLineNumber (  )  ;^213^^^^^181^225^[REPLACE] throw new IOException  (" ")  ;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[ADD]^^209^210^^^^181^225^[ADD] tkn.type = EORECORD; return tkn;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^return tkn;  ;^210^^^^^181^225^[REPLACE] return tkn;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^} else if   (  isEscape  (  c  )    )   {  ;^211^^^^^181^225^[REPLACE] } else if  ( !isWhitespace ( c )  )  {^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^tkn.type = TOKEN  ;^204^^^^^181^225^[REPLACE] tkn.type = EOF;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[ADD]^^205^206^^^^181^225^[ADD] tkn.isReady = true; return tkn;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^return tkn;  ;^206^^^^^181^225^[REPLACE] return tkn;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^return ;^213^^^^^181^225^[REPLACE] throw new IOException  (" ")  ;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^}  else {^211^^^^^181^225^[REPLACE] } else if  ( !isWhitespace ( c )  )  {^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REMOVE]^if  ( isEndOfFile ( c )  )  {     tkn.type = EOF;     tkn.isReady = true;     return tkn; }else     if  ( isEndOfLine ( c )  )  {         tkn.type = EORECORD;         return tkn;     }else         if  ( ! ( isWhitespace ( c )  )  )  {             throw new IOException (  (  ( " ( line " +  ( getLineNumber (  )  )  )  + " )  invalid char between encapsulated token and delimiter" )  ) ;         }^211^^^^^181^225^[REMOVE] ^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[ADD]^^213^^^^^181^225^[ADD] throw new IOException  (" ")  ;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^tkn.isReady = false;^205^^^^^181^225^[REPLACE] tkn.isReady = true;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^tkn.type ;^209^^^^^181^225^[REPLACE] tkn.type = EORECORD;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^tkn.type = EOF  ;^201^^^^^181^225^[REPLACE] tkn.type = TOKEN;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^return tkn;  ;^202^^^^^181^225^[REPLACE] return tkn;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^}  if  ( isEndOfFile ( c )  )  {^203^^^^^181^225^[REPLACE] } else if  ( isEndOfFile ( c )  )  {^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^}  else {^207^^^^^181^225^[REPLACE] } else if  ( isEndOfLine ( c )  )  {^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^}  if  ( isWhitespace ( c )  )  {^211^^^^^181^225^[REPLACE] } else if  ( !isWhitespace ( c )  )  {^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^tkn.type  =  tkn.type ;^209^^^^^181^225^[REPLACE] tkn.type = EORECORD;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[ADD]^^205^^^^^181^225^[ADD] tkn.isReady = true;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[ADD]^}   tkn.type = EORECORD;return tkn;^207^208^209^210^^181^225^[ADD] else if  ( isEndOfLine ( c )  )  {  tkn.type = EORECORD; return tkn;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[ADD]^tkn.content.append (  ( char )  c ) ;^194^195^^^^181^225^[ADD] c = in.read (  ) ; tkn.content.append (  ( char )  c ) ;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^c = in.readAgain (  )  ;^199^^^^^181^225^[REPLACE] c = in.read (  ) ;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[ADD]^^201^202^^^^181^225^[ADD] tkn.type = TOKEN; return tkn;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[ADD]^^204^^^^^181^225^[ADD] tkn.type = EOF;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^tkn.type = EOF  ;^209^^^^^181^225^[REPLACE] tkn.type = EORECORD;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REMOVE]^if  ( isEndOfFile ( c )  )  {     tkn.type = EOF;     tkn.isReady = true;     return tkn; }else     if  ( isEndOfLine ( c )  )  {         tkn.type = EORECORD;         return tkn;     }else         if  ( ! ( isWhitespace ( c )  )  )  {             throw new IOException (  (  ( " ( line " +  ( getLineNumber (  )  )  )  + " )  invalid char between encapsulated token and delimiter" )  ) ;         }^192^^^^^181^225^[REMOVE] ^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^}  if  ( isEndOfFile ( c )  )  {^203^^^^^192^216^[REPLACE] } else if  ( isEndOfFile ( c )  )  {^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^tkn.type  = null ;^209^^^^^192^216^[REPLACE] tkn.type = EORECORD;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^} else if  ( isWhitespace ( c )  )  {^211^^^^^192^216^[REPLACE] } else if  ( !isWhitespace ( c )  )  {^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^c = in.readAgain (  )  ;^194^^^^^181^225^[REPLACE] c = in.read (  ) ;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^}  else {^203^^^^^181^225^[REPLACE] } else if  ( isEndOfFile ( c )  )  {^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^} else if   (  isDelimiter  (  c  )    )   {  ;^207^^^^^181^225^[REPLACE] } else if  ( isEndOfLine ( c )  )  {^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[ADD]^^209^^^^^181^225^[ADD] tkn.type = EORECORD;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[ADD]^return tkn;^201^202^^^^181^225^[ADD] tkn.type = TOKEN; return tkn;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REMOVE]^( isWhitespace ( c )  )  ;^213^^^^^181^225^[REMOVE] ^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[ADD]^^199^^^^^181^225^[ADD] c = in.read (  ) ;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^tkn.type  = null ;^209^^^^^181^225^[REPLACE] tkn.type = EORECORD;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^append (  (  ( char )   ( c )  )  )  ;^190^^^^^181^225^[REPLACE] tkn.content.append (  ( char )  readEscape ( c )  ) ;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^( isEndOfFile ( lastChar )  )  ;^190^^^^^181^225^[REPLACE] tkn.content.append (  ( char )  readEscape ( c )  ) ;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^} else if   (  isEndOfFile  (  c  )    )   {  ;^191^^^^^181^225^[REPLACE] } else if  ( isEncapsulator ( c )  )  {^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REMOVE]^if  ( isEncapsulator ( in.lookAhead (  )  )  )  {     c = in.read (  ) ;     append (  (  ( char )   ( c )  )  ) ; }else {     while  ( true )  {         c = in.read (  ) ;         if  ( isDelimiter ( c )  )  {             tkn.type = TOKEN;             return tkn;         }else             if  ( isEndOfFile ( c )  )  {                 tkn.type = EOF;                 tkn.isReady = true;                 return tkn;             }else                 if  ( isEndOfLine ( c )  )  {                     tkn.type = EORECORD;                     return tkn;                 }else                     if  ( ! ( isWhitespace ( c )  )  )  {                         throw new IOException (  (  ( " ( line " +  ( getLineNumber (  )  )  )  + " )  invalid char between encapsulated token and delimiter" )  ) ;                     }                                            }  }^191^^^^^181^225^[REMOVE] ^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^} else if   (  isDelimiter  (  c  )    )   {  ;^217^^^^^181^225^[REPLACE] } else if  ( isEndOfFile ( c )  )  {^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[ADD]^^209^^^^^192^216^[ADD] tkn.type = EORECORD;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^}  if  ( isEndOfLine ( c )  )  {^207^^^^^192^216^[REPLACE] } else if  ( isEndOfLine ( c )  )  {^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^} else if   (  isEscape  (  c  )    )   {  ;^211^^^^^192^216^[REPLACE] } else if  ( !isWhitespace ( c )  )  {^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[ADD]^^204^^^^^192^216^[ADD] tkn.type = EOF;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REPLACE]^} else if   (  isDelimiter  (  c  )    )   {  ;^203^^^^^192^216^[REPLACE] } else if  ( isEndOfFile ( c )  )  {^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REMOVE]^if  ( eol )  {     tkn.type = EORECORD; }else     if  ( isEncapsulator ( c )  )  {         encapsulatedTokenLexer ( tkn, c ) ;     }else         if  ( isEndOfFile ( c )  )  {             tkn.type = EOF;             tkn.isReady = true;         }else {             simpleTokenLexer ( tkn, c ) ;         }^200^^^^^181^225^[REMOVE] ^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REMOVE]^if  ( isDelimiter ( c )  )  {     tkn.type = TOKEN;     break; }else     if  ( isEscape ( c )  )  {         append (  (  ( char )   ( readEscape ( c )  )  )  ) ;     }else {         append (  (  ( char )   ( c )  )  ) ;     }^207^^^^^181^225^[REMOVE] ^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[ADD]^^201^^^^^181^225^[ADD] tkn.type = TOKEN;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[ADD]^^204^205^^^^181^225^[ADD] tkn.type = EOF; tkn.isReady = true;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[ADD]^^192^193^194^195^^181^225^[ADD] if  ( isEncapsulator ( in.lookAhead (  )  )  )  {  c = in.read (  ) ; tkn.content.append (  ( char )  c ) ;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[ADD]^return tkn;^205^206^^^^192^216^[ADD] tkn.isReady = true; return tkn;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[REMOVE]^append (  (  ( char )   ( readEscape ( c )  )  )  )  ;^222^^^^^217^223^[REMOVE] ^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
[ADD]^^187^^^^^181^225^[ADD] c = in.read (  ) ;^[METHOD] encapsulatedTokenLexer [TYPE] Token [PARAMETER] Token tkn int c [CLASS] CSVLexer   [TYPE]  boolean false  true  [TYPE]  Token tkn  [TYPE]  int c  startLineNumber 
