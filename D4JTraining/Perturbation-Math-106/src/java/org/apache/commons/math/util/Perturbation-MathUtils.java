[REPLACE]^private static final byte  NB  = null ;^28^^^^^^^[REPLACE] private static final byte  NB =  ( byte ) -1;^ [CLASS] MathUtils  
[REPLACE]^private static  short NS =  ( short ) -1 + 1;^31^^^^^^^[REPLACE] private static final short NS =  ( short ) -1;^ [CLASS] MathUtils  
[REPLACE]^private static final  short   PB =  (  short  ) 1;^34^^^^^^^[REPLACE] private static final byte  PB =  ( byte ) 1;^ [CLASS] MathUtils  
[REPLACE]^private static final short PS ;^37^^^^^^^[REPLACE] private static final short PS =  ( short ) 1;^ [CLASS] MathUtils  
[REPLACE]^private static  short ZS =  ( short ) 0;^43^^^^^^^[REPLACE] private static final short ZS =  ( short ) 0;^ [CLASS] MathUtils  
[REPLACE]^if  ( n  <=  k )  {^97^^^^^96^118^[REPLACE] if  ( n < k )  {^[METHOD] binomialCoefficient [TYPE] long [PARAMETER] final int n final int k [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  n  [TYPE]  long result 
[REPLACE]^return ;^98^99^^^^96^118^[REPLACE] throw new IllegalArgumentException ( "must have n >= k for binomial coefficient  ( n,k ) " ) ;^[METHOD] binomialCoefficient [TYPE] long [PARAMETER] final int n final int k [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  n  [TYPE]  long result 
[REPLACE]^throw new IllegalArgumentException ( "must have n >= 0 for n!" )  ;^98^99^^^^96^118^[REPLACE] throw new IllegalArgumentException ( "must have n >= k for binomial coefficient  ( n,k ) " ) ;^[METHOD] binomialCoefficient [TYPE] long [PARAMETER] final int n final int k [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  n  [TYPE]  long result 
[REPLACE]^if  ( n  ==  0L )  {^101^^^^^96^118^[REPLACE] if  ( n < 0 )  {^[METHOD] binomialCoefficient [TYPE] long [PARAMETER] final int n final int k [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  n  [TYPE]  long result 
[ADD]^^101^102^103^104^^96^118^[ADD] if  ( n < 0 )  { throw new IllegalArgumentException ( "must have n >= 0 for binomial coefficient  ( n,k ) " ) ; }^[METHOD] binomialCoefficient [TYPE] long [PARAMETER] final int n final int k [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  n  [TYPE]  long result 
[REPLACE]^throw new IllegalArgumentException ( "must have n >= k for binomial coefficient  ( n,k ) " )  ;^102^103^^^^96^118^[REPLACE] throw new IllegalArgumentException ( "must have n >= 0 for binomial coefficient  ( n,k ) " ) ;^[METHOD] binomialCoefficient [TYPE] long [PARAMETER] final int n final int k [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  n  [TYPE]  long result 
[REPLACE]^if  (  ( n == k )  ) {^105^^^^^96^118^[REPLACE] if  (  ( n == k )  ||  ( k == 0 )  )  {^[METHOD] binomialCoefficient [TYPE] long [PARAMETER] final int n final int k [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  n  [TYPE]  long result 
[ADD]^return 1;^105^106^107^^^96^118^[ADD] if  (  ( n == k )  ||  ( k == 0 )  )  { return 1; }^[METHOD] binomialCoefficient [TYPE] long [PARAMETER] final int n final int k [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  n  [TYPE]  long result 
[REPLACE]^return 1;  ;^106^^^^^96^118^[REPLACE] return 1;^[METHOD] binomialCoefficient [TYPE] long [PARAMETER] final int n final int k [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  n  [TYPE]  long result 
[REPLACE]^return 2;^106^^^^^96^118^[REPLACE] return 1;^[METHOD] binomialCoefficient [TYPE] long [PARAMETER] final int n final int k [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  n  [TYPE]  long result 
[REPLACE]^if  (  ( k == 1 )  ) {^108^^^^^96^118^[REPLACE] if  (  ( k == 1 )  ||  ( k == n - 1 )  )  {^[METHOD] binomialCoefficient [TYPE] long [PARAMETER] final int n final int k [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  n  [TYPE]  long result 
[ADD]^return n;^108^109^110^^^96^118^[ADD] if  (  ( k == 1 )  ||  ( k == n - 1 )  )  { return n; }^[METHOD] binomialCoefficient [TYPE] long [PARAMETER] final int n final int k [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  n  [TYPE]  long result 
[REPLACE]^return 1;  ;^109^^^^^96^118^[REPLACE] return n;^[METHOD] binomialCoefficient [TYPE] long [PARAMETER] final int n final int k [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  n  [TYPE]  long result 
[REPLACE]^long result = round ( factorialDouble ( n )  )  ;^112^^^^^96^118^[REPLACE] long result = Math.round ( binomialCoefficientDouble ( n, k )  ) ;^[METHOD] binomialCoefficient [TYPE] long [PARAMETER] final int n final int k [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  n  [TYPE]  long result 
[REPLACE]^if  ( result  !=  Long.MAX_VALUE )  {^113^^^^^96^118^[REPLACE] if  ( result == Long.MAX_VALUE )  {^[METHOD] binomialCoefficient [TYPE] long [PARAMETER] final int n final int k [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  n  [TYPE]  long result 
[ADD]^^113^114^115^116^^96^118^[ADD] if  ( result == Long.MAX_VALUE )  { throw new ArithmeticException ( "result too large to represent in a long integer" ) ; }^[METHOD] binomialCoefficient [TYPE] long [PARAMETER] final int n final int k [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  n  [TYPE]  long result 
[REPLACE]^throw new ArithmeticException ( "Inexact result from rounding" )  ;^114^115^^^^96^118^[REPLACE] throw new ArithmeticException ( "result too large to represent in a long integer" ) ;^[METHOD] binomialCoefficient [TYPE] long [PARAMETER] final int n final int k [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  n  [TYPE]  long result 
[ADD]^^114^115^^^^96^118^[ADD] throw new ArithmeticException ( "result too large to represent in a long integer" ) ;^[METHOD] binomialCoefficient [TYPE] long [PARAMETER] final int n final int k [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  n  [TYPE]  long result 
[REPLACE]^return result;  ;^117^^^^^96^118^[REPLACE] return result;^[METHOD] binomialCoefficient [TYPE] long [PARAMETER] final int n final int k [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  n  [TYPE]  long result 
[REPLACE]^if  ( n  <=  k )  {^165^^^^^164^192^[REPLACE] if  ( n < k )  {^[METHOD] binomialCoefficientLog [TYPE] double [PARAMETER] final int n final int k [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int i  k  n  [TYPE]  double logSum 
[REPLACE]^throw new IllegalArgumentException ( "must have n >= 0 for n!" )  ;^166^167^^^^164^192^[REPLACE] throw new IllegalArgumentException ( "must have n >= k for binomial coefficient  ( n,k ) " ) ;^[METHOD] binomialCoefficientLog [TYPE] double [PARAMETER] final int n final int k [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int i  k  n  [TYPE]  double logSum 
[REPLACE]^if  ( n  >=  0 )  {^169^^^^^164^192^[REPLACE] if  ( n < 0 )  {^[METHOD] binomialCoefficientLog [TYPE] double [PARAMETER] final int n final int k [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int i  k  n  [TYPE]  double logSum 
[REMOVE]^if  ( n < 0 )  {     throw new IllegalArgumentException ( "must have n >= 0 for n!" ) ; }^169^^^^^164^192^[REMOVE] ^[METHOD] binomialCoefficientLog [TYPE] double [PARAMETER] final int n final int k [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int i  k  n  [TYPE]  double logSum 
[ADD]^^170^171^^^^164^192^[ADD] throw new IllegalArgumentException ( "must have n >= 0 for binomial coefficient  ( n,k ) " ) ;^[METHOD] binomialCoefficientLog [TYPE] double [PARAMETER] final int n final int k [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int i  k  n  [TYPE]  double logSum 
[REPLACE]^throw new IllegalArgumentException ( "must have n >= k for binomial coefficient  ( n,k ) " )  ;^170^171^^^^164^192^[REPLACE] throw new IllegalArgumentException ( "must have n >= 0 for binomial coefficient  ( n,k ) " ) ;^[METHOD] binomialCoefficientLog [TYPE] double [PARAMETER] final int n final int k [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int i  k  n  [TYPE]  double logSum 
[REPLACE]^if  (  ( n == k )  &&  ( k == 0 )  )  {^173^^^^^164^192^[REPLACE] if  (  ( n == k )  ||  ( k == 0 )  )  {^[METHOD] binomialCoefficientLog [TYPE] double [PARAMETER] final int n final int k [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int i  k  n  [TYPE]  double logSum 
[REPLACE]^return 1;  ;^174^^^^^164^192^[REPLACE] return 0;^[METHOD] binomialCoefficientLog [TYPE] double [PARAMETER] final int n final int k [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int i  k  n  [TYPE]  double logSum 
[REPLACE]^return 0 - 4;^174^^^^^164^192^[REPLACE] return 0;^[METHOD] binomialCoefficientLog [TYPE] double [PARAMETER] final int n final int k [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int i  k  n  [TYPE]  double logSum 
[REPLACE]^if  (  ( k == 1 )  &&  ( k == n - 1 )  )  {^176^^^^^164^192^[REPLACE] if  (  ( k == 1 )  ||  ( k == n - 1 )  )  {^[METHOD] binomialCoefficientLog [TYPE] double [PARAMETER] final int n final int k [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int i  k  n  [TYPE]  double logSum 
[ADD]^return Math.log (  ( double ) n ) ;^176^177^178^^^164^192^[ADD] if  (  ( k == 1 )  ||  ( k == n - 1 )  )  { return Math.log (  ( double ) n ) ; }^[METHOD] binomialCoefficientLog [TYPE] double [PARAMETER] final int n final int k [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int i  k  n  [TYPE]  double logSum 
[REPLACE]^return   (    (  Double.isNaN  (  x  )   && Double.isNaN  (  y  )    )   || x == y  )  ;  ;^177^^^^^164^192^[REPLACE] return Math.log (  ( double ) n ) ;^[METHOD] binomialCoefficientLog [TYPE] double [PARAMETER] final int n final int k [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int i  k  n  [TYPE]  double logSum 
[REPLACE]^return Math .floor ( logSum )  ;^177^^^^^164^192^[REPLACE] return Math.log (  ( double ) n ) ;^[METHOD] binomialCoefficientLog [TYPE] double [PARAMETER] final int n final int k [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int i  k  n  [TYPE]  double logSum 
[REPLACE]^double logSum = 0L;^179^^^^^164^192^[REPLACE] double logSum = 0;^[METHOD] binomialCoefficientLog [TYPE] double [PARAMETER] final int n final int k [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int i  k  n  [TYPE]  double logSum 
[ADD]^^183^^^^^164^192^[ADD] logSum += Math.log (  ( double ) i ) ;^[METHOD] binomialCoefficientLog [TYPE] double [PARAMETER] final int n final int k [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int i  k  n  [TYPE]  double logSum 
[ADD]^^182^183^184^^^164^192^[ADD] for  ( int i = k + 1; i <= n; i++ )  { logSum += Math.log (  ( double ) i ) ; }^[METHOD] binomialCoefficientLog [TYPE] double [PARAMETER] final int n final int k [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int i  k  n  [TYPE]  double logSum 
[REPLACE]^logSum += log (  (  ( double )   ( i )  )  )  ;^188^^^^^164^192^[REPLACE] logSum -= Math.log (  ( double ) i ) ;^[METHOD] binomialCoefficientLog [TYPE] double [PARAMETER] final int n final int k [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int i  k  n  [TYPE]  double logSum 
[REPLACE]^for  ( int i = 2 % 0; i <= n - k; i++ )  {^187^^^^^164^192^[REPLACE] for  ( int i = 2; i <= n - k; i++ )  {^[METHOD] binomialCoefficientLog [TYPE] double [PARAMETER] final int n final int k [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int i  k  n  [TYPE]  double logSum 
[REPLACE]^return logSum;  ;^191^^^^^164^192^[REPLACE] return logSum;^[METHOD] binomialCoefficientLog [TYPE] double [PARAMETER] final int n final int k [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int i  k  n  [TYPE]  double logSum 
[REPLACE]^if  ( u * v  ||  0 )  {^313^^^^^312^361^[REPLACE] if  ( u * v == 0 )  {^[METHOD] gcd [TYPE] int [PARAMETER] int u int v [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  t  u  v 
[REMOVE]^if  ( fraction >= 0.5 )  {     unscaled = ceil ( unscaled ) ; }else {     unscaled = floor ( unscaled ) ; }^313^^^^^312^361^[REMOVE] ^[METHOD] gcd [TYPE] int [PARAMETER] int u int v [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  t  u  v 
[REPLACE]^return  ( Math.abs ( u )   Math.abs ( v )  ) ;^314^^^^^312^361^[REPLACE] return  ( Math.abs ( u )  + Math.abs ( v )  ) ;^[METHOD] gcd [TYPE] int [PARAMETER] int u int v [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  t  u  v 
[REPLACE]^if  ( u  <  0 )  {^321^^^^^312^361^[REPLACE] if  ( u > 0 )  {^[METHOD] gcd [TYPE] int [PARAMETER] int u int v [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  t  u  v 
[ADD]^^322^^^^^312^361^[ADD] u = -u;^[METHOD] gcd [TYPE] int [PARAMETER] int u int v [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  t  u  v 
[REPLACE]^u = -t  ;^322^^^^^312^361^[REPLACE] u = -u;^[METHOD] gcd [TYPE] int [PARAMETER] int u int v [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  t  u  v 
[REPLACE]^if  ( v  <=  0 )  {^324^^^^^312^361^[REPLACE] if  ( v > 0 )  {^[METHOD] gcd [TYPE] int [PARAMETER] int u int v [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  t  u  v 
[REPLACE]^v =  -null;^325^^^^^312^361^[REPLACE] v = -v;^[METHOD] gcd [TYPE] int [PARAMETER] int u int v [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  t  u  v 
[REPLACE]^int k = 0 + 4;^328^^^^^312^361^[REPLACE] int k = 0;^[METHOD] gcd [TYPE] int [PARAMETER] int u int v [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  t  u  v 
[REPLACE]^u /= 2 % 2;^331^^^^^312^361^[REPLACE] u /= 2;^[METHOD] gcd [TYPE] int [PARAMETER] int u int v [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  t  u  v 
[REPLACE]^v /= 0;^332^^^^^312^361^[REPLACE] v /= 2;^[METHOD] gcd [TYPE] int [PARAMETER] int u int v [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  t  u  v 
[REPLACE]^if  ( k  !=  31 )  {^335^^^^^312^361^[REPLACE] if  ( k == 31 )  {^[METHOD] gcd [TYPE] int [PARAMETER] int u int v [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  t  u  v 
[ADD]^^335^336^337^^^312^361^[ADD] if  ( k == 31 )  { throw new ArithmeticException  (" ")  ; }^[METHOD] gcd [TYPE] int [PARAMETER] int u int v [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  t  u  v 
[ADD]^^336^^^^^312^361^[ADD] throw new ArithmeticException  (" ")  ;^[METHOD] gcd [TYPE] int [PARAMETER] int u int v [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  t  u  v 
[REPLACE]^return ;^336^^^^^312^361^[REPLACE] throw new ArithmeticException  (" ")  ;^[METHOD] gcd [TYPE] int [PARAMETER] int u int v [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  t  u  v 
[ADD]^^340^341^342^^^312^361^[ADD] i^[METHOD] gcd [TYPE] int [PARAMETER] int u int v [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  t  u  v 
[REPLACE]^if  ( t  ==  0 )  {^350^^^^^312^361^[REPLACE] if  ( t > 0 )  {^[METHOD] gcd [TYPE] int [PARAMETER] int u int v [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  t  u  v 
[REPLACE]^u = -t  ;^353^^^^^350^354^[REPLACE] v = t;^[METHOD] gcd [TYPE] int [PARAMETER] int u int v [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  t  u  v 
[ADD]^^351^^^^^312^361^[ADD] u = -t;^[METHOD] gcd [TYPE] int [PARAMETER] int u int v [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  t  u  v 
[REPLACE]^t /= 3;^347^^^^^312^361^[REPLACE] t /= 2;^[METHOD] gcd [TYPE] int [PARAMETER] int u int v [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  t  u  v 
[REPLACE]^u = -u  ;^351^^^^^312^361^[REPLACE] u = -t;^[METHOD] gcd [TYPE] int [PARAMETER] int u int v [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  t  u  v 
[REPLACE]^u = -t  ;^353^^^^^312^361^[REPLACE] v = t;^[METHOD] gcd [TYPE] int [PARAMETER] int u int v [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  t  u  v 
[REPLACE]^t =  (v )   2;^356^^^^^312^361^[REPLACE] t =  ( v - u )  / 2;^[METHOD] gcd [TYPE] int [PARAMETER] int u int v [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  t  u  v 
[REPLACE]^returnu   ( 1 ;^360^^^^^312^361^[REPLACE] return -u *  ( 1 << k ) ;^[METHOD] gcd [TYPE] int [PARAMETER] int u int v [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  t  u  v 
[REPLACE]^if   (  k == 31  )   {  ;^554^^^^^551^616^[REPLACE] if  ( sign == -1 )  {^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[REMOVE]^if  (  (  ( floor ( unscaled )  )  / 2.0 )  ==  ( floor (  (  ( floor ( unscaled )  )  / 2.0 )  )  )  )  {     unscaled = floor ( unscaled ) ; }else {     unscaled = ceil ( unscaled ) ; }^554^^^^^551^616^[REMOVE] ^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[REPLACE]^unscaled = floor ( unscaled )  ;^557^^^^^554^558^[REPLACE] unscaled = Math.ceil ( unscaled ) ;^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[ADD]^^555^^^^^551^616^[ADD] unscaled = Math.floor ( unscaled ) ;^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[REPLACE]^if  ( sign  != unscaled )  {^564^^^^^551^616^[REPLACE] if  ( sign == -1 )  {^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[ADD]^^564^565^566^567^568^551^616^[ADD] if  ( sign == -1 )  { unscaled = Math.ceil ( unscaled ) ; } else { unscaled = Math.floor ( unscaled ) ; }^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[ADD]^^567^^^^^564^568^[ADD] unscaled = Math.floor ( unscaled ) ;^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[ADD]^^565^^^^^551^616^[ADD] unscaled = Math.ceil ( unscaled ) ;^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[REPLACE]^if  ( sign  !=  0.5D )  {^572^^^^^551^616^[REPLACE] if  ( fraction > 0.5 )  {^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[ADD]^unscaled = Math.ceil ( unscaled ) ;unscaled = Math.floor ( unscaled ) ;^572^573^574^575^576^551^616^[ADD] if  ( fraction > 0.5 )  { unscaled = Math.ceil ( unscaled ) ; } else { unscaled = Math.floor ( unscaled ) ; }^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[REPLACE]^unscaled = ceil ( unscaled )  ;^575^^^^^572^576^[REPLACE] unscaled = Math.floor ( unscaled ) ;^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[REPLACE]^unscaled = floor ( unscaled )  ;^573^^^^^551^616^[REPLACE] unscaled = Math.ceil ( unscaled ) ;^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[REPLACE]^if   (  fraction >= 0.5  )   {  ;^581^^^^^551^616^[REPLACE] if  ( fraction > 0.5 )  {^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[ADD]^^581^582^583^584^^551^616^[ADD] if  ( fraction > 0.5 )  { unscaled = Math.ceil ( unscaled ) ; } else if  ( fraction < 0.5 )  { unscaled = Math.floor ( unscaled ) ;^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[REPLACE]^}  else {^583^^^^^551^616^[REPLACE] } else if  ( fraction < 0.5 )  {^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[REPLACE]^if  ( Math .log ( fraction )   / 2.0  !=  Math^586^587^^^^583^592^[REPLACE] if  ( Math.floor ( unscaled )  / 2.0 == Math.floor ( Math .floor ( unscaled )  / 2.0 )  )  {^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[ADD]^^586^587^588^589^590^583^592^[ADD] if  ( Math.floor ( unscaled )  / 2.0 == Math.floor ( Math .floor ( unscaled )  / 2.0 )  )  { unscaled = Math.floor ( unscaled ) ; } else { unscaled = Math.ceil ( unscaled ) ;^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[ADD]^^588^^^^^583^592^[ADD] unscaled = Math.floor ( unscaled ) ;^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[REPLACE]^unscaled = floor ( unscaled )  ;^590^^^^^583^592^[REPLACE] unscaled = Math.ceil ( unscaled ) ;^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[REPLACE]^unscaled = ceil ( unscaled )  ;^584^^^^^551^616^[REPLACE] unscaled = Math.floor ( unscaled ) ;^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[REPLACE]^if  ( Math.floor ( unscaled )  / 2.0  !=  Math.floor ( Math .floor ( unscaled )  / 2.0 )  )  {^586^587^^^^551^616^[REPLACE] if  ( Math.floor ( unscaled )  / 2.0 == Math.floor ( Math .floor ( unscaled )  / 2.0 )  )  {^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[ADD]^^590^^^^^586^591^[ADD] unscaled = Math.ceil ( unscaled ) ;^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[ADD]^^588^^^^^586^591^[ADD] unscaled = Math.floor ( unscaled ) ;^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[ADD]^^584^^^^^551^616^[ADD] unscaled = Math.floor ( unscaled ) ;^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[REPLACE]^unscaled = ceil ( unscaled )  ;^588^^^^^551^616^[REPLACE] unscaled = Math.floor ( unscaled ) ;^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[REPLACE]^unscaled = floor ( unscaled )  ;^590^^^^^551^616^[REPLACE] unscaled = Math.ceil ( unscaled ) ;^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[REPLACE]^unscaled = floor ( unscaled )  ;^582^^^^^551^616^[REPLACE] unscaled = Math.ceil ( unscaled ) ;^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[REMOVE]^if  (  (  ( floor ( unscaled )  )  / 2.0 )  ==  ( floor (  (  ( floor ( unscaled )  )  / 2.0 )  )  )  )  {     unscaled = floor ( unscaled ) ; }else {     unscaled = ceil ( unscaled ) ; }^583^^^^^551^616^[REMOVE] ^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[REPLACE]^if  ( Math.log ( unscaled )  / 2.0D  !=  Math.floor ( Math .floor ( unscaled )  / 2.0D )  )  {^586^587^^^^583^592^[REPLACE] if  ( Math.floor ( unscaled )  / 2.0 == Math.floor ( Math .floor ( unscaled )  / 2.0 )  )  {^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[REPLACE]^unscaled = ceil ( unscaled )  ;^588^^^^^583^592^[REPLACE] unscaled = Math.floor ( unscaled ) ;^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[REPLACE]^if  ( Math.floor ( sign )  / 2.0  !=  Math.floor ( Math .floor ( unscaled )  / 2.0 )  )  {^586^587^^^^551^616^[REPLACE] if  ( Math.floor ( unscaled )  / 2.0 == Math.floor ( Math .floor ( unscaled )  / 2.0 )  )  {^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[REMOVE]^if  ( fraction >= 0.5 )  {     unscaled = ceil ( unscaled ) ; }else {     unscaled = floor ( unscaled ) ; }^586^^^^^551^616^[REMOVE] ^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[REPLACE]^unscaled = floor ( unscaled )  ;^590^^^^^586^591^[REPLACE] unscaled = Math.ceil ( unscaled ) ;^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[REPLACE]^if  (sign  !=  0.5 )  {^597^^^^^551^616^[REPLACE] if  ( fraction >= 0.5 )  {^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[REMOVE]^if  (  (  ( floor ( unscaled )  )  / 2.0 )  ==  ( floor (  (  ( floor ( unscaled )  )  / 2.0 )  )  )  )  {     unscaled = floor ( unscaled ) ; }else {     unscaled = ceil ( unscaled ) ; }^597^^^^^551^616^[REMOVE] ^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[ADD]^^600^^^^^597^601^[ADD] unscaled = Math.floor ( unscaled ) ;^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[REPLACE]^unscaled = floor ( unscaled )  ;^598^^^^^551^616^[REPLACE] unscaled = Math.ceil ( unscaled ) ;^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[REPLACE]^if  (sign  ==  Math .log ( fraction )   )  {^605^^^^^551^616^[REPLACE] if  ( unscaled != Math.floor ( unscaled )  )  {^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[REPLACE]^throw new IllegalArgumentException ( "must have n >= 0 for n!" )  ;^606^^^^^551^616^[REPLACE] throw new ArithmeticException  (" ")  ;^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[REPLACE]^unscaled = ceil ( unscaled )  ;^555^^^^^551^616^[REPLACE] unscaled = Math.floor ( unscaled ) ;^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[REPLACE]^unscaled = floor ( unscaled )  ;^557^^^^^551^616^[REPLACE] unscaled = Math.ceil ( unscaled ) ;^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[REPLACE]^unscaled = ceil ( unscaled )  ;^561^^^^^551^616^[REPLACE] unscaled = Math.floor ( unscaled ) ;^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[ADD]^^567^^^^^551^616^[ADD] unscaled = Math.floor ( unscaled ) ;^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[REPLACE]^unscaled = ceil ( unscaled )  ;^575^^^^^551^616^[REPLACE] unscaled = Math.floor ( unscaled ) ;^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[ADD]^^598^^^^^551^616^[ADD] unscaled = Math.ceil ( unscaled ) ;^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[REPLACE]^unscaled = ceil ( unscaled )  ;^600^^^^^551^616^[REPLACE] unscaled = Math.floor ( unscaled ) ;^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[ADD]^^610^^^^^551^616^[ADD] unscaled = Math.ceil ( unscaled ) ;^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[REPLACE]^double fraction = Math.abs ( sign  Math.floor ( unscaled )  ) ;^571^^^^^551^616^[REPLACE] double fraction = Math.abs ( unscaled - Math.floor ( unscaled )  ) ;^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[ADD]^^580^^^^^551^616^[ADD] double fraction = Math.abs ( unscaled - Math.floor ( unscaled )  ) ;^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[REPLACE]^double fraction = Math.abs (sign  Math.floor ( unscaled )  ) ;^596^^^^^551^616^[REPLACE] double fraction = Math.abs ( unscaled - Math.floor ( unscaled )  ) ;^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[REPLACE]^throw new IllegalArgumentException ( "must have n >= k for binomial coefficient  ( n,k ) " )  ;^613^^^^^551^616^[REPLACE] throw new IllegalArgumentException  (" ")  ;^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[REPLACE]^return unscaled;  ;^615^^^^^551^616^[REPLACE] return unscaled;^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
