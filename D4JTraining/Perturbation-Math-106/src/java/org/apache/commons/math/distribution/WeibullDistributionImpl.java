[REPLACE]^private static final long serialVersionUID ;^32^^^^^^^[REPLACE] private static final long serialVersionUID = 8589540077390120676L;^ [CLASS] WeibullDistributionImpl  
[REPLACE]^setShape ( alpha ) ;^47^^^^^46^50^[REPLACE] super (  ) ;^[METHOD] <init> [TYPE] WeibullDistributionImpl(double,double) [PARAMETER] double alpha double beta [CLASS] WeibullDistributionImpl   [TYPE]  double alpha  beta  [TYPE]  long serialVersionUID  [TYPE]  boolean false  true 
[ADD]^^47^48^^^^46^50^[ADD] super (  ) ; setShape ( alpha ) ;^[METHOD] <init> [TYPE] WeibullDistributionImpl(double,double) [PARAMETER] double alpha double beta [CLASS] WeibullDistributionImpl   [TYPE]  double alpha  beta  [TYPE]  long serialVersionUID  [TYPE]  boolean false  true 
[REPLACE]^setShape ( beta ) ;^48^^^^^46^50^[REPLACE] setShape ( alpha ) ;^[METHOD] <init> [TYPE] WeibullDistributionImpl(double,double) [PARAMETER] double alpha double beta [CLASS] WeibullDistributionImpl   [TYPE]  double alpha  beta  [TYPE]  long serialVersionUID  [TYPE]  boolean false  true 
[REPLACE]^setScale ( alpha ) ;^49^^^^^46^50^[REPLACE] setScale ( beta ) ;^[METHOD] <init> [TYPE] WeibullDistributionImpl(double,double) [PARAMETER] double alpha double beta [CLASS] WeibullDistributionImpl   [TYPE]  double alpha  beta  [TYPE]  long serialVersionUID  [TYPE]  boolean false  true 
[REPLACE]^if  ( x  <  0.0 )  {^59^^^^^57^65^[REPLACE] if  ( x <= 0.0 )  {^[METHOD] cumulativeProbability [TYPE] double [PARAMETER] double x [CLASS] WeibullDistributionImpl   [TYPE]  double alpha  beta  ret  x  [TYPE]  long serialVersionUID  [TYPE]  boolean false  true 
[REPLACE]^ret = 1.0  |  Math.exp (  | Math.pow ( x / getScale (  ) , getShape (  )  )  ) ;^62^^^^^57^65^[REPLACE] ret = 1.0 - Math.exp ( -Math.pow ( x / getScale (  ) , getShape (  )  )  ) ;^[METHOD] cumulativeProbability [TYPE] double [PARAMETER] double x [CLASS] WeibullDistributionImpl   [TYPE]  double alpha  beta  ret  x  [TYPE]  long serialVersionUID  [TYPE]  boolean false  true 
[ADD]^^62^^^^^57^65^[ADD] ret = 1.0 - Math.exp ( -Math.pow ( x / getScale (  ) , getShape (  )  )  ) ;^[METHOD] cumulativeProbability [TYPE] double [PARAMETER] double x [CLASS] WeibullDistributionImpl   [TYPE]  double alpha  beta  ret  x  [TYPE]  long serialVersionUID  [TYPE]  boolean false  true 
[REPLACE]^ret = 0.0D;^60^^^^^57^65^[REPLACE] ret = 0.0;^[METHOD] cumulativeProbability [TYPE] double [PARAMETER] double x [CLASS] WeibullDistributionImpl   [TYPE]  double alpha  beta  ret  x  [TYPE]  long serialVersionUID  [TYPE]  boolean false  true 
[REPLACE]^ret = 1.0  ^  Math.exp (  ^ Math.pow ( x / getScale (  ) , getShape (  )  )  ) ;^62^^^^^57^65^[REPLACE] ret = 1.0 - Math.exp ( -Math.pow ( x / getScale (  ) , getShape (  )  )  ) ;^[METHOD] cumulativeProbability [TYPE] double [PARAMETER] double x [CLASS] WeibullDistributionImpl   [TYPE]  double alpha  beta  ret  x  [TYPE]  long serialVersionUID  [TYPE]  boolean false  true 
[REPLACE]^return beta;^64^^^^^57^65^[REPLACE] return ret;^[METHOD] cumulativeProbability [TYPE] double [PARAMETER] double x [CLASS] WeibullDistributionImpl   [TYPE]  double alpha  beta  ret  x  [TYPE]  long serialVersionUID  [TYPE]  boolean false  true 
[REPLACE]^return Double.MAX_VALUE;^72^^^^^71^73^[REPLACE] return alpha;^[METHOD] getShape [TYPE] double [PARAMETER] [CLASS] WeibullDistributionImpl   [TYPE]  double alpha  beta  ret  x  [TYPE]  long serialVersionUID  [TYPE]  boolean false  true 
[REPLACE]^return ret;^80^^^^^79^81^[REPLACE] return beta;^[METHOD] getScale [TYPE] double [PARAMETER] [CLASS] WeibullDistributionImpl   [TYPE]  double alpha  beta  ret  x  [TYPE]  long serialVersionUID  [TYPE]  boolean false  true 
[REPLACE]^if  ( p < 0.0D && p > 1.0 )  {^97^^^^^95^108^[REPLACE] if  ( p < 0.0 || p > 1.0 )  {^[METHOD] inverseCumulativeProbability [TYPE] double [PARAMETER] double p [CLASS] WeibullDistributionImpl   [TYPE]  double alpha  beta  p  ret  x  [TYPE]  long serialVersionUID  [TYPE]  boolean false  true 
[REPLACE]^}  else {^100^^^^^95^108^[REPLACE] } else if  ( p == 0 )  {^[METHOD] inverseCumulativeProbability [TYPE] double [PARAMETER] double p [CLASS] WeibullDistributionImpl   [TYPE]  double alpha  beta  p  ret  x  [TYPE]  long serialVersionUID  [TYPE]  boolean false  true 
[REPLACE]^}  else {^102^^^^^95^108^[REPLACE] } else  if  ( p == 1 )  {^[METHOD] inverseCumulativeProbability [TYPE] double [PARAMETER] double p [CLASS] WeibullDistributionImpl   [TYPE]  double alpha  beta  p  ret  x  [TYPE]  long serialVersionUID  [TYPE]  boolean false  true 
[REPLACE]^ret =ret (  )   ;^105^^^^^95^108^[REPLACE] ret = getScale (  )  * Math.pow ( -Math.log ( 1.0 - p ) , 1.0 / getShape (  )  ) ;^[METHOD] inverseCumulativeProbability [TYPE] double [PARAMETER] double p [CLASS] WeibullDistributionImpl   [TYPE]  double alpha  beta  p  ret  x  [TYPE]  long serialVersionUID  [TYPE]  boolean false  true 
[REPLACE]^ret  =  ret ;^103^^^^^95^108^[REPLACE] ret = Double.POSITIVE_INFINITY;^[METHOD] inverseCumulativeProbability [TYPE] double [PARAMETER] double p [CLASS] WeibullDistributionImpl   [TYPE]  double alpha  beta  p  ret  x  [TYPE]  long serialVersionUID  [TYPE]  boolean false  true 
[ADD]^^103^^^^^95^108^[ADD] ret = Double.POSITIVE_INFINITY;^[METHOD] inverseCumulativeProbability [TYPE] double [PARAMETER] double p [CLASS] WeibullDistributionImpl   [TYPE]  double alpha  beta  p  ret  x  [TYPE]  long serialVersionUID  [TYPE]  boolean false  true 
[REPLACE]^ret ;^103^^^^^95^108^[REPLACE] ret = Double.POSITIVE_INFINITY;^[METHOD] inverseCumulativeProbability [TYPE] double [PARAMETER] double p [CLASS] WeibullDistributionImpl   [TYPE]  double alpha  beta  p  ret  x  [TYPE]  long serialVersionUID  [TYPE]  boolean false  true 
[REPLACE]^ret = getScale (  )   ;^105^^^^^95^108^[REPLACE] ret = getScale (  )  * Math.pow ( -Math.log ( 1.0 - p ) , 1.0 / getShape (  )  ) ;^[METHOD] inverseCumulativeProbability [TYPE] double [PARAMETER] double p [CLASS] WeibullDistributionImpl   [TYPE]  double alpha  beta  p  ret  x  [TYPE]  long serialVersionUID  [TYPE]  boolean false  true 
[ADD]^^105^^^^^95^108^[ADD] ret = getScale (  )  * Math.pow ( -Math.log ( 1.0 - p ) , 1.0 / getShape (  )  ) ;^[METHOD] inverseCumulativeProbability [TYPE] double [PARAMETER] double p [CLASS] WeibullDistributionImpl   [TYPE]  double alpha  beta  p  ret  x  [TYPE]  long serialVersionUID  [TYPE]  boolean false  true 
[REPLACE]^ret = 0.0D;^101^^^^^95^108^[REPLACE] ret = 0.0;^[METHOD] inverseCumulativeProbability [TYPE] double [PARAMETER] double p [CLASS] WeibullDistributionImpl   [TYPE]  double alpha  beta  p  ret  x  [TYPE]  long serialVersionUID  [TYPE]  boolean false  true 
[ADD]^^101^^^^^95^108^[ADD] ret = 0.0;^[METHOD] inverseCumulativeProbability [TYPE] double [PARAMETER] double p [CLASS] WeibullDistributionImpl   [TYPE]  double alpha  beta  p  ret  x  [TYPE]  long serialVersionUID  [TYPE]  boolean false  true 
[REPLACE]^} else  if  ( p  &&  1 )  {^102^^^^^95^108^[REPLACE] } else  if  ( p == 1 )  {^[METHOD] inverseCumulativeProbability [TYPE] double [PARAMETER] double p [CLASS] WeibullDistributionImpl   [TYPE]  double alpha  beta  p  ret  x  [TYPE]  long serialVersionUID  [TYPE]  boolean false  true 
[REPLACE]^ret  = null ;^103^^^^^95^108^[REPLACE] ret = Double.POSITIVE_INFINITY;^[METHOD] inverseCumulativeProbability [TYPE] double [PARAMETER] double p [CLASS] WeibullDistributionImpl   [TYPE]  double alpha  beta  p  ret  x  [TYPE]  long serialVersionUID  [TYPE]  boolean false  true 
[REPLACE]^throw new IllegalArgumentException ( "Shape must be positive." ) ; ;^98^99^^^^95^108^[REPLACE] throw new IllegalArgumentException ( "probability argument must be between 0 and 1  ( inclusive ) " ) ;^[METHOD] inverseCumulativeProbability [TYPE] double [PARAMETER] double p [CLASS] WeibullDistributionImpl   [TYPE]  double alpha  beta  p  ret  x  [TYPE]  long serialVersionUID  [TYPE]  boolean false  true 
[REPLACE]^} else if  ( p  && alpha )  {^100^^^^^95^108^[REPLACE] } else if  ( p == 0 )  {^[METHOD] inverseCumulativeProbability [TYPE] double [PARAMETER] double p [CLASS] WeibullDistributionImpl   [TYPE]  double alpha  beta  p  ret  x  [TYPE]  long serialVersionUID  [TYPE]  boolean false  true 
[ADD]^}   ret = Double.POSITIVE_INFINITY;^100^101^102^103^^95^108^[ADD] else if  ( p == 0 )  { ret = 0.0; } else  if  ( p == 1 )  { ret = Double.POSITIVE_INFINITY;^[METHOD] inverseCumulativeProbability [TYPE] double [PARAMETER] double p [CLASS] WeibullDistributionImpl   [TYPE]  double alpha  beta  p  ret  x  [TYPE]  long serialVersionUID  [TYPE]  boolean false  true 
[REPLACE]^} else  if  ( alpha  &&  0 )  {^102^^^^^95^108^[REPLACE] } else  if  ( p == 1 )  {^[METHOD] inverseCumulativeProbability [TYPE] double [PARAMETER] double p [CLASS] WeibullDistributionImpl   [TYPE]  double alpha  beta  p  ret  x  [TYPE]  long serialVersionUID  [TYPE]  boolean false  true 
[REPLACE]^ret = 4.0d;^101^^^^^95^108^[REPLACE] ret = 0.0;^[METHOD] inverseCumulativeProbability [TYPE] double [PARAMETER] double p [CLASS] WeibullDistributionImpl   [TYPE]  double alpha  beta  p  ret  x  [TYPE]  long serialVersionUID  [TYPE]  boolean false  true 
[REPLACE]^}   if  ( p  ||  1 )  {^102^^^^^95^108^[REPLACE] } else  if  ( p == 1 )  {^[METHOD] inverseCumulativeProbability [TYPE] double [PARAMETER] double p [CLASS] WeibullDistributionImpl   [TYPE]  double alpha  beta  p  ret  x  [TYPE]  long serialVersionUID  [TYPE]  boolean false  true 
[REMOVE]^if  ( p == 0 )  {     ret = 0.0; }else     if  ( p == 1 )  {         ret = POSITIVE_INFINITY;     }else {         ret =  ( getScale (  )  )  *  ( pow (  ( - ( log (  ( 1.0 - p )  )  )  ) ,  ( 1.0 /  ( getShape (  )  )  )  )  ) ;     }^102^^^^^95^108^[REMOVE] ^[METHOD] inverseCumulativeProbability [TYPE] double [PARAMETER] double p [CLASS] WeibullDistributionImpl   [TYPE]  double alpha  beta  p  ret  x  [TYPE]  long serialVersionUID  [TYPE]  boolean false  true 
[REPLACE]^ret = 3.0d;^101^^^^^95^108^[REPLACE] ret = 0.0;^[METHOD] inverseCumulativeProbability [TYPE] double [PARAMETER] double p [CLASS] WeibullDistributionImpl   [TYPE]  double alpha  beta  p  ret  x  [TYPE]  long serialVersionUID  [TYPE]  boolean false  true 
[ADD]^^98^99^^^^95^108^[ADD] throw new IllegalArgumentException ( "probability argument must be between 0 and 1  ( inclusive ) " ) ;^[METHOD] inverseCumulativeProbability [TYPE] double [PARAMETER] double p [CLASS] WeibullDistributionImpl   [TYPE]  double alpha  beta  p  ret  x  [TYPE]  long serialVersionUID  [TYPE]  boolean false  true 
[REPLACE]^return beta;^107^^^^^95^108^[REPLACE] return ret;^[METHOD] inverseCumulativeProbability [TYPE] double [PARAMETER] double p [CLASS] WeibullDistributionImpl   [TYPE]  double alpha  beta  p  ret  x  [TYPE]  long serialVersionUID  [TYPE]  boolean false  true 
[REPLACE]^if  ( p  ==  0.0 )  {^115^^^^^114^120^[REPLACE] if  ( alpha <= 0.0 )  {^[METHOD] setShape [TYPE] void [PARAMETER] double alpha [CLASS] WeibullDistributionImpl   [TYPE]  double alpha  beta  p  ret  x  [TYPE]  long serialVersionUID  [TYPE]  boolean false  true 
[ADD]^^115^116^117^118^^114^120^[ADD] if  ( alpha <= 0.0 )  { throw new IllegalArgumentException ( "Shape must be positive." ) ; }^[METHOD] setShape [TYPE] void [PARAMETER] double alpha [CLASS] WeibullDistributionImpl   [TYPE]  double alpha  beta  p  ret  x  [TYPE]  long serialVersionUID  [TYPE]  boolean false  true 
[REPLACE]^return ;^116^117^^^^114^120^[REPLACE] throw new IllegalArgumentException ( "Shape must be positive." ) ;^[METHOD] setShape [TYPE] void [PARAMETER] double alpha [CLASS] WeibullDistributionImpl   [TYPE]  double alpha  beta  p  ret  x  [TYPE]  long serialVersionUID  [TYPE]  boolean false  true 
[ADD]^^116^117^^^^114^120^[ADD] throw new IllegalArgumentException ( "Shape must be positive." ) ;^[METHOD] setShape [TYPE] void [PARAMETER] double alpha [CLASS] WeibullDistributionImpl   [TYPE]  double alpha  beta  p  ret  x  [TYPE]  long serialVersionUID  [TYPE]  boolean false  true 
[REPLACE]^this.alpha =  p;^119^^^^^114^120^[REPLACE] this.alpha = alpha;^[METHOD] setShape [TYPE] void [PARAMETER] double alpha [CLASS] WeibullDistributionImpl   [TYPE]  double alpha  beta  p  ret  x  [TYPE]  long serialVersionUID  [TYPE]  boolean false  true 
[REPLACE]^if  ( beta  >  0.0 )  {^127^^^^^126^132^[REPLACE] if  ( beta <= 0.0 )  {^[METHOD] setScale [TYPE] void [PARAMETER] double beta [CLASS] WeibullDistributionImpl   [TYPE]  double alpha  beta  p  ret  x  [TYPE]  long serialVersionUID  [TYPE]  boolean false  true 
[REPLACE]^throw new IllegalArgumentException ( "Shape must be positive." ) ; ;^128^129^^^^126^132^[REPLACE] throw new IllegalArgumentException ( "Scale must be positive." ) ;^[METHOD] setScale [TYPE] void [PARAMETER] double beta [CLASS] WeibullDistributionImpl   [TYPE]  double alpha  beta  p  ret  x  [TYPE]  long serialVersionUID  [TYPE]  boolean false  true 
[REPLACE]^this.beta =  null;^131^^^^^126^132^[REPLACE] this.beta = beta;^[METHOD] setScale [TYPE] void [PARAMETER] double beta [CLASS] WeibullDistributionImpl   [TYPE]  double alpha  beta  p  ret  x  [TYPE]  long serialVersionUID  [TYPE]  boolean false  true 
[ADD]^^131^^^^^126^132^[ADD] this.beta = beta;^[METHOD] setScale [TYPE] void [PARAMETER] double beta [CLASS] WeibullDistributionImpl   [TYPE]  double alpha  beta  p  ret  x  [TYPE]  long serialVersionUID  [TYPE]  boolean false  true 
[REPLACE]^return 0.0D;^144^^^^^143^145^[REPLACE] return 0.0;^[METHOD] getDomainLowerBound [TYPE] double [PARAMETER] double p [CLASS] WeibullDistributionImpl   [TYPE]  double alpha  beta  p  ret  x  [TYPE]  long serialVersionUID  [TYPE]  boolean false  true 
[REPLACE]^return alpha;^157^^^^^156^158^[REPLACE] return Double.MAX_VALUE;^[METHOD] getDomainUpperBound [TYPE] double [PARAMETER] double p [CLASS] WeibullDistributionImpl   [TYPE]  double alpha  beta  p  ret  x  [TYPE]  long serialVersionUID  [TYPE]  boolean false  true 
[REPLACE]^return   2.0   , 1.0 / getShape (  )  ) ;^170^^^^^168^171^[REPLACE] return Math.pow ( getScale (  )  * Math.log ( 2.0 ) , 1.0 / getShape (  )  ) ;^[METHOD] getInitialDomain [TYPE] double [PARAMETER] double p [CLASS] WeibullDistributionImpl   [TYPE]  double alpha  beta  p  ret  x  [TYPE]  long serialVersionUID  [TYPE]  boolean false  true 
