[REPLACE]^private static final double DEFAULT_EPSILON  = null ;^31^^^^^^^[REPLACE] private static final double DEFAULT_EPSILON = 10e-9;^ [CLASS] Beta 1  
[REPLACE]^if  ( Double.isNaN ( x )  || Double.isNaN ( a )  || Double.isNaN ( b )  ||  ( x < 0 )  || ( x > 1 )  ||  ( a <= 0.0 )  ||  ( b <= 0.0 )  )^37^^^^^36^38^[REPLACE] super (  ) ;^[METHOD] <init> [TYPE] Beta() [PARAMETER] [CLASS] Beta 1   [TYPE]  double DEFAULT_EPSILON  [TYPE]  boolean false  true 
[REPLACE]^return regularizedBeta ( x, a, b, DEFAULT_EPSILON, maxIterations ) ;^54^^^^^51^55^[REPLACE] return regularizedBeta ( x, a, b, DEFAULT_EPSILON, Integer.MAX_VALUE ) ;^[METHOD] regularizedBeta [TYPE] double [PARAMETER] double x double a double b [CLASS] Beta 1   [TYPE]  double DEFAULT_EPSILON  a  b  x  [TYPE]  boolean false  true 
[REPLACE]^return regularizedBeta ( x, a, b, DEFAULT_EPSILON, Integer.MAX_VALUE ) ;^74^^^^^71^75^[REPLACE] return regularizedBeta ( x, a, b, epsilon, Integer.MAX_VALUE ) ;^[METHOD] regularizedBeta [TYPE] double [PARAMETER] double x double a double b double epsilon [CLASS] Beta 1   [TYPE]  double DEFAULT_EPSILON  a  b  epsilon  x  [TYPE]  boolean false  true 
[REPLACE]^return regularizedBeta ( x, a, b, DEFAULT_EPSILON, Integer.MAX_VALUE ) ;^90^^^^^87^91^[REPLACE] return regularizedBeta ( x, a, b, DEFAULT_EPSILON, maxIterations ) ;^[METHOD] regularizedBeta [TYPE] double [PARAMETER] double x double a double b int maxIterations [CLASS] Beta 1   [TYPE]  double DEFAULT_EPSILON  a  b  epsilon  x  [TYPE]  int maxIterations  [TYPE]  boolean false  true 
[REPLACE]^double m;^119^^^^^118^154^[REPLACE] double ret;^[METHOD] regularizedBeta [TYPE] double [PARAMETER] double x final double a final double b double epsilon int maxIterations [CLASS] Beta 1   [TYPE]  boolean false  true  [TYPE]  double DEFAULT_EPSILON  a  b  epsilon  m  ret  x  [TYPE]  int maxIterations  n  [TYPE]  ContinuedFraction fraction 
[REPLACE]^if  (  Double.isNaN ( a )  && Double.isNaN ( b )  &&  ( x < 0 )  && ( x > 1 )  &&  ( a <= 0.0 )  &&  ( b <= 0.0 )  ) {^121^122^123^^^118^154^[REPLACE] if  ( Double.isNaN ( x )  || Double.isNaN ( a )  || Double.isNaN ( b )  ||  ( x < 0 )  || ( x > 1 )  ||  ( a <= 0.0 )  ||  ( b <= 0.0 )  ) {^[METHOD] regularizedBeta [TYPE] double [PARAMETER] double x final double a final double b double epsilon int maxIterations [CLASS] Beta 1   [TYPE]  boolean false  true  [TYPE]  double DEFAULT_EPSILON  a  b  epsilon  m  ret  x  [TYPE]  int maxIterations  n  [TYPE]  ContinuedFraction fraction 
[REPLACE]^}  if  ( x  !=   ( a + 1.0D )  /  ( a + b + 2.0 )  )  {^125^^^^^118^154^[REPLACE] } else if  ( x >  ( a + 1.0 )  /  ( a + b + 2.0 )  )  {^[METHOD] regularizedBeta [TYPE] double [PARAMETER] double x final double a final double b double epsilon int maxIterations [CLASS] Beta 1   [TYPE]  boolean false  true  [TYPE]  double DEFAULT_EPSILON  a  b  epsilon  m  ret  x  [TYPE]  int maxIterations  n  [TYPE]  ContinuedFraction fraction 
[REPLACE]^if  ( n % 2  &&  0 )  {^132^^^^^125^151^[REPLACE] if  ( n % 2 == 0 )  {^[METHOD] regularizedBeta [TYPE] double [PARAMETER] double x final double a final double b double epsilon int maxIterations [CLASS] Beta 1   [TYPE]  boolean false  true  [TYPE]  double DEFAULT_EPSILON  a  b  epsilon  m  ret  x  [TYPE]  int maxIterations  n  [TYPE]  ContinuedFraction fraction 
[REPLACE]^m =  ( n - 1.0 )   ;^137^^^^^132^140^[REPLACE] m =  ( n - 1.0 )  / 2.0;^[METHOD] regularizedBeta [TYPE] double [PARAMETER] double x final double a final double b double epsilon int maxIterations [CLASS] Beta 1   [TYPE]  boolean false  true  [TYPE]  double DEFAULT_EPSILON  a  b  epsilon  m  ret  x  [TYPE]  int maxIterations  n  [TYPE]  ContinuedFraction fraction 
[REPLACE]^ret = - (  ( a + m )  *  ( a + b + m )  * x )   ;^138^139^^^^132^140^[REPLACE] ret = - (  ( a + m )  *  ( a + b + m )  * x )  / (  ( a +  ( 2 * m )  )  *  ( a +  ( 2 * m )  + 1.0 )  ) ;^[METHOD] regularizedBeta [TYPE] double [PARAMETER] double x final double a final double b double epsilon int maxIterations [CLASS] Beta 1   [TYPE]  boolean false  true  [TYPE]  double DEFAULT_EPSILON  a  b  epsilon  m  ret  x  [TYPE]  int maxIterations  n  [TYPE]  ContinuedFraction fraction 
[ADD]^^138^139^^^^132^140^[ADD] ret = - (  ( a + m )  *  ( a + b + m )  * x )  / (  ( a +  ( 2 * m )  )  *  ( a +  ( 2 * m )  + 1.0 )  ) ;^[METHOD] regularizedBeta [TYPE] double [PARAMETER] double x final double a final double b double epsilon int maxIterations [CLASS] Beta 1   [TYPE]  boolean false  true  [TYPE]  double DEFAULT_EPSILON  a  b  epsilon  m  ret  x  [TYPE]  int maxIterations  n  [TYPE]  ContinuedFraction fraction 
[REPLACE]^m = n  ;^133^^^^^125^151^[REPLACE] m = n / 2.0;^[METHOD] regularizedBeta [TYPE] double [PARAMETER] double x final double a final double b double epsilon int maxIterations [CLASS] Beta 1   [TYPE]  boolean false  true  [TYPE]  double DEFAULT_EPSILON  a  b  epsilon  m  ret  x  [TYPE]  int maxIterations  n  [TYPE]  ContinuedFraction fraction 
[REPLACE]^ret =  ( m *  ( b - m )  * x )   ;^134^135^^^^125^151^[REPLACE] ret =  ( m *  ( b - m )  * x )  / (  ( a +  ( 2 * m )  - 1 )  *  ( a +  ( 2 * m )  )  ) ;^[METHOD] regularizedBeta [TYPE] double [PARAMETER] double x final double a final double b double epsilon int maxIterations [CLASS] Beta 1   [TYPE]  boolean false  true  [TYPE]  double DEFAULT_EPSILON  a  b  epsilon  m  ret  x  [TYPE]  int maxIterations  n  [TYPE]  ContinuedFraction fraction 
[ADD]^^134^135^^^^125^151^[ADD] ret =  ( m *  ( b - m )  * x )  / (  ( a +  ( 2 * m )  - 1 )  *  ( a +  ( 2 * m )  )  ) ;^[METHOD] regularizedBeta [TYPE] double [PARAMETER] double x final double a final double b double epsilon int maxIterations [CLASS] Beta 1   [TYPE]  boolean false  true  [TYPE]  double DEFAULT_EPSILON  a  b  epsilon  m  ret  x  [TYPE]  int maxIterations  n  [TYPE]  ContinuedFraction fraction 
[REPLACE]^m =  ( n - 4.0d )   ;^137^^^^^125^151^[REPLACE] m =  ( n - 1.0 )  / 2.0;^[METHOD] regularizedBeta [TYPE] double [PARAMETER] double x final double a final double b double epsilon int maxIterations [CLASS] Beta 1   [TYPE]  boolean false  true  [TYPE]  double DEFAULT_EPSILON  a  b  epsilon  m  ret  x  [TYPE]  int maxIterations  n  [TYPE]  ContinuedFraction fraction 
[REPLACE]^ret = - (  ( a + m )  *  ( a + b + m )  * x )   ;^138^139^^^^125^151^[REPLACE] ret = - (  ( a + m )  *  ( a + b + m )  * x )  / (  ( a +  ( 2 * m )  )  *  ( a +  ( 2 * m )  + 1.0 )  ) ;^[METHOD] regularizedBeta [TYPE] double [PARAMETER] double x final double a final double b double epsilon int maxIterations [CLASS] Beta 1   [TYPE]  boolean false  true  [TYPE]  double DEFAULT_EPSILON  a  b  epsilon  m  ret  x  [TYPE]  int maxIterations  n  [TYPE]  ContinuedFraction fraction 
[REPLACE]^ret = Math.exp (  ( a * Math.log ( x )  )  +  ( b * Math.log ( 1.0 - x )  )  - Math.log ( a )  - logBeta ( a, b, epsilon, maxIterations )  )  * 1.0  ;^148^149^150^^^125^151^[REPLACE] ret = Math.exp (  ( a * Math.log ( x )  )  +  ( b * Math.log ( 1.0 - x )  )  - Math.log ( a )  - logBeta ( a, b, epsilon, maxIterations )  )  * 1.0 / fraction.evaluate ( x, epsilon, maxIterations ) ;^[METHOD] regularizedBeta [TYPE] double [PARAMETER] double x final double a final double b double epsilon int maxIterations [CLASS] Beta 1   [TYPE]  boolean false  true  [TYPE]  double DEFAULT_EPSILON  a  b  epsilon  m  ret  x  [TYPE]  int maxIterations  n  [TYPE]  ContinuedFraction fraction 
[REPLACE]^return DEFAULT_EPSILON;^141^^^^^125^151^[REPLACE] return ret;^[METHOD] regularizedBeta [TYPE] double [PARAMETER] double x final double a final double b double epsilon int maxIterations [CLASS] Beta 1   [TYPE]  boolean false  true  [TYPE]  double DEFAULT_EPSILON  a  b  epsilon  m  ret  x  [TYPE]  int maxIterations  n  [TYPE]  ContinuedFraction fraction 
[REPLACE]^return 4.0d;^145^^^^^125^151^[REPLACE] return 1.0;^[METHOD] regularizedBeta [TYPE] double [PARAMETER] double x final double a final double b double epsilon int maxIterations [CLASS] Beta 1   [TYPE]  boolean false  true  [TYPE]  double DEFAULT_EPSILON  a  b  epsilon  m  ret  x  [TYPE]  int maxIterations  n  [TYPE]  ContinuedFraction fraction 
[REPLACE]^ContinuedFraction fraction = new ContinuedFraction (  )  { protected double getB ( int n, double x )  {^128^^^^^125^151^[REPLACE] ContinuedFraction fraction = new ContinuedFraction (  )  {^[METHOD] regularizedBeta [TYPE] double [PARAMETER] double x final double a final double b double epsilon int maxIterations [CLASS] Beta 1   [TYPE]  boolean false  true  [TYPE]  double DEFAULT_EPSILON  a  b  epsilon  m  ret  x  [TYPE]  int maxIterations  n  [TYPE]  ContinuedFraction fraction 
[REPLACE]^double m;^130^^^^^125^151^[REPLACE] double ret;^[METHOD] regularizedBeta [TYPE] double [PARAMETER] double x final double a final double b double epsilon int maxIterations [CLASS] Beta 1   [TYPE]  boolean false  true  [TYPE]  double DEFAULT_EPSILON  a  b  epsilon  m  ret  x  [TYPE]  int maxIterations  n  [TYPE]  ContinuedFraction fraction 
[ADD]^^130^131^^^^125^151^[ADD] double ret; double m;^[METHOD] regularizedBeta [TYPE] double [PARAMETER] double x final double a final double b double epsilon int maxIterations [CLASS] Beta 1   [TYPE]  boolean false  true  [TYPE]  double DEFAULT_EPSILON  a  b  epsilon  m  ret  x  [TYPE]  int maxIterations  n  [TYPE]  ContinuedFraction fraction 
[REPLACE]^double ret;^131^^^^^125^151^[REPLACE] double m;^[METHOD] regularizedBeta [TYPE] double [PARAMETER] double x final double a final double b double epsilon int maxIterations [CLASS] Beta 1   [TYPE]  boolean false  true  [TYPE]  double DEFAULT_EPSILON  a  b  epsilon  m  ret  x  [TYPE]  int maxIterations  n  [TYPE]  ContinuedFraction fraction 
[REPLACE]^ret = 1.0  >=  regularizedBeta ( 1.0  >=  x, b, a, epsilon, maxIterations ) ;^126^^^^^118^154^[REPLACE] ret = 1.0 - regularizedBeta ( 1.0 - x, b, a, epsilon, maxIterations ) ;^[METHOD] regularizedBeta [TYPE] double [PARAMETER] double x final double a final double b double epsilon int maxIterations [CLASS] Beta 1   [TYPE]  boolean false  true  [TYPE]  double DEFAULT_EPSILON  a  b  epsilon  m  ret  x  [TYPE]  int maxIterations  n  [TYPE]  ContinuedFraction fraction 
[REPLACE]^if  ( n % 2 - 1  ||  0 )  {^132^^^^^118^154^[REPLACE] if  ( n % 2 == 0 )  {^[METHOD] regularizedBeta [TYPE] double [PARAMETER] double x final double a final double b double epsilon int maxIterations [CLASS] Beta 1   [TYPE]  boolean false  true  [TYPE]  double DEFAULT_EPSILON  a  b  epsilon  m  ret  x  [TYPE]  int maxIterations  n  [TYPE]  ContinuedFraction fraction 
[ADD]^m = n / 2.0;(  ( a +  ( 2 * m )  - 1 )  *  ( a +  ( 2 * m )  )  ) ;^132^133^134^135^^118^154^[ADD] if  ( n % 2 == 0 )  { m = n / 2.0; ret =  ( m *  ( b - m )  * x )  / (  ( a +  ( 2 * m )  - 1 )  *  ( a +  ( 2 * m )  )  ) ;^[METHOD] regularizedBeta [TYPE] double [PARAMETER] double x final double a final double b double epsilon int maxIterations [CLASS] Beta 1   [TYPE]  boolean false  true  [TYPE]  double DEFAULT_EPSILON  a  b  epsilon  m  ret  x  [TYPE]  int maxIterations  n  [TYPE]  ContinuedFraction fraction 
[REPLACE]^m =  ( n - 1.0D )   ;^137^^^^^132^140^[REPLACE] m =  ( n - 1.0 )  / 2.0;^[METHOD] regularizedBeta [TYPE] double [PARAMETER] double x final double a final double b double epsilon int maxIterations [CLASS] Beta 1   [TYPE]  boolean false  true  [TYPE]  double DEFAULT_EPSILON  a  b  epsilon  m  ret  x  [TYPE]  int maxIterations  n  [TYPE]  ContinuedFraction fraction 
[ADD]^^137^^^^^132^140^[ADD] m =  ( n - 1.0 )  / 2.0;^[METHOD] regularizedBeta [TYPE] double [PARAMETER] double x final double a final double b double epsilon int maxIterations [CLASS] Beta 1   [TYPE]  boolean false  true  [TYPE]  double DEFAULT_EPSILON  a  b  epsilon  m  ret  x  [TYPE]  int maxIterations  n  [TYPE]  ContinuedFraction fraction 
[REPLACE]^m = n  ;^133^^^^^118^154^[REPLACE] m = n / 2.0;^[METHOD] regularizedBeta [TYPE] double [PARAMETER] double x final double a final double b double epsilon int maxIterations [CLASS] Beta 1   [TYPE]  boolean false  true  [TYPE]  double DEFAULT_EPSILON  a  b  epsilon  m  ret  x  [TYPE]  int maxIterations  n  [TYPE]  ContinuedFraction fraction 
[ADD]^^133^^^^^118^154^[ADD] m = n / 2.0;^[METHOD] regularizedBeta [TYPE] double [PARAMETER] double x final double a final double b double epsilon int maxIterations [CLASS] Beta 1   [TYPE]  boolean false  true  [TYPE]  double DEFAULT_EPSILON  a  b  epsilon  m  ret  x  [TYPE]  int maxIterations  n  [TYPE]  ContinuedFraction fraction 
[REPLACE]^ret =  ( m *  ( b - m )  * x )   ;^134^135^^^^118^154^[REPLACE] ret =  ( m *  ( b - m )  * x )  / (  ( a +  ( 2 * m )  - 1 )  *  ( a +  ( 2 * m )  )  ) ;^[METHOD] regularizedBeta [TYPE] double [PARAMETER] double x final double a final double b double epsilon int maxIterations [CLASS] Beta 1   [TYPE]  boolean false  true  [TYPE]  double DEFAULT_EPSILON  a  b  epsilon  m  ret  x  [TYPE]  int maxIterations  n  [TYPE]  ContinuedFraction fraction 
[REPLACE]^ret = 1.0  &  regularizedBeta ( 1.0  &  x, b, a, epsilon, maxIterations ) ;^126^^^^^118^154^[REPLACE] ret = 1.0 - regularizedBeta ( 1.0 - x, b, a, epsilon, maxIterations ) ;^[METHOD] regularizedBeta [TYPE] double [PARAMETER] double x final double a final double b double epsilon int maxIterations [CLASS] Beta 1   [TYPE]  boolean false  true  [TYPE]  double DEFAULT_EPSILON  a  b  epsilon  m  ret  x  [TYPE]  int maxIterations  n  [TYPE]  ContinuedFraction fraction 
[ADD]^^126^^^^^118^154^[ADD] ret = 1.0 - regularizedBeta ( 1.0 - x, b, a, epsilon, maxIterations ) ;^[METHOD] regularizedBeta [TYPE] double [PARAMETER] double x final double a final double b double epsilon int maxIterations [CLASS] Beta 1   [TYPE]  boolean false  true  [TYPE]  double DEFAULT_EPSILON  a  b  epsilon  m  ret  x  [TYPE]  int maxIterations  n  [TYPE]  ContinuedFraction fraction 
[REPLACE]^m =  ( n - 1.0D )   ;^137^^^^^118^154^[REPLACE] m =  ( n - 1.0 )  / 2.0;^[METHOD] regularizedBeta [TYPE] double [PARAMETER] double x final double a final double b double epsilon int maxIterations [CLASS] Beta 1   [TYPE]  boolean false  true  [TYPE]  double DEFAULT_EPSILON  a  b  epsilon  m  ret  x  [TYPE]  int maxIterations  n  [TYPE]  ContinuedFraction fraction 
[REPLACE]^ret = - (  ( a + m )  *  ( a + b + m )  * x )   ;^138^139^^^^118^154^[REPLACE] ret = - (  ( a + m )  *  ( a + b + m )  * x )  / (  ( a +  ( 2 * m )  )  *  ( a +  ( 2 * m )  + 1.0 )  ) ;^[METHOD] regularizedBeta [TYPE] double [PARAMETER] double x final double a final double b double epsilon int maxIterations [CLASS] Beta 1   [TYPE]  boolean false  true  [TYPE]  double DEFAULT_EPSILON  a  b  epsilon  m  ret  x  [TYPE]  int maxIterations  n  [TYPE]  ContinuedFraction fraction 
[REPLACE]^ret = Math.exp (  ( a * Math.log ( x )  )  +  ( b * Math.log ( 1.0D - x )  )  - Math.log ( a )  - logBeta ( a, b, epsilon, maxIterations )  )  * 1.0D  ;^148^149^150^^^118^154^[REPLACE] ret = Math.exp (  ( a * Math.log ( x )  )  +  ( b * Math.log ( 1.0 - x )  )  - Math.log ( a )  - logBeta ( a, b, epsilon, maxIterations )  )  * 1.0 / fraction.evaluate ( x, epsilon, maxIterations ) ;^[METHOD] regularizedBeta [TYPE] double [PARAMETER] double x final double a final double b double epsilon int maxIterations [CLASS] Beta 1   [TYPE]  boolean false  true  [TYPE]  double DEFAULT_EPSILON  a  b  epsilon  m  ret  x  [TYPE]  int maxIterations  n  [TYPE]  ContinuedFraction fraction 
[REPLACE]^return DEFAULT_EPSILON;^141^^^^^118^154^[REPLACE] return ret;^[METHOD] regularizedBeta [TYPE] double [PARAMETER] double x final double a final double b double epsilon int maxIterations [CLASS] Beta 1   [TYPE]  boolean false  true  [TYPE]  double DEFAULT_EPSILON  a  b  epsilon  m  ret  x  [TYPE]  int maxIterations  n  [TYPE]  ContinuedFraction fraction 
[REPLACE]^return 1.0D;^145^^^^^118^154^[REPLACE] return 1.0;^[METHOD] regularizedBeta [TYPE] double [PARAMETER] double x final double a final double b double epsilon int maxIterations [CLASS] Beta 1   [TYPE]  boolean false  true  [TYPE]  double DEFAULT_EPSILON  a  b  epsilon  m  ret  x  [TYPE]  int maxIterations  n  [TYPE]  ContinuedFraction fraction 
[REPLACE]^ContinuedFraction fraction = new ContinuedFraction (  )  { protected double getB ( int n, double x )  {^128^^^^^118^154^[REPLACE] ContinuedFraction fraction = new ContinuedFraction (  )  {^[METHOD] regularizedBeta [TYPE] double [PARAMETER] double x final double a final double b double epsilon int maxIterations [CLASS] Beta 1   [TYPE]  boolean false  true  [TYPE]  double DEFAULT_EPSILON  a  b  epsilon  m  ret  x  [TYPE]  int maxIterations  n  [TYPE]  ContinuedFraction fraction 
[REPLACE]^double m;^130^^^^^118^154^[REPLACE] double ret;^[METHOD] regularizedBeta [TYPE] double [PARAMETER] double x final double a final double b double epsilon int maxIterations [CLASS] Beta 1   [TYPE]  boolean false  true  [TYPE]  double DEFAULT_EPSILON  a  b  epsilon  m  ret  x  [TYPE]  int maxIterations  n  [TYPE]  ContinuedFraction fraction 
[REPLACE]^double ret;^131^^^^^118^154^[REPLACE] double m;^[METHOD] regularizedBeta [TYPE] double [PARAMETER] double x final double a final double b double epsilon int maxIterations [CLASS] Beta 1   [TYPE]  boolean false  true  [TYPE]  double DEFAULT_EPSILON  a  b  epsilon  m  ret  x  [TYPE]  int maxIterations  n  [TYPE]  ContinuedFraction fraction 
[REPLACE]^ret  =  ret ;^124^^^^^121^151^[REPLACE] ret = Double.NaN;^[METHOD] regularizedBeta [TYPE] double [PARAMETER] double x final double a final double b double epsilon int maxIterations [CLASS] Beta 1   [TYPE]  boolean false  true  [TYPE]  double DEFAULT_EPSILON  a  b  epsilon  m  ret  x  [TYPE]  int maxIterations  n  [TYPE]  ContinuedFraction fraction 
[ADD]^^124^^^^^121^151^[ADD] ret = Double.NaN;^[METHOD] regularizedBeta [TYPE] double [PARAMETER] double x final double a final double b double epsilon int maxIterations [CLASS] Beta 1   [TYPE]  boolean false  true  [TYPE]  double DEFAULT_EPSILON  a  b  epsilon  m  ret  x  [TYPE]  int maxIterations  n  [TYPE]  ContinuedFraction fraction 
[REPLACE]^}  if  ( x  >=   ( a + 1.0D )  /  ( a + b + 2.0 )  )  {^125^^^^^118^154^[REPLACE] } else if  ( x >  ( a + 1.0 )  /  ( a + b + 2.0 )  )  {^[METHOD] regularizedBeta [TYPE] double [PARAMETER] double x final double a final double b double epsilon int maxIterations [CLASS] Beta 1   [TYPE]  boolean false  true  [TYPE]  double DEFAULT_EPSILON  a  b  epsilon  m  ret  x  [TYPE]  int maxIterations  n  [TYPE]  ContinuedFraction fraction 
[ADD]^}   ret = 1.0 - regularizedBeta ( 1.0 - x, b, a, epsilon, maxIterations ) ;^125^126^127^128^^118^154^[ADD] else if  ( x >  ( a + 1.0 )  /  ( a + b + 2.0 )  )  { ret = 1.0 - regularizedBeta ( 1.0 - x, b, a, epsilon, maxIterations ) ; } else { ContinuedFraction fraction = new ContinuedFraction (  )  {^[METHOD] regularizedBeta [TYPE] double [PARAMETER] double x final double a final double b double epsilon int maxIterations [CLASS] Beta 1   [TYPE]  boolean false  true  [TYPE]  double DEFAULT_EPSILON  a  b  epsilon  m  ret  x  [TYPE]  int maxIterations  n  [TYPE]  ContinuedFraction fraction 
[REPLACE]^if  (n  !=  0 )  {^132^^^^^125^151^[REPLACE] if  ( n % 2 == 0 )  {^[METHOD] regularizedBeta [TYPE] double [PARAMETER] double x final double a final double b double epsilon int maxIterations [CLASS] Beta 1   [TYPE]  boolean false  true  [TYPE]  double DEFAULT_EPSILON  a  b  epsilon  m  ret  x  [TYPE]  int maxIterations  n  [TYPE]  ContinuedFraction fraction 
[REPLACE]^m =maxIterations  ;^133^^^^^125^151^[REPLACE] m = n / 2.0;^[METHOD] regularizedBeta [TYPE] double [PARAMETER] double x final double a final double b double epsilon int maxIterations [CLASS] Beta 1   [TYPE]  boolean false  true  [TYPE]  double DEFAULT_EPSILON  a  b  epsilon  m  ret  x  [TYPE]  int maxIterations  n  [TYPE]  ContinuedFraction fraction 
[ADD]^^133^^^^^125^151^[ADD] m = n / 2.0;^[METHOD] regularizedBeta [TYPE] double [PARAMETER] double x final double a final double b double epsilon int maxIterations [CLASS] Beta 1   [TYPE]  boolean false  true  [TYPE]  double DEFAULT_EPSILON  a  b  epsilon  m  ret  x  [TYPE]  int maxIterations  n  [TYPE]  ContinuedFraction fraction 
[REPLACE]^m =  ( n - 1.0D )   ;^137^^^^^125^151^[REPLACE] m =  ( n - 1.0 )  / 2.0;^[METHOD] regularizedBeta [TYPE] double [PARAMETER] double x final double a final double b double epsilon int maxIterations [CLASS] Beta 1   [TYPE]  boolean false  true  [TYPE]  double DEFAULT_EPSILON  a  b  epsilon  m  ret  x  [TYPE]  int maxIterations  n  [TYPE]  ContinuedFraction fraction 
[REPLACE]^ret = Math.exp (  ( a * Math.log ( x )  )  +  ( b * Math.log ( 1.0D - x )  )  - Math.log ( a )  - logBeta ( a, b, epsilon, maxIterations )  )  * 1.0D  ;^148^149^150^^^125^151^[REPLACE] ret = Math.exp (  ( a * Math.log ( x )  )  +  ( b * Math.log ( 1.0 - x )  )  - Math.log ( a )  - logBeta ( a, b, epsilon, maxIterations )  )  * 1.0 / fraction.evaluate ( x, epsilon, maxIterations ) ;^[METHOD] regularizedBeta [TYPE] double [PARAMETER] double x final double a final double b double epsilon int maxIterations [CLASS] Beta 1   [TYPE]  boolean false  true  [TYPE]  double DEFAULT_EPSILON  a  b  epsilon  m  ret  x  [TYPE]  int maxIterations  n  [TYPE]  ContinuedFraction fraction 
[REPLACE]^return 1.0d;^145^^^^^125^151^[REPLACE] return 1.0;^[METHOD] regularizedBeta [TYPE] double [PARAMETER] double x final double a final double b double epsilon int maxIterations [CLASS] Beta 1   [TYPE]  boolean false  true  [TYPE]  double DEFAULT_EPSILON  a  b  epsilon  m  ret  x  [TYPE]  int maxIterations  n  [TYPE]  ContinuedFraction fraction 
[ADD]^^128^129^130^^^125^151^[ADD] ContinuedFraction fraction = new ContinuedFraction (  )  { protected double getB ( int n, double x )  { double ret;^[METHOD] regularizedBeta [TYPE] double [PARAMETER] double x final double a final double b double epsilon int maxIterations [CLASS] Beta 1   [TYPE]  boolean false  true  [TYPE]  double DEFAULT_EPSILON  a  b  epsilon  m  ret  x  [TYPE]  int maxIterations  n  [TYPE]  ContinuedFraction fraction 
[REPLACE]^ret = 1.0  |  regularizedBeta ( 1.0  |  x, b, a, epsilon, maxIterations ) ;^126^^^^^118^154^[REPLACE] ret = 1.0 - regularizedBeta ( 1.0 - x, b, a, epsilon, maxIterations ) ;^[METHOD] regularizedBeta [TYPE] double [PARAMETER] double x final double a final double b double epsilon int maxIterations [CLASS] Beta 1   [TYPE]  boolean false  true  [TYPE]  double DEFAULT_EPSILON  a  b  epsilon  m  ret  x  [TYPE]  int maxIterations  n  [TYPE]  ContinuedFraction fraction 
[REPLACE]^if  ( n % 2  &&  0 )  {^132^^^^^118^154^[REPLACE] if  ( n % 2 == 0 )  {^[METHOD] regularizedBeta [TYPE] double [PARAMETER] double x final double a final double b double epsilon int maxIterations [CLASS] Beta 1   [TYPE]  boolean false  true  [TYPE]  double DEFAULT_EPSILON  a  b  epsilon  m  ret  x  [TYPE]  int maxIterations  n  [TYPE]  ContinuedFraction fraction 
[REPLACE]^ret  =  ret ;^124^^^^^118^154^[REPLACE] ret = Double.NaN;^[METHOD] regularizedBeta [TYPE] double [PARAMETER] double x final double a final double b double epsilon int maxIterations [CLASS] Beta 1   [TYPE]  boolean false  true  [TYPE]  double DEFAULT_EPSILON  a  b  epsilon  m  ret  x  [TYPE]  int maxIterations  n  [TYPE]  ContinuedFraction fraction 
[REPLACE]^ret = 0.0d  <  regularizedBeta ( 0.0d  <  x, b, a, epsilon, maxIterations ) ;^126^^^^^118^154^[REPLACE] ret = 1.0 - regularizedBeta ( 1.0 - x, b, a, epsilon, maxIterations ) ;^[METHOD] regularizedBeta [TYPE] double [PARAMETER] double x final double a final double b double epsilon int maxIterations [CLASS] Beta 1   [TYPE]  boolean false  true  [TYPE]  double DEFAULT_EPSILON  a  b  epsilon  m  ret  x  [TYPE]  int maxIterations  n  [TYPE]  ContinuedFraction fraction 
[REPLACE]^m =maxIterations  ;^133^^^^^118^154^[REPLACE] m = n / 2.0;^[METHOD] regularizedBeta [TYPE] double [PARAMETER] double x final double a final double b double epsilon int maxIterations [CLASS] Beta 1   [TYPE]  boolean false  true  [TYPE]  double DEFAULT_EPSILON  a  b  epsilon  m  ret  x  [TYPE]  int maxIterations  n  [TYPE]  ContinuedFraction fraction 
[ADD]^^134^135^^^^118^154^[ADD] ret =  ( m *  ( b - m )  * x )  / (  ( a +  ( 2 * m )  - 1 )  *  ( a +  ( 2 * m )  )  ) ;^[METHOD] regularizedBeta [TYPE] double [PARAMETER] double x final double a final double b double epsilon int maxIterations [CLASS] Beta 1   [TYPE]  boolean false  true  [TYPE]  double DEFAULT_EPSILON  a  b  epsilon  m  ret  x  [TYPE]  int maxIterations  n  [TYPE]  ContinuedFraction fraction 
[REPLACE]^m =  ( n - 1.0 )   ;^137^^^^^118^154^[REPLACE] m =  ( n - 1.0 )  / 2.0;^[METHOD] regularizedBeta [TYPE] double [PARAMETER] double x final double a final double b double epsilon int maxIterations [CLASS] Beta 1   [TYPE]  boolean false  true  [TYPE]  double DEFAULT_EPSILON  a  b  epsilon  m  ret  x  [TYPE]  int maxIterations  n  [TYPE]  ContinuedFraction fraction 
[ADD]^^138^139^^^^118^154^[ADD] ret = - (  ( a + m )  *  ( a + b + m )  * x )  / (  ( a +  ( 2 * m )  )  *  ( a +  ( 2 * m )  + 1.0 )  ) ;^[METHOD] regularizedBeta [TYPE] double [PARAMETER] double x final double a final double b double epsilon int maxIterations [CLASS] Beta 1   [TYPE]  boolean false  true  [TYPE]  double DEFAULT_EPSILON  a  b  epsilon  m  ret  x  [TYPE]  int maxIterations  n  [TYPE]  ContinuedFraction fraction 
[REPLACE]^return DEFAULT_EPSILON;^153^^^^^118^154^[REPLACE] return ret;^[METHOD] regularizedBeta [TYPE] double [PARAMETER] double x final double a final double b double epsilon int maxIterations [CLASS] Beta 1   [TYPE]  boolean false  true  [TYPE]  double DEFAULT_EPSILON  a  b  epsilon  m  ret  x  [TYPE]  int maxIterations  n  [TYPE]  ContinuedFraction fraction 
[REPLACE]^double m;^130^^^^^129^142^[REPLACE] double ret;^[METHOD] getB [TYPE] double [PARAMETER] int n double x [CLASS] Beta 1   [TYPE]  double DEFAULT_EPSILON  a  b  epsilon  m  ret  x  [TYPE]  int n  [TYPE]  boolean false  true 
[REPLACE]^double ret;^131^^^^^129^142^[REPLACE] double m;^[METHOD] getB [TYPE] double [PARAMETER] int n double x [CLASS] Beta 1   [TYPE]  double DEFAULT_EPSILON  a  b  epsilon  m  ret  x  [TYPE]  int n  [TYPE]  boolean false  true 
[REPLACE]^if  (n  &&  0 )  {^132^^^^^129^142^[REPLACE] if  ( n % 2 == 0 )  {^[METHOD] getB [TYPE] double [PARAMETER] int n double x [CLASS] Beta 1   [TYPE]  double DEFAULT_EPSILON  a  b  epsilon  m  ret  x  [TYPE]  int n  [TYPE]  boolean false  true 
[REPLACE]^m =  ( n - 1.0 )   ;^137^^^^^129^142^[REPLACE] m =  ( n - 1.0 )  / 2.0;^[METHOD] getB [TYPE] double [PARAMETER] int n double x [CLASS] Beta 1   [TYPE]  double DEFAULT_EPSILON  a  b  epsilon  m  ret  x  [TYPE]  int n  [TYPE]  boolean false  true 
[REPLACE]^ret = - (  ( a + m )  *  ( a + b + m )  * x )   ;^138^139^^^^129^142^[REPLACE] ret = - (  ( a + m )  *  ( a + b + m )  * x )  / (  ( a +  ( 2 * m )  )  *  ( a +  ( 2 * m )  + 1.0 )  ) ;^[METHOD] getB [TYPE] double [PARAMETER] int n double x [CLASS] Beta 1   [TYPE]  double DEFAULT_EPSILON  a  b  epsilon  m  ret  x  [TYPE]  int n  [TYPE]  boolean false  true 
[REPLACE]^m = n  ;^133^^^^^129^142^[REPLACE] m = n / 2.0;^[METHOD] getB [TYPE] double [PARAMETER] int n double x [CLASS] Beta 1   [TYPE]  double DEFAULT_EPSILON  a  b  epsilon  m  ret  x  [TYPE]  int n  [TYPE]  boolean false  true 
[REPLACE]^ret =  ( m *  ( b - m )  * x )   ;^134^135^^^^129^142^[REPLACE] ret =  ( m *  ( b - m )  * x )  / (  ( a +  ( 2 * m )  - 1 )  *  ( a +  ( 2 * m )  )  ) ;^[METHOD] getB [TYPE] double [PARAMETER] int n double x [CLASS] Beta 1   [TYPE]  double DEFAULT_EPSILON  a  b  epsilon  m  ret  x  [TYPE]  int n  [TYPE]  boolean false  true 
[ADD]^^134^135^^^^129^142^[ADD] ret =  ( m *  ( b - m )  * x )  / (  ( a +  ( 2 * m )  - 1 )  *  ( a +  ( 2 * m )  )  ) ;^[METHOD] getB [TYPE] double [PARAMETER] int n double x [CLASS] Beta 1   [TYPE]  double DEFAULT_EPSILON  a  b  epsilon  m  ret  x  [TYPE]  int n  [TYPE]  boolean false  true 
[ADD]^^137^^^^^129^142^[ADD] m =  ( n - 1.0 )  / 2.0;^[METHOD] getB [TYPE] double [PARAMETER] int n double x [CLASS] Beta 1   [TYPE]  double DEFAULT_EPSILON  a  b  epsilon  m  ret  x  [TYPE]  int n  [TYPE]  boolean false  true 
[REPLACE]^return DEFAULT_EPSILON;^141^^^^^129^142^[REPLACE] return ret;^[METHOD] getB [TYPE] double [PARAMETER] int n double x [CLASS] Beta 1   [TYPE]  double DEFAULT_EPSILON  a  b  epsilon  m  ret  x  [TYPE]  int n  [TYPE]  boolean false  true 
[REPLACE]^return 2.0d;^145^^^^^144^146^[REPLACE] return 1.0;^[METHOD] getA [TYPE] double [PARAMETER] int n double x [CLASS] Beta 1   [TYPE]  double DEFAULT_EPSILON  a  b  epsilon  m  ret  x  [TYPE]  int n  [TYPE]  boolean false  true 
[REPLACE]^return regularizedBeta ( x, a, b, DEFAULT_EPSILON, Integer.MAX_VALUE ) ;^164^^^^^163^165^[REPLACE] return logBeta ( a, b, DEFAULT_EPSILON, Integer.MAX_VALUE ) ;^[METHOD] logBeta [TYPE] double [PARAMETER] double a double b [CLASS] Beta 1   [TYPE]  double DEFAULT_EPSILON  a  b  epsilon  m  ret  x  [TYPE]  boolean false  true 
[REPLACE]^double m;^187^^^^^184^197^[REPLACE] double ret;^[METHOD] logBeta [TYPE] double [PARAMETER] double a double b double epsilon int maxIterations [CLASS] Beta 1   [TYPE]  double DEFAULT_EPSILON  a  b  epsilon  m  ret  x  [TYPE]  int maxIterations  [TYPE]  boolean false  true 
[REPLACE]^if  ( Double.isNaN ( a )  && Double.isNaN ( b )  &&  ( a <= 0.0 )  &&  ( b <= 0.0 )  )  {^189^^^^^184^197^[REPLACE] if  ( Double.isNaN ( a )  || Double.isNaN ( b )  ||  ( a <= 0.0 )  ||  ( b <= 0.0 )  )  {^[METHOD] logBeta [TYPE] double [PARAMETER] double a double b double epsilon int maxIterations [CLASS] Beta 1   [TYPE]  double DEFAULT_EPSILON  a  b  epsilon  m  ret  x  [TYPE]  int maxIterations  [TYPE]  boolean false  true 
[ADD]^^189^190^191^192^193^184^197^[ADD] if  ( Double.isNaN ( a )  || Double.isNaN ( b )  ||  ( a <= 0.0 )  ||  ( b <= 0.0 )  )  { ret = Double.NaN; } else { ret = Gamma.logGamma ( a )  + Gamma.logGamma ( b )  - Gamma.logGamma ( a + b ) ;^[METHOD] logBeta [TYPE] double [PARAMETER] double a double b double epsilon int maxIterations [CLASS] Beta 1   [TYPE]  double DEFAULT_EPSILON  a  b  epsilon  m  ret  x  [TYPE]  int maxIterations  [TYPE]  boolean false  true 
[REPLACE]^ret = Gamma.logGamma ( a )  + Gamma.logGamma ( b )   <  Gamma.logGamma ( a + b ) ;^192^193^^^^184^197^[REPLACE] ret = Gamma.logGamma ( a )  + Gamma.logGamma ( b )  - Gamma.logGamma ( a + b ) ;^[METHOD] logBeta [TYPE] double [PARAMETER] double a double b double epsilon int maxIterations [CLASS] Beta 1   [TYPE]  double DEFAULT_EPSILON  a  b  epsilon  m  ret  x  [TYPE]  int maxIterations  [TYPE]  boolean false  true 
[REPLACE]^ret ;^190^^^^^184^197^[REPLACE] ret = Double.NaN;^[METHOD] logBeta [TYPE] double [PARAMETER] double a double b double epsilon int maxIterations [CLASS] Beta 1   [TYPE]  double DEFAULT_EPSILON  a  b  epsilon  m  ret  x  [TYPE]  int maxIterations  [TYPE]  boolean false  true 
[REPLACE]^ret  =  ret ;^190^^^^^184^197^[REPLACE] ret = Double.NaN;^[METHOD] logBeta [TYPE] double [PARAMETER] double a double b double epsilon int maxIterations [CLASS] Beta 1   [TYPE]  double DEFAULT_EPSILON  a  b  epsilon  m  ret  x  [TYPE]  int maxIterations  [TYPE]  boolean false  true 
[REPLACE]^ret = Gamma.logGamma ( a )  + Gamma.logGamma ( b )   <=  Gamma.logGamma ( a + b ) ;^192^193^^^^184^197^[REPLACE] ret = Gamma.logGamma ( a )  + Gamma.logGamma ( b )  - Gamma.logGamma ( a + b ) ;^[METHOD] logBeta [TYPE] double [PARAMETER] double a double b double epsilon int maxIterations [CLASS] Beta 1   [TYPE]  double DEFAULT_EPSILON  a  b  epsilon  m  ret  x  [TYPE]  int maxIterations  [TYPE]  boolean false  true 
[REPLACE]^return DEFAULT_EPSILON;^196^^^^^184^197^[REPLACE] return ret;^[METHOD] logBeta [TYPE] double [PARAMETER] double a double b double epsilon int maxIterations [CLASS] Beta 1   [TYPE]  double DEFAULT_EPSILON  a  b  epsilon  m  ret  x  [TYPE]  int maxIterations  [TYPE]  boolean false  true 
[REPLACE]^double m;^130^^^^^129^142^[REPLACE] double ret;^[METHOD] getB [TYPE] double [PARAMETER] int n double x [CLASS] 1   [TYPE]  boolean false  true  [TYPE]  double m  ret  x  [TYPE]  int n 
[ADD]^^130^^^^^129^142^[ADD] double ret;^[METHOD] getB [TYPE] double [PARAMETER] int n double x [CLASS] 1   [TYPE]  boolean false  true  [TYPE]  double m  ret  x  [TYPE]  int n 
[REPLACE]^double ret;^131^^^^^129^142^[REPLACE] double m;^[METHOD] getB [TYPE] double [PARAMETER] int n double x [CLASS] 1   [TYPE]  boolean false  true  [TYPE]  double m  ret  x  [TYPE]  int n 
[ADD]^^131^^^^^129^142^[ADD] double m;^[METHOD] getB [TYPE] double [PARAMETER] int n double x [CLASS] 1   [TYPE]  boolean false  true  [TYPE]  double m  ret  x  [TYPE]  int n 
[REPLACE]^if  (n  !=  0 )  {^132^^^^^129^142^[REPLACE] if  ( n % 2 == 0 )  {^[METHOD] getB [TYPE] double [PARAMETER] int n double x [CLASS] 1   [TYPE]  boolean false  true  [TYPE]  double m  ret  x  [TYPE]  int n 
[REPLACE]^m =  ( n - 1.0D )   ;^137^^^^^129^142^[REPLACE] m =  ( n - 1.0 )  / 2.0;^[METHOD] getB [TYPE] double [PARAMETER] int n double x [CLASS] 1   [TYPE]  boolean false  true  [TYPE]  double m  ret  x  [TYPE]  int n 
[REPLACE]^ret = - (  ( a + m )  *  ( a + b + m )  * x )   ;^138^139^^^^129^142^[REPLACE] ret = - (  ( a + m )  *  ( a + b + m )  * x )  / (  ( a +  ( 2 * m )  )  *  ( a +  ( 2 * m )  + 1.0 )  ) ;^[METHOD] getB [TYPE] double [PARAMETER] int n double x [CLASS] 1   [TYPE]  boolean false  true  [TYPE]  double m  ret  x  [TYPE]  int n 
[REPLACE]^m = n  ;^133^^^^^129^142^[REPLACE] m = n / 2.0;^[METHOD] getB [TYPE] double [PARAMETER] int n double x [CLASS] 1   [TYPE]  boolean false  true  [TYPE]  double m  ret  x  [TYPE]  int n 
[REPLACE]^ret =  ( m *  ( b - m )  * x )   ;^134^135^^^^129^142^[REPLACE] ret =  ( m *  ( b - m )  * x )  / (  ( a +  ( 2 * m )  - 1 )  *  ( a +  ( 2 * m )  )  ) ;^[METHOD] getB [TYPE] double [PARAMETER] int n double x [CLASS] 1   [TYPE]  boolean false  true  [TYPE]  double m  ret  x  [TYPE]  int n 
[ADD]^^134^135^^^^129^142^[ADD] ret =  ( m *  ( b - m )  * x )  / (  ( a +  ( 2 * m )  - 1 )  *  ( a +  ( 2 * m )  )  ) ;^[METHOD] getB [TYPE] double [PARAMETER] int n double x [CLASS] 1   [TYPE]  boolean false  true  [TYPE]  double m  ret  x  [TYPE]  int n 
[ADD]^^133^^^^^129^142^[ADD] m = n / 2.0;^[METHOD] getB [TYPE] double [PARAMETER] int n double x [CLASS] 1   [TYPE]  boolean false  true  [TYPE]  double m  ret  x  [TYPE]  int n 
[REPLACE]^m =  ( n - 1.0 )   ;^137^^^^^129^142^[REPLACE] m =  ( n - 1.0 )  / 2.0;^[METHOD] getB [TYPE] double [PARAMETER] int n double x [CLASS] 1   [TYPE]  boolean false  true  [TYPE]  double m  ret  x  [TYPE]  int n 
[ADD]^^137^^^^^129^142^[ADD] m =  ( n - 1.0 )  / 2.0;^[METHOD] getB [TYPE] double [PARAMETER] int n double x [CLASS] 1   [TYPE]  boolean false  true  [TYPE]  double m  ret  x  [TYPE]  int n 
[REPLACE]^return 1.0;^141^^^^^129^142^[REPLACE] return ret;^[METHOD] getB [TYPE] double [PARAMETER] int n double x [CLASS] 1   [TYPE]  boolean false  true  [TYPE]  double m  ret  x  [TYPE]  int n 
[REPLACE]^return 1.0d;^145^^^^^144^146^[REPLACE] return 1.0;^[METHOD] getA [TYPE] double [PARAMETER] int n double x [CLASS] 1   [TYPE]  boolean false  true  [TYPE]  double x  [TYPE]  int n 
