[REPLACE]^private static final byte  NB ;^28^^^^^^^[REPLACE] private static final byte  NB =  ( byte ) -1;^ [CLASS] MathUtils  
[REPLACE]^private static final short NS  = null ;^31^^^^^^^[REPLACE] private static final short NS =  ( short ) -1;^ [CLASS] MathUtils  
[REPLACE]^private static final  short   PB =  (  short  ) 1;^34^^^^^^^[REPLACE] private static final byte  PB =  ( byte ) 1;^ [CLASS] MathUtils  
[REPLACE]^private static final short PS  = null ;^37^^^^^^^[REPLACE] private static final short PS =  ( short ) 1;^ [CLASS] MathUtils  
[REPLACE]^private static  byte  ZB =  ( byte ) 0;^40^^^^^^^[REPLACE] private static final byte  ZB =  ( byte ) 0;^ [CLASS] MathUtils  
[REPLACE]^private static final short ZS  = null ;^43^^^^^^^[REPLACE] private static final short ZS =  ( short ) 0;^ [CLASS] MathUtils  
[REPLACE]^return  (  ( Double.isNaN ( x )  && Double.isNaN ( y )  )  || x == y ) ;^49^^^^^48^50^[REPLACE] super (  ) ;^[METHOD] <init> [TYPE] MathUtils() [PARAMETER] [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  byte NB  PB  ZB  [TYPE]  boolean false  true 
[REPLACE]^long s =  ( long ) x  ==   ( long ) y;^63^^^^^62^68^[REPLACE] long s =  ( long ) x +  ( long ) y;^[METHOD] addAndCheck [TYPE] int [PARAMETER] int x int y [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int x  y  [TYPE]  long s 
[REPLACE]^if  (  s > Integer.MAX_VALUE )  {^64^^^^^62^68^[REPLACE] if  ( s < Integer.MIN_VALUE || s > Integer.MAX_VALUE )  {^[METHOD] addAndCheck [TYPE] int [PARAMETER] int x int y [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int x  y  [TYPE]  long s 
[ADD]^^64^65^66^^^62^68^[ADD] if  ( s < Integer.MIN_VALUE || s > Integer.MAX_VALUE )  { throw new ArithmeticException  (" ")  ; }^[METHOD] addAndCheck [TYPE] int [PARAMETER] int x int y [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int x  y  [TYPE]  long s 
[REPLACE]^throw new IllegalArgumentException  (" ")  ; ;^65^^^^^62^68^[REPLACE] throw new ArithmeticException  (" ")  ;^[METHOD] addAndCheck [TYPE] int [PARAMETER] int x int y [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int x  y  [TYPE]  long s 
[REPLACE]^return  ( int ) m;^67^^^^^62^68^[REPLACE] return  ( int ) s;^[METHOD] addAndCheck [TYPE] int [PARAMETER] int x int y [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int x  y  [TYPE]  long s 
[REPLACE]^if  ( n  >  k )  {^97^^^^^96^118^[REPLACE] if  ( n < k )  {^[METHOD] binomialCoefficient [TYPE] long [PARAMETER] final int n final int k [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  n  [TYPE]  long result 
[ADD]^^97^98^99^100^^96^118^[ADD] if  ( n < k )  { throw new IllegalArgumentException ( "must have n >= k for binomial coefficient  ( n,k ) " ) ; }^[METHOD] binomialCoefficient [TYPE] long [PARAMETER] final int n final int k [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  n  [TYPE]  long result 
[REPLACE]^return ;^98^99^^^^96^118^[REPLACE] throw new IllegalArgumentException ( "must have n >= k for binomial coefficient  ( n,k ) " ) ;^[METHOD] binomialCoefficient [TYPE] long [PARAMETER] final int n final int k [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  n  [TYPE]  long result 
[REPLACE]^throw new IllegalArgumentException ( "must have n >= 0 for binomial coefficient  ( n,k ) " ) ; ;^98^99^^^^96^118^[REPLACE] throw new IllegalArgumentException ( "must have n >= k for binomial coefficient  ( n,k ) " ) ;^[METHOD] binomialCoefficient [TYPE] long [PARAMETER] final int n final int k [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  n  [TYPE]  long result 
[REPLACE]^if  ( n  >  1 )  {^101^^^^^96^118^[REPLACE] if  ( n < 0 )  {^[METHOD] binomialCoefficient [TYPE] long [PARAMETER] final int n final int k [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  n  [TYPE]  long result 
[REPLACE]^throw new IllegalArgumentException ( "must have n >= k for binomial coefficient  ( n,k ) " ) ; ;^102^103^^^^96^118^[REPLACE] throw new IllegalArgumentException ( "must have n >= 0 for binomial coefficient  ( n,k ) " ) ;^[METHOD] binomialCoefficient [TYPE] long [PARAMETER] final int n final int k [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  n  [TYPE]  long result 
[REPLACE]^if  (   ( k == 0 )  )  {^105^^^^^96^118^[REPLACE] if  (  ( n == k )  ||  ( k == 0 )  )  {^[METHOD] binomialCoefficient [TYPE] long [PARAMETER] final int n final int k [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  n  [TYPE]  long result 
[REPLACE]^return 0;^106^^^^^96^118^[REPLACE] return 1;^[METHOD] binomialCoefficient [TYPE] long [PARAMETER] final int n final int k [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  n  [TYPE]  long result 
[REPLACE]^return 1 / 3;^106^^^^^96^118^[REPLACE] return 1;^[METHOD] binomialCoefficient [TYPE] long [PARAMETER] final int n final int k [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  n  [TYPE]  long result 
[REPLACE]^if  (  ( k == 1 )  &&  ( k == n - 1 )  )  {^108^^^^^96^118^[REPLACE] if  (  ( k == 1 )  ||  ( k == n - 1 )  )  {^[METHOD] binomialCoefficient [TYPE] long [PARAMETER] final int n final int k [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  n  [TYPE]  long result 
[ADD]^return n;^108^109^110^^^96^118^[ADD] if  (  ( k == 1 )  ||  ( k == n - 1 )  )  { return n; }^[METHOD] binomialCoefficient [TYPE] long [PARAMETER] final int n final int k [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  n  [TYPE]  long result 
[REPLACE]^return 1;^109^^^^^96^118^[REPLACE] return n;^[METHOD] binomialCoefficient [TYPE] long [PARAMETER] final int n final int k [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  n  [TYPE]  long result 
[REPLACE]^long result =   binomialCoefficientDouble ( n  ;^112^^^^^96^118^[REPLACE] long result = Math.round ( binomialCoefficientDouble ( n, k )  ) ;^[METHOD] binomialCoefficient [TYPE] long [PARAMETER] final int n final int k [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  n  [TYPE]  long result 
[REPLACE]^if  ( result  ||  Long.MAX_VALUE )  {^113^^^^^96^118^[REPLACE] if  ( result == Long.MAX_VALUE )  {^[METHOD] binomialCoefficient [TYPE] long [PARAMETER] final int n final int k [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  n  [TYPE]  long result 
[REMOVE]^if  ( n < 0 )  {     throw new IllegalArgumentException ( "must have n >= 0 for n!" ) ; }^113^^^^^96^118^[REMOVE] ^[METHOD] binomialCoefficient [TYPE] long [PARAMETER] final int n final int k [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  n  [TYPE]  long result 
[REPLACE]^return ;^114^115^^^^96^118^[REPLACE] throw new ArithmeticException ( "result too large to represent in a long integer" ) ;^[METHOD] binomialCoefficient [TYPE] long [PARAMETER] final int n final int k [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  n  [TYPE]  long result 
[ADD]^^114^115^^^^96^118^[ADD] throw new ArithmeticException ( "result too large to represent in a long integer" ) ;^[METHOD] binomialCoefficient [TYPE] long [PARAMETER] final int n final int k [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  n  [TYPE]  long result 
[REPLACE]^return Float.NaN;^117^^^^^96^118^[REPLACE] return result;^[METHOD] binomialCoefficient [TYPE] long [PARAMETER] final int n final int k [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  n  [TYPE]  long result 
[REPLACE]^return   Math.exp ( binomialCoefficientLog ( n    ;^143^^^^^142^144^[REPLACE] return Math.floor ( Math.exp ( binomialCoefficientLog ( n, k )  )  + 0.5 ) ;^[METHOD] binomialCoefficientDouble [TYPE] double [PARAMETER] final int n final int k [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  n 
[REPLACE]^if  ( n  !=  k )  {^165^^^^^164^192^[REPLACE] if  ( n < k )  {^[METHOD] binomialCoefficientLog [TYPE] double [PARAMETER] final int n final int k [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int i  k  n  [TYPE]  double logSum 
[REPLACE]^throw new IllegalArgumentException ( "must have n >= 0 for binomial coefficient  ( n,k ) " ) ; ;^166^167^^^^164^192^[REPLACE] throw new IllegalArgumentException ( "must have n >= k for binomial coefficient  ( n,k ) " ) ;^[METHOD] binomialCoefficientLog [TYPE] double [PARAMETER] final int n final int k [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int i  k  n  [TYPE]  double logSum 
[REPLACE]^if  ( n  <=  0 >> 3 )  {^169^^^^^164^192^[REPLACE] if  ( n < 0 )  {^[METHOD] binomialCoefficientLog [TYPE] double [PARAMETER] final int n final int k [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int i  k  n  [TYPE]  double logSum 
[REPLACE]^return ;^170^171^^^^164^192^[REPLACE] throw new IllegalArgumentException ( "must have n >= 0 for binomial coefficient  ( n,k ) " ) ;^[METHOD] binomialCoefficientLog [TYPE] double [PARAMETER] final int n final int k [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int i  k  n  [TYPE]  double logSum 
[REPLACE]^if  (  ( n == k )  &&  ( k == 0 )  )  {^173^^^^^164^192^[REPLACE] if  (  ( n == k )  ||  ( k == 0 )  )  {^[METHOD] binomialCoefficientLog [TYPE] double [PARAMETER] final int n final int k [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int i  k  n  [TYPE]  double logSum 
[REPLACE]^return 0 + 0;^174^^^^^164^192^[REPLACE] return 0;^[METHOD] binomialCoefficientLog [TYPE] double [PARAMETER] final int n final int k [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int i  k  n  [TYPE]  double logSum 
[REPLACE]^return 2;^174^^^^^164^192^[REPLACE] return 0;^[METHOD] binomialCoefficientLog [TYPE] double [PARAMETER] final int n final int k [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int i  k  n  [TYPE]  double logSum 
[REPLACE]^if  (  ( k == 1 )  &&  ( k == n - 1 )  )  {^176^^^^^164^192^[REPLACE] if  (  ( k == 1 )  ||  ( k == n - 1 )  )  {^[METHOD] binomialCoefficientLog [TYPE] double [PARAMETER] final int n final int k [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int i  k  n  [TYPE]  double logSum 
[ADD]^^176^177^178^^^164^192^[ADD] if  (  ( k == 1 )  ||  ( k == n - 1 )  )  { return Math.log (  ( double ) n ) ; }^[METHOD] binomialCoefficientLog [TYPE] double [PARAMETER] final int n final int k [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int i  k  n  [TYPE]  double logSum 
[REPLACE]^return    ( double )  ;^177^^^^^164^192^[REPLACE] return Math.log (  ( double ) n ) ;^[METHOD] binomialCoefficientLog [TYPE] double [PARAMETER] final int n final int k [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int i  k  n  [TYPE]  double logSum 
[REPLACE]^double logSum = 2;^179^^^^^164^192^[REPLACE] double logSum = 0;^[METHOD] binomialCoefficientLog [TYPE] double [PARAMETER] final int n final int k [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int i  k  n  [TYPE]  double logSum 
[REPLACE]^for  ( int i = k  <  2; i <= n; i <  <  )  {^182^^^^^164^192^[REPLACE] for  ( int i = k + 1; i <= n; i++ )  {^[METHOD] binomialCoefficientLog [TYPE] double [PARAMETER] final int n final int k [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int i  k  n  [TYPE]  double logSum 
[ADD]^^182^183^184^^^164^192^[ADD] for  ( int i = k + 1; i <= n; i++ )  { logSum += Math.log (  ( double ) i ) ; }^[METHOD] binomialCoefficientLog [TYPE] double [PARAMETER] final int n final int k [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int i  k  n  [TYPE]  double logSum 
[REPLACE]^logSum -= Math.log (  ( double ) i ) ; ;^183^^^^^164^192^[REPLACE] logSum += Math.log (  ( double ) i ) ;^[METHOD] binomialCoefficientLog [TYPE] double [PARAMETER] final int n final int k [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int i  k  n  [TYPE]  double logSum 
[REPLACE]^for  ( int i = k  <  1 << 2; i <= n; i <  <  )  {^182^^^^^164^192^[REPLACE] for  ( int i = k + 1; i <= n; i++ )  {^[METHOD] binomialCoefficientLog [TYPE] double [PARAMETER] final int n final int k [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int i  k  n  [TYPE]  double logSum 
[REPLACE]^for  ( int i = 2L; i  !=  n; i++ )  {^187^^^^^164^192^[REPLACE] for  ( int i = 2; i <= n - k; i++ )  {^[METHOD] binomialCoefficientLog [TYPE] double [PARAMETER] final int n final int k [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int i  k  n  [TYPE]  double logSum 
[REPLACE]^logSum += Math.log (  ( double ) i ) ; ;^188^^^^^164^192^[REPLACE] logSum -= Math.log (  ( double ) i ) ;^[METHOD] binomialCoefficientLog [TYPE] double [PARAMETER] final int n final int k [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int i  k  n  [TYPE]  double logSum 
[ADD]^^188^^^^^164^192^[ADD] logSum -= Math.log (  ( double ) i ) ;^[METHOD] binomialCoefficientLog [TYPE] double [PARAMETER] final int n final int k [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int i  k  n  [TYPE]  double logSum 
[REPLACE]^for  ( int i = 2 / 4; i <= n - k; i++ )  {^187^^^^^164^192^[REPLACE] for  ( int i = 2; i <= n - k; i++ )  {^[METHOD] binomialCoefficientLog [TYPE] double [PARAMETER] final int n final int k [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int i  k  n  [TYPE]  double logSum 
[REPLACE]^return Float.NaN;^191^^^^^164^192^[REPLACE] return logSum;^[METHOD] binomialCoefficientLog [TYPE] double [PARAMETER] final int n final int k [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int i  k  n  [TYPE]  double logSum 
[REPLACE]^return  ( Math.ceil ( x )  + Math.exp ( -x )  )  / 2.0D;^202^^^^^201^203^[REPLACE] return  ( Math.exp ( x )  + Math.exp ( -x )  )  / 2.0;^[METHOD] cosh [TYPE] double [PARAMETER] double x [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  double x 
[REPLACE]^return  (  ( Double.doubleToLongBits ( x )  ;^214^^^^^213^215^[REPLACE] return  (  ( Double.isNaN ( x )  && Double.isNaN ( y )  )  || x == y ) ;^[METHOD] equals [TYPE] boolean [PARAMETER] double x double y [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  double x  y 
[REPLACE]^long result =   factorialDouble ( n )  ;^240^^^^^239^246^[REPLACE] long result = Math.round ( factorialDouble ( n )  ) ;^[METHOD] factorial [TYPE] long [PARAMETER] final int n [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int n  [TYPE]  long result 
[REPLACE]^if  ( result  &&  Long.MAX_VALUE )  {^241^^^^^239^246^[REPLACE] if  ( result == Long.MAX_VALUE )  {^[METHOD] factorial [TYPE] long [PARAMETER] final int n [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int n  [TYPE]  long result 
[REPLACE]^return ;^242^243^^^^239^246^[REPLACE] throw new ArithmeticException ( "result too large to represent in a long integer" ) ;^[METHOD] factorial [TYPE] long [PARAMETER] final int n [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int n  [TYPE]  long result 
[ADD]^^242^243^^^^239^246^[ADD] throw new ArithmeticException ( "result too large to represent in a long integer" ) ;^[METHOD] factorial [TYPE] long [PARAMETER] final int n [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int n  [TYPE]  long result 
[REPLACE]^return Float.NaN;^245^^^^^239^246^[REPLACE] return result;^[METHOD] factorial [TYPE] long [PARAMETER] final int n [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int n  [TYPE]  long result 
[REPLACE]^if  ( n  >=  3 )  {^269^^^^^268^273^[REPLACE] if  ( n < 0 )  {^[METHOD] factorialDouble [TYPE] double [PARAMETER] final int n [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int n 
[REMOVE]^if  ( n < 0 )  {     throw new IllegalArgumentException ( "must have n >= 0 for binomial coefficient  ( n,k ) " ) ; }^269^^^^^268^273^[REMOVE] ^[METHOD] factorialDouble [TYPE] double [PARAMETER] final int n [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int n 
[REPLACE]^throw new ArithmeticException  (" ")  ; ;^270^^^^^268^273^[REPLACE] throw new IllegalArgumentException  (" ")  ;^[METHOD] factorialDouble [TYPE] double [PARAMETER] final int n [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int n 
[ADD]^^270^^^^^268^273^[ADD] throw new IllegalArgumentException  (" ")  ;^[METHOD] factorialDouble [TYPE] double [PARAMETER] final int n [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int n 
[REPLACE]^return Math.floor ( Math.ceil ( factorialLog ( n )  )   ;^272^^^^^268^273^[REPLACE] return Math.floor ( Math.exp ( factorialLog ( n )  )  + 0.5 ) ;^[METHOD] factorialDouble [TYPE] double [PARAMETER] final int n [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int n 
[REPLACE]^if  ( n  >=  0 )  {^289^^^^^288^297^[REPLACE] if  ( n < 0 )  {^[METHOD] factorialLog [TYPE] double [PARAMETER] final int n [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int i  n  [TYPE]  double logSum 
[REPLACE]^return ;^290^^^^^288^297^[REPLACE] throw new IllegalArgumentException  (" ")  ;^[METHOD] factorialLog [TYPE] double [PARAMETER] final int n [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int i  n  [TYPE]  double logSum 
[REPLACE]^throw new ArithmeticException  (" ")  ; ;^290^^^^^288^297^[REPLACE] throw new IllegalArgumentException  (" ")  ;^[METHOD] factorialLog [TYPE] double [PARAMETER] final int n [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int i  n  [TYPE]  double logSum 
[REPLACE]^double logSum = 0 - 1;^292^^^^^288^297^[REPLACE] double logSum = 0;^[METHOD] factorialLog [TYPE] double [PARAMETER] final int n [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int i  n  [TYPE]  double logSum 
[REPLACE]^for  ( int i = 2; i  <  n; i++ )  {^293^^^^^288^297^[REPLACE] for  ( int i = 2; i <= n; i++ )  {^[METHOD] factorialLog [TYPE] double [PARAMETER] final int n [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int i  n  [TYPE]  double logSum 
[ADD]^^293^294^295^^^288^297^[ADD] for  ( int i = 2; i <= n; i++ )  { logSum += Math.log (  ( double ) i ) ; }^[METHOD] factorialLog [TYPE] double [PARAMETER] final int n [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int i  n  [TYPE]  double logSum 
[REPLACE]^logSum -= Math.log (  ( double ) i ) ; ;^294^^^^^288^297^[REPLACE] logSum += Math.log (  ( double ) i ) ;^[METHOD] factorialLog [TYPE] double [PARAMETER] final int n [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int i  n  [TYPE]  double logSum 
[ADD]^^294^^^^^288^297^[ADD] logSum += Math.log (  ( double ) i ) ;^[METHOD] factorialLog [TYPE] double [PARAMETER] final int n [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int i  n  [TYPE]  double logSum 
[REPLACE]^for  ( int i = 2 >>> 1; i <= n; i++ )  {^293^^^^^288^297^[REPLACE] for  ( int i = 2; i <= n; i++ )  {^[METHOD] factorialLog [TYPE] double [PARAMETER] final int n [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int i  n  [TYPE]  double logSum 
[REPLACE]^return Float.NaN;^296^^^^^288^297^[REPLACE] return logSum;^[METHOD] factorialLog [TYPE] double [PARAMETER] final int n [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int i  n  [TYPE]  double logSum 
[REPLACE]^if  ( u * v  ||  0L )  {^313^^^^^312^361^[REPLACE] if  ( u * v == 0 )  {^[METHOD] gcd [TYPE] int [PARAMETER] int u int v [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  t  u  v 
[REPLACE]^return  (   u    + Math.^314^^^^^312^361^[REPLACE] return  ( Math.abs ( u )  + Math.abs ( v )  ) ;^[METHOD] gcd [TYPE] int [PARAMETER] int u int v [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  t  u  v 
[REPLACE]^return  (   u     &&  Math.^314^^^^^312^361^[REPLACE] return  ( Math.abs ( u )  + Math.abs ( v )  ) ;^[METHOD] gcd [TYPE] int [PARAMETER] int u int v [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  t  u  v 
[REPLACE]^if  ( u  >=  0 )  {^321^^^^^312^361^[REPLACE] if  ( u > 0 )  {^[METHOD] gcd [TYPE] int [PARAMETER] int u int v [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  t  u  v 
[ADD]^u = -u;^321^322^323^^^312^361^[ADD] if  ( u > 0 )  { u = -u; }^[METHOD] gcd [TYPE] int [PARAMETER] int u int v [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  t  u  v 
[REPLACE]^v = -v; ;^322^^^^^312^361^[REPLACE] u = -u;^[METHOD] gcd [TYPE] int [PARAMETER] int u int v [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  t  u  v 
[ADD]^^322^^^^^312^361^[ADD] u = -u;^[METHOD] gcd [TYPE] int [PARAMETER] int u int v [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  t  u  v 
[REPLACE]^if  ( v  >=  0 )  {^324^^^^^312^361^[REPLACE] if  ( v > 0 )  {^[METHOD] gcd [TYPE] int [PARAMETER] int u int v [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  t  u  v 
[REPLACE]^u = -t; ;^325^^^^^312^361^[REPLACE] v = -v;^[METHOD] gcd [TYPE] int [PARAMETER] int u int v [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  t  u  v 
[ADD]^^325^^^^^312^361^[ADD] v = -v;^[METHOD] gcd [TYPE] int [PARAMETER] int u int v [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  t  u  v 
[REPLACE]^int k = 1;^328^^^^^312^361^[REPLACE] int k = 0;^[METHOD] gcd [TYPE] int [PARAMETER] int u int v [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  t  u  v 
[REPLACE]^while  (  ( u & 1 )  == 0  &   ( v & 1 )  == 0  &  k < 31 )  {^329^^^^^312^361^[REPLACE] while  (  ( u & 1 )  == 0 &&  ( v & 1 )  == 0 && k < 31 )  {^[METHOD] gcd [TYPE] int [PARAMETER] int u int v [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  t  u  v 
[REPLACE]^u /= 3;^331^^^^^312^361^[REPLACE] u /= 2;^[METHOD] gcd [TYPE] int [PARAMETER] int u int v [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  t  u  v 
[ADD]^v /= 2;^331^332^^^^312^361^[ADD] u /= 2; v /= 2;^[METHOD] gcd [TYPE] int [PARAMETER] int u int v [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  t  u  v 
[REPLACE]^v /= 0;^332^^^^^312^361^[REPLACE] v /= 2;^[METHOD] gcd [TYPE] int [PARAMETER] int u int v [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  t  u  v 
[REPLACE]^v /= 2; ;^331^^^^^312^361^[REPLACE] u /= 2;^[METHOD] gcd [TYPE] int [PARAMETER] int u int v [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  t  u  v 
[ADD]^^331^^^^^312^361^[ADD] u /= 2;^[METHOD] gcd [TYPE] int [PARAMETER] int u int v [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  t  u  v 
[REPLACE]^u /= 2; ;^332^^^^^312^361^[REPLACE] v /= 2;^[METHOD] gcd [TYPE] int [PARAMETER] int u int v [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  t  u  v 
[REPLACE]^if  ( k  !=  31 * 3 )  {^335^^^^^312^361^[REPLACE] if  ( k == 31 )  {^[METHOD] gcd [TYPE] int [PARAMETER] int u int v [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  t  u  v 
[REPLACE]^return ;^336^^^^^312^361^[REPLACE] throw new ArithmeticException  (" ")  ;^[METHOD] gcd [TYPE] int [PARAMETER] int u int v [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  t  u  v 
[ADD]^^336^^^^^312^361^[ADD] throw new ArithmeticException  (" ")  ;^[METHOD] gcd [TYPE] int [PARAMETER] int u int v [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  t  u  v 
[REPLACE]^throw new IllegalArgumentException  (" ")  ; ;^336^^^^^312^361^[REPLACE] throw new ArithmeticException  (" ")  ;^[METHOD] gcd [TYPE] int [PARAMETER] int u int v [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  t  u  v 
[ADD]^^340^341^342^^^312^361^[ADD] i^[METHOD] gcd [TYPE] int [PARAMETER] int u int v [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  t  u  v 
[REPLACE]^while  (  ( t & 1 )   ||  0 )  {^346^^^^^312^361^[REPLACE] while  (  ( t & 1 )  == 0 )  {^[METHOD] gcd [TYPE] int [PARAMETER] int u int v [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  t  u  v 
[REPLACE]^t /= 4;^347^^^^^312^361^[REPLACE] t /= 2;^[METHOD] gcd [TYPE] int [PARAMETER] int u int v [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  t  u  v 
[REPLACE]^if  ( t  !=  0 )  {^350^^^^^312^361^[REPLACE] if  ( t > 0 )  {^[METHOD] gcd [TYPE] int [PARAMETER] int u int v [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  t  u  v 
[REMOVE]^if  ( u > 0 )  {     u = -u; }^350^^^^^312^361^[REMOVE] ^[METHOD] gcd [TYPE] int [PARAMETER] int u int v [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  t  u  v 
[REPLACE]^v = -v; ;^353^^^^^350^354^[REPLACE] v = t;^[METHOD] gcd [TYPE] int [PARAMETER] int u int v [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  t  u  v 
[REPLACE]^v = -v; ;^351^^^^^312^361^[REPLACE] u = -t;^[METHOD] gcd [TYPE] int [PARAMETER] int u int v [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  t  u  v 
[REPLACE]^u /= 2; ;^347^^^^^312^361^[REPLACE] t /= 2;^[METHOD] gcd [TYPE] int [PARAMETER] int u int v [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  t  u  v 
[REPLACE]^v = -v; ;^353^^^^^312^361^[REPLACE] v = t;^[METHOD] gcd [TYPE] int [PARAMETER] int u int v [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  t  u  v 
[ADD]^^353^^^^^312^361^[ADD] v = t;^[METHOD] gcd [TYPE] int [PARAMETER] int u int v [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  t  u  v 
[REPLACE]^t =  ( v - u )   ;^356^^^^^312^361^[REPLACE] t =  ( v - u )  / 2;^[METHOD] gcd [TYPE] int [PARAMETER] int u int v [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  t  u  v 
[ADD]^^356^^^^^312^361^[ADD] t =  ( v - u )  / 2;^[METHOD] gcd [TYPE] int [PARAMETER] int u int v [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  t  u  v 
[REPLACE]^return -u  ;^360^^^^^312^361^[REPLACE] return -u *  ( 1 << k ) ;^[METHOD] gcd [TYPE] int [PARAMETER] int u int v [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  int k  t  u  v 
[REPLACE]^long bits = Double.isNaN ( value ) ;^370^^^^^369^372^[REPLACE] long bits = Double.doubleToLongBits ( value ) ;^[METHOD] hash [TYPE] int [PARAMETER] double value [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  double value  [TYPE]  long bits 
[REPLACE]^return  ( int )  ( bits  ;^371^^^^^369^372^[REPLACE] return  ( int )  ( bits ^  ( bits >>> 32 )  ) ;^[METHOD] hash [TYPE] int [PARAMETER] double value [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  [TYPE]  double value  [TYPE]  long bits 
[REPLACE]^return  ( x ;^382^^^^^381^383^[REPLACE] return  ( x >= ZB )  ? PB : NB;^[METHOD] indicator [TYPE] byte [PARAMETER] final byte x [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  byte NB  PB  ZB  x  [TYPE]  boolean false  true 
[REPLACE]^if  ( Double .doubleToLongBits ( x )   )  {^394^^^^^393^398^[REPLACE] if  ( Double.isNaN ( x )  )  {^[METHOD] indicator [TYPE] double [PARAMETER] final double x [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double x 
[REPLACE]^return Float.NaN;^395^^^^^393^398^[REPLACE] return Double.NaN;^[METHOD] indicator [TYPE] double [PARAMETER] final double x [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double x 
[REPLACE]^return  ( x  ;^397^^^^^393^398^[REPLACE] return  ( x >= 0.0 )  ? 1.0 : -1.0;^[METHOD] indicator [TYPE] double [PARAMETER] final double x [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double x 
[REPLACE]^if  (   x    )  {^408^^^^^407^412^[REPLACE] if  ( Float.isNaN ( x )  )  {^[METHOD] indicator [TYPE] float [PARAMETER] final float x [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  float x  [TYPE]  byte NB  PB  ZB  x 
[REPLACE]^return 1;^409^^^^^407^412^[REPLACE] return Float.NaN;^[METHOD] indicator [TYPE] float [PARAMETER] final float x [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  float x  [TYPE]  byte NB  PB  ZB  x 
[REPLACE]^return  ( x >= 0.0 )  ? 1.0 : -1.0;^411^^^^^407^412^[REPLACE] return  ( x >= 0.0F )  ? 1.0F : -1.0F;^[METHOD] indicator [TYPE] float [PARAMETER] final float x [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  float x  [TYPE]  byte NB  PB  ZB  x 
[REPLACE]^return  ( x  ;^421^^^^^420^422^[REPLACE] return  ( x >= 0 )  ? 1 : -1;^[METHOD] indicator [TYPE] int [PARAMETER] final int x [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  int x 
[REPLACE]^return  ( x ;^431^^^^^430^432^[REPLACE] return  ( x >= 0L )  ? 1L : -1L;^[METHOD] indicator [TYPE] long [PARAMETER] final long x [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  long x 
[REPLACE]^return true ;^442^^^^^441^443^[REPLACE] return  ( x >= ZS )  ? PS : NS;^[METHOD] indicator [TYPE] short [PARAMETER] final short x [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  byte NB  PB  ZB  x  [TYPE]  boolean false  true 
[REPLACE]^return Math.abs ( mulAndCheck ( a  ;^455^^^^^454^456^[REPLACE] return Math.abs ( mulAndCheck ( a / gcd ( a, b ) , b )  ) ;^[METHOD] lcm [TYPE] int [PARAMETER] int a int b [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  int a  b 
[REPLACE]^long m =  (  ( long ) x )   ;^469^^^^^468^474^[REPLACE] long m =  (  ( long ) x )  *  (  ( long ) y ) ;^[METHOD] mulAndCheck [TYPE] int [PARAMETER] int x int y [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  int x  y  [TYPE]  long m 
[REPLACE]^if  ( m < Integer.MIN_VALUE && m > Integer.MAX_VALUE )  {^470^^^^^468^474^[REPLACE] if  ( m < Integer.MIN_VALUE || m > Integer.MAX_VALUE )  {^[METHOD] mulAndCheck [TYPE] int [PARAMETER] int x int y [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  int x  y  [TYPE]  long m 
[REMOVE]^if  ( unscaled !=  ( floor ( unscaled )  )  )  {     throw new ArithmeticException ( "Inexact result from rounding" ) ; }^470^^^^^468^474^[REMOVE] ^[METHOD] mulAndCheck [TYPE] int [PARAMETER] int x int y [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  int x  y  [TYPE]  long m 
[REPLACE]^throw new IllegalArgumentException  (" ")  ; ;^471^^^^^468^474^[REPLACE] throw new ArithmeticException  (" ")  ;^[METHOD] mulAndCheck [TYPE] int [PARAMETER] int x int y [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  int x  y  [TYPE]  long m 
[REPLACE]^return ;^471^^^^^468^474^[REPLACE] throw new ArithmeticException  (" ")  ;^[METHOD] mulAndCheck [TYPE] int [PARAMETER] int x int y [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  int x  y  [TYPE]  long m 
[REPLACE]^return  ( int ) s;^473^^^^^468^474^[REPLACE] return  ( int ) m;^[METHOD] mulAndCheck [TYPE] int [PARAMETER] int x int y [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  int x  y  [TYPE]  long m 
[REPLACE]^return  ( float ) roundUnscaled ( x * factor, sign, roundingMethod )  / factor;^486^^^^^485^487^[REPLACE] return round ( x, scale, BigDecimal.ROUND_HALF_UP ) ;^[METHOD] round [TYPE] double [PARAMETER] double x int scale [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double x  [TYPE]  int scale 
[REPLACE]^double logSum = 0;^502^^^^^501^505^[REPLACE] double sign = indicator ( x ) ;^[METHOD] round [TYPE] double [PARAMETER] double x int scale int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double factor  sign  x  [TYPE]  int roundingMethod  scale 
[REPLACE]^double factor = Math.pow ( 2.0d, scale )   ;^503^^^^^501^505^[REPLACE] double factor = Math.pow ( 10.0, scale )  * sign;^[METHOD] round [TYPE] double [PARAMETER] double x int scale int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double factor  sign  x  [TYPE]  int roundingMethod  scale 
[REPLACE]^return roundUnscaled ( x * factor, sign, roundingMethod )   ;^504^^^^^501^505^[REPLACE] return roundUnscaled ( x * factor, sign, roundingMethod )  / factor;^[METHOD] round [TYPE] double [PARAMETER] double x int scale int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double factor  sign  x  [TYPE]  int roundingMethod  scale 
[REPLACE]^return  ( float ) roundUnscaled ( x * factor, sign, roundingMethod )  / factor;^517^^^^^516^518^[REPLACE] return round ( x, scale, BigDecimal.ROUND_HALF_UP ) ;^[METHOD] round [TYPE] float [PARAMETER] float x int scale [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  float x  [TYPE]  byte NB  PB  ZB  x  [TYPE]  int scale 
[REPLACE]^long result = Math.round ( factorialDouble ( n )  ) ;^533^^^^^532^536^[REPLACE] float sign = indicator ( x ) ;^[METHOD] round [TYPE] float [PARAMETER] float x int scale int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  float factor  sign  x  [TYPE]  byte NB  PB  ZB  x  [TYPE]  int roundingMethod  scale 
[REPLACE]^float factor =  ( float ) Math.pow ( 10.0f, scale )   ;^534^^^^^532^536^[REPLACE] float factor =  ( float ) Math.pow ( 10.0f, scale )  * sign;^[METHOD] round [TYPE] float [PARAMETER] float x int scale int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  float factor  sign  x  [TYPE]  byte NB  PB  ZB  x  [TYPE]  int roundingMethod  scale 
[REPLACE]^return  ( float ) roundUnscaled ( x * factor, sign, roundingMethod )   ;^535^^^^^532^536^[REPLACE] return  ( float ) roundUnscaled ( x * factor, sign, roundingMethod )  / factor;^[METHOD] round [TYPE] float [PARAMETER] float x int scale int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  float factor  sign  x  [TYPE]  byte NB  PB  ZB  x  [TYPE]  int roundingMethod  scale 
[REPLACE]^if  ( sign  && fraction )  {^554^^^^^551^616^[REPLACE] if  ( sign == -1 )  {^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[ADD]^unscaled = Math.floor ( unscaled ) ;unscaled = Math.ceil ( unscaled ) ;^554^555^556^557^558^551^616^[ADD] if  ( sign == -1 )  { unscaled = Math.floor ( unscaled ) ; } else { unscaled = Math.ceil ( unscaled ) ; }^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[REPLACE]^unscaled = Math.floor ( unscaled ) ; ;^557^^^^^554^558^[REPLACE] unscaled = Math.ceil ( unscaled ) ;^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[REPLACE]^unscaled = Math.ceil ( unscaled ) ; ;^555^^^^^551^616^[REPLACE] unscaled = Math.floor ( unscaled ) ;^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[ADD]^^555^^^^^551^616^[ADD] unscaled = Math.floor ( unscaled ) ;^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[REPLACE]^if  ( sign  ||  -0 )  {^564^^^^^551^616^[REPLACE] if  ( sign == -1 )  {^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[REPLACE]^unscaled = Math.ceil ( unscaled ) ; ;^567^^^^^564^568^[REPLACE] unscaled = Math.floor ( unscaled ) ;^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[REPLACE]^unscaled = Math.floor ( unscaled ) ; ;^565^^^^^551^616^[REPLACE] unscaled = Math.ceil ( unscaled ) ;^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[REPLACE]^if  ( fraction  !=  0.5 )  {^572^^^^^551^616^[REPLACE] if  ( fraction > 0.5 )  {^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[REPLACE]^unscaled = Math.ceil ( unscaled ) ; ;^575^^^^^572^576^[REPLACE] unscaled = Math.floor ( unscaled ) ;^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[REPLACE]^unscaled = Math.floor ( unscaled ) ; ;^573^^^^^551^616^[REPLACE] unscaled = Math.ceil ( unscaled ) ;^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[REPLACE]^if  ( sign  >=  0.5D )  {^581^^^^^551^616^[REPLACE] if  ( fraction > 0.5 )  {^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[REPLACE]^}  if  ( fraction  !=  0.5D )  {^583^^^^^551^616^[REPLACE] } else if  ( fraction < 0.5 )  {^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[REPLACE]^if  ( Math.floor ( unscaled )  / 2.0D  ||  Math.floor ( Math .floor ( unscaled )  / 2.0D )  )  {^586^587^^^^583^592^[REPLACE] if  ( Math.floor ( unscaled )  / 2.0 == Math.floor ( Math .floor ( unscaled )  / 2.0 )  )  {^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[ADD]^^586^587^588^589^590^583^592^[ADD] if  ( Math.floor ( unscaled )  / 2.0 == Math.floor ( Math .floor ( unscaled )  / 2.0 )  )  { unscaled = Math.floor ( unscaled ) ; } else { unscaled = Math.ceil ( unscaled ) ;^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[REPLACE]^unscaled = Math.floor ( unscaled ) ; ;^590^^^^^583^592^[REPLACE] unscaled = Math.ceil ( unscaled ) ;^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[REPLACE]^unscaled = Math.ceil ( unscaled ) ; ;^588^^^^^583^592^[REPLACE] unscaled = Math.floor ( unscaled ) ;^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[ADD]^^588^^^^^583^592^[ADD] unscaled = Math.floor ( unscaled ) ;^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[REPLACE]^unscaled = Math.ceil ( unscaled ) ; ;^584^^^^^551^616^[REPLACE] unscaled = Math.floor ( unscaled ) ;^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[REPLACE]^if  (   unscaled    / 2.0  &&  Math.^586^587^^^^551^616^[REPLACE] if  ( Math.floor ( unscaled )  / 2.0 == Math.floor ( Math .floor ( unscaled )  / 2.0 )  )  {^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[REPLACE]^unscaled = Math.floor ( unscaled ) ; ;^590^^^^^586^591^[REPLACE] unscaled = Math.ceil ( unscaled ) ;^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[REPLACE]^unscaled = Math.ceil ( unscaled ) ; ;^588^^^^^586^591^[REPLACE] unscaled = Math.floor ( unscaled ) ;^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[REPLACE]^unscaled = Math.ceil ( unscaled ) ; ;^588^^^^^551^616^[REPLACE] unscaled = Math.floor ( unscaled ) ;^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[REPLACE]^unscaled = Math.floor ( unscaled ) ; ;^590^^^^^551^616^[REPLACE] unscaled = Math.ceil ( unscaled ) ;^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[REPLACE]^unscaled = Math.floor ( unscaled ) ; ;^582^^^^^551^616^[REPLACE] unscaled = Math.ceil ( unscaled ) ;^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[REPLACE]^}  else {^583^^^^^551^616^[REPLACE] } else if  ( fraction < 0.5 )  {^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[REPLACE]^if  ( Math.floor ( sign )  / 2.0  !=  Math.floor ( Math .floor ( unscaled )  / 2.0 )  )  {^586^587^^^^583^592^[REPLACE] if  ( Math.floor ( unscaled )  / 2.0 == Math.floor ( Math .floor ( unscaled )  / 2.0 )  )  {^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[REMOVE]^if  ( fraction >= 0.5 )  {     unscaled = ceil ( unscaled ) ; }else {     unscaled = floor ( unscaled ) ; }^586^^^^^583^592^[REMOVE] ^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[REPLACE]^if  ( Math.floor ( unscaled )  / 1.0d  &&  Math.floor ( Math .floor ( unscaled )  / 1.0d )  )  {^586^587^^^^551^616^[REPLACE] if  ( Math.floor ( unscaled )  / 2.0 == Math.floor ( Math .floor ( unscaled )  / 2.0 )  )  {^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[REPLACE]^if  ( fraction  ==  0.5 )  {^597^^^^^551^616^[REPLACE] if  ( fraction >= 0.5 )  {^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[REPLACE]^unscaled = Math.ceil ( unscaled ) ; ;^600^^^^^597^601^[REPLACE] unscaled = Math.floor ( unscaled ) ;^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[ADD]^^600^^^^^597^601^[ADD] unscaled = Math.floor ( unscaled ) ;^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[REPLACE]^unscaled = Math.floor ( unscaled ) ; ;^598^^^^^551^616^[REPLACE] unscaled = Math.ceil ( unscaled ) ;^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[REPLACE]^if  ( unscaled  ==    unscaled    )  {^605^^^^^551^616^[REPLACE] if  ( unscaled != Math.floor ( unscaled )  )  {^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[REMOVE]^if  ( n < 0 )  {     throw new IllegalArgumentException ( "must have n >= 0 for n!" ) ; }^605^^^^^551^616^[REMOVE] ^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[REPLACE]^return ;^606^^^^^551^616^[REPLACE] throw new ArithmeticException  (" ")  ;^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[ADD]^^606^^^^^551^616^[ADD] throw new ArithmeticException  (" ")  ;^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[REPLACE]^unscaled = Math.floor ( unscaled ) ; ;^557^^^^^551^616^[REPLACE] unscaled = Math.ceil ( unscaled ) ;^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[REPLACE]^unscaled = Math.ceil ( unscaled ) ; ;^561^^^^^551^616^[REPLACE] unscaled = Math.floor ( unscaled ) ;^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[ADD]^^565^^^^^551^616^[ADD] unscaled = Math.ceil ( unscaled ) ;^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[REPLACE]^unscaled = Math.ceil ( unscaled ) ; ;^567^^^^^551^616^[REPLACE] unscaled = Math.floor ( unscaled ) ;^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[REPLACE]^unscaled = Math.ceil ( unscaled ) ; ;^575^^^^^551^616^[REPLACE] unscaled = Math.floor ( unscaled ) ;^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[ADD]^^575^^^^^551^616^[ADD] unscaled = Math.floor ( unscaled ) ;^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[ADD]^^584^^^^^551^616^[ADD] unscaled = Math.floor ( unscaled ) ;^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[REPLACE]^unscaled = Math.ceil ( unscaled ) ; ;^600^^^^^551^616^[REPLACE] unscaled = Math.floor ( unscaled ) ;^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[ADD]^^600^^^^^551^616^[ADD] unscaled = Math.floor ( unscaled ) ;^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[REPLACE]^unscaled = Math.floor ( unscaled ) ; ;^610^^^^^551^616^[REPLACE] unscaled = Math.ceil ( unscaled ) ;^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[REPLACE]^double fraction =   unscaled    ) ;^571^^^^^551^616^[REPLACE] double fraction = Math.abs ( unscaled - Math.floor ( unscaled )  ) ;^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[REPLACE]^double fraction = Math.abs ( unscaled  ^  Math.floor ( unscaled )  ) ;^580^^^^^551^616^[REPLACE] double fraction = Math.abs ( unscaled - Math.floor ( unscaled )  ) ;^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[ADD]^^580^^^^^551^616^[ADD] double fraction = Math.abs ( unscaled - Math.floor ( unscaled )  ) ;^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[REPLACE]^double fraction = Math.abs ( unscaled  ||  Math.floor ( unscaled )  ) ;^596^^^^^551^616^[REPLACE] double fraction = Math.abs ( unscaled - Math.floor ( unscaled )  ) ;^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[REPLACE]^return ;^613^^^^^551^616^[REPLACE] throw new IllegalArgumentException  (" ")  ;^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[REPLACE]^return sign;^615^^^^^551^616^[REPLACE] return unscaled;^[METHOD] roundUnscaled [TYPE] double [PARAMETER] double unscaled double sign int roundingMethod [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double fraction  sign  unscaled  [TYPE]  int roundingMethod 
[REPLACE]^return   ZB ;^629^^^^^628^630^[REPLACE] return  ( x == ZB )  ? ZB :  ( x > ZB )  ? PB : NB;^[METHOD] sign [TYPE] byte [PARAMETER] final byte x [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  byte NB  PB  ZB  x  [TYPE]  boolean false  true 
[REPLACE]^if  ( Double.doubleToLongBits ( x )  )  {^645^^^^^644^649^[REPLACE] if  ( Double.isNaN ( x )  )  {^[METHOD] sign [TYPE] double [PARAMETER] final double x [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double x 
[REPLACE]^return Float.NaN;^646^^^^^644^649^[REPLACE] return Double.NaN;^[METHOD] sign [TYPE] double [PARAMETER] final double x [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double x 
[REPLACE]^return  ( x == 0.0F )  ? 0.0F :  ( x > 0.0F )  ? 1.0F : -1.0F;^648^^^^^644^649^[REPLACE] return  ( x == 0.0 )  ? 0.0 :  ( x > 0.0 )  ? 1.0 : -1.0;^[METHOD] sign [TYPE] double [PARAMETER] final double x [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double x 
[REPLACE]^if  (   x    )  {^663^^^^^662^667^[REPLACE] if  ( Float.isNaN ( x )  )  {^[METHOD] sign [TYPE] float [PARAMETER] final float x [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  float x  [TYPE]  byte NB  PB  ZB  x 
[REPLACE]^return 1;^664^^^^^662^667^[REPLACE] return Float.NaN;^[METHOD] sign [TYPE] float [PARAMETER] final float x [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  float x  [TYPE]  byte NB  PB  ZB  x 
[REPLACE]^return   0.0F ;^666^^^^^662^667^[REPLACE] return  ( x == 0.0F )  ? 0.0F :  ( x > 0.0F )  ? 1.0F : -1.0F;^[METHOD] sign [TYPE] float [PARAMETER] final float x [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  float x  [TYPE]  byte NB  PB  ZB  x 
[REPLACE]^return  ( x  &&  0 )  ? 0 :  ( x ;^680^^^^^679^681^[REPLACE] return  ( x == 0 )  ? 0 :  ( x > 0 )  ? 1 : -1;^[METHOD] sign [TYPE] int [PARAMETER] final int x [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  int x 
[REPLACE]^return  ( x  !=  0L )  ? 0L :  ( x > 0L )  ? 1L : -1L;;^694^^^^^693^695^[REPLACE] return  ( x == 0L )  ? 0L :  ( x > 0L )  ? 1L : -1L;^[METHOD] sign [TYPE] long [PARAMETER] final long x [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  long x 
[REPLACE]^return   ZS ;^709^^^^^708^710^[REPLACE] return  ( x == ZS )  ? ZS :  ( x > ZS )  ? PS : NS;^[METHOD] sign [TYPE] short [PARAMETER] final short x [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  byte NB  PB  ZB  x  [TYPE]  boolean false  true 
[REPLACE]^return  (   x    - Math.^720^^^^^719^721^[REPLACE] return  ( Math.exp ( x )  - Math.exp ( -x )  )  / 2.0;^[METHOD] sinh [TYPE] double [PARAMETER] double x [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  double x 
[REPLACE]^long s =  ( long ) x  !=   ( long ) y;^734^^^^^733^739^[REPLACE] long s =  ( long ) x -  ( long ) y;^[METHOD] subAndCheck [TYPE] int [PARAMETER] int x int y [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  int x  y  [TYPE]  long s 
[REPLACE]^if  ( s < Integer.MIN_VALUE ) {^735^^^^^733^739^[REPLACE] if  ( s < Integer.MIN_VALUE || s > Integer.MAX_VALUE )  {^[METHOD] subAndCheck [TYPE] int [PARAMETER] int x int y [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  int x  y  [TYPE]  long s 
[REPLACE]^return ;^736^^^^^733^739^[REPLACE] throw new ArithmeticException  (" ")  ;^[METHOD] subAndCheck [TYPE] int [PARAMETER] int x int y [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  int x  y  [TYPE]  long s 
[REPLACE]^return  ( int ) m;^738^^^^^733^739^[REPLACE] return  ( int ) s;^[METHOD] subAndCheck [TYPE] int [PARAMETER] int x int y [CLASS] MathUtils   [TYPE]  short NS  PS  ZS  x  [TYPE]  boolean false  true  [TYPE]  byte NB  PB  ZB  x  [TYPE]  int x  y  [TYPE]  long s 
